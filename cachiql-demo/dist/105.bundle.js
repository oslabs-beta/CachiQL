"use strict";(self.webpackChunkcachiql_demo=self.webpackChunkcachiql_demo||[]).push([[105],{26105:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "a": () => (/* binding */ searchcursor$2),\n/* harmony export */   "s": () => (/* binding */ searchcursor$1)\n/* harmony export */ });\n/* harmony import */ var _codemirror_es_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97480);\nvar __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, "name", { value, configurable: true });\n\nfunction _mergeNamespaces(n, m) {\n  m.forEach(function(e) {\n    e && typeof e !== "string" && !Array.isArray(e) && Object.keys(e).forEach(function(k) {\n      if (k !== "default" && !(k in n)) {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function() {\n            return e[k];\n          }\n        });\n      }\n    });\n  });\n  return Object.freeze(n);\n}\n__name(_mergeNamespaces, "_mergeNamespaces");\nvar searchcursor$2 = { exports: {} };\n(function(module, exports) {\n  (function(mod) {\n    mod(_codemirror_es_js__WEBPACK_IMPORTED_MODULE_0__.a.exports);\n  })(function(CodeMirror) {\n    var Pos = CodeMirror.Pos;\n    function regexpFlags(regexp) {\n      var flags = regexp.flags;\n      return flags != null ? flags : (regexp.ignoreCase ? "i" : "") + (regexp.global ? "g" : "") + (regexp.multiline ? "m" : "");\n    }\n    __name(regexpFlags, "regexpFlags");\n    function ensureFlags(regexp, flags) {\n      var current = regexpFlags(regexp), target = current;\n      for (var i = 0; i < flags.length; i++)\n        if (target.indexOf(flags.charAt(i)) == -1)\n          target += flags.charAt(i);\n      return current == target ? regexp : new RegExp(regexp.source, target);\n    }\n    __name(ensureFlags, "ensureFlags");\n    function maybeMultiline(regexp) {\n      return /\\\\s|\\\\n|\\n|\\\\W|\\\\D|\\[\\^/.test(regexp.source);\n    }\n    __name(maybeMultiline, "maybeMultiline");\n    function searchRegexpForward(doc, regexp, start) {\n      regexp = ensureFlags(regexp, "g");\n      for (var line = start.line, ch = start.ch, last = doc.lastLine(); line <= last; line++, ch = 0) {\n        regexp.lastIndex = ch;\n        var string = doc.getLine(line), match = regexp.exec(string);\n        if (match)\n          return {\n            from: Pos(line, match.index),\n            to: Pos(line, match.index + match[0].length),\n            match\n          };\n      }\n    }\n    __name(searchRegexpForward, "searchRegexpForward");\n    function searchRegexpForwardMultiline(doc, regexp, start) {\n      if (!maybeMultiline(regexp))\n        return searchRegexpForward(doc, regexp, start);\n      regexp = ensureFlags(regexp, "gm");\n      var string, chunk = 1;\n      for (var line = start.line, last = doc.lastLine(); line <= last; ) {\n        for (var i = 0; i < chunk; i++) {\n          if (line > last)\n            break;\n          var curLine = doc.getLine(line++);\n          string = string == null ? curLine : string + "\\n" + curLine;\n        }\n        chunk = chunk * 2;\n        regexp.lastIndex = start.ch;\n        var match = regexp.exec(string);\n        if (match) {\n          var before = string.slice(0, match.index).split("\\n"), inside = match[0].split("\\n");\n          var startLine = start.line + before.length - 1, startCh = before[before.length - 1].length;\n          return {\n            from: Pos(startLine, startCh),\n            to: Pos(startLine + inside.length - 1, inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\n            match\n          };\n        }\n      }\n    }\n    __name(searchRegexpForwardMultiline, "searchRegexpForwardMultiline");\n    function lastMatchIn(string, regexp, endMargin) {\n      var match, from = 0;\n      while (from <= string.length) {\n        regexp.lastIndex = from;\n        var newMatch = regexp.exec(string);\n        if (!newMatch)\n          break;\n        var end = newMatch.index + newMatch[0].length;\n        if (end > string.length - endMargin)\n          break;\n        if (!match || end > match.index + match[0].length)\n          match = newMatch;\n        from = newMatch.index + 1;\n      }\n      return match;\n    }\n    __name(lastMatchIn, "lastMatchIn");\n    function searchRegexpBackward(doc, regexp, start) {\n      regexp = ensureFlags(regexp, "g");\n      for (var line = start.line, ch = start.ch, first = doc.firstLine(); line >= first; line--, ch = -1) {\n        var string = doc.getLine(line);\n        var match = lastMatchIn(string, regexp, ch < 0 ? 0 : string.length - ch);\n        if (match)\n          return {\n            from: Pos(line, match.index),\n            to: Pos(line, match.index + match[0].length),\n            match\n          };\n      }\n    }\n    __name(searchRegexpBackward, "searchRegexpBackward");\n    function searchRegexpBackwardMultiline(doc, regexp, start) {\n      if (!maybeMultiline(regexp))\n        return searchRegexpBackward(doc, regexp, start);\n      regexp = ensureFlags(regexp, "gm");\n      var string, chunkSize = 1, endMargin = doc.getLine(start.line).length - start.ch;\n      for (var line = start.line, first = doc.firstLine(); line >= first; ) {\n        for (var i = 0; i < chunkSize && line >= first; i++) {\n          var curLine = doc.getLine(line--);\n          string = string == null ? curLine : curLine + "\\n" + string;\n        }\n        chunkSize *= 2;\n        var match = lastMatchIn(string, regexp, endMargin);\n        if (match) {\n          var before = string.slice(0, match.index).split("\\n"), inside = match[0].split("\\n");\n          var startLine = line + before.length, startCh = before[before.length - 1].length;\n          return {\n            from: Pos(startLine, startCh),\n            to: Pos(startLine + inside.length - 1, inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\n            match\n          };\n        }\n      }\n    }\n    __name(searchRegexpBackwardMultiline, "searchRegexpBackwardMultiline");\n    var doFold, noFold;\n    if (String.prototype.normalize) {\n      doFold = /* @__PURE__ */ __name(function(str) {\n        return str.normalize("NFD").toLowerCase();\n      }, "doFold");\n      noFold = /* @__PURE__ */ __name(function(str) {\n        return str.normalize("NFD");\n      }, "noFold");\n    } else {\n      doFold = /* @__PURE__ */ __name(function(str) {\n        return str.toLowerCase();\n      }, "doFold");\n      noFold = /* @__PURE__ */ __name(function(str) {\n        return str;\n      }, "noFold");\n    }\n    function adjustPos(orig, folded, pos, foldFunc) {\n      if (orig.length == folded.length)\n        return pos;\n      for (var min = 0, max = pos + Math.max(0, orig.length - folded.length); ; ) {\n        if (min == max)\n          return min;\n        var mid = min + max >> 1;\n        var len = foldFunc(orig.slice(0, mid)).length;\n        if (len == pos)\n          return mid;\n        else if (len > pos)\n          max = mid;\n        else\n          min = mid + 1;\n      }\n    }\n    __name(adjustPos, "adjustPos");\n    function searchStringForward(doc, query, start, caseFold) {\n      if (!query.length)\n        return null;\n      var fold = caseFold ? doFold : noFold;\n      var lines = fold(query).split(/\\r|\\n\\r?/);\n      search:\n        for (var line = start.line, ch = start.ch, last = doc.lastLine() + 1 - lines.length; line <= last; line++, ch = 0) {\n          var orig = doc.getLine(line).slice(ch), string = fold(orig);\n          if (lines.length == 1) {\n            var found = string.indexOf(lines[0]);\n            if (found == -1)\n              continue search;\n            var start = adjustPos(orig, string, found, fold) + ch;\n            return {\n              from: Pos(line, adjustPos(orig, string, found, fold) + ch),\n              to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold) + ch)\n            };\n          } else {\n            var cutFrom = string.length - lines[0].length;\n            if (string.slice(cutFrom) != lines[0])\n              continue search;\n            for (var i = 1; i < lines.length - 1; i++)\n              if (fold(doc.getLine(line + i)) != lines[i])\n                continue search;\n            var end = doc.getLine(line + lines.length - 1), endString = fold(end), lastLine = lines[lines.length - 1];\n            if (endString.slice(0, lastLine.length) != lastLine)\n              continue search;\n            return {\n              from: Pos(line, adjustPos(orig, string, cutFrom, fold) + ch),\n              to: Pos(line + lines.length - 1, adjustPos(end, endString, lastLine.length, fold))\n            };\n          }\n        }\n    }\n    __name(searchStringForward, "searchStringForward");\n    function searchStringBackward(doc, query, start, caseFold) {\n      if (!query.length)\n        return null;\n      var fold = caseFold ? doFold : noFold;\n      var lines = fold(query).split(/\\r|\\n\\r?/);\n      search:\n        for (var line = start.line, ch = start.ch, first = doc.firstLine() - 1 + lines.length; line >= first; line--, ch = -1) {\n          var orig = doc.getLine(line);\n          if (ch > -1)\n            orig = orig.slice(0, ch);\n          var string = fold(orig);\n          if (lines.length == 1) {\n            var found = string.lastIndexOf(lines[0]);\n            if (found == -1)\n              continue search;\n            return {\n              from: Pos(line, adjustPos(orig, string, found, fold)),\n              to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold))\n            };\n          } else {\n            var lastLine = lines[lines.length - 1];\n            if (string.slice(0, lastLine.length) != lastLine)\n              continue search;\n            for (var i = 1, start = line - lines.length + 1; i < lines.length - 1; i++)\n              if (fold(doc.getLine(start + i)) != lines[i])\n                continue search;\n            var top = doc.getLine(line + 1 - lines.length), topString = fold(top);\n            if (topString.slice(topString.length - lines[0].length) != lines[0])\n              continue search;\n            return {\n              from: Pos(line + 1 - lines.length, adjustPos(top, topString, top.length - lines[0].length, fold)),\n              to: Pos(line, adjustPos(orig, string, lastLine.length, fold))\n            };\n          }\n        }\n    }\n    __name(searchStringBackward, "searchStringBackward");\n    function SearchCursor(doc, query, pos, options) {\n      this.atOccurrence = false;\n      this.afterEmptyMatch = false;\n      this.doc = doc;\n      pos = pos ? doc.clipPos(pos) : Pos(0, 0);\n      this.pos = { from: pos, to: pos };\n      var caseFold;\n      if (typeof options == "object") {\n        caseFold = options.caseFold;\n      } else {\n        caseFold = options;\n        options = null;\n      }\n      if (typeof query == "string") {\n        if (caseFold == null)\n          caseFold = false;\n        this.matches = function(reverse, pos2) {\n          return (reverse ? searchStringBackward : searchStringForward)(doc, query, pos2, caseFold);\n        };\n      } else {\n        query = ensureFlags(query, "gm");\n        if (!options || options.multiline !== false)\n          this.matches = function(reverse, pos2) {\n            return (reverse ? searchRegexpBackwardMultiline : searchRegexpForwardMultiline)(doc, query, pos2);\n          };\n        else\n          this.matches = function(reverse, pos2) {\n            return (reverse ? searchRegexpBackward : searchRegexpForward)(doc, query, pos2);\n          };\n      }\n    }\n    __name(SearchCursor, "SearchCursor");\n    SearchCursor.prototype = {\n      findNext: function() {\n        return this.find(false);\n      },\n      findPrevious: function() {\n        return this.find(true);\n      },\n      find: function(reverse) {\n        var head = this.doc.clipPos(reverse ? this.pos.from : this.pos.to);\n        if (this.afterEmptyMatch && this.atOccurrence) {\n          head = Pos(head.line, head.ch);\n          if (reverse) {\n            head.ch--;\n            if (head.ch < 0) {\n              head.line--;\n              head.ch = (this.doc.getLine(head.line) || "").length;\n            }\n          } else {\n            head.ch++;\n            if (head.ch > (this.doc.getLine(head.line) || "").length) {\n              head.ch = 0;\n              head.line++;\n            }\n          }\n          if (CodeMirror.cmpPos(head, this.doc.clipPos(head)) != 0) {\n            return this.atOccurrence = false;\n          }\n        }\n        var result = this.matches(reverse, head);\n        this.afterEmptyMatch = result && CodeMirror.cmpPos(result.from, result.to) == 0;\n        if (result) {\n          this.pos = result;\n          this.atOccurrence = true;\n          return this.pos.match || true;\n        } else {\n          var end = Pos(reverse ? this.doc.firstLine() : this.doc.lastLine() + 1, 0);\n          this.pos = { from: end, to: end };\n          return this.atOccurrence = false;\n        }\n      },\n      from: function() {\n        if (this.atOccurrence)\n          return this.pos.from;\n      },\n      to: function() {\n        if (this.atOccurrence)\n          return this.pos.to;\n      },\n      replace: function(newText, origin) {\n        if (!this.atOccurrence)\n          return;\n        var lines = CodeMirror.splitLines(newText);\n        this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin);\n        this.pos.to = Pos(this.pos.from.line + lines.length - 1, lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0));\n      }\n    };\n    CodeMirror.defineExtension("getSearchCursor", function(query, pos, caseFold) {\n      return new SearchCursor(this.doc, query, pos, caseFold);\n    });\n    CodeMirror.defineDocExtension("getSearchCursor", function(query, pos, caseFold) {\n      return new SearchCursor(this, query, pos, caseFold);\n    });\n    CodeMirror.defineExtension("selectMatches", function(query, caseFold) {\n      var ranges = [];\n      var cur = this.getSearchCursor(query, this.getCursor("from"), caseFold);\n      while (cur.findNext()) {\n        if (CodeMirror.cmpPos(cur.to(), this.getCursor("to")) > 0)\n          break;\n        ranges.push({ anchor: cur.from(), head: cur.to() });\n      }\n      if (ranges.length)\n        this.setSelections(ranges, 0);\n    });\n  });\n})();\nvar searchcursor = searchcursor$2.exports;\nvar searchcursor$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  [Symbol.toStringTag]: "Module",\n  "default": searchcursor\n}, [searchcursor$2.exports]));\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0NBQW9DO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ21EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2FjaGlxbC1kZW1vLy4vbm9kZV9tb2R1bGVzL0BncmFwaGlxbC9yZWFjdC9kaXN0L3NlYXJjaGN1cnNvci5lcy5qcz8xY2JhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19uYW1lID0gKHRhcmdldCwgdmFsdWUpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwibmFtZVwiLCB7IHZhbHVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG5pbXBvcnQgeyBhIGFzIGNvZGVtaXJyb3IgfSBmcm9tIFwiLi9jb2RlbWlycm9yLmVzLmpzXCI7XG5mdW5jdGlvbiBfbWVyZ2VOYW1lc3BhY2VzKG4sIG0pIHtcbiAgbS5mb3JFYWNoKGZ1bmN0aW9uKGUpIHtcbiAgICBlICYmIHR5cGVvZiBlICE9PSBcInN0cmluZ1wiICYmICFBcnJheS5pc0FycmF5KGUpICYmIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmICEoayBpbiBuKSkge1xuICAgICAgICB2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgayk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBrLCBkLmdldCA/IGQgOiB7XG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGVba107XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xufVxuX19uYW1lKF9tZXJnZU5hbWVzcGFjZXMsIFwiX21lcmdlTmFtZXNwYWNlc1wiKTtcbnZhciBzZWFyY2hjdXJzb3IkMiA9IHsgZXhwb3J0czoge30gfTtcbihmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcbiAgKGZ1bmN0aW9uKG1vZCkge1xuICAgIG1vZChjb2RlbWlycm9yLmV4cG9ydHMpO1xuICB9KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG4gICAgdmFyIFBvcyA9IENvZGVNaXJyb3IuUG9zO1xuICAgIGZ1bmN0aW9uIHJlZ2V4cEZsYWdzKHJlZ2V4cCkge1xuICAgICAgdmFyIGZsYWdzID0gcmVnZXhwLmZsYWdzO1xuICAgICAgcmV0dXJuIGZsYWdzICE9IG51bGwgPyBmbGFncyA6IChyZWdleHAuaWdub3JlQ2FzZSA/IFwiaVwiIDogXCJcIikgKyAocmVnZXhwLmdsb2JhbCA/IFwiZ1wiIDogXCJcIikgKyAocmVnZXhwLm11bHRpbGluZSA/IFwibVwiIDogXCJcIik7XG4gICAgfVxuICAgIF9fbmFtZShyZWdleHBGbGFncywgXCJyZWdleHBGbGFnc1wiKTtcbiAgICBmdW5jdGlvbiBlbnN1cmVGbGFncyhyZWdleHAsIGZsYWdzKSB7XG4gICAgICB2YXIgY3VycmVudCA9IHJlZ2V4cEZsYWdzKHJlZ2V4cCksIHRhcmdldCA9IGN1cnJlbnQ7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZsYWdzLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAodGFyZ2V0LmluZGV4T2YoZmxhZ3MuY2hhckF0KGkpKSA9PSAtMSlcbiAgICAgICAgICB0YXJnZXQgKz0gZmxhZ3MuY2hhckF0KGkpO1xuICAgICAgcmV0dXJuIGN1cnJlbnQgPT0gdGFyZ2V0ID8gcmVnZXhwIDogbmV3IFJlZ0V4cChyZWdleHAuc291cmNlLCB0YXJnZXQpO1xuICAgIH1cbiAgICBfX25hbWUoZW5zdXJlRmxhZ3MsIFwiZW5zdXJlRmxhZ3NcIik7XG4gICAgZnVuY3Rpb24gbWF5YmVNdWx0aWxpbmUocmVnZXhwKSB7XG4gICAgICByZXR1cm4gL1xcXFxzfFxcXFxufFxcbnxcXFxcV3xcXFxcRHxcXFtcXF4vLnRlc3QocmVnZXhwLnNvdXJjZSk7XG4gICAgfVxuICAgIF9fbmFtZShtYXliZU11bHRpbGluZSwgXCJtYXliZU11bHRpbGluZVwiKTtcbiAgICBmdW5jdGlvbiBzZWFyY2hSZWdleHBGb3J3YXJkKGRvYywgcmVnZXhwLCBzdGFydCkge1xuICAgICAgcmVnZXhwID0gZW5zdXJlRmxhZ3MocmVnZXhwLCBcImdcIik7XG4gICAgICBmb3IgKHZhciBsaW5lID0gc3RhcnQubGluZSwgY2ggPSBzdGFydC5jaCwgbGFzdCA9IGRvYy5sYXN0TGluZSgpOyBsaW5lIDw9IGxhc3Q7IGxpbmUrKywgY2ggPSAwKSB7XG4gICAgICAgIHJlZ2V4cC5sYXN0SW5kZXggPSBjaDtcbiAgICAgICAgdmFyIHN0cmluZyA9IGRvYy5nZXRMaW5lKGxpbmUpLCBtYXRjaCA9IHJlZ2V4cC5leGVjKHN0cmluZyk7XG4gICAgICAgIGlmIChtYXRjaClcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZnJvbTogUG9zKGxpbmUsIG1hdGNoLmluZGV4KSxcbiAgICAgICAgICAgIHRvOiBQb3MobGluZSwgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpLFxuICAgICAgICAgICAgbWF0Y2hcbiAgICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoc2VhcmNoUmVnZXhwRm9yd2FyZCwgXCJzZWFyY2hSZWdleHBGb3J3YXJkXCIpO1xuICAgIGZ1bmN0aW9uIHNlYXJjaFJlZ2V4cEZvcndhcmRNdWx0aWxpbmUoZG9jLCByZWdleHAsIHN0YXJ0KSB7XG4gICAgICBpZiAoIW1heWJlTXVsdGlsaW5lKHJlZ2V4cCkpXG4gICAgICAgIHJldHVybiBzZWFyY2hSZWdleHBGb3J3YXJkKGRvYywgcmVnZXhwLCBzdGFydCk7XG4gICAgICByZWdleHAgPSBlbnN1cmVGbGFncyhyZWdleHAsIFwiZ21cIik7XG4gICAgICB2YXIgc3RyaW5nLCBjaHVuayA9IDE7XG4gICAgICBmb3IgKHZhciBsaW5lID0gc3RhcnQubGluZSwgbGFzdCA9IGRvYy5sYXN0TGluZSgpOyBsaW5lIDw9IGxhc3Q7ICkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNodW5rOyBpKyspIHtcbiAgICAgICAgICBpZiAobGluZSA+IGxhc3QpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB2YXIgY3VyTGluZSA9IGRvYy5nZXRMaW5lKGxpbmUrKyk7XG4gICAgICAgICAgc3RyaW5nID0gc3RyaW5nID09IG51bGwgPyBjdXJMaW5lIDogc3RyaW5nICsgXCJcXG5cIiArIGN1ckxpbmU7XG4gICAgICAgIH1cbiAgICAgICAgY2h1bmsgPSBjaHVuayAqIDI7XG4gICAgICAgIHJlZ2V4cC5sYXN0SW5kZXggPSBzdGFydC5jaDtcbiAgICAgICAgdmFyIG1hdGNoID0gcmVnZXhwLmV4ZWMoc3RyaW5nKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgdmFyIGJlZm9yZSA9IHN0cmluZy5zbGljZSgwLCBtYXRjaC5pbmRleCkuc3BsaXQoXCJcXG5cIiksIGluc2lkZSA9IG1hdGNoWzBdLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICAgIHZhciBzdGFydExpbmUgPSBzdGFydC5saW5lICsgYmVmb3JlLmxlbmd0aCAtIDEsIHN0YXJ0Q2ggPSBiZWZvcmVbYmVmb3JlLmxlbmd0aCAtIDFdLmxlbmd0aDtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZnJvbTogUG9zKHN0YXJ0TGluZSwgc3RhcnRDaCksXG4gICAgICAgICAgICB0bzogUG9zKHN0YXJ0TGluZSArIGluc2lkZS5sZW5ndGggLSAxLCBpbnNpZGUubGVuZ3RoID09IDEgPyBzdGFydENoICsgaW5zaWRlWzBdLmxlbmd0aCA6IGluc2lkZVtpbnNpZGUubGVuZ3RoIC0gMV0ubGVuZ3RoKSxcbiAgICAgICAgICAgIG1hdGNoXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoc2VhcmNoUmVnZXhwRm9yd2FyZE11bHRpbGluZSwgXCJzZWFyY2hSZWdleHBGb3J3YXJkTXVsdGlsaW5lXCIpO1xuICAgIGZ1bmN0aW9uIGxhc3RNYXRjaEluKHN0cmluZywgcmVnZXhwLCBlbmRNYXJnaW4pIHtcbiAgICAgIHZhciBtYXRjaCwgZnJvbSA9IDA7XG4gICAgICB3aGlsZSAoZnJvbSA8PSBzdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgIHJlZ2V4cC5sYXN0SW5kZXggPSBmcm9tO1xuICAgICAgICB2YXIgbmV3TWF0Y2ggPSByZWdleHAuZXhlYyhzdHJpbmcpO1xuICAgICAgICBpZiAoIW5ld01hdGNoKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB2YXIgZW5kID0gbmV3TWF0Y2guaW5kZXggKyBuZXdNYXRjaFswXS5sZW5ndGg7XG4gICAgICAgIGlmIChlbmQgPiBzdHJpbmcubGVuZ3RoIC0gZW5kTWFyZ2luKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAoIW1hdGNoIHx8IGVuZCA+IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKVxuICAgICAgICAgIG1hdGNoID0gbmV3TWF0Y2g7XG4gICAgICAgIGZyb20gPSBuZXdNYXRjaC5pbmRleCArIDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxuICAgIF9fbmFtZShsYXN0TWF0Y2hJbiwgXCJsYXN0TWF0Y2hJblwiKTtcbiAgICBmdW5jdGlvbiBzZWFyY2hSZWdleHBCYWNrd2FyZChkb2MsIHJlZ2V4cCwgc3RhcnQpIHtcbiAgICAgIHJlZ2V4cCA9IGVuc3VyZUZsYWdzKHJlZ2V4cCwgXCJnXCIpO1xuICAgICAgZm9yICh2YXIgbGluZSA9IHN0YXJ0LmxpbmUsIGNoID0gc3RhcnQuY2gsIGZpcnN0ID0gZG9jLmZpcnN0TGluZSgpOyBsaW5lID49IGZpcnN0OyBsaW5lLS0sIGNoID0gLTEpIHtcbiAgICAgICAgdmFyIHN0cmluZyA9IGRvYy5nZXRMaW5lKGxpbmUpO1xuICAgICAgICB2YXIgbWF0Y2ggPSBsYXN0TWF0Y2hJbihzdHJpbmcsIHJlZ2V4cCwgY2ggPCAwID8gMCA6IHN0cmluZy5sZW5ndGggLSBjaCk7XG4gICAgICAgIGlmIChtYXRjaClcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZnJvbTogUG9zKGxpbmUsIG1hdGNoLmluZGV4KSxcbiAgICAgICAgICAgIHRvOiBQb3MobGluZSwgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpLFxuICAgICAgICAgICAgbWF0Y2hcbiAgICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoc2VhcmNoUmVnZXhwQmFja3dhcmQsIFwic2VhcmNoUmVnZXhwQmFja3dhcmRcIik7XG4gICAgZnVuY3Rpb24gc2VhcmNoUmVnZXhwQmFja3dhcmRNdWx0aWxpbmUoZG9jLCByZWdleHAsIHN0YXJ0KSB7XG4gICAgICBpZiAoIW1heWJlTXVsdGlsaW5lKHJlZ2V4cCkpXG4gICAgICAgIHJldHVybiBzZWFyY2hSZWdleHBCYWNrd2FyZChkb2MsIHJlZ2V4cCwgc3RhcnQpO1xuICAgICAgcmVnZXhwID0gZW5zdXJlRmxhZ3MocmVnZXhwLCBcImdtXCIpO1xuICAgICAgdmFyIHN0cmluZywgY2h1bmtTaXplID0gMSwgZW5kTWFyZ2luID0gZG9jLmdldExpbmUoc3RhcnQubGluZSkubGVuZ3RoIC0gc3RhcnQuY2g7XG4gICAgICBmb3IgKHZhciBsaW5lID0gc3RhcnQubGluZSwgZmlyc3QgPSBkb2MuZmlyc3RMaW5lKCk7IGxpbmUgPj0gZmlyc3Q7ICkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNodW5rU2l6ZSAmJiBsaW5lID49IGZpcnN0OyBpKyspIHtcbiAgICAgICAgICB2YXIgY3VyTGluZSA9IGRvYy5nZXRMaW5lKGxpbmUtLSk7XG4gICAgICAgICAgc3RyaW5nID0gc3RyaW5nID09IG51bGwgPyBjdXJMaW5lIDogY3VyTGluZSArIFwiXFxuXCIgKyBzdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgY2h1bmtTaXplICo9IDI7XG4gICAgICAgIHZhciBtYXRjaCA9IGxhc3RNYXRjaEluKHN0cmluZywgcmVnZXhwLCBlbmRNYXJnaW4pO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICB2YXIgYmVmb3JlID0gc3RyaW5nLnNsaWNlKDAsIG1hdGNoLmluZGV4KS5zcGxpdChcIlxcblwiKSwgaW5zaWRlID0gbWF0Y2hbMF0uc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgdmFyIHN0YXJ0TGluZSA9IGxpbmUgKyBiZWZvcmUubGVuZ3RoLCBzdGFydENoID0gYmVmb3JlW2JlZm9yZS5sZW5ndGggLSAxXS5sZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZyb206IFBvcyhzdGFydExpbmUsIHN0YXJ0Q2gpLFxuICAgICAgICAgICAgdG86IFBvcyhzdGFydExpbmUgKyBpbnNpZGUubGVuZ3RoIC0gMSwgaW5zaWRlLmxlbmd0aCA9PSAxID8gc3RhcnRDaCArIGluc2lkZVswXS5sZW5ndGggOiBpbnNpZGVbaW5zaWRlLmxlbmd0aCAtIDFdLmxlbmd0aCksXG4gICAgICAgICAgICBtYXRjaFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKHNlYXJjaFJlZ2V4cEJhY2t3YXJkTXVsdGlsaW5lLCBcInNlYXJjaFJlZ2V4cEJhY2t3YXJkTXVsdGlsaW5lXCIpO1xuICAgIHZhciBkb0ZvbGQsIG5vRm9sZDtcbiAgICBpZiAoU3RyaW5nLnByb3RvdHlwZS5ub3JtYWxpemUpIHtcbiAgICAgIGRvRm9sZCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIubm9ybWFsaXplKFwiTkZEXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9LCBcImRvRm9sZFwiKTtcbiAgICAgIG5vRm9sZCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIubm9ybWFsaXplKFwiTkZEXCIpO1xuICAgICAgfSwgXCJub0ZvbGRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvRm9sZCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgIH0sIFwiZG9Gb2xkXCIpO1xuICAgICAgbm9Gb2xkID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgIH0sIFwibm9Gb2xkXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGp1c3RQb3Mob3JpZywgZm9sZGVkLCBwb3MsIGZvbGRGdW5jKSB7XG4gICAgICBpZiAob3JpZy5sZW5ndGggPT0gZm9sZGVkLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgIGZvciAodmFyIG1pbiA9IDAsIG1heCA9IHBvcyArIE1hdGgubWF4KDAsIG9yaWcubGVuZ3RoIC0gZm9sZGVkLmxlbmd0aCk7IDsgKSB7XG4gICAgICAgIGlmIChtaW4gPT0gbWF4KVxuICAgICAgICAgIHJldHVybiBtaW47XG4gICAgICAgIHZhciBtaWQgPSBtaW4gKyBtYXggPj4gMTtcbiAgICAgICAgdmFyIGxlbiA9IGZvbGRGdW5jKG9yaWcuc2xpY2UoMCwgbWlkKSkubGVuZ3RoO1xuICAgICAgICBpZiAobGVuID09IHBvcylcbiAgICAgICAgICByZXR1cm4gbWlkO1xuICAgICAgICBlbHNlIGlmIChsZW4gPiBwb3MpXG4gICAgICAgICAgbWF4ID0gbWlkO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgbWluID0gbWlkICsgMTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKGFkanVzdFBvcywgXCJhZGp1c3RQb3NcIik7XG4gICAgZnVuY3Rpb24gc2VhcmNoU3RyaW5nRm9yd2FyZChkb2MsIHF1ZXJ5LCBzdGFydCwgY2FzZUZvbGQpIHtcbiAgICAgIGlmICghcXVlcnkubGVuZ3RoKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBmb2xkID0gY2FzZUZvbGQgPyBkb0ZvbGQgOiBub0ZvbGQ7XG4gICAgICB2YXIgbGluZXMgPSBmb2xkKHF1ZXJ5KS5zcGxpdCgvXFxyfFxcblxccj8vKTtcbiAgICAgIHNlYXJjaDpcbiAgICAgICAgZm9yICh2YXIgbGluZSA9IHN0YXJ0LmxpbmUsIGNoID0gc3RhcnQuY2gsIGxhc3QgPSBkb2MubGFzdExpbmUoKSArIDEgLSBsaW5lcy5sZW5ndGg7IGxpbmUgPD0gbGFzdDsgbGluZSsrLCBjaCA9IDApIHtcbiAgICAgICAgICB2YXIgb3JpZyA9IGRvYy5nZXRMaW5lKGxpbmUpLnNsaWNlKGNoKSwgc3RyaW5nID0gZm9sZChvcmlnKTtcbiAgICAgICAgICBpZiAobGluZXMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIHZhciBmb3VuZCA9IHN0cmluZy5pbmRleE9mKGxpbmVzWzBdKTtcbiAgICAgICAgICAgIGlmIChmb3VuZCA9PSAtMSlcbiAgICAgICAgICAgICAgY29udGludWUgc2VhcmNoO1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gYWRqdXN0UG9zKG9yaWcsIHN0cmluZywgZm91bmQsIGZvbGQpICsgY2g7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBmcm9tOiBQb3MobGluZSwgYWRqdXN0UG9zKG9yaWcsIHN0cmluZywgZm91bmQsIGZvbGQpICsgY2gpLFxuICAgICAgICAgICAgICB0bzogUG9zKGxpbmUsIGFkanVzdFBvcyhvcmlnLCBzdHJpbmcsIGZvdW5kICsgbGluZXNbMF0ubGVuZ3RoLCBmb2xkKSArIGNoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGN1dEZyb20gPSBzdHJpbmcubGVuZ3RoIC0gbGluZXNbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHN0cmluZy5zbGljZShjdXRGcm9tKSAhPSBsaW5lc1swXSlcbiAgICAgICAgICAgICAgY29udGludWUgc2VhcmNoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsaW5lcy5sZW5ndGggLSAxOyBpKyspXG4gICAgICAgICAgICAgIGlmIChmb2xkKGRvYy5nZXRMaW5lKGxpbmUgKyBpKSkgIT0gbGluZXNbaV0pXG4gICAgICAgICAgICAgICAgY29udGludWUgc2VhcmNoO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGRvYy5nZXRMaW5lKGxpbmUgKyBsaW5lcy5sZW5ndGggLSAxKSwgZW5kU3RyaW5nID0gZm9sZChlbmQpLCBsYXN0TGluZSA9IGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKGVuZFN0cmluZy5zbGljZSgwLCBsYXN0TGluZS5sZW5ndGgpICE9IGxhc3RMaW5lKVxuICAgICAgICAgICAgICBjb250aW51ZSBzZWFyY2g7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBmcm9tOiBQb3MobGluZSwgYWRqdXN0UG9zKG9yaWcsIHN0cmluZywgY3V0RnJvbSwgZm9sZCkgKyBjaCksXG4gICAgICAgICAgICAgIHRvOiBQb3MobGluZSArIGxpbmVzLmxlbmd0aCAtIDEsIGFkanVzdFBvcyhlbmQsIGVuZFN0cmluZywgbGFzdExpbmUubGVuZ3RoLCBmb2xkKSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShzZWFyY2hTdHJpbmdGb3J3YXJkLCBcInNlYXJjaFN0cmluZ0ZvcndhcmRcIik7XG4gICAgZnVuY3Rpb24gc2VhcmNoU3RyaW5nQmFja3dhcmQoZG9jLCBxdWVyeSwgc3RhcnQsIGNhc2VGb2xkKSB7XG4gICAgICBpZiAoIXF1ZXJ5Lmxlbmd0aClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgZm9sZCA9IGNhc2VGb2xkID8gZG9Gb2xkIDogbm9Gb2xkO1xuICAgICAgdmFyIGxpbmVzID0gZm9sZChxdWVyeSkuc3BsaXQoL1xccnxcXG5cXHI/Lyk7XG4gICAgICBzZWFyY2g6XG4gICAgICAgIGZvciAodmFyIGxpbmUgPSBzdGFydC5saW5lLCBjaCA9IHN0YXJ0LmNoLCBmaXJzdCA9IGRvYy5maXJzdExpbmUoKSAtIDEgKyBsaW5lcy5sZW5ndGg7IGxpbmUgPj0gZmlyc3Q7IGxpbmUtLSwgY2ggPSAtMSkge1xuICAgICAgICAgIHZhciBvcmlnID0gZG9jLmdldExpbmUobGluZSk7XG4gICAgICAgICAgaWYgKGNoID4gLTEpXG4gICAgICAgICAgICBvcmlnID0gb3JpZy5zbGljZSgwLCBjaCk7XG4gICAgICAgICAgdmFyIHN0cmluZyA9IGZvbGQob3JpZyk7XG4gICAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICB2YXIgZm91bmQgPSBzdHJpbmcubGFzdEluZGV4T2YobGluZXNbMF0pO1xuICAgICAgICAgICAgaWYgKGZvdW5kID09IC0xKVxuICAgICAgICAgICAgICBjb250aW51ZSBzZWFyY2g7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBmcm9tOiBQb3MobGluZSwgYWRqdXN0UG9zKG9yaWcsIHN0cmluZywgZm91bmQsIGZvbGQpKSxcbiAgICAgICAgICAgICAgdG86IFBvcyhsaW5lLCBhZGp1c3RQb3Mob3JpZywgc3RyaW5nLCBmb3VuZCArIGxpbmVzWzBdLmxlbmd0aCwgZm9sZCkpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbGFzdExpbmUgPSBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChzdHJpbmcuc2xpY2UoMCwgbGFzdExpbmUubGVuZ3RoKSAhPSBsYXN0TGluZSlcbiAgICAgICAgICAgICAgY29udGludWUgc2VhcmNoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDEsIHN0YXJ0ID0gbGluZSAtIGxpbmVzLmxlbmd0aCArIDE7IGkgPCBsaW5lcy5sZW5ndGggLSAxOyBpKyspXG4gICAgICAgICAgICAgIGlmIChmb2xkKGRvYy5nZXRMaW5lKHN0YXJ0ICsgaSkpICE9IGxpbmVzW2ldKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlIHNlYXJjaDtcbiAgICAgICAgICAgIHZhciB0b3AgPSBkb2MuZ2V0TGluZShsaW5lICsgMSAtIGxpbmVzLmxlbmd0aCksIHRvcFN0cmluZyA9IGZvbGQodG9wKTtcbiAgICAgICAgICAgIGlmICh0b3BTdHJpbmcuc2xpY2UodG9wU3RyaW5nLmxlbmd0aCAtIGxpbmVzWzBdLmxlbmd0aCkgIT0gbGluZXNbMF0pXG4gICAgICAgICAgICAgIGNvbnRpbnVlIHNlYXJjaDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGZyb206IFBvcyhsaW5lICsgMSAtIGxpbmVzLmxlbmd0aCwgYWRqdXN0UG9zKHRvcCwgdG9wU3RyaW5nLCB0b3AubGVuZ3RoIC0gbGluZXNbMF0ubGVuZ3RoLCBmb2xkKSksXG4gICAgICAgICAgICAgIHRvOiBQb3MobGluZSwgYWRqdXN0UG9zKG9yaWcsIHN0cmluZywgbGFzdExpbmUubGVuZ3RoLCBmb2xkKSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShzZWFyY2hTdHJpbmdCYWNrd2FyZCwgXCJzZWFyY2hTdHJpbmdCYWNrd2FyZFwiKTtcbiAgICBmdW5jdGlvbiBTZWFyY2hDdXJzb3IoZG9jLCBxdWVyeSwgcG9zLCBvcHRpb25zKSB7XG4gICAgICB0aGlzLmF0T2NjdXJyZW5jZSA9IGZhbHNlO1xuICAgICAgdGhpcy5hZnRlckVtcHR5TWF0Y2ggPSBmYWxzZTtcbiAgICAgIHRoaXMuZG9jID0gZG9jO1xuICAgICAgcG9zID0gcG9zID8gZG9jLmNsaXBQb3MocG9zKSA6IFBvcygwLCAwKTtcbiAgICAgIHRoaXMucG9zID0geyBmcm9tOiBwb3MsIHRvOiBwb3MgfTtcbiAgICAgIHZhciBjYXNlRm9sZDtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGNhc2VGb2xkID0gb3B0aW9ucy5jYXNlRm9sZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhc2VGb2xkID0gb3B0aW9ucztcbiAgICAgICAgb3B0aW9ucyA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHF1ZXJ5ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKGNhc2VGb2xkID09IG51bGwpXG4gICAgICAgICAgY2FzZUZvbGQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tYXRjaGVzID0gZnVuY3Rpb24ocmV2ZXJzZSwgcG9zMikge1xuICAgICAgICAgIHJldHVybiAocmV2ZXJzZSA/IHNlYXJjaFN0cmluZ0JhY2t3YXJkIDogc2VhcmNoU3RyaW5nRm9yd2FyZCkoZG9jLCBxdWVyeSwgcG9zMiwgY2FzZUZvbGQpO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVlcnkgPSBlbnN1cmVGbGFncyhxdWVyeSwgXCJnbVwiKTtcbiAgICAgICAgaWYgKCFvcHRpb25zIHx8IG9wdGlvbnMubXVsdGlsaW5lICE9PSBmYWxzZSlcbiAgICAgICAgICB0aGlzLm1hdGNoZXMgPSBmdW5jdGlvbihyZXZlcnNlLCBwb3MyKSB7XG4gICAgICAgICAgICByZXR1cm4gKHJldmVyc2UgPyBzZWFyY2hSZWdleHBCYWNrd2FyZE11bHRpbGluZSA6IHNlYXJjaFJlZ2V4cEZvcndhcmRNdWx0aWxpbmUpKGRvYywgcXVlcnksIHBvczIpO1xuICAgICAgICAgIH07XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aGlzLm1hdGNoZXMgPSBmdW5jdGlvbihyZXZlcnNlLCBwb3MyKSB7XG4gICAgICAgICAgICByZXR1cm4gKHJldmVyc2UgPyBzZWFyY2hSZWdleHBCYWNrd2FyZCA6IHNlYXJjaFJlZ2V4cEZvcndhcmQpKGRvYywgcXVlcnksIHBvczIpO1xuICAgICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShTZWFyY2hDdXJzb3IsIFwiU2VhcmNoQ3Vyc29yXCIpO1xuICAgIFNlYXJjaEN1cnNvci5wcm90b3R5cGUgPSB7XG4gICAgICBmaW5kTmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmQoZmFsc2UpO1xuICAgICAgfSxcbiAgICAgIGZpbmRQcmV2aW91czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmQodHJ1ZSk7XG4gICAgICB9LFxuICAgICAgZmluZDogZnVuY3Rpb24ocmV2ZXJzZSkge1xuICAgICAgICB2YXIgaGVhZCA9IHRoaXMuZG9jLmNsaXBQb3MocmV2ZXJzZSA/IHRoaXMucG9zLmZyb20gOiB0aGlzLnBvcy50byk7XG4gICAgICAgIGlmICh0aGlzLmFmdGVyRW1wdHlNYXRjaCAmJiB0aGlzLmF0T2NjdXJyZW5jZSkge1xuICAgICAgICAgIGhlYWQgPSBQb3MoaGVhZC5saW5lLCBoZWFkLmNoKTtcbiAgICAgICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICAgICAgaGVhZC5jaC0tO1xuICAgICAgICAgICAgaWYgKGhlYWQuY2ggPCAwKSB7XG4gICAgICAgICAgICAgIGhlYWQubGluZS0tO1xuICAgICAgICAgICAgICBoZWFkLmNoID0gKHRoaXMuZG9jLmdldExpbmUoaGVhZC5saW5lKSB8fCBcIlwiKS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhlYWQuY2grKztcbiAgICAgICAgICAgIGlmIChoZWFkLmNoID4gKHRoaXMuZG9jLmdldExpbmUoaGVhZC5saW5lKSB8fCBcIlwiKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgaGVhZC5jaCA9IDA7XG4gICAgICAgICAgICAgIGhlYWQubGluZSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoQ29kZU1pcnJvci5jbXBQb3MoaGVhZCwgdGhpcy5kb2MuY2xpcFBvcyhoZWFkKSkgIT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXRPY2N1cnJlbmNlID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLm1hdGNoZXMocmV2ZXJzZSwgaGVhZCk7XG4gICAgICAgIHRoaXMuYWZ0ZXJFbXB0eU1hdGNoID0gcmVzdWx0ICYmIENvZGVNaXJyb3IuY21wUG9zKHJlc3VsdC5mcm9tLCByZXN1bHQudG8pID09IDA7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICB0aGlzLnBvcyA9IHJlc3VsdDtcbiAgICAgICAgICB0aGlzLmF0T2NjdXJyZW5jZSA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucG9zLm1hdGNoIHx8IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGVuZCA9IFBvcyhyZXZlcnNlID8gdGhpcy5kb2MuZmlyc3RMaW5lKCkgOiB0aGlzLmRvYy5sYXN0TGluZSgpICsgMSwgMCk7XG4gICAgICAgICAgdGhpcy5wb3MgPSB7IGZyb206IGVuZCwgdG86IGVuZCB9O1xuICAgICAgICAgIHJldHVybiB0aGlzLmF0T2NjdXJyZW5jZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZnJvbTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmF0T2NjdXJyZW5jZSlcbiAgICAgICAgICByZXR1cm4gdGhpcy5wb3MuZnJvbTtcbiAgICAgIH0sXG4gICAgICB0bzogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmF0T2NjdXJyZW5jZSlcbiAgICAgICAgICByZXR1cm4gdGhpcy5wb3MudG87XG4gICAgICB9LFxuICAgICAgcmVwbGFjZTogZnVuY3Rpb24obmV3VGV4dCwgb3JpZ2luKSB7XG4gICAgICAgIGlmICghdGhpcy5hdE9jY3VycmVuY2UpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgbGluZXMgPSBDb2RlTWlycm9yLnNwbGl0TGluZXMobmV3VGV4dCk7XG4gICAgICAgIHRoaXMuZG9jLnJlcGxhY2VSYW5nZShsaW5lcywgdGhpcy5wb3MuZnJvbSwgdGhpcy5wb3MudG8sIG9yaWdpbik7XG4gICAgICAgIHRoaXMucG9zLnRvID0gUG9zKHRoaXMucG9zLmZyb20ubGluZSArIGxpbmVzLmxlbmd0aCAtIDEsIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLmxlbmd0aCArIChsaW5lcy5sZW5ndGggPT0gMSA/IHRoaXMucG9zLmZyb20uY2ggOiAwKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBDb2RlTWlycm9yLmRlZmluZUV4dGVuc2lvbihcImdldFNlYXJjaEN1cnNvclwiLCBmdW5jdGlvbihxdWVyeSwgcG9zLCBjYXNlRm9sZCkge1xuICAgICAgcmV0dXJuIG5ldyBTZWFyY2hDdXJzb3IodGhpcy5kb2MsIHF1ZXJ5LCBwb3MsIGNhc2VGb2xkKTtcbiAgICB9KTtcbiAgICBDb2RlTWlycm9yLmRlZmluZURvY0V4dGVuc2lvbihcImdldFNlYXJjaEN1cnNvclwiLCBmdW5jdGlvbihxdWVyeSwgcG9zLCBjYXNlRm9sZCkge1xuICAgICAgcmV0dXJuIG5ldyBTZWFyY2hDdXJzb3IodGhpcywgcXVlcnksIHBvcywgY2FzZUZvbGQpO1xuICAgIH0pO1xuICAgIENvZGVNaXJyb3IuZGVmaW5lRXh0ZW5zaW9uKFwic2VsZWN0TWF0Y2hlc1wiLCBmdW5jdGlvbihxdWVyeSwgY2FzZUZvbGQpIHtcbiAgICAgIHZhciByYW5nZXMgPSBbXTtcbiAgICAgIHZhciBjdXIgPSB0aGlzLmdldFNlYXJjaEN1cnNvcihxdWVyeSwgdGhpcy5nZXRDdXJzb3IoXCJmcm9tXCIpLCBjYXNlRm9sZCk7XG4gICAgICB3aGlsZSAoY3VyLmZpbmROZXh0KCkpIHtcbiAgICAgICAgaWYgKENvZGVNaXJyb3IuY21wUG9zKGN1ci50bygpLCB0aGlzLmdldEN1cnNvcihcInRvXCIpKSA+IDApXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIHJhbmdlcy5wdXNoKHsgYW5jaG9yOiBjdXIuZnJvbSgpLCBoZWFkOiBjdXIudG8oKSB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChyYW5nZXMubGVuZ3RoKVxuICAgICAgICB0aGlzLnNldFNlbGVjdGlvbnMocmFuZ2VzLCAwKTtcbiAgICB9KTtcbiAgfSk7XG59KSgpO1xudmFyIHNlYXJjaGN1cnNvciA9IHNlYXJjaGN1cnNvciQyLmV4cG9ydHM7XG52YXIgc2VhcmNoY3Vyc29yJDEgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gX21lcmdlTmFtZXNwYWNlcyh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106IFwiTW9kdWxlXCIsXG4gIFwiZGVmYXVsdFwiOiBzZWFyY2hjdXJzb3Jcbn0sIFtzZWFyY2hjdXJzb3IkMi5leHBvcnRzXSkpO1xuZXhwb3J0IHsgc2VhcmNoY3Vyc29yJDIgYXMgYSwgc2VhcmNoY3Vyc29yJDEgYXMgcyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///26105\n')}}]);