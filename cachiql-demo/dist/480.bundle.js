"use strict";(self.webpackChunkcachiql_demo=self.webpackChunkcachiql_demo||[]).push([[480],{97480:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "C": () => (/* binding */ CodeMirror),\n/* harmony export */   "a": () => (/* binding */ codemirror$1),\n/* harmony export */   "c": () => (/* binding */ codemirror)\n/* harmony export */ });\n/* harmony import */ var _index_es_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59361);\nvar __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, "name", { value, configurable: true });\n\nfunction _mergeNamespaces(n, m) {\n  m.forEach(function(e) {\n    e && typeof e !== "string" && !Array.isArray(e) && Object.keys(e).forEach(function(k) {\n      if (k !== "default" && !(k in n)) {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function() {\n            return e[k];\n          }\n        });\n      }\n    });\n  });\n  return Object.freeze(n);\n}\n__name(_mergeNamespaces, "_mergeNamespaces");\nvar codemirror$1 = { exports: {} };\n(function(module, exports) {\n  (function(global, factory) {\n    module.exports = factory();\n  })(_index_es_js__WEBPACK_IMPORTED_MODULE_0__.c, function() {\n    var userAgent = navigator.userAgent;\n    var platform = navigator.platform;\n    var gecko = /gecko\\/\\d/i.test(userAgent);\n    var ie_upto10 = /MSIE \\d/.test(userAgent);\n    var ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(userAgent);\n    var edge = /Edge\\/(\\d+)/.exec(userAgent);\n    var ie = ie_upto10 || ie_11up || edge;\n    var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);\n    var webkit = !edge && /WebKit\\//.test(userAgent);\n    var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(userAgent);\n    var chrome = !edge && /Chrome\\//.test(userAgent);\n    var presto = /Opera\\//.test(userAgent);\n    var safari = /Apple Computer/.test(navigator.vendor);\n    var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(userAgent);\n    var phantom = /PhantomJS/.test(userAgent);\n    var ios = safari && (/Mobile\\/\\w+/.test(userAgent) || navigator.maxTouchPoints > 2);\n    var android = /Android/.test(userAgent);\n    var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);\n    var mac = ios || /Mac/.test(platform);\n    var chromeOS = /\\bCrOS\\b/.test(userAgent);\n    var windows = /win/i.test(platform);\n    var presto_version = presto && userAgent.match(/Version\\/(\\d*\\.\\d*)/);\n    if (presto_version) {\n      presto_version = Number(presto_version[1]);\n    }\n    if (presto_version && presto_version >= 15) {\n      presto = false;\n      webkit = true;\n    }\n    var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\n    var captureRightClick = gecko || ie && ie_version >= 9;\n    function classTest(cls) {\n      return new RegExp("(^|\\\\s)" + cls + "(?:$|\\\\s)\\\\s*");\n    }\n    __name(classTest, "classTest");\n    var rmClass = /* @__PURE__ */ __name(function(node, cls) {\n      var current = node.className;\n      var match = classTest(cls).exec(current);\n      if (match) {\n        var after = current.slice(match.index + match[0].length);\n        node.className = current.slice(0, match.index) + (after ? match[1] + after : "");\n      }\n    }, "rmClass");\n    function removeChildren(e) {\n      for (var count = e.childNodes.length; count > 0; --count) {\n        e.removeChild(e.firstChild);\n      }\n      return e;\n    }\n    __name(removeChildren, "removeChildren");\n    function removeChildrenAndAdd(parent, e) {\n      return removeChildren(parent).appendChild(e);\n    }\n    __name(removeChildrenAndAdd, "removeChildrenAndAdd");\n    function elt(tag, content, className, style) {\n      var e = document.createElement(tag);\n      if (className) {\n        e.className = className;\n      }\n      if (style) {\n        e.style.cssText = style;\n      }\n      if (typeof content == "string") {\n        e.appendChild(document.createTextNode(content));\n      } else if (content) {\n        for (var i2 = 0; i2 < content.length; ++i2) {\n          e.appendChild(content[i2]);\n        }\n      }\n      return e;\n    }\n    __name(elt, "elt");\n    function eltP(tag, content, className, style) {\n      var e = elt(tag, content, className, style);\n      e.setAttribute("role", "presentation");\n      return e;\n    }\n    __name(eltP, "eltP");\n    var range;\n    if (document.createRange) {\n      range = /* @__PURE__ */ __name(function(node, start, end, endNode) {\n        var r = document.createRange();\n        r.setEnd(endNode || node, end);\n        r.setStart(node, start);\n        return r;\n      }, "range");\n    } else {\n      range = /* @__PURE__ */ __name(function(node, start, end) {\n        var r = document.body.createTextRange();\n        try {\n          r.moveToElementText(node.parentNode);\n        } catch (e) {\n          return r;\n        }\n        r.collapse(true);\n        r.moveEnd("character", end);\n        r.moveStart("character", start);\n        return r;\n      }, "range");\n    }\n    function contains(parent, child) {\n      if (child.nodeType == 3) {\n        child = child.parentNode;\n      }\n      if (parent.contains) {\n        return parent.contains(child);\n      }\n      do {\n        if (child.nodeType == 11) {\n          child = child.host;\n        }\n        if (child == parent) {\n          return true;\n        }\n      } while (child = child.parentNode);\n    }\n    __name(contains, "contains");\n    function activeElt() {\n      var activeElement;\n      try {\n        activeElement = document.activeElement;\n      } catch (e) {\n        activeElement = document.body || null;\n      }\n      while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement) {\n        activeElement = activeElement.shadowRoot.activeElement;\n      }\n      return activeElement;\n    }\n    __name(activeElt, "activeElt");\n    function addClass(node, cls) {\n      var current = node.className;\n      if (!classTest(cls).test(current)) {\n        node.className += (current ? " " : "") + cls;\n      }\n    }\n    __name(addClass, "addClass");\n    function joinClasses(a, b) {\n      var as = a.split(" ");\n      for (var i2 = 0; i2 < as.length; i2++) {\n        if (as[i2] && !classTest(as[i2]).test(b)) {\n          b += " " + as[i2];\n        }\n      }\n      return b;\n    }\n    __name(joinClasses, "joinClasses");\n    var selectInput = /* @__PURE__ */ __name(function(node) {\n      node.select();\n    }, "selectInput");\n    if (ios) {\n      selectInput = /* @__PURE__ */ __name(function(node) {\n        node.selectionStart = 0;\n        node.selectionEnd = node.value.length;\n      }, "selectInput");\n    } else if (ie) {\n      selectInput = /* @__PURE__ */ __name(function(node) {\n        try {\n          node.select();\n        } catch (_e) {\n        }\n      }, "selectInput");\n    }\n    function bind(f) {\n      var args = Array.prototype.slice.call(arguments, 1);\n      return function() {\n        return f.apply(null, args);\n      };\n    }\n    __name(bind, "bind");\n    function copyObj(obj, target, overwrite) {\n      if (!target) {\n        target = {};\n      }\n      for (var prop2 in obj) {\n        if (obj.hasOwnProperty(prop2) && (overwrite !== false || !target.hasOwnProperty(prop2))) {\n          target[prop2] = obj[prop2];\n        }\n      }\n      return target;\n    }\n    __name(copyObj, "copyObj");\n    function countColumn(string, end, tabSize, startIndex, startValue) {\n      if (end == null) {\n        end = string.search(/[^\\s\\u00a0]/);\n        if (end == -1) {\n          end = string.length;\n        }\n      }\n      for (var i2 = startIndex || 0, n = startValue || 0; ; ) {\n        var nextTab = string.indexOf("\t", i2);\n        if (nextTab < 0 || nextTab >= end) {\n          return n + (end - i2);\n        }\n        n += nextTab - i2;\n        n += tabSize - n % tabSize;\n        i2 = nextTab + 1;\n      }\n    }\n    __name(countColumn, "countColumn");\n    var Delayed = /* @__PURE__ */ __name(function() {\n      this.id = null;\n      this.f = null;\n      this.time = 0;\n      this.handler = bind(this.onTimeout, this);\n    }, "Delayed");\n    Delayed.prototype.onTimeout = function(self) {\n      self.id = 0;\n      if (self.time <= +new Date()) {\n        self.f();\n      } else {\n        setTimeout(self.handler, self.time - +new Date());\n      }\n    };\n    Delayed.prototype.set = function(ms, f) {\n      this.f = f;\n      var time = +new Date() + ms;\n      if (!this.id || time < this.time) {\n        clearTimeout(this.id);\n        this.id = setTimeout(this.handler, ms);\n        this.time = time;\n      }\n    };\n    function indexOf(array, elt2) {\n      for (var i2 = 0; i2 < array.length; ++i2) {\n        if (array[i2] == elt2) {\n          return i2;\n        }\n      }\n      return -1;\n    }\n    __name(indexOf, "indexOf");\n    var scrollerGap = 50;\n    var Pass = { toString: function() {\n      return "CodeMirror.Pass";\n    } };\n    var sel_dontScroll = { scroll: false }, sel_mouse = { origin: "*mouse" }, sel_move = { origin: "+move" };\n    function findColumn(string, goal, tabSize) {\n      for (var pos = 0, col = 0; ; ) {\n        var nextTab = string.indexOf("\t", pos);\n        if (nextTab == -1) {\n          nextTab = string.length;\n        }\n        var skipped = nextTab - pos;\n        if (nextTab == string.length || col + skipped >= goal) {\n          return pos + Math.min(skipped, goal - col);\n        }\n        col += nextTab - pos;\n        col += tabSize - col % tabSize;\n        pos = nextTab + 1;\n        if (col >= goal) {\n          return pos;\n        }\n      }\n    }\n    __name(findColumn, "findColumn");\n    var spaceStrs = [""];\n    function spaceStr(n) {\n      while (spaceStrs.length <= n) {\n        spaceStrs.push(lst(spaceStrs) + " ");\n      }\n      return spaceStrs[n];\n    }\n    __name(spaceStr, "spaceStr");\n    function lst(arr) {\n      return arr[arr.length - 1];\n    }\n    __name(lst, "lst");\n    function map(array, f) {\n      var out = [];\n      for (var i2 = 0; i2 < array.length; i2++) {\n        out[i2] = f(array[i2], i2);\n      }\n      return out;\n    }\n    __name(map, "map");\n    function insertSorted(array, value, score) {\n      var pos = 0, priority = score(value);\n      while (pos < array.length && score(array[pos]) <= priority) {\n        pos++;\n      }\n      array.splice(pos, 0, value);\n    }\n    __name(insertSorted, "insertSorted");\n    function nothing() {\n    }\n    __name(nothing, "nothing");\n    function createObj(base, props) {\n      var inst;\n      if (Object.create) {\n        inst = Object.create(base);\n      } else {\n        nothing.prototype = base;\n        inst = new nothing();\n      }\n      if (props) {\n        copyObj(props, inst);\n      }\n      return inst;\n    }\n    __name(createObj, "createObj");\n    var nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\n    function isWordCharBasic(ch) {\n      return /\\w/.test(ch) || ch > "\\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));\n    }\n    __name(isWordCharBasic, "isWordCharBasic");\n    function isWordChar(ch, helper) {\n      if (!helper) {\n        return isWordCharBasic(ch);\n      }\n      if (helper.source.indexOf("\\\\w") > -1 && isWordCharBasic(ch)) {\n        return true;\n      }\n      return helper.test(ch);\n    }\n    __name(isWordChar, "isWordChar");\n    function isEmpty(obj) {\n      for (var n in obj) {\n        if (obj.hasOwnProperty(n) && obj[n]) {\n          return false;\n        }\n      }\n      return true;\n    }\n    __name(isEmpty, "isEmpty");\n    var extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\n    function isExtendingChar(ch) {\n      return ch.charCodeAt(0) >= 768 && extendingChars.test(ch);\n    }\n    __name(isExtendingChar, "isExtendingChar");\n    function skipExtendingChars(str, pos, dir) {\n      while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) {\n        pos += dir;\n      }\n      return pos;\n    }\n    __name(skipExtendingChars, "skipExtendingChars");\n    function findFirst(pred, from, to) {\n      var dir = from > to ? -1 : 1;\n      for (; ; ) {\n        if (from == to) {\n          return from;\n        }\n        var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);\n        if (mid == from) {\n          return pred(mid) ? from : to;\n        }\n        if (pred(mid)) {\n          to = mid;\n        } else {\n          from = mid + dir;\n        }\n      }\n    }\n    __name(findFirst, "findFirst");\n    function iterateBidiSections(order, from, to, f) {\n      if (!order) {\n        return f(from, to, "ltr", 0);\n      }\n      var found = false;\n      for (var i2 = 0; i2 < order.length; ++i2) {\n        var part = order[i2];\n        if (part.from < to && part.to > from || from == to && part.to == from) {\n          f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i2);\n          found = true;\n        }\n      }\n      if (!found) {\n        f(from, to, "ltr");\n      }\n    }\n    __name(iterateBidiSections, "iterateBidiSections");\n    var bidiOther = null;\n    function getBidiPartAt(order, ch, sticky) {\n      var found;\n      bidiOther = null;\n      for (var i2 = 0; i2 < order.length; ++i2) {\n        var cur = order[i2];\n        if (cur.from < ch && cur.to > ch) {\n          return i2;\n        }\n        if (cur.to == ch) {\n          if (cur.from != cur.to && sticky == "before") {\n            found = i2;\n          } else {\n            bidiOther = i2;\n          }\n        }\n        if (cur.from == ch) {\n          if (cur.from != cur.to && sticky != "before") {\n            found = i2;\n          } else {\n            bidiOther = i2;\n          }\n        }\n      }\n      return found != null ? found : bidiOther;\n    }\n    __name(getBidiPartAt, "getBidiPartAt");\n    var bidiOrdering = function() {\n      var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";\n      var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";\n      function charType(code) {\n        if (code <= 247) {\n          return lowTypes.charAt(code);\n        } else if (1424 <= code && code <= 1524) {\n          return "R";\n        } else if (1536 <= code && code <= 1785) {\n          return arabicTypes.charAt(code - 1536);\n        } else if (1774 <= code && code <= 2220) {\n          return "r";\n        } else if (8192 <= code && code <= 8203) {\n          return "w";\n        } else if (code == 8204) {\n          return "b";\n        } else {\n          return "L";\n        }\n      }\n      __name(charType, "charType");\n      var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n      var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n      function BidiSpan(level, from, to) {\n        this.level = level;\n        this.from = from;\n        this.to = to;\n      }\n      __name(BidiSpan, "BidiSpan");\n      return function(str, direction) {\n        var outerType = direction == "ltr" ? "L" : "R";\n        if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) {\n          return false;\n        }\n        var len = str.length, types = [];\n        for (var i2 = 0; i2 < len; ++i2) {\n          types.push(charType(str.charCodeAt(i2)));\n        }\n        for (var i$12 = 0, prev = outerType; i$12 < len; ++i$12) {\n          var type = types[i$12];\n          if (type == "m") {\n            types[i$12] = prev;\n          } else {\n            prev = type;\n          }\n        }\n        for (var i$22 = 0, cur = outerType; i$22 < len; ++i$22) {\n          var type$1 = types[i$22];\n          if (type$1 == "1" && cur == "r") {\n            types[i$22] = "n";\n          } else if (isStrong.test(type$1)) {\n            cur = type$1;\n            if (type$1 == "r") {\n              types[i$22] = "R";\n            }\n          }\n        }\n        for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {\n          var type$2 = types[i$3];\n          if (type$2 == "+" && prev$1 == "1" && types[i$3 + 1] == "1") {\n            types[i$3] = "1";\n          } else if (type$2 == "," && prev$1 == types[i$3 + 1] && (prev$1 == "1" || prev$1 == "n")) {\n            types[i$3] = prev$1;\n          }\n          prev$1 = type$2;\n        }\n        for (var i$4 = 0; i$4 < len; ++i$4) {\n          var type$3 = types[i$4];\n          if (type$3 == ",") {\n            types[i$4] = "N";\n          } else if (type$3 == "%") {\n            var end = void 0;\n            for (end = i$4 + 1; end < len && types[end] == "%"; ++end) {\n            }\n            var replace = i$4 && types[i$4 - 1] == "!" || end < len && types[end] == "1" ? "1" : "N";\n            for (var j = i$4; j < end; ++j) {\n              types[j] = replace;\n            }\n            i$4 = end - 1;\n          }\n        }\n        for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {\n          var type$4 = types[i$5];\n          if (cur$1 == "L" && type$4 == "1") {\n            types[i$5] = "L";\n          } else if (isStrong.test(type$4)) {\n            cur$1 = type$4;\n          }\n        }\n        for (var i$6 = 0; i$6 < len; ++i$6) {\n          if (isNeutral.test(types[i$6])) {\n            var end$1 = void 0;\n            for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {\n            }\n            var before = (i$6 ? types[i$6 - 1] : outerType) == "L";\n            var after = (end$1 < len ? types[end$1] : outerType) == "L";\n            var replace$1 = before == after ? before ? "L" : "R" : outerType;\n            for (var j$1 = i$6; j$1 < end$1; ++j$1) {\n              types[j$1] = replace$1;\n            }\n            i$6 = end$1 - 1;\n          }\n        }\n        var order = [], m;\n        for (var i$7 = 0; i$7 < len; ) {\n          if (countsAsLeft.test(types[i$7])) {\n            var start = i$7;\n            for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {\n            }\n            order.push(new BidiSpan(0, start, i$7));\n          } else {\n            var pos = i$7, at = order.length, isRTL = direction == "rtl" ? 1 : 0;\n            for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) {\n            }\n            for (var j$2 = pos; j$2 < i$7; ) {\n              if (countsAsNum.test(types[j$2])) {\n                if (pos < j$2) {\n                  order.splice(at, 0, new BidiSpan(1, pos, j$2));\n                  at += isRTL;\n                }\n                var nstart = j$2;\n                for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {\n                }\n                order.splice(at, 0, new BidiSpan(2, nstart, j$2));\n                at += isRTL;\n                pos = j$2;\n              } else {\n                ++j$2;\n              }\n            }\n            if (pos < i$7) {\n              order.splice(at, 0, new BidiSpan(1, pos, i$7));\n            }\n          }\n        }\n        if (direction == "ltr") {\n          if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n            order[0].from = m[0].length;\n            order.unshift(new BidiSpan(0, 0, m[0].length));\n          }\n          if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n            lst(order).to -= m[0].length;\n            order.push(new BidiSpan(0, len - m[0].length, len));\n          }\n        }\n        return direction == "rtl" ? order.reverse() : order;\n      };\n    }();\n    function getOrder(line, direction) {\n      var order = line.order;\n      if (order == null) {\n        order = line.order = bidiOrdering(line.text, direction);\n      }\n      return order;\n    }\n    __name(getOrder, "getOrder");\n    var noHandlers = [];\n    var on = /* @__PURE__ */ __name(function(emitter, type, f) {\n      if (emitter.addEventListener) {\n        emitter.addEventListener(type, f, false);\n      } else if (emitter.attachEvent) {\n        emitter.attachEvent("on" + type, f);\n      } else {\n        var map2 = emitter._handlers || (emitter._handlers = {});\n        map2[type] = (map2[type] || noHandlers).concat(f);\n      }\n    }, "on");\n    function getHandlers(emitter, type) {\n      return emitter._handlers && emitter._handlers[type] || noHandlers;\n    }\n    __name(getHandlers, "getHandlers");\n    function off(emitter, type, f) {\n      if (emitter.removeEventListener) {\n        emitter.removeEventListener(type, f, false);\n      } else if (emitter.detachEvent) {\n        emitter.detachEvent("on" + type, f);\n      } else {\n        var map2 = emitter._handlers, arr = map2 && map2[type];\n        if (arr) {\n          var index = indexOf(arr, f);\n          if (index > -1) {\n            map2[type] = arr.slice(0, index).concat(arr.slice(index + 1));\n          }\n        }\n      }\n    }\n    __name(off, "off");\n    function signal(emitter, type) {\n      var handlers = getHandlers(emitter, type);\n      if (!handlers.length) {\n        return;\n      }\n      var args = Array.prototype.slice.call(arguments, 2);\n      for (var i2 = 0; i2 < handlers.length; ++i2) {\n        handlers[i2].apply(null, args);\n      }\n    }\n    __name(signal, "signal");\n    function signalDOMEvent(cm, e, override) {\n      if (typeof e == "string") {\n        e = { type: e, preventDefault: function() {\n          this.defaultPrevented = true;\n        } };\n      }\n      signal(cm, override || e.type, cm, e);\n      return e_defaultPrevented(e) || e.codemirrorIgnore;\n    }\n    __name(signalDOMEvent, "signalDOMEvent");\n    function signalCursorActivity(cm) {\n      var arr = cm._handlers && cm._handlers.cursorActivity;\n      if (!arr) {\n        return;\n      }\n      var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\n      for (var i2 = 0; i2 < arr.length; ++i2) {\n        if (indexOf(set, arr[i2]) == -1) {\n          set.push(arr[i2]);\n        }\n      }\n    }\n    __name(signalCursorActivity, "signalCursorActivity");\n    function hasHandler(emitter, type) {\n      return getHandlers(emitter, type).length > 0;\n    }\n    __name(hasHandler, "hasHandler");\n    function eventMixin(ctor) {\n      ctor.prototype.on = function(type, f) {\n        on(this, type, f);\n      };\n      ctor.prototype.off = function(type, f) {\n        off(this, type, f);\n      };\n    }\n    __name(eventMixin, "eventMixin");\n    function e_preventDefault(e) {\n      if (e.preventDefault) {\n        e.preventDefault();\n      } else {\n        e.returnValue = false;\n      }\n    }\n    __name(e_preventDefault, "e_preventDefault");\n    function e_stopPropagation(e) {\n      if (e.stopPropagation) {\n        e.stopPropagation();\n      } else {\n        e.cancelBubble = true;\n      }\n    }\n    __name(e_stopPropagation, "e_stopPropagation");\n    function e_defaultPrevented(e) {\n      return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;\n    }\n    __name(e_defaultPrevented, "e_defaultPrevented");\n    function e_stop(e) {\n      e_preventDefault(e);\n      e_stopPropagation(e);\n    }\n    __name(e_stop, "e_stop");\n    function e_target(e) {\n      return e.target || e.srcElement;\n    }\n    __name(e_target, "e_target");\n    function e_button(e) {\n      var b = e.which;\n      if (b == null) {\n        if (e.button & 1) {\n          b = 1;\n        } else if (e.button & 2) {\n          b = 3;\n        } else if (e.button & 4) {\n          b = 2;\n        }\n      }\n      if (mac && e.ctrlKey && b == 1) {\n        b = 3;\n      }\n      return b;\n    }\n    __name(e_button, "e_button");\n    var dragAndDrop = function() {\n      if (ie && ie_version < 9) {\n        return false;\n      }\n      var div = elt("div");\n      return "draggable" in div || "dragDrop" in div;\n    }();\n    var zwspSupported;\n    function zeroWidthElement(measure) {\n      if (zwspSupported == null) {\n        var test = elt("span", "\\u200B");\n        removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));\n        if (measure.firstChild.offsetHeight != 0) {\n          zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);\n        }\n      }\n      var node = zwspSupported ? elt("span", "\\u200B") : elt("span", "\\xA0", null, "display: inline-block; width: 1px; margin-right: -1px");\n      node.setAttribute("cm-text", "");\n      return node;\n    }\n    __name(zeroWidthElement, "zeroWidthElement");\n    var badBidiRects;\n    function hasBadBidiRects(measure) {\n      if (badBidiRects != null) {\n        return badBidiRects;\n      }\n      var txt = removeChildrenAndAdd(measure, document.createTextNode("A\\u062EA"));\n      var r0 = range(txt, 0, 1).getBoundingClientRect();\n      var r1 = range(txt, 1, 2).getBoundingClientRect();\n      removeChildren(measure);\n      if (!r0 || r0.left == r0.right) {\n        return false;\n      }\n      return badBidiRects = r1.right - r0.right < 3;\n    }\n    __name(hasBadBidiRects, "hasBadBidiRects");\n    var splitLinesAuto = "\\n\\nb".split(/\\n/).length != 3 ? function(string) {\n      var pos = 0, result = [], l = string.length;\n      while (pos <= l) {\n        var nl = string.indexOf("\\n", pos);\n        if (nl == -1) {\n          nl = string.length;\n        }\n        var line = string.slice(pos, string.charAt(nl - 1) == "\\r" ? nl - 1 : nl);\n        var rt = line.indexOf("\\r");\n        if (rt != -1) {\n          result.push(line.slice(0, rt));\n          pos += rt + 1;\n        } else {\n          result.push(line);\n          pos = nl + 1;\n        }\n      }\n      return result;\n    } : function(string) {\n      return string.split(/\\r\\n?|\\n/);\n    };\n    var hasSelection = window.getSelection ? function(te) {\n      try {\n        return te.selectionStart != te.selectionEnd;\n      } catch (e) {\n        return false;\n      }\n    } : function(te) {\n      var range2;\n      try {\n        range2 = te.ownerDocument.selection.createRange();\n      } catch (e) {\n      }\n      if (!range2 || range2.parentElement() != te) {\n        return false;\n      }\n      return range2.compareEndPoints("StartToEnd", range2) != 0;\n    };\n    var hasCopyEvent = function() {\n      var e = elt("div");\n      if ("oncopy" in e) {\n        return true;\n      }\n      e.setAttribute("oncopy", "return;");\n      return typeof e.oncopy == "function";\n    }();\n    var badZoomedRects = null;\n    function hasBadZoomedRects(measure) {\n      if (badZoomedRects != null) {\n        return badZoomedRects;\n      }\n      var node = removeChildrenAndAdd(measure, elt("span", "x"));\n      var normal = node.getBoundingClientRect();\n      var fromRange = range(node, 0, 1).getBoundingClientRect();\n      return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;\n    }\n    __name(hasBadZoomedRects, "hasBadZoomedRects");\n    var modes = {}, mimeModes = {};\n    function defineMode(name, mode) {\n      if (arguments.length > 2) {\n        mode.dependencies = Array.prototype.slice.call(arguments, 2);\n      }\n      modes[name] = mode;\n    }\n    __name(defineMode, "defineMode");\n    function defineMIME(mime, spec) {\n      mimeModes[mime] = spec;\n    }\n    __name(defineMIME, "defineMIME");\n    function resolveMode(spec) {\n      if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {\n        spec = mimeModes[spec];\n      } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {\n        var found = mimeModes[spec.name];\n        if (typeof found == "string") {\n          found = { name: found };\n        }\n        spec = createObj(found, spec);\n        spec.name = found.name;\n      } else if (typeof spec == "string" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n        return resolveMode("application/xml");\n      } else if (typeof spec == "string" && /^[\\w\\-]+\\/[\\w\\-]+\\+json$/.test(spec)) {\n        return resolveMode("application/json");\n      }\n      if (typeof spec == "string") {\n        return { name: spec };\n      } else {\n        return spec || { name: "null" };\n      }\n    }\n    __name(resolveMode, "resolveMode");\n    function getMode(options, spec) {\n      spec = resolveMode(spec);\n      var mfactory = modes[spec.name];\n      if (!mfactory) {\n        return getMode(options, "text/plain");\n      }\n      var modeObj = mfactory(options, spec);\n      if (modeExtensions.hasOwnProperty(spec.name)) {\n        var exts = modeExtensions[spec.name];\n        for (var prop2 in exts) {\n          if (!exts.hasOwnProperty(prop2)) {\n            continue;\n          }\n          if (modeObj.hasOwnProperty(prop2)) {\n            modeObj["_" + prop2] = modeObj[prop2];\n          }\n          modeObj[prop2] = exts[prop2];\n        }\n      }\n      modeObj.name = spec.name;\n      if (spec.helperType) {\n        modeObj.helperType = spec.helperType;\n      }\n      if (spec.modeProps) {\n        for (var prop$1 in spec.modeProps) {\n          modeObj[prop$1] = spec.modeProps[prop$1];\n        }\n      }\n      return modeObj;\n    }\n    __name(getMode, "getMode");\n    var modeExtensions = {};\n    function extendMode(mode, properties) {\n      var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};\n      copyObj(properties, exts);\n    }\n    __name(extendMode, "extendMode");\n    function copyState(mode, state) {\n      if (state === true) {\n        return state;\n      }\n      if (mode.copyState) {\n        return mode.copyState(state);\n      }\n      var nstate = {};\n      for (var n in state) {\n        var val = state[n];\n        if (val instanceof Array) {\n          val = val.concat([]);\n        }\n        nstate[n] = val;\n      }\n      return nstate;\n    }\n    __name(copyState, "copyState");\n    function innerMode(mode, state) {\n      var info;\n      while (mode.innerMode) {\n        info = mode.innerMode(state);\n        if (!info || info.mode == mode) {\n          break;\n        }\n        state = info.state;\n        mode = info.mode;\n      }\n      return info || { mode, state };\n    }\n    __name(innerMode, "innerMode");\n    function startState(mode, a1, a2) {\n      return mode.startState ? mode.startState(a1, a2) : true;\n    }\n    __name(startState, "startState");\n    var StringStream = /* @__PURE__ */ __name(function(string, tabSize, lineOracle) {\n      this.pos = this.start = 0;\n      this.string = string;\n      this.tabSize = tabSize || 8;\n      this.lastColumnPos = this.lastColumnValue = 0;\n      this.lineStart = 0;\n      this.lineOracle = lineOracle;\n    }, "StringStream");\n    StringStream.prototype.eol = function() {\n      return this.pos >= this.string.length;\n    };\n    StringStream.prototype.sol = function() {\n      return this.pos == this.lineStart;\n    };\n    StringStream.prototype.peek = function() {\n      return this.string.charAt(this.pos) || void 0;\n    };\n    StringStream.prototype.next = function() {\n      if (this.pos < this.string.length) {\n        return this.string.charAt(this.pos++);\n      }\n    };\n    StringStream.prototype.eat = function(match) {\n      var ch = this.string.charAt(this.pos);\n      var ok;\n      if (typeof match == "string") {\n        ok = ch == match;\n      } else {\n        ok = ch && (match.test ? match.test(ch) : match(ch));\n      }\n      if (ok) {\n        ++this.pos;\n        return ch;\n      }\n    };\n    StringStream.prototype.eatWhile = function(match) {\n      var start = this.pos;\n      while (this.eat(match)) {\n      }\n      return this.pos > start;\n    };\n    StringStream.prototype.eatSpace = function() {\n      var start = this.pos;\n      while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) {\n        ++this.pos;\n      }\n      return this.pos > start;\n    };\n    StringStream.prototype.skipToEnd = function() {\n      this.pos = this.string.length;\n    };\n    StringStream.prototype.skipTo = function(ch) {\n      var found = this.string.indexOf(ch, this.pos);\n      if (found > -1) {\n        this.pos = found;\n        return true;\n      }\n    };\n    StringStream.prototype.backUp = function(n) {\n      this.pos -= n;\n    };\n    StringStream.prototype.column = function() {\n      if (this.lastColumnPos < this.start) {\n        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n        this.lastColumnPos = this.start;\n      }\n      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n    };\n    StringStream.prototype.indentation = function() {\n      return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n    };\n    StringStream.prototype.match = function(pattern, consume, caseInsensitive) {\n      if (typeof pattern == "string") {\n        var cased = /* @__PURE__ */ __name(function(str) {\n          return caseInsensitive ? str.toLowerCase() : str;\n        }, "cased");\n        var substr = this.string.substr(this.pos, pattern.length);\n        if (cased(substr) == cased(pattern)) {\n          if (consume !== false) {\n            this.pos += pattern.length;\n          }\n          return true;\n        }\n      } else {\n        var match = this.string.slice(this.pos).match(pattern);\n        if (match && match.index > 0) {\n          return null;\n        }\n        if (match && consume !== false) {\n          this.pos += match[0].length;\n        }\n        return match;\n      }\n    };\n    StringStream.prototype.current = function() {\n      return this.string.slice(this.start, this.pos);\n    };\n    StringStream.prototype.hideFirstChars = function(n, inner) {\n      this.lineStart += n;\n      try {\n        return inner();\n      } finally {\n        this.lineStart -= n;\n      }\n    };\n    StringStream.prototype.lookAhead = function(n) {\n      var oracle = this.lineOracle;\n      return oracle && oracle.lookAhead(n);\n    };\n    StringStream.prototype.baseToken = function() {\n      var oracle = this.lineOracle;\n      return oracle && oracle.baseToken(this.pos);\n    };\n    function getLine(doc, n) {\n      n -= doc.first;\n      if (n < 0 || n >= doc.size) {\n        throw new Error("There is no line " + (n + doc.first) + " in the document.");\n      }\n      var chunk = doc;\n      while (!chunk.lines) {\n        for (var i2 = 0; ; ++i2) {\n          var child = chunk.children[i2], sz = child.chunkSize();\n          if (n < sz) {\n            chunk = child;\n            break;\n          }\n          n -= sz;\n        }\n      }\n      return chunk.lines[n];\n    }\n    __name(getLine, "getLine");\n    function getBetween(doc, start, end) {\n      var out = [], n = start.line;\n      doc.iter(start.line, end.line + 1, function(line) {\n        var text = line.text;\n        if (n == end.line) {\n          text = text.slice(0, end.ch);\n        }\n        if (n == start.line) {\n          text = text.slice(start.ch);\n        }\n        out.push(text);\n        ++n;\n      });\n      return out;\n    }\n    __name(getBetween, "getBetween");\n    function getLines(doc, from, to) {\n      var out = [];\n      doc.iter(from, to, function(line) {\n        out.push(line.text);\n      });\n      return out;\n    }\n    __name(getLines, "getLines");\n    function updateLineHeight(line, height) {\n      var diff = height - line.height;\n      if (diff) {\n        for (var n = line; n; n = n.parent) {\n          n.height += diff;\n        }\n      }\n    }\n    __name(updateLineHeight, "updateLineHeight");\n    function lineNo(line) {\n      if (line.parent == null) {\n        return null;\n      }\n      var cur = line.parent, no = indexOf(cur.lines, line);\n      for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n        for (var i2 = 0; ; ++i2) {\n          if (chunk.children[i2] == cur) {\n            break;\n          }\n          no += chunk.children[i2].chunkSize();\n        }\n      }\n      return no + cur.first;\n    }\n    __name(lineNo, "lineNo");\n    function lineAtHeight(chunk, h) {\n      var n = chunk.first;\n      outer:\n        do {\n          for (var i$12 = 0; i$12 < chunk.children.length; ++i$12) {\n            var child = chunk.children[i$12], ch = child.height;\n            if (h < ch) {\n              chunk = child;\n              continue outer;\n            }\n            h -= ch;\n            n += child.chunkSize();\n          }\n          return n;\n        } while (!chunk.lines);\n      var i2 = 0;\n      for (; i2 < chunk.lines.length; ++i2) {\n        var line = chunk.lines[i2], lh = line.height;\n        if (h < lh) {\n          break;\n        }\n        h -= lh;\n      }\n      return n + i2;\n    }\n    __name(lineAtHeight, "lineAtHeight");\n    function isLine(doc, l) {\n      return l >= doc.first && l < doc.first + doc.size;\n    }\n    __name(isLine, "isLine");\n    function lineNumberFor(options, i2) {\n      return String(options.lineNumberFormatter(i2 + options.firstLineNumber));\n    }\n    __name(lineNumberFor, "lineNumberFor");\n    function Pos(line, ch, sticky) {\n      if (sticky === void 0)\n        sticky = null;\n      if (!(this instanceof Pos)) {\n        return new Pos(line, ch, sticky);\n      }\n      this.line = line;\n      this.ch = ch;\n      this.sticky = sticky;\n    }\n    __name(Pos, "Pos");\n    function cmp(a, b) {\n      return a.line - b.line || a.ch - b.ch;\n    }\n    __name(cmp, "cmp");\n    function equalCursorPos(a, b) {\n      return a.sticky == b.sticky && cmp(a, b) == 0;\n    }\n    __name(equalCursorPos, "equalCursorPos");\n    function copyPos(x) {\n      return Pos(x.line, x.ch);\n    }\n    __name(copyPos, "copyPos");\n    function maxPos(a, b) {\n      return cmp(a, b) < 0 ? b : a;\n    }\n    __name(maxPos, "maxPos");\n    function minPos(a, b) {\n      return cmp(a, b) < 0 ? a : b;\n    }\n    __name(minPos, "minPos");\n    function clipLine(doc, n) {\n      return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));\n    }\n    __name(clipLine, "clipLine");\n    function clipPos(doc, pos) {\n      if (pos.line < doc.first) {\n        return Pos(doc.first, 0);\n      }\n      var last = doc.first + doc.size - 1;\n      if (pos.line > last) {\n        return Pos(last, getLine(doc, last).text.length);\n      }\n      return clipToLen(pos, getLine(doc, pos.line).text.length);\n    }\n    __name(clipPos, "clipPos");\n    function clipToLen(pos, linelen) {\n      var ch = pos.ch;\n      if (ch == null || ch > linelen) {\n        return Pos(pos.line, linelen);\n      } else if (ch < 0) {\n        return Pos(pos.line, 0);\n      } else {\n        return pos;\n      }\n    }\n    __name(clipToLen, "clipToLen");\n    function clipPosArray(doc, array) {\n      var out = [];\n      for (var i2 = 0; i2 < array.length; i2++) {\n        out[i2] = clipPos(doc, array[i2]);\n      }\n      return out;\n    }\n    __name(clipPosArray, "clipPosArray");\n    var SavedContext = /* @__PURE__ */ __name(function(state, lookAhead) {\n      this.state = state;\n      this.lookAhead = lookAhead;\n    }, "SavedContext");\n    var Context = /* @__PURE__ */ __name(function(doc, state, line, lookAhead) {\n      this.state = state;\n      this.doc = doc;\n      this.line = line;\n      this.maxLookAhead = lookAhead || 0;\n      this.baseTokens = null;\n      this.baseTokenPos = 1;\n    }, "Context");\n    Context.prototype.lookAhead = function(n) {\n      var line = this.doc.getLine(this.line + n);\n      if (line != null && n > this.maxLookAhead) {\n        this.maxLookAhead = n;\n      }\n      return line;\n    };\n    Context.prototype.baseToken = function(n) {\n      if (!this.baseTokens) {\n        return null;\n      }\n      while (this.baseTokens[this.baseTokenPos] <= n) {\n        this.baseTokenPos += 2;\n      }\n      var type = this.baseTokens[this.baseTokenPos + 1];\n      return {\n        type: type && type.replace(/( |^)overlay .*/, ""),\n        size: this.baseTokens[this.baseTokenPos] - n\n      };\n    };\n    Context.prototype.nextLine = function() {\n      this.line++;\n      if (this.maxLookAhead > 0) {\n        this.maxLookAhead--;\n      }\n    };\n    Context.fromSaved = function(doc, saved, line) {\n      if (saved instanceof SavedContext) {\n        return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead);\n      } else {\n        return new Context(doc, copyState(doc.mode, saved), line);\n      }\n    };\n    Context.prototype.save = function(copy) {\n      var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;\n      return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state;\n    };\n    function highlightLine(cm, line, context, forceToEnd) {\n      var st = [cm.state.modeGen], lineClasses = {};\n      runMode(cm, line.text, cm.doc.mode, context, function(end, style) {\n        return st.push(end, style);\n      }, lineClasses, forceToEnd);\n      var state = context.state;\n      var loop = /* @__PURE__ */ __name(function(o2) {\n        context.baseTokens = st;\n        var overlay = cm.state.overlays[o2], i2 = 1, at = 0;\n        context.state = true;\n        runMode(cm, line.text, overlay.mode, context, function(end, style) {\n          var start = i2;\n          while (at < end) {\n            var i_end = st[i2];\n            if (i_end > end) {\n              st.splice(i2, 1, end, st[i2 + 1], i_end);\n            }\n            i2 += 2;\n            at = Math.min(end, i_end);\n          }\n          if (!style) {\n            return;\n          }\n          if (overlay.opaque) {\n            st.splice(start, i2 - start, end, "overlay " + style);\n            i2 = start + 2;\n          } else {\n            for (; start < i2; start += 2) {\n              var cur = st[start + 1];\n              st[start + 1] = (cur ? cur + " " : "") + "overlay " + style;\n            }\n          }\n        }, lineClasses);\n        context.state = state;\n        context.baseTokens = null;\n        context.baseTokenPos = 1;\n      }, "loop");\n      for (var o = 0; o < cm.state.overlays.length; ++o)\n        loop(o);\n      return { styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null };\n    }\n    __name(highlightLine, "highlightLine");\n    function getLineStyles(cm, line, updateFrontier) {\n      if (!line.styles || line.styles[0] != cm.state.modeGen) {\n        var context = getContextBefore(cm, lineNo(line));\n        var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);\n        var result = highlightLine(cm, line, context);\n        if (resetState) {\n          context.state = resetState;\n        }\n        line.stateAfter = context.save(!resetState);\n        line.styles = result.styles;\n        if (result.classes) {\n          line.styleClasses = result.classes;\n        } else if (line.styleClasses) {\n          line.styleClasses = null;\n        }\n        if (updateFrontier === cm.doc.highlightFrontier) {\n          cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier);\n        }\n      }\n      return line.styles;\n    }\n    __name(getLineStyles, "getLineStyles");\n    function getContextBefore(cm, n, precise) {\n      var doc = cm.doc, display = cm.display;\n      if (!doc.mode.startState) {\n        return new Context(doc, true, n);\n      }\n      var start = findStartLine(cm, n, precise);\n      var saved = start > doc.first && getLine(doc, start - 1).stateAfter;\n      var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);\n      doc.iter(start, n, function(line) {\n        processLine(cm, line.text, context);\n        var pos = context.line;\n        line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;\n        context.nextLine();\n      });\n      if (precise) {\n        doc.modeFrontier = context.line;\n      }\n      return context;\n    }\n    __name(getContextBefore, "getContextBefore");\n    function processLine(cm, text, context, startAt) {\n      var mode = cm.doc.mode;\n      var stream = new StringStream(text, cm.options.tabSize, context);\n      stream.start = stream.pos = startAt || 0;\n      if (text == "") {\n        callBlankLine(mode, context.state);\n      }\n      while (!stream.eol()) {\n        readToken(mode, stream, context.state);\n        stream.start = stream.pos;\n      }\n    }\n    __name(processLine, "processLine");\n    function callBlankLine(mode, state) {\n      if (mode.blankLine) {\n        return mode.blankLine(state);\n      }\n      if (!mode.innerMode) {\n        return;\n      }\n      var inner = innerMode(mode, state);\n      if (inner.mode.blankLine) {\n        return inner.mode.blankLine(inner.state);\n      }\n    }\n    __name(callBlankLine, "callBlankLine");\n    function readToken(mode, stream, state, inner) {\n      for (var i2 = 0; i2 < 10; i2++) {\n        if (inner) {\n          inner[0] = innerMode(mode, state).mode;\n        }\n        var style = mode.token(stream, state);\n        if (stream.pos > stream.start) {\n          return style;\n        }\n      }\n      throw new Error("Mode " + mode.name + " failed to advance stream.");\n    }\n    __name(readToken, "readToken");\n    var Token = /* @__PURE__ */ __name(function(stream, type, state) {\n      this.start = stream.start;\n      this.end = stream.pos;\n      this.string = stream.current();\n      this.type = type || null;\n      this.state = state;\n    }, "Token");\n    function takeToken(cm, pos, precise, asArray) {\n      var doc = cm.doc, mode = doc.mode, style;\n      pos = clipPos(doc, pos);\n      var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);\n      var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;\n      if (asArray) {\n        tokens = [];\n      }\n      while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\n        stream.start = stream.pos;\n        style = readToken(mode, stream, context.state);\n        if (asArray) {\n          tokens.push(new Token(stream, style, copyState(doc.mode, context.state)));\n        }\n      }\n      return asArray ? tokens : new Token(stream, style, context.state);\n    }\n    __name(takeToken, "takeToken");\n    function extractLineClasses(type, output) {\n      if (type) {\n        for (; ; ) {\n          var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n          if (!lineClass) {\n            break;\n          }\n          type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\n          var prop2 = lineClass[1] ? "bgClass" : "textClass";\n          if (output[prop2] == null) {\n            output[prop2] = lineClass[2];\n          } else if (!new RegExp("(?:^|\\\\s)" + lineClass[2] + "(?:$|\\\\s)").test(output[prop2])) {\n            output[prop2] += " " + lineClass[2];\n          }\n        }\n      }\n      return type;\n    }\n    __name(extractLineClasses, "extractLineClasses");\n    function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {\n      var flattenSpans = mode.flattenSpans;\n      if (flattenSpans == null) {\n        flattenSpans = cm.options.flattenSpans;\n      }\n      var curStart = 0, curStyle = null;\n      var stream = new StringStream(text, cm.options.tabSize, context), style;\n      var inner = cm.options.addModeClass && [null];\n      if (text == "") {\n        extractLineClasses(callBlankLine(mode, context.state), lineClasses);\n      }\n      while (!stream.eol()) {\n        if (stream.pos > cm.options.maxHighlightLength) {\n          flattenSpans = false;\n          if (forceToEnd) {\n            processLine(cm, text, context, stream.pos);\n          }\n          stream.pos = text.length;\n          style = null;\n        } else {\n          style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);\n        }\n        if (inner) {\n          var mName = inner[0].name;\n          if (mName) {\n            style = "m-" + (style ? mName + " " + style : mName);\n          }\n        }\n        if (!flattenSpans || curStyle != style) {\n          while (curStart < stream.start) {\n            curStart = Math.min(stream.start, curStart + 5e3);\n            f(curStart, curStyle);\n          }\n          curStyle = style;\n        }\n        stream.start = stream.pos;\n      }\n      while (curStart < stream.pos) {\n        var pos = Math.min(stream.pos, curStart + 5e3);\n        f(pos, curStyle);\n        curStart = pos;\n      }\n    }\n    __name(runMode, "runMode");\n    function findStartLine(cm, n, precise) {\n      var minindent, minline, doc = cm.doc;\n      var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1e3 : 100);\n      for (var search = n; search > lim; --search) {\n        if (search <= doc.first) {\n          return doc.first;\n        }\n        var line = getLine(doc, search - 1), after = line.stateAfter;\n        if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier)) {\n          return search;\n        }\n        var indented = countColumn(line.text, null, cm.options.tabSize);\n        if (minline == null || minindent > indented) {\n          minline = search - 1;\n          minindent = indented;\n        }\n      }\n      return minline;\n    }\n    __name(findStartLine, "findStartLine");\n    function retreatFrontier(doc, n) {\n      doc.modeFrontier = Math.min(doc.modeFrontier, n);\n      if (doc.highlightFrontier < n - 10) {\n        return;\n      }\n      var start = doc.first;\n      for (var line = n - 1; line > start; line--) {\n        var saved = getLine(doc, line).stateAfter;\n        if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {\n          start = line + 1;\n          break;\n        }\n      }\n      doc.highlightFrontier = Math.min(doc.highlightFrontier, start);\n    }\n    __name(retreatFrontier, "retreatFrontier");\n    var sawReadOnlySpans = false, sawCollapsedSpans = false;\n    function seeReadOnlySpans() {\n      sawReadOnlySpans = true;\n    }\n    __name(seeReadOnlySpans, "seeReadOnlySpans");\n    function seeCollapsedSpans() {\n      sawCollapsedSpans = true;\n    }\n    __name(seeCollapsedSpans, "seeCollapsedSpans");\n    function MarkedSpan(marker, from, to) {\n      this.marker = marker;\n      this.from = from;\n      this.to = to;\n    }\n    __name(MarkedSpan, "MarkedSpan");\n    function getMarkedSpanFor(spans, marker) {\n      if (spans) {\n        for (var i2 = 0; i2 < spans.length; ++i2) {\n          var span = spans[i2];\n          if (span.marker == marker) {\n            return span;\n          }\n        }\n      }\n    }\n    __name(getMarkedSpanFor, "getMarkedSpanFor");\n    function removeMarkedSpan(spans, span) {\n      var r;\n      for (var i2 = 0; i2 < spans.length; ++i2) {\n        if (spans[i2] != span) {\n          (r || (r = [])).push(spans[i2]);\n        }\n      }\n      return r;\n    }\n    __name(removeMarkedSpan, "removeMarkedSpan");\n    function addMarkedSpan(line, span, op) {\n      var inThisOp = op && window.WeakSet && (op.markedSpans || (op.markedSpans = /* @__PURE__ */ new WeakSet()));\n      if (inThisOp && line.markedSpans && inThisOp.has(line.markedSpans)) {\n        line.markedSpans.push(span);\n      } else {\n        line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n        if (inThisOp) {\n          inThisOp.add(line.markedSpans);\n        }\n      }\n      span.marker.attachLine(line);\n    }\n    __name(addMarkedSpan, "addMarkedSpan");\n    function markedSpansBefore(old, startCh, isInsert) {\n      var nw;\n      if (old) {\n        for (var i2 = 0; i2 < old.length; ++i2) {\n          var span = old[i2], marker = span.marker;\n          var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n          if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {\n            var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);\n            (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\n          }\n        }\n      }\n      return nw;\n    }\n    __name(markedSpansBefore, "markedSpansBefore");\n    function markedSpansAfter(old, endCh, isInsert) {\n      var nw;\n      if (old) {\n        for (var i2 = 0; i2 < old.length; ++i2) {\n          var span = old[i2], marker = span.marker;\n          var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n          if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {\n            var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);\n            (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh, span.to == null ? null : span.to - endCh));\n          }\n        }\n      }\n      return nw;\n    }\n    __name(markedSpansAfter, "markedSpansAfter");\n    function stretchSpansOverChange(doc, change) {\n      if (change.full) {\n        return null;\n      }\n      var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n      var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n      if (!oldFirst && !oldLast) {\n        return null;\n      }\n      var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;\n      var first = markedSpansBefore(oldFirst, startCh, isInsert);\n      var last = markedSpansAfter(oldLast, endCh, isInsert);\n      var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\n      if (first) {\n        for (var i2 = 0; i2 < first.length; ++i2) {\n          var span = first[i2];\n          if (span.to == null) {\n            var found = getMarkedSpanFor(last, span.marker);\n            if (!found) {\n              span.to = startCh;\n            } else if (sameLine) {\n              span.to = found.to == null ? null : found.to + offset;\n            }\n          }\n        }\n      }\n      if (last) {\n        for (var i$12 = 0; i$12 < last.length; ++i$12) {\n          var span$1 = last[i$12];\n          if (span$1.to != null) {\n            span$1.to += offset;\n          }\n          if (span$1.from == null) {\n            var found$1 = getMarkedSpanFor(first, span$1.marker);\n            if (!found$1) {\n              span$1.from = offset;\n              if (sameLine) {\n                (first || (first = [])).push(span$1);\n              }\n            }\n          } else {\n            span$1.from += offset;\n            if (sameLine) {\n              (first || (first = [])).push(span$1);\n            }\n          }\n        }\n      }\n      if (first) {\n        first = clearEmptySpans(first);\n      }\n      if (last && last != first) {\n        last = clearEmptySpans(last);\n      }\n      var newMarkers = [first];\n      if (!sameLine) {\n        var gap = change.text.length - 2, gapMarkers;\n        if (gap > 0 && first) {\n          for (var i$22 = 0; i$22 < first.length; ++i$22) {\n            if (first[i$22].to == null) {\n              (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$22].marker, null, null));\n            }\n          }\n        }\n        for (var i$3 = 0; i$3 < gap; ++i$3) {\n          newMarkers.push(gapMarkers);\n        }\n        newMarkers.push(last);\n      }\n      return newMarkers;\n    }\n    __name(stretchSpansOverChange, "stretchSpansOverChange");\n    function clearEmptySpans(spans) {\n      for (var i2 = 0; i2 < spans.length; ++i2) {\n        var span = spans[i2];\n        if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false) {\n          spans.splice(i2--, 1);\n        }\n      }\n      if (!spans.length) {\n        return null;\n      }\n      return spans;\n    }\n    __name(clearEmptySpans, "clearEmptySpans");\n    function removeReadOnlyRanges(doc, from, to) {\n      var markers = null;\n      doc.iter(from.line, to.line + 1, function(line) {\n        if (line.markedSpans) {\n          for (var i3 = 0; i3 < line.markedSpans.length; ++i3) {\n            var mark = line.markedSpans[i3].marker;\n            if (mark.readOnly && (!markers || indexOf(markers, mark) == -1)) {\n              (markers || (markers = [])).push(mark);\n            }\n          }\n        }\n      });\n      if (!markers) {\n        return null;\n      }\n      var parts = [{ from, to }];\n      for (var i2 = 0; i2 < markers.length; ++i2) {\n        var mk = markers[i2], m = mk.find(0);\n        for (var j = 0; j < parts.length; ++j) {\n          var p = parts[j];\n          if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) {\n            continue;\n          }\n          var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);\n          if (dfrom < 0 || !mk.inclusiveLeft && !dfrom) {\n            newParts.push({ from: p.from, to: m.from });\n          }\n          if (dto > 0 || !mk.inclusiveRight && !dto) {\n            newParts.push({ from: m.to, to: p.to });\n          }\n          parts.splice.apply(parts, newParts);\n          j += newParts.length - 3;\n        }\n      }\n      return parts;\n    }\n    __name(removeReadOnlyRanges, "removeReadOnlyRanges");\n    function detachMarkedSpans(line) {\n      var spans = line.markedSpans;\n      if (!spans) {\n        return;\n      }\n      for (var i2 = 0; i2 < spans.length; ++i2) {\n        spans[i2].marker.detachLine(line);\n      }\n      line.markedSpans = null;\n    }\n    __name(detachMarkedSpans, "detachMarkedSpans");\n    function attachMarkedSpans(line, spans) {\n      if (!spans) {\n        return;\n      }\n      for (var i2 = 0; i2 < spans.length; ++i2) {\n        spans[i2].marker.attachLine(line);\n      }\n      line.markedSpans = spans;\n    }\n    __name(attachMarkedSpans, "attachMarkedSpans");\n    function extraLeft(marker) {\n      return marker.inclusiveLeft ? -1 : 0;\n    }\n    __name(extraLeft, "extraLeft");\n    function extraRight(marker) {\n      return marker.inclusiveRight ? 1 : 0;\n    }\n    __name(extraRight, "extraRight");\n    function compareCollapsedMarkers(a, b) {\n      var lenDiff = a.lines.length - b.lines.length;\n      if (lenDiff != 0) {\n        return lenDiff;\n      }\n      var aPos = a.find(), bPos = b.find();\n      var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n      if (fromCmp) {\n        return -fromCmp;\n      }\n      var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n      if (toCmp) {\n        return toCmp;\n      }\n      return b.id - a.id;\n    }\n    __name(compareCollapsedMarkers, "compareCollapsedMarkers");\n    function collapsedSpanAtSide(line, start) {\n      var sps = sawCollapsedSpans && line.markedSpans, found;\n      if (sps) {\n        for (var sp = void 0, i2 = 0; i2 < sps.length; ++i2) {\n          sp = sps[i2];\n          if (sp.marker.collapsed && (start ? sp.from : sp.to) == null && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {\n            found = sp.marker;\n          }\n        }\n      }\n      return found;\n    }\n    __name(collapsedSpanAtSide, "collapsedSpanAtSide");\n    function collapsedSpanAtStart(line) {\n      return collapsedSpanAtSide(line, true);\n    }\n    __name(collapsedSpanAtStart, "collapsedSpanAtStart");\n    function collapsedSpanAtEnd(line) {\n      return collapsedSpanAtSide(line, false);\n    }\n    __name(collapsedSpanAtEnd, "collapsedSpanAtEnd");\n    function collapsedSpanAround(line, ch) {\n      var sps = sawCollapsedSpans && line.markedSpans, found;\n      if (sps) {\n        for (var i2 = 0; i2 < sps.length; ++i2) {\n          var sp = sps[i2];\n          if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {\n            found = sp.marker;\n          }\n        }\n      }\n      return found;\n    }\n    __name(collapsedSpanAround, "collapsedSpanAround");\n    function conflictingCollapsedRange(doc, lineNo2, from, to, marker) {\n      var line = getLine(doc, lineNo2);\n      var sps = sawCollapsedSpans && line.markedSpans;\n      if (sps) {\n        for (var i2 = 0; i2 < sps.length; ++i2) {\n          var sp = sps[i2];\n          if (!sp.marker.collapsed) {\n            continue;\n          }\n          var found = sp.marker.find(0);\n          var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n          var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n          if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) {\n            continue;\n          }\n          if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) || fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0)) {\n            return true;\n          }\n        }\n      }\n    }\n    __name(conflictingCollapsedRange, "conflictingCollapsedRange");\n    function visualLine(line) {\n      var merged;\n      while (merged = collapsedSpanAtStart(line)) {\n        line = merged.find(-1, true).line;\n      }\n      return line;\n    }\n    __name(visualLine, "visualLine");\n    function visualLineEnd(line) {\n      var merged;\n      while (merged = collapsedSpanAtEnd(line)) {\n        line = merged.find(1, true).line;\n      }\n      return line;\n    }\n    __name(visualLineEnd, "visualLineEnd");\n    function visualLineContinued(line) {\n      var merged, lines;\n      while (merged = collapsedSpanAtEnd(line)) {\n        line = merged.find(1, true).line;\n        (lines || (lines = [])).push(line);\n      }\n      return lines;\n    }\n    __name(visualLineContinued, "visualLineContinued");\n    function visualLineNo(doc, lineN) {\n      var line = getLine(doc, lineN), vis = visualLine(line);\n      if (line == vis) {\n        return lineN;\n      }\n      return lineNo(vis);\n    }\n    __name(visualLineNo, "visualLineNo");\n    function visualLineEndNo(doc, lineN) {\n      if (lineN > doc.lastLine()) {\n        return lineN;\n      }\n      var line = getLine(doc, lineN), merged;\n      if (!lineIsHidden(doc, line)) {\n        return lineN;\n      }\n      while (merged = collapsedSpanAtEnd(line)) {\n        line = merged.find(1, true).line;\n      }\n      return lineNo(line) + 1;\n    }\n    __name(visualLineEndNo, "visualLineEndNo");\n    function lineIsHidden(doc, line) {\n      var sps = sawCollapsedSpans && line.markedSpans;\n      if (sps) {\n        for (var sp = void 0, i2 = 0; i2 < sps.length; ++i2) {\n          sp = sps[i2];\n          if (!sp.marker.collapsed) {\n            continue;\n          }\n          if (sp.from == null) {\n            return true;\n          }\n          if (sp.marker.widgetNode) {\n            continue;\n          }\n          if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp)) {\n            return true;\n          }\n        }\n      }\n    }\n    __name(lineIsHidden, "lineIsHidden");\n    function lineIsHiddenInner(doc, line, span) {\n      if (span.to == null) {\n        var end = span.marker.find(1, true);\n        return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));\n      }\n      if (span.marker.inclusiveRight && span.to == line.text.length) {\n        return true;\n      }\n      for (var sp = void 0, i2 = 0; i2 < line.markedSpans.length; ++i2) {\n        sp = line.markedSpans[i2];\n        if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (sp.to == null || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp)) {\n          return true;\n        }\n      }\n    }\n    __name(lineIsHiddenInner, "lineIsHiddenInner");\n    function heightAtLine(lineObj) {\n      lineObj = visualLine(lineObj);\n      var h = 0, chunk = lineObj.parent;\n      for (var i2 = 0; i2 < chunk.lines.length; ++i2) {\n        var line = chunk.lines[i2];\n        if (line == lineObj) {\n          break;\n        } else {\n          h += line.height;\n        }\n      }\n      for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n        for (var i$12 = 0; i$12 < p.children.length; ++i$12) {\n          var cur = p.children[i$12];\n          if (cur == chunk) {\n            break;\n          } else {\n            h += cur.height;\n          }\n        }\n      }\n      return h;\n    }\n    __name(heightAtLine, "heightAtLine");\n    function lineLength(line) {\n      if (line.height == 0) {\n        return 0;\n      }\n      var len = line.text.length, merged, cur = line;\n      while (merged = collapsedSpanAtStart(cur)) {\n        var found = merged.find(0, true);\n        cur = found.from.line;\n        len += found.from.ch - found.to.ch;\n      }\n      cur = line;\n      while (merged = collapsedSpanAtEnd(cur)) {\n        var found$1 = merged.find(0, true);\n        len -= cur.text.length - found$1.from.ch;\n        cur = found$1.to.line;\n        len += cur.text.length - found$1.to.ch;\n      }\n      return len;\n    }\n    __name(lineLength, "lineLength");\n    function findMaxLine(cm) {\n      var d = cm.display, doc = cm.doc;\n      d.maxLine = getLine(doc, doc.first);\n      d.maxLineLength = lineLength(d.maxLine);\n      d.maxLineChanged = true;\n      doc.iter(function(line) {\n        var len = lineLength(line);\n        if (len > d.maxLineLength) {\n          d.maxLineLength = len;\n          d.maxLine = line;\n        }\n      });\n    }\n    __name(findMaxLine, "findMaxLine");\n    var Line = /* @__PURE__ */ __name(function(text, markedSpans, estimateHeight2) {\n      this.text = text;\n      attachMarkedSpans(this, markedSpans);\n      this.height = estimateHeight2 ? estimateHeight2(this) : 1;\n    }, "Line");\n    Line.prototype.lineNo = function() {\n      return lineNo(this);\n    };\n    eventMixin(Line);\n    function updateLine(line, text, markedSpans, estimateHeight2) {\n      line.text = text;\n      if (line.stateAfter) {\n        line.stateAfter = null;\n      }\n      if (line.styles) {\n        line.styles = null;\n      }\n      if (line.order != null) {\n        line.order = null;\n      }\n      detachMarkedSpans(line);\n      attachMarkedSpans(line, markedSpans);\n      var estHeight = estimateHeight2 ? estimateHeight2(line) : 1;\n      if (estHeight != line.height) {\n        updateLineHeight(line, estHeight);\n      }\n    }\n    __name(updateLine, "updateLine");\n    function cleanUpLine(line) {\n      line.parent = null;\n      detachMarkedSpans(line);\n    }\n    __name(cleanUpLine, "cleanUpLine");\n    var styleToClassCache = {}, styleToClassCacheWithMode = {};\n    function interpretTokenStyle(style, options) {\n      if (!style || /^\\s*$/.test(style)) {\n        return null;\n      }\n      var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n      return cache[style] || (cache[style] = style.replace(/\\S+/g, "cm-$&"));\n    }\n    __name(interpretTokenStyle, "interpretTokenStyle");\n    function buildLineContent(cm, lineView) {\n      var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);\n      var builder = {\n        pre: eltP("pre", [content], "CodeMirror-line"),\n        content,\n        col: 0,\n        pos: 0,\n        cm,\n        trailingSpace: false,\n        splitSpaces: cm.getOption("lineWrapping")\n      };\n      lineView.measure = {};\n      for (var i2 = 0; i2 <= (lineView.rest ? lineView.rest.length : 0); i2++) {\n        var line = i2 ? lineView.rest[i2 - 1] : lineView.line, order = void 0;\n        builder.pos = 0;\n        builder.addToken = buildToken;\n        if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction))) {\n          builder.addToken = buildTokenBadBidi(builder.addToken, order);\n        }\n        builder.map = [];\n        var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\n        insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\n        if (line.styleClasses) {\n          if (line.styleClasses.bgClass) {\n            builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");\n          }\n          if (line.styleClasses.textClass) {\n            builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");\n          }\n        }\n        if (builder.map.length == 0) {\n          builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));\n        }\n        if (i2 == 0) {\n          lineView.measure.map = builder.map;\n          lineView.measure.cache = {};\n        } else {\n          (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);\n          (lineView.measure.caches || (lineView.measure.caches = [])).push({});\n        }\n      }\n      if (webkit) {\n        var last = builder.content.lastChild;\n        if (/\\bcm-tab\\b/.test(last.className) || last.querySelector && last.querySelector(".cm-tab")) {\n          builder.content.className = "cm-tab-wrap-hack";\n        }\n      }\n      signal(cm, "renderLine", cm, lineView.line, builder.pre);\n      if (builder.pre.className) {\n        builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");\n      }\n      return builder;\n    }\n    __name(buildLineContent, "buildLineContent");\n    function defaultSpecialCharPlaceholder(ch) {\n      var token = elt("span", "\\u2022", "cm-invalidchar");\n      token.title = "\\\\u" + ch.charCodeAt(0).toString(16);\n      token.setAttribute("aria-label", token.title);\n      return token;\n    }\n    __name(defaultSpecialCharPlaceholder, "defaultSpecialCharPlaceholder");\n    function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {\n      if (!text) {\n        return;\n      }\n      var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;\n      var special = builder.cm.state.specialChars, mustWrap = false;\n      var content;\n      if (!special.test(text)) {\n        builder.col += text.length;\n        content = document.createTextNode(displayText);\n        builder.map.push(builder.pos, builder.pos + text.length, content);\n        if (ie && ie_version < 9) {\n          mustWrap = true;\n        }\n        builder.pos += text.length;\n      } else {\n        content = document.createDocumentFragment();\n        var pos = 0;\n        while (true) {\n          special.lastIndex = pos;\n          var m = special.exec(text);\n          var skipped = m ? m.index - pos : text.length - pos;\n          if (skipped) {\n            var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\n            if (ie && ie_version < 9) {\n              content.appendChild(elt("span", [txt]));\n            } else {\n              content.appendChild(txt);\n            }\n            builder.map.push(builder.pos, builder.pos + skipped, txt);\n            builder.col += skipped;\n            builder.pos += skipped;\n          }\n          if (!m) {\n            break;\n          }\n          pos += skipped + 1;\n          var txt$1 = void 0;\n          if (m[0] == "\t") {\n            var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n            txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));\n            txt$1.setAttribute("role", "presentation");\n            txt$1.setAttribute("cm-text", "\t");\n            builder.col += tabWidth;\n          } else if (m[0] == "\\r" || m[0] == "\\n") {\n            txt$1 = content.appendChild(elt("span", m[0] == "\\r" ? "\\u240D" : "\\u2424", "cm-invalidchar"));\n            txt$1.setAttribute("cm-text", m[0]);\n            builder.col += 1;\n          } else {\n            txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);\n            txt$1.setAttribute("cm-text", m[0]);\n            if (ie && ie_version < 9) {\n              content.appendChild(elt("span", [txt$1]));\n            } else {\n              content.appendChild(txt$1);\n            }\n            builder.col += 1;\n          }\n          builder.map.push(builder.pos, builder.pos + 1, txt$1);\n          builder.pos++;\n        }\n      }\n      builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;\n      if (style || startStyle || endStyle || mustWrap || css || attributes) {\n        var fullStyle = style || "";\n        if (startStyle) {\n          fullStyle += startStyle;\n        }\n        if (endStyle) {\n          fullStyle += endStyle;\n        }\n        var token = elt("span", [content], fullStyle, css);\n        if (attributes) {\n          for (var attr in attributes) {\n            if (attributes.hasOwnProperty(attr) && attr != "style" && attr != "class") {\n              token.setAttribute(attr, attributes[attr]);\n            }\n          }\n        }\n        return builder.content.appendChild(token);\n      }\n      builder.content.appendChild(content);\n    }\n    __name(buildToken, "buildToken");\n    function splitSpaces(text, trailingBefore) {\n      if (text.length > 1 && !/  /.test(text)) {\n        return text;\n      }\n      var spaceBefore = trailingBefore, result = "";\n      for (var i2 = 0; i2 < text.length; i2++) {\n        var ch = text.charAt(i2);\n        if (ch == " " && spaceBefore && (i2 == text.length - 1 || text.charCodeAt(i2 + 1) == 32)) {\n          ch = "\\xA0";\n        }\n        result += ch;\n        spaceBefore = ch == " ";\n      }\n      return result;\n    }\n    __name(splitSpaces, "splitSpaces");\n    function buildTokenBadBidi(inner, order) {\n      return function(builder, text, style, startStyle, endStyle, css, attributes) {\n        style = style ? style + " cm-force-border" : "cm-force-border";\n        var start = builder.pos, end = start + text.length;\n        for (; ; ) {\n          var part = void 0;\n          for (var i2 = 0; i2 < order.length; i2++) {\n            part = order[i2];\n            if (part.to > start && part.from <= start) {\n              break;\n            }\n          }\n          if (part.to >= end) {\n            return inner(builder, text, style, startStyle, endStyle, css, attributes);\n          }\n          inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);\n          startStyle = null;\n          text = text.slice(part.to - start);\n          start = part.to;\n        }\n      };\n    }\n    __name(buildTokenBadBidi, "buildTokenBadBidi");\n    function buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n      var widget = !ignoreWidget && marker.widgetNode;\n      if (widget) {\n        builder.map.push(builder.pos, builder.pos + size, widget);\n      }\n      if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\n        if (!widget) {\n          widget = builder.content.appendChild(document.createElement("span"));\n        }\n        widget.setAttribute("cm-marker", marker.id);\n      }\n      if (widget) {\n        builder.cm.display.input.setUneditable(widget);\n        builder.content.appendChild(widget);\n      }\n      builder.pos += size;\n      builder.trailingSpace = false;\n    }\n    __name(buildCollapsedSpan, "buildCollapsedSpan");\n    function insertLineContent(line, builder, styles) {\n      var spans = line.markedSpans, allText = line.text, at = 0;\n      if (!spans) {\n        for (var i$12 = 1; i$12 < styles.length; i$12 += 2) {\n          builder.addToken(builder, allText.slice(at, at = styles[i$12]), interpretTokenStyle(styles[i$12 + 1], builder.cm.options));\n        }\n        return;\n      }\n      var len = allText.length, pos = 0, i2 = 1, text = "", style, css;\n      var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;\n      for (; ; ) {\n        if (nextChange == pos) {\n          spanStyle = spanEndStyle = spanStartStyle = css = "";\n          attributes = null;\n          collapsed = null;\n          nextChange = Infinity;\n          var foundBookmarks = [], endStyles = void 0;\n          for (var j = 0; j < spans.length; ++j) {\n            var sp = spans[j], m = sp.marker;\n            if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {\n              foundBookmarks.push(m);\n            } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\n              if (sp.to != null && sp.to != pos && nextChange > sp.to) {\n                nextChange = sp.to;\n                spanEndStyle = "";\n              }\n              if (m.className) {\n                spanStyle += " " + m.className;\n              }\n              if (m.css) {\n                css = (css ? css + ";" : "") + m.css;\n              }\n              if (m.startStyle && sp.from == pos) {\n                spanStartStyle += " " + m.startStyle;\n              }\n              if (m.endStyle && sp.to == nextChange) {\n                (endStyles || (endStyles = [])).push(m.endStyle, sp.to);\n              }\n              if (m.title) {\n                (attributes || (attributes = {})).title = m.title;\n              }\n              if (m.attributes) {\n                for (var attr in m.attributes) {\n                  (attributes || (attributes = {}))[attr] = m.attributes[attr];\n                }\n              }\n              if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0)) {\n                collapsed = sp;\n              }\n            } else if (sp.from > pos && nextChange > sp.from) {\n              nextChange = sp.from;\n            }\n          }\n          if (endStyles) {\n            for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2) {\n              if (endStyles[j$1 + 1] == nextChange) {\n                spanEndStyle += " " + endStyles[j$1];\n              }\n            }\n          }\n          if (!collapsed || collapsed.from == pos) {\n            for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2) {\n              buildCollapsedSpan(builder, 0, foundBookmarks[j$2]);\n            }\n          }\n          if (collapsed && (collapsed.from || 0) == pos) {\n            buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos, collapsed.marker, collapsed.from == null);\n            if (collapsed.to == null) {\n              return;\n            }\n            if (collapsed.to == pos) {\n              collapsed = false;\n            }\n          }\n        }\n        if (pos >= len) {\n          break;\n        }\n        var upto = Math.min(len, nextChange);\n        while (true) {\n          if (text) {\n            var end = pos + text.length;\n            if (!collapsed) {\n              var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n              builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", css, attributes);\n            }\n            if (end >= upto) {\n              text = text.slice(upto - pos);\n              pos = upto;\n              break;\n            }\n            pos = end;\n            spanStartStyle = "";\n          }\n          text = allText.slice(at, at = styles[i2++]);\n          style = interpretTokenStyle(styles[i2++], builder.cm.options);\n        }\n      }\n    }\n    __name(insertLineContent, "insertLineContent");\n    function LineView(doc, line, lineN) {\n      this.line = line;\n      this.rest = visualLineContinued(line);\n      this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\n      this.node = this.text = null;\n      this.hidden = lineIsHidden(doc, line);\n    }\n    __name(LineView, "LineView");\n    function buildViewArray(cm, from, to) {\n      var array = [], nextPos;\n      for (var pos = from; pos < to; pos = nextPos) {\n        var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\n        nextPos = pos + view.size;\n        array.push(view);\n      }\n      return array;\n    }\n    __name(buildViewArray, "buildViewArray");\n    var operationGroup = null;\n    function pushOperation(op) {\n      if (operationGroup) {\n        operationGroup.ops.push(op);\n      } else {\n        op.ownsGroup = operationGroup = {\n          ops: [op],\n          delayedCallbacks: []\n        };\n      }\n    }\n    __name(pushOperation, "pushOperation");\n    function fireCallbacksForOps(group) {\n      var callbacks = group.delayedCallbacks, i2 = 0;\n      do {\n        for (; i2 < callbacks.length; i2++) {\n          callbacks[i2].call(null);\n        }\n        for (var j = 0; j < group.ops.length; j++) {\n          var op = group.ops[j];\n          if (op.cursorActivityHandlers) {\n            while (op.cursorActivityCalled < op.cursorActivityHandlers.length) {\n              op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);\n            }\n          }\n        }\n      } while (i2 < callbacks.length);\n    }\n    __name(fireCallbacksForOps, "fireCallbacksForOps");\n    function finishOperation(op, endCb) {\n      var group = op.ownsGroup;\n      if (!group) {\n        return;\n      }\n      try {\n        fireCallbacksForOps(group);\n      } finally {\n        operationGroup = null;\n        endCb(group);\n      }\n    }\n    __name(finishOperation, "finishOperation");\n    var orphanDelayedCallbacks = null;\n    function signalLater(emitter, type) {\n      var arr = getHandlers(emitter, type);\n      if (!arr.length) {\n        return;\n      }\n      var args = Array.prototype.slice.call(arguments, 2), list;\n      if (operationGroup) {\n        list = operationGroup.delayedCallbacks;\n      } else if (orphanDelayedCallbacks) {\n        list = orphanDelayedCallbacks;\n      } else {\n        list = orphanDelayedCallbacks = [];\n        setTimeout(fireOrphanDelayed, 0);\n      }\n      var loop = /* @__PURE__ */ __name(function(i3) {\n        list.push(function() {\n          return arr[i3].apply(null, args);\n        });\n      }, "loop");\n      for (var i2 = 0; i2 < arr.length; ++i2)\n        loop(i2);\n    }\n    __name(signalLater, "signalLater");\n    function fireOrphanDelayed() {\n      var delayed = orphanDelayedCallbacks;\n      orphanDelayedCallbacks = null;\n      for (var i2 = 0; i2 < delayed.length; ++i2) {\n        delayed[i2]();\n      }\n    }\n    __name(fireOrphanDelayed, "fireOrphanDelayed");\n    function updateLineForChanges(cm, lineView, lineN, dims) {\n      for (var j = 0; j < lineView.changes.length; j++) {\n        var type = lineView.changes[j];\n        if (type == "text") {\n          updateLineText(cm, lineView);\n        } else if (type == "gutter") {\n          updateLineGutter(cm, lineView, lineN, dims);\n        } else if (type == "class") {\n          updateLineClasses(cm, lineView);\n        } else if (type == "widget") {\n          updateLineWidgets(cm, lineView, dims);\n        }\n      }\n      lineView.changes = null;\n    }\n    __name(updateLineForChanges, "updateLineForChanges");\n    function ensureLineWrapped(lineView) {\n      if (lineView.node == lineView.text) {\n        lineView.node = elt("div", null, null, "position: relative");\n        if (lineView.text.parentNode) {\n          lineView.text.parentNode.replaceChild(lineView.node, lineView.text);\n        }\n        lineView.node.appendChild(lineView.text);\n        if (ie && ie_version < 8) {\n          lineView.node.style.zIndex = 2;\n        }\n      }\n      return lineView.node;\n    }\n    __name(ensureLineWrapped, "ensureLineWrapped");\n    function updateLineBackground(cm, lineView) {\n      var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;\n      if (cls) {\n        cls += " CodeMirror-linebackground";\n      }\n      if (lineView.background) {\n        if (cls) {\n          lineView.background.className = cls;\n        } else {\n          lineView.background.parentNode.removeChild(lineView.background);\n          lineView.background = null;\n        }\n      } else if (cls) {\n        var wrap = ensureLineWrapped(lineView);\n        lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);\n        cm.display.input.setUneditable(lineView.background);\n      }\n    }\n    __name(updateLineBackground, "updateLineBackground");\n    function getLineContent(cm, lineView) {\n      var ext = cm.display.externalMeasured;\n      if (ext && ext.line == lineView.line) {\n        cm.display.externalMeasured = null;\n        lineView.measure = ext.measure;\n        return ext.built;\n      }\n      return buildLineContent(cm, lineView);\n    }\n    __name(getLineContent, "getLineContent");\n    function updateLineText(cm, lineView) {\n      var cls = lineView.text.className;\n      var built = getLineContent(cm, lineView);\n      if (lineView.text == lineView.node) {\n        lineView.node = built.pre;\n      }\n      lineView.text.parentNode.replaceChild(built.pre, lineView.text);\n      lineView.text = built.pre;\n      if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\n        lineView.bgClass = built.bgClass;\n        lineView.textClass = built.textClass;\n        updateLineClasses(cm, lineView);\n      } else if (cls) {\n        lineView.text.className = cls;\n      }\n    }\n    __name(updateLineText, "updateLineText");\n    function updateLineClasses(cm, lineView) {\n      updateLineBackground(cm, lineView);\n      if (lineView.line.wrapClass) {\n        ensureLineWrapped(lineView).className = lineView.line.wrapClass;\n      } else if (lineView.node != lineView.text) {\n        lineView.node.className = "";\n      }\n      var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;\n      lineView.text.className = textClass || "";\n    }\n    __name(updateLineClasses, "updateLineClasses");\n    function updateLineGutter(cm, lineView, lineN, dims) {\n      if (lineView.gutter) {\n        lineView.node.removeChild(lineView.gutter);\n        lineView.gutter = null;\n      }\n      if (lineView.gutterBackground) {\n        lineView.node.removeChild(lineView.gutterBackground);\n        lineView.gutterBackground = null;\n      }\n      if (lineView.line.gutterClass) {\n        var wrap = ensureLineWrapped(lineView);\n        lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass, "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + dims.gutterTotalWidth + "px");\n        cm.display.input.setUneditable(lineView.gutterBackground);\n        wrap.insertBefore(lineView.gutterBackground, lineView.text);\n      }\n      var markers = lineView.line.gutterMarkers;\n      if (cm.options.lineNumbers || markers) {\n        var wrap$1 = ensureLineWrapped(lineView);\n        var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px");\n        gutterWrap.setAttribute("aria-hidden", "true");\n        cm.display.input.setUneditable(gutterWrap);\n        wrap$1.insertBefore(gutterWrap, lineView.text);\n        if (lineView.line.gutterClass) {\n          gutterWrap.className += " " + lineView.line.gutterClass;\n        }\n        if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"])) {\n          lineView.lineNumber = gutterWrap.appendChild(elt("div", lineNumberFor(cm.options, lineN), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + cm.display.lineNumInnerWidth + "px"));\n        }\n        if (markers) {\n          for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {\n            var id = cm.display.gutterSpecs[k].className, found = markers.hasOwnProperty(id) && markers[id];\n            if (found) {\n              gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " + dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));\n            }\n          }\n        }\n      }\n    }\n    __name(updateLineGutter, "updateLineGutter");\n    function updateLineWidgets(cm, lineView, dims) {\n      if (lineView.alignable) {\n        lineView.alignable = null;\n      }\n      var isWidget = classTest("CodeMirror-linewidget");\n      for (var node = lineView.node.firstChild, next = void 0; node; node = next) {\n        next = node.nextSibling;\n        if (isWidget.test(node.className)) {\n          lineView.node.removeChild(node);\n        }\n      }\n      insertLineWidgets(cm, lineView, dims);\n    }\n    __name(updateLineWidgets, "updateLineWidgets");\n    function buildLineElement(cm, lineView, lineN, dims) {\n      var built = getLineContent(cm, lineView);\n      lineView.text = lineView.node = built.pre;\n      if (built.bgClass) {\n        lineView.bgClass = built.bgClass;\n      }\n      if (built.textClass) {\n        lineView.textClass = built.textClass;\n      }\n      updateLineClasses(cm, lineView);\n      updateLineGutter(cm, lineView, lineN, dims);\n      insertLineWidgets(cm, lineView, dims);\n      return lineView.node;\n    }\n    __name(buildLineElement, "buildLineElement");\n    function insertLineWidgets(cm, lineView, dims) {\n      insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\n      if (lineView.rest) {\n        for (var i2 = 0; i2 < lineView.rest.length; i2++) {\n          insertLineWidgetsFor(cm, lineView.rest[i2], lineView, dims, false);\n        }\n      }\n    }\n    __name(insertLineWidgets, "insertLineWidgets");\n    function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\n      if (!line.widgets) {\n        return;\n      }\n      var wrap = ensureLineWrapped(lineView);\n      for (var i2 = 0, ws = line.widgets; i2 < ws.length; ++i2) {\n        var widget = ws[i2], node = elt("div", [widget.node], "CodeMirror-linewidget" + (widget.className ? " " + widget.className : ""));\n        if (!widget.handleMouseEvents) {\n          node.setAttribute("cm-ignore-events", "true");\n        }\n        positionLineWidget(widget, node, lineView, dims);\n        cm.display.input.setUneditable(node);\n        if (allowAbove && widget.above) {\n          wrap.insertBefore(node, lineView.gutter || lineView.text);\n        } else {\n          wrap.appendChild(node);\n        }\n        signalLater(widget, "redraw");\n      }\n    }\n    __name(insertLineWidgetsFor, "insertLineWidgetsFor");\n    function positionLineWidget(widget, node, lineView, dims) {\n      if (widget.noHScroll) {\n        (lineView.alignable || (lineView.alignable = [])).push(node);\n        var width = dims.wrapperWidth;\n        node.style.left = dims.fixedPos + "px";\n        if (!widget.coverGutter) {\n          width -= dims.gutterTotalWidth;\n          node.style.paddingLeft = dims.gutterTotalWidth + "px";\n        }\n        node.style.width = width + "px";\n      }\n      if (widget.coverGutter) {\n        node.style.zIndex = 5;\n        node.style.position = "relative";\n        if (!widget.noHScroll) {\n          node.style.marginLeft = -dims.gutterTotalWidth + "px";\n        }\n      }\n    }\n    __name(positionLineWidget, "positionLineWidget");\n    function widgetHeight(widget) {\n      if (widget.height != null) {\n        return widget.height;\n      }\n      var cm = widget.doc.cm;\n      if (!cm) {\n        return 0;\n      }\n      if (!contains(document.body, widget.node)) {\n        var parentStyle = "position: relative;";\n        if (widget.coverGutter) {\n          parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;";\n        }\n        if (widget.noHScroll) {\n          parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;";\n        }\n        removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));\n      }\n      return widget.height = widget.node.parentNode.offsetHeight;\n    }\n    __name(widgetHeight, "widgetHeight");\n    function eventInWidget(display, e) {\n      for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n        if (!n || n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true" || n.parentNode == display.sizer && n != display.mover) {\n          return true;\n        }\n      }\n    }\n    __name(eventInWidget, "eventInWidget");\n    function paddingTop(display) {\n      return display.lineSpace.offsetTop;\n    }\n    __name(paddingTop, "paddingTop");\n    function paddingVert(display) {\n      return display.mover.offsetHeight - display.lineSpace.offsetHeight;\n    }\n    __name(paddingVert, "paddingVert");\n    function paddingH(display) {\n      if (display.cachedPaddingH) {\n        return display.cachedPaddingH;\n      }\n      var e = removeChildrenAndAdd(display.measure, elt("pre", "x", "CodeMirror-line-like"));\n      var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\n      var data = { left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight) };\n      if (!isNaN(data.left) && !isNaN(data.right)) {\n        display.cachedPaddingH = data;\n      }\n      return data;\n    }\n    __name(paddingH, "paddingH");\n    function scrollGap(cm) {\n      return scrollerGap - cm.display.nativeBarWidth;\n    }\n    __name(scrollGap, "scrollGap");\n    function displayWidth(cm) {\n      return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;\n    }\n    __name(displayWidth, "displayWidth");\n    function displayHeight(cm) {\n      return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;\n    }\n    __name(displayHeight, "displayHeight");\n    function ensureLineHeights(cm, lineView, rect) {\n      var wrapping = cm.options.lineWrapping;\n      var curWidth = wrapping && displayWidth(cm);\n      if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\n        var heights = lineView.measure.heights = [];\n        if (wrapping) {\n          lineView.measure.width = curWidth;\n          var rects = lineView.text.firstChild.getClientRects();\n          for (var i2 = 0; i2 < rects.length - 1; i2++) {\n            var cur = rects[i2], next = rects[i2 + 1];\n            if (Math.abs(cur.bottom - next.bottom) > 2) {\n              heights.push((cur.bottom + next.top) / 2 - rect.top);\n            }\n          }\n        }\n        heights.push(rect.bottom - rect.top);\n      }\n    }\n    __name(ensureLineHeights, "ensureLineHeights");\n    function mapFromLineView(lineView, line, lineN) {\n      if (lineView.line == line) {\n        return { map: lineView.measure.map, cache: lineView.measure.cache };\n      }\n      if (lineView.rest) {\n        for (var i2 = 0; i2 < lineView.rest.length; i2++) {\n          if (lineView.rest[i2] == line) {\n            return { map: lineView.measure.maps[i2], cache: lineView.measure.caches[i2] };\n          }\n        }\n        for (var i$12 = 0; i$12 < lineView.rest.length; i$12++) {\n          if (lineNo(lineView.rest[i$12]) > lineN) {\n            return { map: lineView.measure.maps[i$12], cache: lineView.measure.caches[i$12], before: true };\n          }\n        }\n      }\n    }\n    __name(mapFromLineView, "mapFromLineView");\n    function updateExternalMeasurement(cm, line) {\n      line = visualLine(line);\n      var lineN = lineNo(line);\n      var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\n      view.lineN = lineN;\n      var built = view.built = buildLineContent(cm, view);\n      view.text = built.pre;\n      removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\n      return view;\n    }\n    __name(updateExternalMeasurement, "updateExternalMeasurement");\n    function measureChar(cm, line, ch, bias) {\n      return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);\n    }\n    __name(measureChar, "measureChar");\n    function findViewForLine(cm, lineN) {\n      if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo) {\n        return cm.display.view[findViewIndex(cm, lineN)];\n      }\n      var ext = cm.display.externalMeasured;\n      if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size) {\n        return ext;\n      }\n    }\n    __name(findViewForLine, "findViewForLine");\n    function prepareMeasureForLine(cm, line) {\n      var lineN = lineNo(line);\n      var view = findViewForLine(cm, lineN);\n      if (view && !view.text) {\n        view = null;\n      } else if (view && view.changes) {\n        updateLineForChanges(cm, view, lineN, getDimensions(cm));\n        cm.curOp.forceUpdate = true;\n      }\n      if (!view) {\n        view = updateExternalMeasurement(cm, line);\n      }\n      var info = mapFromLineView(view, line, lineN);\n      return {\n        line,\n        view,\n        rect: null,\n        map: info.map,\n        cache: info.cache,\n        before: info.before,\n        hasHeights: false\n      };\n    }\n    __name(prepareMeasureForLine, "prepareMeasureForLine");\n    function measureCharPrepared(cm, prepared, ch, bias, varHeight) {\n      if (prepared.before) {\n        ch = -1;\n      }\n      var key = ch + (bias || ""), found;\n      if (prepared.cache.hasOwnProperty(key)) {\n        found = prepared.cache[key];\n      } else {\n        if (!prepared.rect) {\n          prepared.rect = prepared.view.text.getBoundingClientRect();\n        }\n        if (!prepared.hasHeights) {\n          ensureLineHeights(cm, prepared.view, prepared.rect);\n          prepared.hasHeights = true;\n        }\n        found = measureCharInner(cm, prepared, ch, bias);\n        if (!found.bogus) {\n          prepared.cache[key] = found;\n        }\n      }\n      return {\n        left: found.left,\n        right: found.right,\n        top: varHeight ? found.rtop : found.top,\n        bottom: varHeight ? found.rbottom : found.bottom\n      };\n    }\n    __name(measureCharPrepared, "measureCharPrepared");\n    var nullRect = { left: 0, right: 0, top: 0, bottom: 0 };\n    function nodeAndOffsetInLineMap(map2, ch, bias) {\n      var node, start, end, collapse, mStart, mEnd;\n      for (var i2 = 0; i2 < map2.length; i2 += 3) {\n        mStart = map2[i2];\n        mEnd = map2[i2 + 1];\n        if (ch < mStart) {\n          start = 0;\n          end = 1;\n          collapse = "left";\n        } else if (ch < mEnd) {\n          start = ch - mStart;\n          end = start + 1;\n        } else if (i2 == map2.length - 3 || ch == mEnd && map2[i2 + 3] > ch) {\n          end = mEnd - mStart;\n          start = end - 1;\n          if (ch >= mEnd) {\n            collapse = "right";\n          }\n        }\n        if (start != null) {\n          node = map2[i2 + 2];\n          if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right")) {\n            collapse = bias;\n          }\n          if (bias == "left" && start == 0) {\n            while (i2 && map2[i2 - 2] == map2[i2 - 3] && map2[i2 - 1].insertLeft) {\n              node = map2[(i2 -= 3) + 2];\n              collapse = "left";\n            }\n          }\n          if (bias == "right" && start == mEnd - mStart) {\n            while (i2 < map2.length - 3 && map2[i2 + 3] == map2[i2 + 4] && !map2[i2 + 5].insertLeft) {\n              node = map2[(i2 += 3) + 2];\n              collapse = "right";\n            }\n          }\n          break;\n        }\n      }\n      return { node, start, end, collapse, coverStart: mStart, coverEnd: mEnd };\n    }\n    __name(nodeAndOffsetInLineMap, "nodeAndOffsetInLineMap");\n    function getUsefulRect(rects, bias) {\n      var rect = nullRect;\n      if (bias == "left") {\n        for (var i2 = 0; i2 < rects.length; i2++) {\n          if ((rect = rects[i2]).left != rect.right) {\n            break;\n          }\n        }\n      } else {\n        for (var i$12 = rects.length - 1; i$12 >= 0; i$12--) {\n          if ((rect = rects[i$12]).left != rect.right) {\n            break;\n          }\n        }\n      }\n      return rect;\n    }\n    __name(getUsefulRect, "getUsefulRect");\n    function measureCharInner(cm, prepared, ch, bias) {\n      var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\n      var node = place.node, start = place.start, end = place.end, collapse = place.collapse;\n      var rect;\n      if (node.nodeType == 3) {\n        for (var i$12 = 0; i$12 < 4; i$12++) {\n          while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) {\n            --start;\n          }\n          while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) {\n            ++end;\n          }\n          if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart) {\n            rect = node.parentNode.getBoundingClientRect();\n          } else {\n            rect = getUsefulRect(range(node, start, end).getClientRects(), bias);\n          }\n          if (rect.left || rect.right || start == 0) {\n            break;\n          }\n          end = start;\n          start = start - 1;\n          collapse = "right";\n        }\n        if (ie && ie_version < 11) {\n          rect = maybeUpdateRectForZooming(cm.display.measure, rect);\n        }\n      } else {\n        if (start > 0) {\n          collapse = bias = "right";\n        }\n        var rects;\n        if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1) {\n          rect = rects[bias == "right" ? rects.length - 1 : 0];\n        } else {\n          rect = node.getBoundingClientRect();\n        }\n      }\n      if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\n        var rSpan = node.parentNode.getClientRects()[0];\n        if (rSpan) {\n          rect = { left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom };\n        } else {\n          rect = nullRect;\n        }\n      }\n      var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\n      var mid = (rtop + rbot) / 2;\n      var heights = prepared.view.measure.heights;\n      var i2 = 0;\n      for (; i2 < heights.length - 1; i2++) {\n        if (mid < heights[i2]) {\n          break;\n        }\n      }\n      var top = i2 ? heights[i2 - 1] : 0, bot = heights[i2];\n      var result = {\n        left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,\n        right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,\n        top,\n        bottom: bot\n      };\n      if (!rect.left && !rect.right) {\n        result.bogus = true;\n      }\n      if (!cm.options.singleCursorHeightPerLine) {\n        result.rtop = rtop;\n        result.rbottom = rbot;\n      }\n      return result;\n    }\n    __name(measureCharInner, "measureCharInner");\n    function maybeUpdateRectForZooming(measure, rect) {\n      if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure)) {\n        return rect;\n      }\n      var scaleX = screen.logicalXDPI / screen.deviceXDPI;\n      var scaleY = screen.logicalYDPI / screen.deviceYDPI;\n      return {\n        left: rect.left * scaleX,\n        right: rect.right * scaleX,\n        top: rect.top * scaleY,\n        bottom: rect.bottom * scaleY\n      };\n    }\n    __name(maybeUpdateRectForZooming, "maybeUpdateRectForZooming");\n    function clearLineMeasurementCacheFor(lineView) {\n      if (lineView.measure) {\n        lineView.measure.cache = {};\n        lineView.measure.heights = null;\n        if (lineView.rest) {\n          for (var i2 = 0; i2 < lineView.rest.length; i2++) {\n            lineView.measure.caches[i2] = {};\n          }\n        }\n      }\n    }\n    __name(clearLineMeasurementCacheFor, "clearLineMeasurementCacheFor");\n    function clearLineMeasurementCache(cm) {\n      cm.display.externalMeasure = null;\n      removeChildren(cm.display.lineMeasure);\n      for (var i2 = 0; i2 < cm.display.view.length; i2++) {\n        clearLineMeasurementCacheFor(cm.display.view[i2]);\n      }\n    }\n    __name(clearLineMeasurementCache, "clearLineMeasurementCache");\n    function clearCaches(cm) {\n      clearLineMeasurementCache(cm);\n      cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\n      if (!cm.options.lineWrapping) {\n        cm.display.maxLineChanged = true;\n      }\n      cm.display.lineNumChars = null;\n    }\n    __name(clearCaches, "clearCaches");\n    function pageScrollX() {\n      if (chrome && android) {\n        return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft));\n      }\n      return window.pageXOffset || (document.documentElement || document.body).scrollLeft;\n    }\n    __name(pageScrollX, "pageScrollX");\n    function pageScrollY() {\n      if (chrome && android) {\n        return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop));\n      }\n      return window.pageYOffset || (document.documentElement || document.body).scrollTop;\n    }\n    __name(pageScrollY, "pageScrollY");\n    function widgetTopHeight(lineObj) {\n      var ref = visualLine(lineObj);\n      var widgets = ref.widgets;\n      var height = 0;\n      if (widgets) {\n        for (var i2 = 0; i2 < widgets.length; ++i2) {\n          if (widgets[i2].above) {\n            height += widgetHeight(widgets[i2]);\n          }\n        }\n      }\n      return height;\n    }\n    __name(widgetTopHeight, "widgetTopHeight");\n    function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {\n      if (!includeWidgets) {\n        var height = widgetTopHeight(lineObj);\n        rect.top += height;\n        rect.bottom += height;\n      }\n      if (context == "line") {\n        return rect;\n      }\n      if (!context) {\n        context = "local";\n      }\n      var yOff = heightAtLine(lineObj);\n      if (context == "local") {\n        yOff += paddingTop(cm.display);\n      } else {\n        yOff -= cm.display.viewOffset;\n      }\n      if (context == "page" || context == "window") {\n        var lOff = cm.display.lineSpace.getBoundingClientRect();\n        yOff += lOff.top + (context == "window" ? 0 : pageScrollY());\n        var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());\n        rect.left += xOff;\n        rect.right += xOff;\n      }\n      rect.top += yOff;\n      rect.bottom += yOff;\n      return rect;\n    }\n    __name(intoCoordSystem, "intoCoordSystem");\n    function fromCoordSystem(cm, coords, context) {\n      if (context == "div") {\n        return coords;\n      }\n      var left = coords.left, top = coords.top;\n      if (context == "page") {\n        left -= pageScrollX();\n        top -= pageScrollY();\n      } else if (context == "local" || !context) {\n        var localBox = cm.display.sizer.getBoundingClientRect();\n        left += localBox.left;\n        top += localBox.top;\n      }\n      var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\n      return { left: left - lineSpaceBox.left, top: top - lineSpaceBox.top };\n    }\n    __name(fromCoordSystem, "fromCoordSystem");\n    function charCoords(cm, pos, context, lineObj, bias) {\n      if (!lineObj) {\n        lineObj = getLine(cm.doc, pos.line);\n      }\n      return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);\n    }\n    __name(charCoords, "charCoords");\n    function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\n      lineObj = lineObj || getLine(cm.doc, pos.line);\n      if (!preparedMeasure) {\n        preparedMeasure = prepareMeasureForLine(cm, lineObj);\n      }\n      function get(ch2, right) {\n        var m = measureCharPrepared(cm, preparedMeasure, ch2, right ? "right" : "left", varHeight);\n        if (right) {\n          m.left = m.right;\n        } else {\n          m.right = m.left;\n        }\n        return intoCoordSystem(cm, lineObj, m, context);\n      }\n      __name(get, "get");\n      var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;\n      if (ch >= lineObj.text.length) {\n        ch = lineObj.text.length;\n        sticky = "before";\n      } else if (ch <= 0) {\n        ch = 0;\n        sticky = "after";\n      }\n      if (!order) {\n        return get(sticky == "before" ? ch - 1 : ch, sticky == "before");\n      }\n      function getBidi(ch2, partPos2, invert) {\n        var part = order[partPos2], right = part.level == 1;\n        return get(invert ? ch2 - 1 : ch2, right != invert);\n      }\n      __name(getBidi, "getBidi");\n      var partPos = getBidiPartAt(order, ch, sticky);\n      var other = bidiOther;\n      var val = getBidi(ch, partPos, sticky == "before");\n      if (other != null) {\n        val.other = getBidi(ch, other, sticky != "before");\n      }\n      return val;\n    }\n    __name(cursorCoords, "cursorCoords");\n    function estimateCoords(cm, pos) {\n      var left = 0;\n      pos = clipPos(cm.doc, pos);\n      if (!cm.options.lineWrapping) {\n        left = charWidth(cm.display) * pos.ch;\n      }\n      var lineObj = getLine(cm.doc, pos.line);\n      var top = heightAtLine(lineObj) + paddingTop(cm.display);\n      return { left, right: left, top, bottom: top + lineObj.height };\n    }\n    __name(estimateCoords, "estimateCoords");\n    function PosWithInfo(line, ch, sticky, outside, xRel) {\n      var pos = Pos(line, ch, sticky);\n      pos.xRel = xRel;\n      if (outside) {\n        pos.outside = outside;\n      }\n      return pos;\n    }\n    __name(PosWithInfo, "PosWithInfo");\n    function coordsChar(cm, x, y) {\n      var doc = cm.doc;\n      y += cm.display.viewOffset;\n      if (y < 0) {\n        return PosWithInfo(doc.first, 0, null, -1, -1);\n      }\n      var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\n      if (lineN > last) {\n        return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, 1, 1);\n      }\n      if (x < 0) {\n        x = 0;\n      }\n      var lineObj = getLine(doc, lineN);\n      for (; ; ) {\n        var found = coordsCharInner(cm, lineObj, lineN, x, y);\n        var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));\n        if (!collapsed) {\n          return found;\n        }\n        var rangeEnd = collapsed.find(1);\n        if (rangeEnd.line == lineN) {\n          return rangeEnd;\n        }\n        lineObj = getLine(doc, lineN = rangeEnd.line);\n      }\n    }\n    __name(coordsChar, "coordsChar");\n    function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {\n      y -= widgetTopHeight(lineObj);\n      var end = lineObj.text.length;\n      var begin = findFirst(function(ch) {\n        return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y;\n      }, end, 0);\n      end = findFirst(function(ch) {\n        return measureCharPrepared(cm, preparedMeasure, ch).top > y;\n      }, begin, end);\n      return { begin, end };\n    }\n    __name(wrappedLineExtent, "wrappedLineExtent");\n    function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {\n      if (!preparedMeasure) {\n        preparedMeasure = prepareMeasureForLine(cm, lineObj);\n      }\n      var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;\n      return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop);\n    }\n    __name(wrappedLineExtentChar, "wrappedLineExtentChar");\n    function boxIsAfter(box, x, y, left) {\n      return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x;\n    }\n    __name(boxIsAfter, "boxIsAfter");\n    function coordsCharInner(cm, lineObj, lineNo2, x, y) {\n      y -= heightAtLine(lineObj);\n      var preparedMeasure = prepareMeasureForLine(cm, lineObj);\n      var widgetHeight2 = widgetTopHeight(lineObj);\n      var begin = 0, end = lineObj.text.length, ltr = true;\n      var order = getOrder(lineObj, cm.doc.direction);\n      if (order) {\n        var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)(cm, lineObj, lineNo2, preparedMeasure, order, x, y);\n        ltr = part.level != 1;\n        begin = ltr ? part.from : part.to - 1;\n        end = ltr ? part.to : part.from - 1;\n      }\n      var chAround = null, boxAround = null;\n      var ch = findFirst(function(ch2) {\n        var box = measureCharPrepared(cm, preparedMeasure, ch2);\n        box.top += widgetHeight2;\n        box.bottom += widgetHeight2;\n        if (!boxIsAfter(box, x, y, false)) {\n          return false;\n        }\n        if (box.top <= y && box.left <= x) {\n          chAround = ch2;\n          boxAround = box;\n        }\n        return true;\n      }, begin, end);\n      var baseX, sticky, outside = false;\n      if (boxAround) {\n        var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;\n        ch = chAround + (atStart ? 0 : 1);\n        sticky = atStart ? "after" : "before";\n        baseX = atLeft ? boxAround.left : boxAround.right;\n      } else {\n        if (!ltr && (ch == end || ch == begin)) {\n          ch++;\n        }\n        sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" : measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight2 <= y == ltr ? "after" : "before";\n        var coords = cursorCoords(cm, Pos(lineNo2, ch, sticky), "line", lineObj, preparedMeasure);\n        baseX = coords.left;\n        outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0;\n      }\n      ch = skipExtendingChars(lineObj.text, ch, 1);\n      return PosWithInfo(lineNo2, ch, sticky, outside, x - baseX);\n    }\n    __name(coordsCharInner, "coordsCharInner");\n    function coordsBidiPart(cm, lineObj, lineNo2, preparedMeasure, order, x, y) {\n      var index = findFirst(function(i2) {\n        var part2 = order[i2], ltr2 = part2.level != 1;\n        return boxIsAfter(cursorCoords(cm, Pos(lineNo2, ltr2 ? part2.to : part2.from, ltr2 ? "before" : "after"), "line", lineObj, preparedMeasure), x, y, true);\n      }, 0, order.length - 1);\n      var part = order[index];\n      if (index > 0) {\n        var ltr = part.level != 1;\n        var start = cursorCoords(cm, Pos(lineNo2, ltr ? part.from : part.to, ltr ? "after" : "before"), "line", lineObj, preparedMeasure);\n        if (boxIsAfter(start, x, y, true) && start.top > y) {\n          part = order[index - 1];\n        }\n      }\n      return part;\n    }\n    __name(coordsBidiPart, "coordsBidiPart");\n    function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {\n      var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);\n      var begin = ref.begin;\n      var end = ref.end;\n      if (/\\s/.test(lineObj.text.charAt(end - 1))) {\n        end--;\n      }\n      var part = null, closestDist = null;\n      for (var i2 = 0; i2 < order.length; i2++) {\n        var p = order[i2];\n        if (p.from >= end || p.to <= begin) {\n          continue;\n        }\n        var ltr = p.level != 1;\n        var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;\n        var dist = endX < x ? x - endX + 1e9 : endX - x;\n        if (!part || closestDist > dist) {\n          part = p;\n          closestDist = dist;\n        }\n      }\n      if (!part) {\n        part = order[order.length - 1];\n      }\n      if (part.from < begin) {\n        part = { from: begin, to: part.to, level: part.level };\n      }\n      if (part.to > end) {\n        part = { from: part.from, to: end, level: part.level };\n      }\n      return part;\n    }\n    __name(coordsBidiPartWrapped, "coordsBidiPartWrapped");\n    var measureText;\n    function textHeight(display) {\n      if (display.cachedTextHeight != null) {\n        return display.cachedTextHeight;\n      }\n      if (measureText == null) {\n        measureText = elt("pre", null, "CodeMirror-line-like");\n        for (var i2 = 0; i2 < 49; ++i2) {\n          measureText.appendChild(document.createTextNode("x"));\n          measureText.appendChild(elt("br"));\n        }\n        measureText.appendChild(document.createTextNode("x"));\n      }\n      removeChildrenAndAdd(display.measure, measureText);\n      var height = measureText.offsetHeight / 50;\n      if (height > 3) {\n        display.cachedTextHeight = height;\n      }\n      removeChildren(display.measure);\n      return height || 1;\n    }\n    __name(textHeight, "textHeight");\n    function charWidth(display) {\n      if (display.cachedCharWidth != null) {\n        return display.cachedCharWidth;\n      }\n      var anchor = elt("span", "xxxxxxxxxx");\n      var pre = elt("pre", [anchor], "CodeMirror-line-like");\n      removeChildrenAndAdd(display.measure, pre);\n      var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\n      if (width > 2) {\n        display.cachedCharWidth = width;\n      }\n      return width || 10;\n    }\n    __name(charWidth, "charWidth");\n    function getDimensions(cm) {\n      var d = cm.display, left = {}, width = {};\n      var gutterLeft = d.gutters.clientLeft;\n      for (var n = d.gutters.firstChild, i2 = 0; n; n = n.nextSibling, ++i2) {\n        var id = cm.display.gutterSpecs[i2].className;\n        left[id] = n.offsetLeft + n.clientLeft + gutterLeft;\n        width[id] = n.clientWidth;\n      }\n      return {\n        fixedPos: compensateForHScroll(d),\n        gutterTotalWidth: d.gutters.offsetWidth,\n        gutterLeft: left,\n        gutterWidth: width,\n        wrapperWidth: d.wrapper.clientWidth\n      };\n    }\n    __name(getDimensions, "getDimensions");\n    function compensateForHScroll(display) {\n      return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;\n    }\n    __name(compensateForHScroll, "compensateForHScroll");\n    function estimateHeight(cm) {\n      var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n      var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n      return function(line) {\n        if (lineIsHidden(cm.doc, line)) {\n          return 0;\n        }\n        var widgetsHeight = 0;\n        if (line.widgets) {\n          for (var i2 = 0; i2 < line.widgets.length; i2++) {\n            if (line.widgets[i2].height) {\n              widgetsHeight += line.widgets[i2].height;\n            }\n          }\n        }\n        if (wrapping) {\n          return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;\n        } else {\n          return widgetsHeight + th;\n        }\n      };\n    }\n    __name(estimateHeight, "estimateHeight");\n    function estimateLineHeights(cm) {\n      var doc = cm.doc, est = estimateHeight(cm);\n      doc.iter(function(line) {\n        var estHeight = est(line);\n        if (estHeight != line.height) {\n          updateLineHeight(line, estHeight);\n        }\n      });\n    }\n    __name(estimateLineHeights, "estimateLineHeights");\n    function posFromMouse(cm, e, liberal, forRect) {\n      var display = cm.display;\n      if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") {\n        return null;\n      }\n      var x, y, space = display.lineSpace.getBoundingClientRect();\n      try {\n        x = e.clientX - space.left;\n        y = e.clientY - space.top;\n      } catch (e$1) {\n        return null;\n      }\n      var coords = coordsChar(cm, x, y), line;\n      if (forRect && coords.xRel > 0 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\n        var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\n        coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\n      }\n      return coords;\n    }\n    __name(posFromMouse, "posFromMouse");\n    function findViewIndex(cm, n) {\n      if (n >= cm.display.viewTo) {\n        return null;\n      }\n      n -= cm.display.viewFrom;\n      if (n < 0) {\n        return null;\n      }\n      var view = cm.display.view;\n      for (var i2 = 0; i2 < view.length; i2++) {\n        n -= view[i2].size;\n        if (n < 0) {\n          return i2;\n        }\n      }\n    }\n    __name(findViewIndex, "findViewIndex");\n    function regChange(cm, from, to, lendiff) {\n      if (from == null) {\n        from = cm.doc.first;\n      }\n      if (to == null) {\n        to = cm.doc.first + cm.doc.size;\n      }\n      if (!lendiff) {\n        lendiff = 0;\n      }\n      var display = cm.display;\n      if (lendiff && to < display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers > from)) {\n        display.updateLineNumbers = from;\n      }\n      cm.curOp.viewChanged = true;\n      if (from >= display.viewTo) {\n        if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo) {\n          resetView(cm);\n        }\n      } else if (to <= display.viewFrom) {\n        if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\n          resetView(cm);\n        } else {\n          display.viewFrom += lendiff;\n          display.viewTo += lendiff;\n        }\n      } else if (from <= display.viewFrom && to >= display.viewTo) {\n        resetView(cm);\n      } else if (from <= display.viewFrom) {\n        var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\n        if (cut) {\n          display.view = display.view.slice(cut.index);\n          display.viewFrom = cut.lineN;\n          display.viewTo += lendiff;\n        } else {\n          resetView(cm);\n        }\n      } else if (to >= display.viewTo) {\n        var cut$1 = viewCuttingPoint(cm, from, from, -1);\n        if (cut$1) {\n          display.view = display.view.slice(0, cut$1.index);\n          display.viewTo = cut$1.lineN;\n        } else {\n          resetView(cm);\n        }\n      } else {\n        var cutTop = viewCuttingPoint(cm, from, from, -1);\n        var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\n        if (cutTop && cutBot) {\n          display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index));\n          display.viewTo += lendiff;\n        } else {\n          resetView(cm);\n        }\n      }\n      var ext = display.externalMeasured;\n      if (ext) {\n        if (to < ext.lineN) {\n          ext.lineN += lendiff;\n        } else if (from < ext.lineN + ext.size) {\n          display.externalMeasured = null;\n        }\n      }\n    }\n    __name(regChange, "regChange");\n    function regLineChange(cm, line, type) {\n      cm.curOp.viewChanged = true;\n      var display = cm.display, ext = cm.display.externalMeasured;\n      if (ext && line >= ext.lineN && line < ext.lineN + ext.size) {\n        display.externalMeasured = null;\n      }\n      if (line < display.viewFrom || line >= display.viewTo) {\n        return;\n      }\n      var lineView = display.view[findViewIndex(cm, line)];\n      if (lineView.node == null) {\n        return;\n      }\n      var arr = lineView.changes || (lineView.changes = []);\n      if (indexOf(arr, type) == -1) {\n        arr.push(type);\n      }\n    }\n    __name(regLineChange, "regLineChange");\n    function resetView(cm) {\n      cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\n      cm.display.view = [];\n      cm.display.viewOffset = 0;\n    }\n    __name(resetView, "resetView");\n    function viewCuttingPoint(cm, oldN, newN, dir) {\n      var index = findViewIndex(cm, oldN), diff, view = cm.display.view;\n      if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size) {\n        return { index, lineN: newN };\n      }\n      var n = cm.display.viewFrom;\n      for (var i2 = 0; i2 < index; i2++) {\n        n += view[i2].size;\n      }\n      if (n != oldN) {\n        if (dir > 0) {\n          if (index == view.length - 1) {\n            return null;\n          }\n          diff = n + view[index].size - oldN;\n          index++;\n        } else {\n          diff = n - oldN;\n        }\n        oldN += diff;\n        newN += diff;\n      }\n      while (visualLineNo(cm.doc, newN) != newN) {\n        if (index == (dir < 0 ? 0 : view.length - 1)) {\n          return null;\n        }\n        newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\n        index += dir;\n      }\n      return { index, lineN: newN };\n    }\n    __name(viewCuttingPoint, "viewCuttingPoint");\n    function adjustView(cm, from, to) {\n      var display = cm.display, view = display.view;\n      if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\n        display.view = buildViewArray(cm, from, to);\n        display.viewFrom = from;\n      } else {\n        if (display.viewFrom > from) {\n          display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);\n        } else if (display.viewFrom < from) {\n          display.view = display.view.slice(findViewIndex(cm, from));\n        }\n        display.viewFrom = from;\n        if (display.viewTo < to) {\n          display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));\n        } else if (display.viewTo > to) {\n          display.view = display.view.slice(0, findViewIndex(cm, to));\n        }\n      }\n      display.viewTo = to;\n    }\n    __name(adjustView, "adjustView");\n    function countDirtyView(cm) {\n      var view = cm.display.view, dirty = 0;\n      for (var i2 = 0; i2 < view.length; i2++) {\n        var lineView = view[i2];\n        if (!lineView.hidden && (!lineView.node || lineView.changes)) {\n          ++dirty;\n        }\n      }\n      return dirty;\n    }\n    __name(countDirtyView, "countDirtyView");\n    function updateSelection(cm) {\n      cm.display.input.showSelection(cm.display.input.prepareSelection());\n    }\n    __name(updateSelection, "updateSelection");\n    function prepareSelection(cm, primary) {\n      if (primary === void 0)\n        primary = true;\n      var doc = cm.doc, result = {};\n      var curFragment = result.cursors = document.createDocumentFragment();\n      var selFragment = result.selection = document.createDocumentFragment();\n      var customCursor = cm.options.$customCursor;\n      if (customCursor) {\n        primary = true;\n      }\n      for (var i2 = 0; i2 < doc.sel.ranges.length; i2++) {\n        if (!primary && i2 == doc.sel.primIndex) {\n          continue;\n        }\n        var range2 = doc.sel.ranges[i2];\n        if (range2.from().line >= cm.display.viewTo || range2.to().line < cm.display.viewFrom) {\n          continue;\n        }\n        var collapsed = range2.empty();\n        if (customCursor) {\n          var head = customCursor(cm, range2);\n          if (head) {\n            drawSelectionCursor(cm, head, curFragment);\n          }\n        } else if (collapsed || cm.options.showCursorWhenSelecting) {\n          drawSelectionCursor(cm, range2.head, curFragment);\n        }\n        if (!collapsed) {\n          drawSelectionRange(cm, range2, selFragment);\n        }\n      }\n      return result;\n    }\n    __name(prepareSelection, "prepareSelection");\n    function drawSelectionCursor(cm, head, output) {\n      var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);\n      var cursor = output.appendChild(elt("div", "\\xA0", "CodeMirror-cursor"));\n      cursor.style.left = pos.left + "px";\n      cursor.style.top = pos.top + "px";\n      cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";\n      if (/\\bcm-fat-cursor\\b/.test(cm.getWrapperElement().className)) {\n        var charPos = charCoords(cm, head, "div", null, null);\n        var width = charPos.right - charPos.left;\n        cursor.style.width = (width > 0 ? width : cm.defaultCharWidth()) + "px";\n      }\n      if (pos.other) {\n        var otherCursor = output.appendChild(elt("div", "\\xA0", "CodeMirror-cursor CodeMirror-secondarycursor"));\n        otherCursor.style.display = "";\n        otherCursor.style.left = pos.other.left + "px";\n        otherCursor.style.top = pos.other.top + "px";\n        otherCursor.style.height = (pos.other.bottom - pos.other.top) * 0.85 + "px";\n      }\n    }\n    __name(drawSelectionCursor, "drawSelectionCursor");\n    function cmpCoords(a, b) {\n      return a.top - b.top || a.left - b.left;\n    }\n    __name(cmpCoords, "cmpCoords");\n    function drawSelectionRange(cm, range2, output) {\n      var display = cm.display, doc = cm.doc;\n      var fragment = document.createDocumentFragment();\n      var padding = paddingH(cm.display), leftSide = padding.left;\n      var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\n      var docLTR = doc.direction == "ltr";\n      function add(left, top, width, bottom) {\n        if (top < 0) {\n          top = 0;\n        }\n        top = Math.round(top);\n        bottom = Math.round(bottom);\n        fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left + "px;\\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\\n                             height: " + (bottom - top) + "px"));\n      }\n      __name(add, "add");\n      function drawForLine(line, fromArg, toArg) {\n        var lineObj = getLine(doc, line);\n        var lineLen = lineObj.text.length;\n        var start, end;\n        function coords(ch, bias) {\n          return charCoords(cm, Pos(line, ch), "div", lineObj, bias);\n        }\n        __name(coords, "coords");\n        function wrapX(pos, dir, side) {\n          var extent = wrappedLineExtentChar(cm, lineObj, null, pos);\n          var prop2 = dir == "ltr" == (side == "after") ? "left" : "right";\n          var ch = side == "after" ? extent.begin : extent.end - (/\\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);\n          return coords(ch, prop2)[prop2];\n        }\n        __name(wrapX, "wrapX");\n        var order = getOrder(lineObj, doc.direction);\n        iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir, i2) {\n          var ltr = dir == "ltr";\n          var fromPos = coords(from, ltr ? "left" : "right");\n          var toPos = coords(to - 1, ltr ? "right" : "left");\n          var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;\n          var first = i2 == 0, last = !order || i2 == order.length - 1;\n          if (toPos.top - fromPos.top <= 3) {\n            var openLeft = (docLTR ? openStart : openEnd) && first;\n            var openRight = (docLTR ? openEnd : openStart) && last;\n            var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;\n            var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;\n            add(left, fromPos.top, right - left, fromPos.bottom);\n          } else {\n            var topLeft, topRight, botLeft, botRight;\n            if (ltr) {\n              topLeft = docLTR && openStart && first ? leftSide : fromPos.left;\n              topRight = docLTR ? rightSide : wrapX(from, dir, "before");\n              botLeft = docLTR ? leftSide : wrapX(to, dir, "after");\n              botRight = docLTR && openEnd && last ? rightSide : toPos.right;\n            } else {\n              topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");\n              topRight = !docLTR && openStart && first ? rightSide : fromPos.right;\n              botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;\n              botRight = !docLTR ? rightSide : wrapX(to, dir, "after");\n            }\n            add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);\n            if (fromPos.bottom < toPos.top) {\n              add(leftSide, fromPos.bottom, null, toPos.top);\n            }\n            add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);\n          }\n          if (!start || cmpCoords(fromPos, start) < 0) {\n            start = fromPos;\n          }\n          if (cmpCoords(toPos, start) < 0) {\n            start = toPos;\n          }\n          if (!end || cmpCoords(fromPos, end) < 0) {\n            end = fromPos;\n          }\n          if (cmpCoords(toPos, end) < 0) {\n            end = toPos;\n          }\n        });\n        return { start, end };\n      }\n      __name(drawForLine, "drawForLine");\n      var sFrom = range2.from(), sTo = range2.to();\n      if (sFrom.line == sTo.line) {\n        drawForLine(sFrom.line, sFrom.ch, sTo.ch);\n      } else {\n        var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);\n        var singleVLine = visualLine(fromLine) == visualLine(toLine);\n        var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\n        var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\n        if (singleVLine) {\n          if (leftEnd.top < rightStart.top - 2) {\n            add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n            add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\n          } else {\n            add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n          }\n        }\n        if (leftEnd.bottom < rightStart.top) {\n          add(leftSide, leftEnd.bottom, null, rightStart.top);\n        }\n      }\n      output.appendChild(fragment);\n    }\n    __name(drawSelectionRange, "drawSelectionRange");\n    function restartBlink(cm) {\n      if (!cm.state.focused) {\n        return;\n      }\n      var display = cm.display;\n      clearInterval(display.blinker);\n      var on2 = true;\n      display.cursorDiv.style.visibility = "";\n      if (cm.options.cursorBlinkRate > 0) {\n        display.blinker = setInterval(function() {\n          if (!cm.hasFocus()) {\n            onBlur(cm);\n          }\n          display.cursorDiv.style.visibility = (on2 = !on2) ? "" : "hidden";\n        }, cm.options.cursorBlinkRate);\n      } else if (cm.options.cursorBlinkRate < 0) {\n        display.cursorDiv.style.visibility = "hidden";\n      }\n    }\n    __name(restartBlink, "restartBlink");\n    function ensureFocus(cm) {\n      if (!cm.hasFocus()) {\n        cm.display.input.focus();\n        if (!cm.state.focused) {\n          onFocus(cm);\n        }\n      }\n    }\n    __name(ensureFocus, "ensureFocus");\n    function delayBlurEvent(cm) {\n      cm.state.delayingBlurEvent = true;\n      setTimeout(function() {\n        if (cm.state.delayingBlurEvent) {\n          cm.state.delayingBlurEvent = false;\n          if (cm.state.focused) {\n            onBlur(cm);\n          }\n        }\n      }, 100);\n    }\n    __name(delayBlurEvent, "delayBlurEvent");\n    function onFocus(cm, e) {\n      if (cm.state.delayingBlurEvent && !cm.state.draggingText) {\n        cm.state.delayingBlurEvent = false;\n      }\n      if (cm.options.readOnly == "nocursor") {\n        return;\n      }\n      if (!cm.state.focused) {\n        signal(cm, "focus", cm, e);\n        cm.state.focused = true;\n        addClass(cm.display.wrapper, "CodeMirror-focused");\n        if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\n          cm.display.input.reset();\n          if (webkit) {\n            setTimeout(function() {\n              return cm.display.input.reset(true);\n            }, 20);\n          }\n        }\n        cm.display.input.receivedFocus();\n      }\n      restartBlink(cm);\n    }\n    __name(onFocus, "onFocus");\n    function onBlur(cm, e) {\n      if (cm.state.delayingBlurEvent) {\n        return;\n      }\n      if (cm.state.focused) {\n        signal(cm, "blur", cm, e);\n        cm.state.focused = false;\n        rmClass(cm.display.wrapper, "CodeMirror-focused");\n      }\n      clearInterval(cm.display.blinker);\n      setTimeout(function() {\n        if (!cm.state.focused) {\n          cm.display.shift = false;\n        }\n      }, 150);\n    }\n    __name(onBlur, "onBlur");\n    function updateHeightsInViewport(cm) {\n      var display = cm.display;\n      var prevBottom = display.lineDiv.offsetTop;\n      var viewTop = Math.max(0, display.scroller.getBoundingClientRect().top);\n      var oldHeight = display.lineDiv.getBoundingClientRect().top;\n      var mustScroll = 0;\n      for (var i2 = 0; i2 < display.view.length; i2++) {\n        var cur = display.view[i2], wrapping = cm.options.lineWrapping;\n        var height = void 0, width = 0;\n        if (cur.hidden) {\n          continue;\n        }\n        oldHeight += cur.line.height;\n        if (ie && ie_version < 8) {\n          var bot = cur.node.offsetTop + cur.node.offsetHeight;\n          height = bot - prevBottom;\n          prevBottom = bot;\n        } else {\n          var box = cur.node.getBoundingClientRect();\n          height = box.bottom - box.top;\n          if (!wrapping && cur.text.firstChild) {\n            width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1;\n          }\n        }\n        var diff = cur.line.height - height;\n        if (diff > 5e-3 || diff < -5e-3) {\n          if (oldHeight < viewTop) {\n            mustScroll -= diff;\n          }\n          updateLineHeight(cur.line, height);\n          updateWidgetHeight(cur.line);\n          if (cur.rest) {\n            for (var j = 0; j < cur.rest.length; j++) {\n              updateWidgetHeight(cur.rest[j]);\n            }\n          }\n        }\n        if (width > cm.display.sizerWidth) {\n          var chWidth = Math.ceil(width / charWidth(cm.display));\n          if (chWidth > cm.display.maxLineLength) {\n            cm.display.maxLineLength = chWidth;\n            cm.display.maxLine = cur.line;\n            cm.display.maxLineChanged = true;\n          }\n        }\n      }\n      if (Math.abs(mustScroll) > 2) {\n        display.scroller.scrollTop += mustScroll;\n      }\n    }\n    __name(updateHeightsInViewport, "updateHeightsInViewport");\n    function updateWidgetHeight(line) {\n      if (line.widgets) {\n        for (var i2 = 0; i2 < line.widgets.length; ++i2) {\n          var w = line.widgets[i2], parent = w.node.parentNode;\n          if (parent) {\n            w.height = parent.offsetHeight;\n          }\n        }\n      }\n    }\n    __name(updateWidgetHeight, "updateWidgetHeight");\n    function visibleLines(display, doc, viewport) {\n      var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\n      top = Math.floor(top - paddingTop(display));\n      var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\n      var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);\n      if (viewport && viewport.ensure) {\n        var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\n        if (ensureFrom < from) {\n          from = ensureFrom;\n          to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);\n        } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\n          from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);\n          to = ensureTo;\n        }\n      }\n      return { from, to: Math.max(to, from + 1) };\n    }\n    __name(visibleLines, "visibleLines");\n    function maybeScrollWindow(cm, rect) {\n      if (signalDOMEvent(cm, "scrollCursorIntoView")) {\n        return;\n      }\n      var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\n      if (rect.top + box.top < 0) {\n        doScroll = true;\n      } else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) {\n        doScroll = false;\n      }\n      if (doScroll != null && !phantom) {\n        var scrollNode = elt("div", "\\u200B", null, "position: absolute;\\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\\n                         left: " + rect.left + "px; width: " + Math.max(2, rect.right - rect.left) + "px;");\n        cm.display.lineSpace.appendChild(scrollNode);\n        scrollNode.scrollIntoView(doScroll);\n        cm.display.lineSpace.removeChild(scrollNode);\n      }\n    }\n    __name(maybeScrollWindow, "maybeScrollWindow");\n    function scrollPosIntoView(cm, pos, end, margin) {\n      if (margin == null) {\n        margin = 0;\n      }\n      var rect;\n      if (!cm.options.lineWrapping && pos == end) {\n        end = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;\n        pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;\n      }\n      for (var limit = 0; limit < 5; limit++) {\n        var changed = false;\n        var coords = cursorCoords(cm, pos);\n        var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\n        rect = {\n          left: Math.min(coords.left, endCoords.left),\n          top: Math.min(coords.top, endCoords.top) - margin,\n          right: Math.max(coords.left, endCoords.left),\n          bottom: Math.max(coords.bottom, endCoords.bottom) + margin\n        };\n        var scrollPos = calculateScrollPos(cm, rect);\n        var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\n        if (scrollPos.scrollTop != null) {\n          updateScrollTop(cm, scrollPos.scrollTop);\n          if (Math.abs(cm.doc.scrollTop - startTop) > 1) {\n            changed = true;\n          }\n        }\n        if (scrollPos.scrollLeft != null) {\n          setScrollLeft(cm, scrollPos.scrollLeft);\n          if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) {\n            changed = true;\n          }\n        }\n        if (!changed) {\n          break;\n        }\n      }\n      return rect;\n    }\n    __name(scrollPosIntoView, "scrollPosIntoView");\n    function scrollIntoView(cm, rect) {\n      var scrollPos = calculateScrollPos(cm, rect);\n      if (scrollPos.scrollTop != null) {\n        updateScrollTop(cm, scrollPos.scrollTop);\n      }\n      if (scrollPos.scrollLeft != null) {\n        setScrollLeft(cm, scrollPos.scrollLeft);\n      }\n    }\n    __name(scrollIntoView, "scrollIntoView");\n    function calculateScrollPos(cm, rect) {\n      var display = cm.display, snapMargin = textHeight(cm.display);\n      if (rect.top < 0) {\n        rect.top = 0;\n      }\n      var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\n      var screen2 = displayHeight(cm), result = {};\n      if (rect.bottom - rect.top > screen2) {\n        rect.bottom = rect.top + screen2;\n      }\n      var docBottom = cm.doc.height + paddingVert(display);\n      var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;\n      if (rect.top < screentop) {\n        result.scrollTop = atTop ? 0 : rect.top;\n      } else if (rect.bottom > screentop + screen2) {\n        var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen2);\n        if (newTop != screentop) {\n          result.scrollTop = newTop;\n        }\n      }\n      var gutterSpace = cm.options.fixedGutter ? 0 : display.gutters.offsetWidth;\n      var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft - gutterSpace;\n      var screenw = displayWidth(cm) - display.gutters.offsetWidth;\n      var tooWide = rect.right - rect.left > screenw;\n      if (tooWide) {\n        rect.right = rect.left + screenw;\n      }\n      if (rect.left < 10) {\n        result.scrollLeft = 0;\n      } else if (rect.left < screenleft) {\n        result.scrollLeft = Math.max(0, rect.left + gutterSpace - (tooWide ? 0 : 10));\n      } else if (rect.right > screenw + screenleft - 3) {\n        result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw;\n      }\n      return result;\n    }\n    __name(calculateScrollPos, "calculateScrollPos");\n    function addToScrollTop(cm, top) {\n      if (top == null) {\n        return;\n      }\n      resolveScrollToPos(cm);\n      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\n    }\n    __name(addToScrollTop, "addToScrollTop");\n    function ensureCursorVisible(cm) {\n      resolveScrollToPos(cm);\n      var cur = cm.getCursor();\n      cm.curOp.scrollToPos = { from: cur, to: cur, margin: cm.options.cursorScrollMargin };\n    }\n    __name(ensureCursorVisible, "ensureCursorVisible");\n    function scrollToCoords(cm, x, y) {\n      if (x != null || y != null) {\n        resolveScrollToPos(cm);\n      }\n      if (x != null) {\n        cm.curOp.scrollLeft = x;\n      }\n      if (y != null) {\n        cm.curOp.scrollTop = y;\n      }\n    }\n    __name(scrollToCoords, "scrollToCoords");\n    function scrollToRange(cm, range2) {\n      resolveScrollToPos(cm);\n      cm.curOp.scrollToPos = range2;\n    }\n    __name(scrollToRange, "scrollToRange");\n    function resolveScrollToPos(cm) {\n      var range2 = cm.curOp.scrollToPos;\n      if (range2) {\n        cm.curOp.scrollToPos = null;\n        var from = estimateCoords(cm, range2.from), to = estimateCoords(cm, range2.to);\n        scrollToCoordsRange(cm, from, to, range2.margin);\n      }\n    }\n    __name(resolveScrollToPos, "resolveScrollToPos");\n    function scrollToCoordsRange(cm, from, to, margin) {\n      var sPos = calculateScrollPos(cm, {\n        left: Math.min(from.left, to.left),\n        top: Math.min(from.top, to.top) - margin,\n        right: Math.max(from.right, to.right),\n        bottom: Math.max(from.bottom, to.bottom) + margin\n      });\n      scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);\n    }\n    __name(scrollToCoordsRange, "scrollToCoordsRange");\n    function updateScrollTop(cm, val) {\n      if (Math.abs(cm.doc.scrollTop - val) < 2) {\n        return;\n      }\n      if (!gecko) {\n        updateDisplaySimple(cm, { top: val });\n      }\n      setScrollTop(cm, val, true);\n      if (gecko) {\n        updateDisplaySimple(cm);\n      }\n      startWorker(cm, 100);\n    }\n    __name(updateScrollTop, "updateScrollTop");\n    function setScrollTop(cm, val, forceScroll) {\n      val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val));\n      if (cm.display.scroller.scrollTop == val && !forceScroll) {\n        return;\n      }\n      cm.doc.scrollTop = val;\n      cm.display.scrollbars.setScrollTop(val);\n      if (cm.display.scroller.scrollTop != val) {\n        cm.display.scroller.scrollTop = val;\n      }\n    }\n    __name(setScrollTop, "setScrollTop");\n    function setScrollLeft(cm, val, isScroller, forceScroll) {\n      val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth));\n      if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) {\n        return;\n      }\n      cm.doc.scrollLeft = val;\n      alignHorizontally(cm);\n      if (cm.display.scroller.scrollLeft != val) {\n        cm.display.scroller.scrollLeft = val;\n      }\n      cm.display.scrollbars.setScrollLeft(val);\n    }\n    __name(setScrollLeft, "setScrollLeft");\n    function measureForScrollbars(cm) {\n      var d = cm.display, gutterW = d.gutters.offsetWidth;\n      var docH = Math.round(cm.doc.height + paddingVert(cm.display));\n      return {\n        clientHeight: d.scroller.clientHeight,\n        viewHeight: d.wrapper.clientHeight,\n        scrollWidth: d.scroller.scrollWidth,\n        clientWidth: d.scroller.clientWidth,\n        viewWidth: d.wrapper.clientWidth,\n        barLeft: cm.options.fixedGutter ? gutterW : 0,\n        docHeight: docH,\n        scrollHeight: docH + scrollGap(cm) + d.barHeight,\n        nativeBarWidth: d.nativeBarWidth,\n        gutterWidth: gutterW\n      };\n    }\n    __name(measureForScrollbars, "measureForScrollbars");\n    var NativeScrollbars = /* @__PURE__ */ __name(function(place, scroll, cm) {\n      this.cm = cm;\n      var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");\n      var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");\n      vert.tabIndex = horiz.tabIndex = -1;\n      place(vert);\n      place(horiz);\n      on(vert, "scroll", function() {\n        if (vert.clientHeight) {\n          scroll(vert.scrollTop, "vertical");\n        }\n      });\n      on(horiz, "scroll", function() {\n        if (horiz.clientWidth) {\n          scroll(horiz.scrollLeft, "horizontal");\n        }\n      });\n      this.checkedZeroWidth = false;\n      if (ie && ie_version < 8) {\n        this.horiz.style.minHeight = this.vert.style.minWidth = "18px";\n      }\n    }, "NativeScrollbars");\n    NativeScrollbars.prototype.update = function(measure) {\n      var needsH = measure.scrollWidth > measure.clientWidth + 1;\n      var needsV = measure.scrollHeight > measure.clientHeight + 1;\n      var sWidth = measure.nativeBarWidth;\n      if (needsV) {\n        this.vert.style.display = "block";\n        this.vert.style.bottom = needsH ? sWidth + "px" : "0";\n        var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);\n        this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";\n      } else {\n        this.vert.scrollTop = 0;\n        this.vert.style.display = "";\n        this.vert.firstChild.style.height = "0";\n      }\n      if (needsH) {\n        this.horiz.style.display = "block";\n        this.horiz.style.right = needsV ? sWidth + "px" : "0";\n        this.horiz.style.left = measure.barLeft + "px";\n        var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\n        this.horiz.firstChild.style.width = Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";\n      } else {\n        this.horiz.style.display = "";\n        this.horiz.firstChild.style.width = "0";\n      }\n      if (!this.checkedZeroWidth && measure.clientHeight > 0) {\n        if (sWidth == 0) {\n          this.zeroWidthHack();\n        }\n        this.checkedZeroWidth = true;\n      }\n      return { right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0 };\n    };\n    NativeScrollbars.prototype.setScrollLeft = function(pos) {\n      if (this.horiz.scrollLeft != pos) {\n        this.horiz.scrollLeft = pos;\n      }\n      if (this.disableHoriz) {\n        this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz");\n      }\n    };\n    NativeScrollbars.prototype.setScrollTop = function(pos) {\n      if (this.vert.scrollTop != pos) {\n        this.vert.scrollTop = pos;\n      }\n      if (this.disableVert) {\n        this.enableZeroWidthBar(this.vert, this.disableVert, "vert");\n      }\n    };\n    NativeScrollbars.prototype.zeroWidthHack = function() {\n      var w = mac && !mac_geMountainLion ? "12px" : "18px";\n      this.horiz.style.height = this.vert.style.width = w;\n      this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";\n      this.disableHoriz = new Delayed();\n      this.disableVert = new Delayed();\n    };\n    NativeScrollbars.prototype.enableZeroWidthBar = function(bar, delay, type) {\n      bar.style.pointerEvents = "auto";\n      function maybeDisable() {\n        var box = bar.getBoundingClientRect();\n        var elt2 = type == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2) : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);\n        if (elt2 != bar) {\n          bar.style.pointerEvents = "none";\n        } else {\n          delay.set(1e3, maybeDisable);\n        }\n      }\n      __name(maybeDisable, "maybeDisable");\n      delay.set(1e3, maybeDisable);\n    };\n    NativeScrollbars.prototype.clear = function() {\n      var parent = this.horiz.parentNode;\n      parent.removeChild(this.horiz);\n      parent.removeChild(this.vert);\n    };\n    var NullScrollbars = /* @__PURE__ */ __name(function() {\n    }, "NullScrollbars");\n    NullScrollbars.prototype.update = function() {\n      return { bottom: 0, right: 0 };\n    };\n    NullScrollbars.prototype.setScrollLeft = function() {\n    };\n    NullScrollbars.prototype.setScrollTop = function() {\n    };\n    NullScrollbars.prototype.clear = function() {\n    };\n    function updateScrollbars(cm, measure) {\n      if (!measure) {\n        measure = measureForScrollbars(cm);\n      }\n      var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;\n      updateScrollbarsInner(cm, measure);\n      for (var i2 = 0; i2 < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i2++) {\n        if (startWidth != cm.display.barWidth && cm.options.lineWrapping) {\n          updateHeightsInViewport(cm);\n        }\n        updateScrollbarsInner(cm, measureForScrollbars(cm));\n        startWidth = cm.display.barWidth;\n        startHeight = cm.display.barHeight;\n      }\n    }\n    __name(updateScrollbars, "updateScrollbars");\n    function updateScrollbarsInner(cm, measure) {\n      var d = cm.display;\n      var sizes = d.scrollbars.update(measure);\n      d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";\n      d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";\n      d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";\n      if (sizes.right && sizes.bottom) {\n        d.scrollbarFiller.style.display = "block";\n        d.scrollbarFiller.style.height = sizes.bottom + "px";\n        d.scrollbarFiller.style.width = sizes.right + "px";\n      } else {\n        d.scrollbarFiller.style.display = "";\n      }\n      if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n        d.gutterFiller.style.display = "block";\n        d.gutterFiller.style.height = sizes.bottom + "px";\n        d.gutterFiller.style.width = measure.gutterWidth + "px";\n      } else {\n        d.gutterFiller.style.display = "";\n      }\n    }\n    __name(updateScrollbarsInner, "updateScrollbarsInner");\n    var scrollbarModel = { "native": NativeScrollbars, "null": NullScrollbars };\n    function initScrollbars(cm) {\n      if (cm.display.scrollbars) {\n        cm.display.scrollbars.clear();\n        if (cm.display.scrollbars.addClass) {\n          rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);\n        }\n      }\n      cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function(node) {\n        cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);\n        on(node, "mousedown", function() {\n          if (cm.state.focused) {\n            setTimeout(function() {\n              return cm.display.input.focus();\n            }, 0);\n          }\n        });\n        node.setAttribute("cm-not-content", "true");\n      }, function(pos, axis) {\n        if (axis == "horizontal") {\n          setScrollLeft(cm, pos);\n        } else {\n          updateScrollTop(cm, pos);\n        }\n      }, cm);\n      if (cm.display.scrollbars.addClass) {\n        addClass(cm.display.wrapper, cm.display.scrollbars.addClass);\n      }\n    }\n    __name(initScrollbars, "initScrollbars");\n    var nextOpId = 0;\n    function startOperation(cm) {\n      cm.curOp = {\n        cm,\n        viewChanged: false,\n        startHeight: cm.doc.height,\n        forceUpdate: false,\n        updateInput: 0,\n        typing: false,\n        changeObjs: null,\n        cursorActivityHandlers: null,\n        cursorActivityCalled: 0,\n        selectionChanged: false,\n        updateMaxLine: false,\n        scrollLeft: null,\n        scrollTop: null,\n        scrollToPos: null,\n        focus: false,\n        id: ++nextOpId,\n        markArrays: null\n      };\n      pushOperation(cm.curOp);\n    }\n    __name(startOperation, "startOperation");\n    function endOperation(cm) {\n      var op = cm.curOp;\n      if (op) {\n        finishOperation(op, function(group) {\n          for (var i2 = 0; i2 < group.ops.length; i2++) {\n            group.ops[i2].cm.curOp = null;\n          }\n          endOperations(group);\n        });\n      }\n    }\n    __name(endOperation, "endOperation");\n    function endOperations(group) {\n      var ops = group.ops;\n      for (var i2 = 0; i2 < ops.length; i2++) {\n        endOperation_R1(ops[i2]);\n      }\n      for (var i$12 = 0; i$12 < ops.length; i$12++) {\n        endOperation_W1(ops[i$12]);\n      }\n      for (var i$22 = 0; i$22 < ops.length; i$22++) {\n        endOperation_R2(ops[i$22]);\n      }\n      for (var i$3 = 0; i$3 < ops.length; i$3++) {\n        endOperation_W2(ops[i$3]);\n      }\n      for (var i$4 = 0; i$4 < ops.length; i$4++) {\n        endOperation_finish(ops[i$4]);\n      }\n    }\n    __name(endOperations, "endOperations");\n    function endOperation_R1(op) {\n      var cm = op.cm, display = cm.display;\n      maybeClipScrollbars(cm);\n      if (op.updateMaxLine) {\n        findMaxLine(cm);\n      }\n      op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping;\n      op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && { top: op.scrollTop, ensure: op.scrollToPos }, op.forceUpdate);\n    }\n    __name(endOperation_R1, "endOperation_R1");\n    function endOperation_W1(op) {\n      op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\n    }\n    __name(endOperation_W1, "endOperation_W1");\n    function endOperation_R2(op) {\n      var cm = op.cm, display = cm.display;\n      if (op.updatedDisplay) {\n        updateHeightsInViewport(cm);\n      }\n      op.barMeasure = measureForScrollbars(cm);\n      if (display.maxLineChanged && !cm.options.lineWrapping) {\n        op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\n        cm.display.sizerWidth = op.adjustWidthTo;\n        op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\n        op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\n      }\n      if (op.updatedDisplay || op.selectionChanged) {\n        op.preparedSelection = display.input.prepareSelection();\n      }\n    }\n    __name(endOperation_R2, "endOperation_R2");\n    function endOperation_W2(op) {\n      var cm = op.cm;\n      if (op.adjustWidthTo != null) {\n        cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";\n        if (op.maxScrollLeft < cm.doc.scrollLeft) {\n          setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);\n        }\n        cm.display.maxLineChanged = false;\n      }\n      var takeFocus = op.focus && op.focus == activeElt();\n      if (op.preparedSelection) {\n        cm.display.input.showSelection(op.preparedSelection, takeFocus);\n      }\n      if (op.updatedDisplay || op.startHeight != cm.doc.height) {\n        updateScrollbars(cm, op.barMeasure);\n      }\n      if (op.updatedDisplay) {\n        setDocumentHeight(cm, op.barMeasure);\n      }\n      if (op.selectionChanged) {\n        restartBlink(cm);\n      }\n      if (cm.state.focused && op.updateInput) {\n        cm.display.input.reset(op.typing);\n      }\n      if (takeFocus) {\n        ensureFocus(op.cm);\n      }\n    }\n    __name(endOperation_W2, "endOperation_W2");\n    function endOperation_finish(op) {\n      var cm = op.cm, display = cm.display, doc = cm.doc;\n      if (op.updatedDisplay) {\n        postUpdateDisplay(cm, op.update);\n      }\n      if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos)) {\n        display.wheelStartX = display.wheelStartY = null;\n      }\n      if (op.scrollTop != null) {\n        setScrollTop(cm, op.scrollTop, op.forceScroll);\n      }\n      if (op.scrollLeft != null) {\n        setScrollLeft(cm, op.scrollLeft, true, true);\n      }\n      if (op.scrollToPos) {\n        var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from), clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\n        maybeScrollWindow(cm, rect);\n      }\n      var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\n      if (hidden) {\n        for (var i2 = 0; i2 < hidden.length; ++i2) {\n          if (!hidden[i2].lines.length) {\n            signal(hidden[i2], "hide");\n          }\n        }\n      }\n      if (unhidden) {\n        for (var i$12 = 0; i$12 < unhidden.length; ++i$12) {\n          if (unhidden[i$12].lines.length) {\n            signal(unhidden[i$12], "unhide");\n          }\n        }\n      }\n      if (display.wrapper.offsetHeight) {\n        doc.scrollTop = cm.display.scroller.scrollTop;\n      }\n      if (op.changeObjs) {\n        signal(cm, "changes", cm, op.changeObjs);\n      }\n      if (op.update) {\n        op.update.finish();\n      }\n    }\n    __name(endOperation_finish, "endOperation_finish");\n    function runInOp(cm, f) {\n      if (cm.curOp) {\n        return f();\n      }\n      startOperation(cm);\n      try {\n        return f();\n      } finally {\n        endOperation(cm);\n      }\n    }\n    __name(runInOp, "runInOp");\n    function operation(cm, f) {\n      return function() {\n        if (cm.curOp) {\n          return f.apply(cm, arguments);\n        }\n        startOperation(cm);\n        try {\n          return f.apply(cm, arguments);\n        } finally {\n          endOperation(cm);\n        }\n      };\n    }\n    __name(operation, "operation");\n    function methodOp(f) {\n      return function() {\n        if (this.curOp) {\n          return f.apply(this, arguments);\n        }\n        startOperation(this);\n        try {\n          return f.apply(this, arguments);\n        } finally {\n          endOperation(this);\n        }\n      };\n    }\n    __name(methodOp, "methodOp");\n    function docMethodOp(f) {\n      return function() {\n        var cm = this.cm;\n        if (!cm || cm.curOp) {\n          return f.apply(this, arguments);\n        }\n        startOperation(cm);\n        try {\n          return f.apply(this, arguments);\n        } finally {\n          endOperation(cm);\n        }\n      };\n    }\n    __name(docMethodOp, "docMethodOp");\n    function startWorker(cm, time) {\n      if (cm.doc.highlightFrontier < cm.display.viewTo) {\n        cm.state.highlight.set(time, bind(highlightWorker, cm));\n      }\n    }\n    __name(startWorker, "startWorker");\n    function highlightWorker(cm) {\n      var doc = cm.doc;\n      if (doc.highlightFrontier >= cm.display.viewTo) {\n        return;\n      }\n      var end = +new Date() + cm.options.workTime;\n      var context = getContextBefore(cm, doc.highlightFrontier);\n      var changedLines = [];\n      doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {\n        if (context.line >= cm.display.viewFrom) {\n          var oldStyles = line.styles;\n          var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;\n          var highlighted = highlightLine(cm, line, context, true);\n          if (resetState) {\n            context.state = resetState;\n          }\n          line.styles = highlighted.styles;\n          var oldCls = line.styleClasses, newCls = highlighted.classes;\n          if (newCls) {\n            line.styleClasses = newCls;\n          } else if (oldCls) {\n            line.styleClasses = null;\n          }\n          var ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\n          for (var i2 = 0; !ischange && i2 < oldStyles.length; ++i2) {\n            ischange = oldStyles[i2] != line.styles[i2];\n          }\n          if (ischange) {\n            changedLines.push(context.line);\n          }\n          line.stateAfter = context.save();\n          context.nextLine();\n        } else {\n          if (line.text.length <= cm.options.maxHighlightLength) {\n            processLine(cm, line.text, context);\n          }\n          line.stateAfter = context.line % 5 == 0 ? context.save() : null;\n          context.nextLine();\n        }\n        if (+new Date() > end) {\n          startWorker(cm, cm.options.workDelay);\n          return true;\n        }\n      });\n      doc.highlightFrontier = context.line;\n      doc.modeFrontier = Math.max(doc.modeFrontier, context.line);\n      if (changedLines.length) {\n        runInOp(cm, function() {\n          for (var i2 = 0; i2 < changedLines.length; i2++) {\n            regLineChange(cm, changedLines[i2], "text");\n          }\n        });\n      }\n    }\n    __name(highlightWorker, "highlightWorker");\n    var DisplayUpdate = /* @__PURE__ */ __name(function(cm, viewport, force) {\n      var display = cm.display;\n      this.viewport = viewport;\n      this.visible = visibleLines(display, cm.doc, viewport);\n      this.editorIsHidden = !display.wrapper.offsetWidth;\n      this.wrapperHeight = display.wrapper.clientHeight;\n      this.wrapperWidth = display.wrapper.clientWidth;\n      this.oldDisplayWidth = displayWidth(cm);\n      this.force = force;\n      this.dims = getDimensions(cm);\n      this.events = [];\n    }, "DisplayUpdate");\n    DisplayUpdate.prototype.signal = function(emitter, type) {\n      if (hasHandler(emitter, type)) {\n        this.events.push(arguments);\n      }\n    };\n    DisplayUpdate.prototype.finish = function() {\n      for (var i2 = 0; i2 < this.events.length; i2++) {\n        signal.apply(null, this.events[i2]);\n      }\n    };\n    function maybeClipScrollbars(cm) {\n      var display = cm.display;\n      if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\n        display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\n        display.heightForcer.style.height = scrollGap(cm) + "px";\n        display.sizer.style.marginBottom = -display.nativeBarWidth + "px";\n        display.sizer.style.borderRightWidth = scrollGap(cm) + "px";\n        display.scrollbarsClipped = true;\n      }\n    }\n    __name(maybeClipScrollbars, "maybeClipScrollbars");\n    function selectionSnapshot(cm) {\n      if (cm.hasFocus()) {\n        return null;\n      }\n      var active = activeElt();\n      if (!active || !contains(cm.display.lineDiv, active)) {\n        return null;\n      }\n      var result = { activeElt: active };\n      if (window.getSelection) {\n        var sel = window.getSelection();\n        if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {\n          result.anchorNode = sel.anchorNode;\n          result.anchorOffset = sel.anchorOffset;\n          result.focusNode = sel.focusNode;\n          result.focusOffset = sel.focusOffset;\n        }\n      }\n      return result;\n    }\n    __name(selectionSnapshot, "selectionSnapshot");\n    function restoreSelection(snapshot) {\n      if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) {\n        return;\n      }\n      snapshot.activeElt.focus();\n      if (!/^(INPUT|TEXTAREA)$/.test(snapshot.activeElt.nodeName) && snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {\n        var sel = window.getSelection(), range2 = document.createRange();\n        range2.setEnd(snapshot.anchorNode, snapshot.anchorOffset);\n        range2.collapse(false);\n        sel.removeAllRanges();\n        sel.addRange(range2);\n        sel.extend(snapshot.focusNode, snapshot.focusOffset);\n      }\n    }\n    __name(restoreSelection, "restoreSelection");\n    function updateDisplayIfNeeded(cm, update) {\n      var display = cm.display, doc = cm.doc;\n      if (update.editorIsHidden) {\n        resetView(cm);\n        return false;\n      }\n      if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && countDirtyView(cm) == 0) {\n        return false;\n      }\n      if (maybeUpdateLineNumberWidth(cm)) {\n        resetView(cm);\n        update.dims = getDimensions(cm);\n      }\n      var end = doc.first + doc.size;\n      var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\n      var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\n      if (display.viewFrom < from && from - display.viewFrom < 20) {\n        from = Math.max(doc.first, display.viewFrom);\n      }\n      if (display.viewTo > to && display.viewTo - to < 20) {\n        to = Math.min(end, display.viewTo);\n      }\n      if (sawCollapsedSpans) {\n        from = visualLineNo(cm.doc, from);\n        to = visualLineEndNo(cm.doc, to);\n      }\n      var different = from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\n      adjustView(cm, from, to);\n      display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));\n      cm.display.mover.style.top = display.viewOffset + "px";\n      var toUpdate = countDirtyView(cm);\n      if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo)) {\n        return false;\n      }\n      var selSnapshot = selectionSnapshot(cm);\n      if (toUpdate > 4) {\n        display.lineDiv.style.display = "none";\n      }\n      patchDisplay(cm, display.updateLineNumbers, update.dims);\n      if (toUpdate > 4) {\n        display.lineDiv.style.display = "";\n      }\n      display.renderedView = display.view;\n      restoreSelection(selSnapshot);\n      removeChildren(display.cursorDiv);\n      removeChildren(display.selectionDiv);\n      display.gutters.style.height = display.sizer.style.minHeight = 0;\n      if (different) {\n        display.lastWrapHeight = update.wrapperHeight;\n        display.lastWrapWidth = update.wrapperWidth;\n        startWorker(cm, 400);\n      }\n      display.updateLineNumbers = null;\n      return true;\n    }\n    __name(updateDisplayIfNeeded, "updateDisplayIfNeeded");\n    function postUpdateDisplay(cm, update) {\n      var viewport = update.viewport;\n      for (var first = true; ; first = false) {\n        if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\n          if (viewport && viewport.top != null) {\n            viewport = { top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top) };\n          }\n          update.visible = visibleLines(cm.display, cm.doc, viewport);\n          if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo) {\n            break;\n          }\n        } else if (first) {\n          update.visible = visibleLines(cm.display, cm.doc, viewport);\n        }\n        if (!updateDisplayIfNeeded(cm, update)) {\n          break;\n        }\n        updateHeightsInViewport(cm);\n        var barMeasure = measureForScrollbars(cm);\n        updateSelection(cm);\n        updateScrollbars(cm, barMeasure);\n        setDocumentHeight(cm, barMeasure);\n        update.force = false;\n      }\n      update.signal(cm, "update", cm);\n      if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\n        update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);\n        cm.display.reportedViewFrom = cm.display.viewFrom;\n        cm.display.reportedViewTo = cm.display.viewTo;\n      }\n    }\n    __name(postUpdateDisplay, "postUpdateDisplay");\n    function updateDisplaySimple(cm, viewport) {\n      var update = new DisplayUpdate(cm, viewport);\n      if (updateDisplayIfNeeded(cm, update)) {\n        updateHeightsInViewport(cm);\n        postUpdateDisplay(cm, update);\n        var barMeasure = measureForScrollbars(cm);\n        updateSelection(cm);\n        updateScrollbars(cm, barMeasure);\n        setDocumentHeight(cm, barMeasure);\n        update.finish();\n      }\n    }\n    __name(updateDisplaySimple, "updateDisplaySimple");\n    function patchDisplay(cm, updateNumbersFrom, dims) {\n      var display = cm.display, lineNumbers = cm.options.lineNumbers;\n      var container = display.lineDiv, cur = container.firstChild;\n      function rm(node2) {\n        var next = node2.nextSibling;\n        if (webkit && mac && cm.display.currentWheelTarget == node2) {\n          node2.style.display = "none";\n        } else {\n          node2.parentNode.removeChild(node2);\n        }\n        return next;\n      }\n      __name(rm, "rm");\n      var view = display.view, lineN = display.viewFrom;\n      for (var i2 = 0; i2 < view.length; i2++) {\n        var lineView = view[i2];\n        if (lineView.hidden)\n          ;\n        else if (!lineView.node || lineView.node.parentNode != container) {\n          var node = buildLineElement(cm, lineView, lineN, dims);\n          container.insertBefore(node, cur);\n        } else {\n          while (cur != lineView.node) {\n            cur = rm(cur);\n          }\n          var updateNumber = lineNumbers && updateNumbersFrom != null && updateNumbersFrom <= lineN && lineView.lineNumber;\n          if (lineView.changes) {\n            if (indexOf(lineView.changes, "gutter") > -1) {\n              updateNumber = false;\n            }\n            updateLineForChanges(cm, lineView, lineN, dims);\n          }\n          if (updateNumber) {\n            removeChildren(lineView.lineNumber);\n            lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\n          }\n          cur = lineView.node.nextSibling;\n        }\n        lineN += lineView.size;\n      }\n      while (cur) {\n        cur = rm(cur);\n      }\n    }\n    __name(patchDisplay, "patchDisplay");\n    function updateGutterSpace(display) {\n      var width = display.gutters.offsetWidth;\n      display.sizer.style.marginLeft = width + "px";\n      signalLater(display, "gutterChanged", display);\n    }\n    __name(updateGutterSpace, "updateGutterSpace");\n    function setDocumentHeight(cm, measure) {\n      cm.display.sizer.style.minHeight = measure.docHeight + "px";\n      cm.display.heightForcer.style.top = measure.docHeight + "px";\n      cm.display.gutters.style.height = measure.docHeight + cm.display.barHeight + scrollGap(cm) + "px";\n    }\n    __name(setDocumentHeight, "setDocumentHeight");\n    function alignHorizontally(cm) {\n      var display = cm.display, view = display.view;\n      if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) {\n        return;\n      }\n      var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n      var gutterW = display.gutters.offsetWidth, left = comp + "px";\n      for (var i2 = 0; i2 < view.length; i2++) {\n        if (!view[i2].hidden) {\n          if (cm.options.fixedGutter) {\n            if (view[i2].gutter) {\n              view[i2].gutter.style.left = left;\n            }\n            if (view[i2].gutterBackground) {\n              view[i2].gutterBackground.style.left = left;\n            }\n          }\n          var align = view[i2].alignable;\n          if (align) {\n            for (var j = 0; j < align.length; j++) {\n              align[j].style.left = left;\n            }\n          }\n        }\n      }\n      if (cm.options.fixedGutter) {\n        display.gutters.style.left = comp + gutterW + "px";\n      }\n    }\n    __name(alignHorizontally, "alignHorizontally");\n    function maybeUpdateLineNumberWidth(cm) {\n      if (!cm.options.lineNumbers) {\n        return false;\n      }\n      var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\n      if (last.length != display.lineNumChars) {\n        var test = display.measure.appendChild(elt("div", [elt("div", last)], "CodeMirror-linenumber CodeMirror-gutter-elt"));\n        var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\n        display.lineGutter.style.width = "";\n        display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\n        display.lineNumWidth = display.lineNumInnerWidth + padding;\n        display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n        display.lineGutter.style.width = display.lineNumWidth + "px";\n        updateGutterSpace(cm.display);\n        return true;\n      }\n      return false;\n    }\n    __name(maybeUpdateLineNumberWidth, "maybeUpdateLineNumberWidth");\n    function getGutters(gutters, lineNumbers) {\n      var result = [], sawLineNumbers = false;\n      for (var i2 = 0; i2 < gutters.length; i2++) {\n        var name = gutters[i2], style = null;\n        if (typeof name != "string") {\n          style = name.style;\n          name = name.className;\n        }\n        if (name == "CodeMirror-linenumbers") {\n          if (!lineNumbers) {\n            continue;\n          } else {\n            sawLineNumbers = true;\n          }\n        }\n        result.push({ className: name, style });\n      }\n      if (lineNumbers && !sawLineNumbers) {\n        result.push({ className: "CodeMirror-linenumbers", style: null });\n      }\n      return result;\n    }\n    __name(getGutters, "getGutters");\n    function renderGutters(display) {\n      var gutters = display.gutters, specs = display.gutterSpecs;\n      removeChildren(gutters);\n      display.lineGutter = null;\n      for (var i2 = 0; i2 < specs.length; ++i2) {\n        var ref = specs[i2];\n        var className = ref.className;\n        var style = ref.style;\n        var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + className));\n        if (style) {\n          gElt.style.cssText = style;\n        }\n        if (className == "CodeMirror-linenumbers") {\n          display.lineGutter = gElt;\n          gElt.style.width = (display.lineNumWidth || 1) + "px";\n        }\n      }\n      gutters.style.display = specs.length ? "" : "none";\n      updateGutterSpace(display);\n    }\n    __name(renderGutters, "renderGutters");\n    function updateGutters(cm) {\n      renderGutters(cm.display);\n      regChange(cm);\n      alignHorizontally(cm);\n    }\n    __name(updateGutters, "updateGutters");\n    function Display(place, doc, input, options) {\n      var d = this;\n      this.input = input;\n      d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");\n      d.scrollbarFiller.setAttribute("cm-not-content", "true");\n      d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");\n      d.gutterFiller.setAttribute("cm-not-content", "true");\n      d.lineDiv = eltP("div", null, "CodeMirror-code");\n      d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");\n      d.cursorDiv = elt("div", null, "CodeMirror-cursors");\n      d.measure = elt("div", null, "CodeMirror-measure");\n      d.lineMeasure = elt("div", null, "CodeMirror-measure");\n      d.lineSpace = eltP("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv], null, "position: relative; outline: none");\n      var lines = eltP("div", [d.lineSpace], "CodeMirror-lines");\n      d.mover = elt("div", [lines], null, "position: relative");\n      d.sizer = elt("div", [d.mover], "CodeMirror-sizer");\n      d.sizerWidth = null;\n      d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");\n      d.gutters = elt("div", null, "CodeMirror-gutters");\n      d.lineGutter = null;\n      d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");\n      d.scroller.setAttribute("tabIndex", "-1");\n      d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");\n      d.wrapper.setAttribute("translate", "no");\n      if (ie && ie_version < 8) {\n        d.gutters.style.zIndex = -1;\n        d.scroller.style.paddingRight = 0;\n      }\n      if (!webkit && !(gecko && mobile)) {\n        d.scroller.draggable = true;\n      }\n      if (place) {\n        if (place.appendChild) {\n          place.appendChild(d.wrapper);\n        } else {\n          place(d.wrapper);\n        }\n      }\n      d.viewFrom = d.viewTo = doc.first;\n      d.reportedViewFrom = d.reportedViewTo = doc.first;\n      d.view = [];\n      d.renderedView = null;\n      d.externalMeasured = null;\n      d.viewOffset = 0;\n      d.lastWrapHeight = d.lastWrapWidth = 0;\n      d.updateLineNumbers = null;\n      d.nativeBarWidth = d.barHeight = d.barWidth = 0;\n      d.scrollbarsClipped = false;\n      d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n      d.alignWidgets = false;\n      d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n      d.maxLine = null;\n      d.maxLineLength = 0;\n      d.maxLineChanged = false;\n      d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n      d.shift = false;\n      d.selForContextMenu = null;\n      d.activeTouch = null;\n      d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);\n      renderGutters(d);\n      input.init(d);\n    }\n    __name(Display, "Display");\n    var wheelSamples = 0, wheelPixelsPerUnit = null;\n    if (ie) {\n      wheelPixelsPerUnit = -0.53;\n    } else if (gecko) {\n      wheelPixelsPerUnit = 15;\n    } else if (chrome) {\n      wheelPixelsPerUnit = -0.7;\n    } else if (safari) {\n      wheelPixelsPerUnit = -1 / 3;\n    }\n    function wheelEventDelta(e) {\n      var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n      if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) {\n        dx = e.detail;\n      }\n      if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) {\n        dy = e.detail;\n      } else if (dy == null) {\n        dy = e.wheelDelta;\n      }\n      return { x: dx, y: dy };\n    }\n    __name(wheelEventDelta, "wheelEventDelta");\n    function wheelEventPixels(e) {\n      var delta = wheelEventDelta(e);\n      delta.x *= wheelPixelsPerUnit;\n      delta.y *= wheelPixelsPerUnit;\n      return delta;\n    }\n    __name(wheelEventPixels, "wheelEventPixels");\n    function onScrollWheel(cm, e) {\n      var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;\n      var pixelsPerUnit = wheelPixelsPerUnit;\n      if (e.deltaMode === 0) {\n        dx = e.deltaX;\n        dy = e.deltaY;\n        pixelsPerUnit = 1;\n      }\n      var display = cm.display, scroll = display.scroller;\n      var canScrollX = scroll.scrollWidth > scroll.clientWidth;\n      var canScrollY = scroll.scrollHeight > scroll.clientHeight;\n      if (!(dx && canScrollX || dy && canScrollY)) {\n        return;\n      }\n      if (dy && mac && webkit) {\n        outer:\n          for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\n            for (var i2 = 0; i2 < view.length; i2++) {\n              if (view[i2].node == cur) {\n                cm.display.currentWheelTarget = cur;\n                break outer;\n              }\n            }\n          }\n      }\n      if (dx && !gecko && !presto && pixelsPerUnit != null) {\n        if (dy && canScrollY) {\n          updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * pixelsPerUnit));\n        }\n        setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * pixelsPerUnit));\n        if (!dy || dy && canScrollY) {\n          e_preventDefault(e);\n        }\n        display.wheelStartX = null;\n        return;\n      }\n      if (dy && pixelsPerUnit != null) {\n        var pixels = dy * pixelsPerUnit;\n        var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\n        if (pixels < 0) {\n          top = Math.max(0, top + pixels - 50);\n        } else {\n          bot = Math.min(cm.doc.height, bot + pixels + 50);\n        }\n        updateDisplaySimple(cm, { top, bottom: bot });\n      }\n      if (wheelSamples < 20 && e.deltaMode !== 0) {\n        if (display.wheelStartX == null) {\n          display.wheelStartX = scroll.scrollLeft;\n          display.wheelStartY = scroll.scrollTop;\n          display.wheelDX = dx;\n          display.wheelDY = dy;\n          setTimeout(function() {\n            if (display.wheelStartX == null) {\n              return;\n            }\n            var movedX = scroll.scrollLeft - display.wheelStartX;\n            var movedY = scroll.scrollTop - display.wheelStartY;\n            var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;\n            display.wheelStartX = display.wheelStartY = null;\n            if (!sample) {\n              return;\n            }\n            wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n            ++wheelSamples;\n          }, 200);\n        } else {\n          display.wheelDX += dx;\n          display.wheelDY += dy;\n        }\n      }\n    }\n    __name(onScrollWheel, "onScrollWheel");\n    var Selection = /* @__PURE__ */ __name(function(ranges, primIndex) {\n      this.ranges = ranges;\n      this.primIndex = primIndex;\n    }, "Selection");\n    Selection.prototype.primary = function() {\n      return this.ranges[this.primIndex];\n    };\n    Selection.prototype.equals = function(other) {\n      if (other == this) {\n        return true;\n      }\n      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) {\n        return false;\n      }\n      for (var i2 = 0; i2 < this.ranges.length; i2++) {\n        var here = this.ranges[i2], there = other.ranges[i2];\n        if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) {\n          return false;\n        }\n      }\n      return true;\n    };\n    Selection.prototype.deepCopy = function() {\n      var out = [];\n      for (var i2 = 0; i2 < this.ranges.length; i2++) {\n        out[i2] = new Range(copyPos(this.ranges[i2].anchor), copyPos(this.ranges[i2].head));\n      }\n      return new Selection(out, this.primIndex);\n    };\n    Selection.prototype.somethingSelected = function() {\n      for (var i2 = 0; i2 < this.ranges.length; i2++) {\n        if (!this.ranges[i2].empty()) {\n          return true;\n        }\n      }\n      return false;\n    };\n    Selection.prototype.contains = function(pos, end) {\n      if (!end) {\n        end = pos;\n      }\n      for (var i2 = 0; i2 < this.ranges.length; i2++) {\n        var range2 = this.ranges[i2];\n        if (cmp(end, range2.from()) >= 0 && cmp(pos, range2.to()) <= 0) {\n          return i2;\n        }\n      }\n      return -1;\n    };\n    var Range = /* @__PURE__ */ __name(function(anchor, head) {\n      this.anchor = anchor;\n      this.head = head;\n    }, "Range");\n    Range.prototype.from = function() {\n      return minPos(this.anchor, this.head);\n    };\n    Range.prototype.to = function() {\n      return maxPos(this.anchor, this.head);\n    };\n    Range.prototype.empty = function() {\n      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;\n    };\n    function normalizeSelection(cm, ranges, primIndex) {\n      var mayTouch = cm && cm.options.selectionsMayTouch;\n      var prim = ranges[primIndex];\n      ranges.sort(function(a, b) {\n        return cmp(a.from(), b.from());\n      });\n      primIndex = indexOf(ranges, prim);\n      for (var i2 = 1; i2 < ranges.length; i2++) {\n        var cur = ranges[i2], prev = ranges[i2 - 1];\n        var diff = cmp(prev.to(), cur.from());\n        if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {\n          var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\n          var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\n          if (i2 <= primIndex) {\n            --primIndex;\n          }\n          ranges.splice(--i2, 2, new Range(inv ? to : from, inv ? from : to));\n        }\n      }\n      return new Selection(ranges, primIndex);\n    }\n    __name(normalizeSelection, "normalizeSelection");\n    function simpleSelection(anchor, head) {\n      return new Selection([new Range(anchor, head || anchor)], 0);\n    }\n    __name(simpleSelection, "simpleSelection");\n    function changeEnd(change) {\n      if (!change.text) {\n        return change.to;\n      }\n      return Pos(change.from.line + change.text.length - 1, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));\n    }\n    __name(changeEnd, "changeEnd");\n    function adjustForChange(pos, change) {\n      if (cmp(pos, change.from) < 0) {\n        return pos;\n      }\n      if (cmp(pos, change.to) <= 0) {\n        return changeEnd(change);\n      }\n      var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\n      if (pos.line == change.to.line) {\n        ch += changeEnd(change).ch - change.to.ch;\n      }\n      return Pos(line, ch);\n    }\n    __name(adjustForChange, "adjustForChange");\n    function computeSelAfterChange(doc, change) {\n      var out = [];\n      for (var i2 = 0; i2 < doc.sel.ranges.length; i2++) {\n        var range2 = doc.sel.ranges[i2];\n        out.push(new Range(adjustForChange(range2.anchor, change), adjustForChange(range2.head, change)));\n      }\n      return normalizeSelection(doc.cm, out, doc.sel.primIndex);\n    }\n    __name(computeSelAfterChange, "computeSelAfterChange");\n    function offsetPos(pos, old, nw) {\n      if (pos.line == old.line) {\n        return Pos(nw.line, pos.ch - old.ch + nw.ch);\n      } else {\n        return Pos(nw.line + (pos.line - old.line), pos.ch);\n      }\n    }\n    __name(offsetPos, "offsetPos");\n    function computeReplacedSel(doc, changes, hint) {\n      var out = [];\n      var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;\n      for (var i2 = 0; i2 < changes.length; i2++) {\n        var change = changes[i2];\n        var from = offsetPos(change.from, oldPrev, newPrev);\n        var to = offsetPos(changeEnd(change), oldPrev, newPrev);\n        oldPrev = change.to;\n        newPrev = to;\n        if (hint == "around") {\n          var range2 = doc.sel.ranges[i2], inv = cmp(range2.head, range2.anchor) < 0;\n          out[i2] = new Range(inv ? to : from, inv ? from : to);\n        } else {\n          out[i2] = new Range(from, from);\n        }\n      }\n      return new Selection(out, doc.sel.primIndex);\n    }\n    __name(computeReplacedSel, "computeReplacedSel");\n    function loadMode(cm) {\n      cm.doc.mode = getMode(cm.options, cm.doc.modeOption);\n      resetModeState(cm);\n    }\n    __name(loadMode, "loadMode");\n    function resetModeState(cm) {\n      cm.doc.iter(function(line) {\n        if (line.stateAfter) {\n          line.stateAfter = null;\n        }\n        if (line.styles) {\n          line.styles = null;\n        }\n      });\n      cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;\n      startWorker(cm, 100);\n      cm.state.modeGen++;\n      if (cm.curOp) {\n        regChange(cm);\n      }\n    }\n    __name(resetModeState, "resetModeState");\n    function isWholeLineUpdate(doc, change) {\n      return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" && (!doc.cm || doc.cm.options.wholeLineUpdateBefore);\n    }\n    __name(isWholeLineUpdate, "isWholeLineUpdate");\n    function updateDoc(doc, change, markedSpans, estimateHeight2) {\n      function spansFor(n) {\n        return markedSpans ? markedSpans[n] : null;\n      }\n      __name(spansFor, "spansFor");\n      function update(line, text2, spans) {\n        updateLine(line, text2, spans, estimateHeight2);\n        signalLater(line, "change", line, change);\n      }\n      __name(update, "update");\n      function linesFor(start, end) {\n        var result = [];\n        for (var i2 = start; i2 < end; ++i2) {\n          result.push(new Line(text[i2], spansFor(i2), estimateHeight2));\n        }\n        return result;\n      }\n      __name(linesFor, "linesFor");\n      var from = change.from, to = change.to, text = change.text;\n      var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\n      var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\n      if (change.full) {\n        doc.insert(0, linesFor(0, text.length));\n        doc.remove(text.length, doc.size - text.length);\n      } else if (isWholeLineUpdate(doc, change)) {\n        var added = linesFor(0, text.length - 1);\n        update(lastLine, lastLine.text, lastSpans);\n        if (nlines) {\n          doc.remove(from.line, nlines);\n        }\n        if (added.length) {\n          doc.insert(from.line, added);\n        }\n      } else if (firstLine == lastLine) {\n        if (text.length == 1) {\n          update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n        } else {\n          var added$1 = linesFor(1, text.length - 1);\n          added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight2));\n          update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n          doc.insert(from.line + 1, added$1);\n        }\n      } else if (text.length == 1) {\n        update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n        doc.remove(from.line + 1, nlines);\n      } else {\n        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n        update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n        var added$2 = linesFor(1, text.length - 1);\n        if (nlines > 1) {\n          doc.remove(from.line + 1, nlines - 1);\n        }\n        doc.insert(from.line + 1, added$2);\n      }\n      signalLater(doc, "change", doc, change);\n    }\n    __name(updateDoc, "updateDoc");\n    function linkedDocs(doc, f, sharedHistOnly) {\n      function propagate(doc2, skip, sharedHist) {\n        if (doc2.linked) {\n          for (var i2 = 0; i2 < doc2.linked.length; ++i2) {\n            var rel = doc2.linked[i2];\n            if (rel.doc == skip) {\n              continue;\n            }\n            var shared = sharedHist && rel.sharedHist;\n            if (sharedHistOnly && !shared) {\n              continue;\n            }\n            f(rel.doc, shared);\n            propagate(rel.doc, doc2, shared);\n          }\n        }\n      }\n      __name(propagate, "propagate");\n      propagate(doc, null, true);\n    }\n    __name(linkedDocs, "linkedDocs");\n    function attachDoc(cm, doc) {\n      if (doc.cm) {\n        throw new Error("This document is already in use.");\n      }\n      cm.doc = doc;\n      doc.cm = cm;\n      estimateLineHeights(cm);\n      loadMode(cm);\n      setDirectionClass(cm);\n      cm.options.direction = doc.direction;\n      if (!cm.options.lineWrapping) {\n        findMaxLine(cm);\n      }\n      cm.options.mode = doc.modeOption;\n      regChange(cm);\n    }\n    __name(attachDoc, "attachDoc");\n    function setDirectionClass(cm) {\n      (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");\n    }\n    __name(setDirectionClass, "setDirectionClass");\n    function directionChanged(cm) {\n      runInOp(cm, function() {\n        setDirectionClass(cm);\n        regChange(cm);\n      });\n    }\n    __name(directionChanged, "directionChanged");\n    function History(prev) {\n      this.done = [];\n      this.undone = [];\n      this.undoDepth = prev ? prev.undoDepth : Infinity;\n      this.lastModTime = this.lastSelTime = 0;\n      this.lastOp = this.lastSelOp = null;\n      this.lastOrigin = this.lastSelOrigin = null;\n      this.generation = this.maxGeneration = prev ? prev.maxGeneration : 1;\n    }\n    __name(History, "History");\n    function historyChangeFromChange(doc, change) {\n      var histChange = { from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to) };\n      attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n      linkedDocs(doc, function(doc2) {\n        return attachLocalSpans(doc2, histChange, change.from.line, change.to.line + 1);\n      }, true);\n      return histChange;\n    }\n    __name(historyChangeFromChange, "historyChangeFromChange");\n    function clearSelectionEvents(array) {\n      while (array.length) {\n        var last = lst(array);\n        if (last.ranges) {\n          array.pop();\n        } else {\n          break;\n        }\n      }\n    }\n    __name(clearSelectionEvents, "clearSelectionEvents");\n    function lastChangeEvent(hist, force) {\n      if (force) {\n        clearSelectionEvents(hist.done);\n        return lst(hist.done);\n      } else if (hist.done.length && !lst(hist.done).ranges) {\n        return lst(hist.done);\n      } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\n        hist.done.pop();\n        return lst(hist.done);\n      }\n    }\n    __name(lastChangeEvent, "lastChangeEvent");\n    function addChangeToHistory(doc, change, selAfter, opId) {\n      var hist = doc.history;\n      hist.undone.length = 0;\n      var time = +new Date(), cur;\n      var last;\n      if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500) || change.origin.charAt(0) == "*")) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\n        last = lst(cur.changes);\n        if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\n          last.to = changeEnd(change);\n        } else {\n          cur.changes.push(historyChangeFromChange(doc, change));\n        }\n      } else {\n        var before = lst(hist.done);\n        if (!before || !before.ranges) {\n          pushSelectionToHistory(doc.sel, hist.done);\n        }\n        cur = {\n          changes: [historyChangeFromChange(doc, change)],\n          generation: hist.generation\n        };\n        hist.done.push(cur);\n        while (hist.done.length > hist.undoDepth) {\n          hist.done.shift();\n          if (!hist.done[0].ranges) {\n            hist.done.shift();\n          }\n        }\n      }\n      hist.done.push(selAfter);\n      hist.generation = ++hist.maxGeneration;\n      hist.lastModTime = hist.lastSelTime = time;\n      hist.lastOp = hist.lastSelOp = opId;\n      hist.lastOrigin = hist.lastSelOrigin = change.origin;\n      if (!last) {\n        signal(doc, "historyAdded");\n      }\n    }\n    __name(addChangeToHistory, "addChangeToHistory");\n    function selectionEventCanBeMerged(doc, origin, prev, sel) {\n      var ch = origin.charAt(0);\n      return ch == "*" || ch == "+" && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date() - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);\n    }\n    __name(selectionEventCanBeMerged, "selectionEventCanBeMerged");\n    function addSelectionToHistory(doc, sel, opId, options) {\n      var hist = doc.history, origin = options && options.origin;\n      if (opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))) {\n        hist.done[hist.done.length - 1] = sel;\n      } else {\n        pushSelectionToHistory(sel, hist.done);\n      }\n      hist.lastSelTime = +new Date();\n      hist.lastSelOrigin = origin;\n      hist.lastSelOp = opId;\n      if (options && options.clearRedo !== false) {\n        clearSelectionEvents(hist.undone);\n      }\n    }\n    __name(addSelectionToHistory, "addSelectionToHistory");\n    function pushSelectionToHistory(sel, dest) {\n      var top = lst(dest);\n      if (!(top && top.ranges && top.equals(sel))) {\n        dest.push(sel);\n      }\n    }\n    __name(pushSelectionToHistory, "pushSelectionToHistory");\n    function attachLocalSpans(doc, change, from, to) {\n      var existing = change["spans_" + doc.id], n = 0;\n      doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {\n        if (line.markedSpans) {\n          (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;\n        }\n        ++n;\n      });\n    }\n    __name(attachLocalSpans, "attachLocalSpans");\n    function removeClearedSpans(spans) {\n      if (!spans) {\n        return null;\n      }\n      var out;\n      for (var i2 = 0; i2 < spans.length; ++i2) {\n        if (spans[i2].marker.explicitlyCleared) {\n          if (!out) {\n            out = spans.slice(0, i2);\n          }\n        } else if (out) {\n          out.push(spans[i2]);\n        }\n      }\n      return !out ? spans : out.length ? out : null;\n    }\n    __name(removeClearedSpans, "removeClearedSpans");\n    function getOldSpans(doc, change) {\n      var found = change["spans_" + doc.id];\n      if (!found) {\n        return null;\n      }\n      var nw = [];\n      for (var i2 = 0; i2 < change.text.length; ++i2) {\n        nw.push(removeClearedSpans(found[i2]));\n      }\n      return nw;\n    }\n    __name(getOldSpans, "getOldSpans");\n    function mergeOldSpans(doc, change) {\n      var old = getOldSpans(doc, change);\n      var stretched = stretchSpansOverChange(doc, change);\n      if (!old) {\n        return stretched;\n      }\n      if (!stretched) {\n        return old;\n      }\n      for (var i2 = 0; i2 < old.length; ++i2) {\n        var oldCur = old[i2], stretchCur = stretched[i2];\n        if (oldCur && stretchCur) {\n          spans:\n            for (var j = 0; j < stretchCur.length; ++j) {\n              var span = stretchCur[j];\n              for (var k = 0; k < oldCur.length; ++k) {\n                if (oldCur[k].marker == span.marker) {\n                  continue spans;\n                }\n              }\n              oldCur.push(span);\n            }\n        } else if (stretchCur) {\n          old[i2] = stretchCur;\n        }\n      }\n      return old;\n    }\n    __name(mergeOldSpans, "mergeOldSpans");\n    function copyHistoryArray(events, newGroup, instantiateSel) {\n      var copy = [];\n      for (var i2 = 0; i2 < events.length; ++i2) {\n        var event = events[i2];\n        if (event.ranges) {\n          copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\n          continue;\n        }\n        var changes = event.changes, newChanges = [];\n        copy.push({ changes: newChanges });\n        for (var j = 0; j < changes.length; ++j) {\n          var change = changes[j], m = void 0;\n          newChanges.push({ from: change.from, to: change.to, text: change.text });\n          if (newGroup) {\n            for (var prop2 in change) {\n              if (m = prop2.match(/^spans_(\\d+)$/)) {\n                if (indexOf(newGroup, Number(m[1])) > -1) {\n                  lst(newChanges)[prop2] = change[prop2];\n                  delete change[prop2];\n                }\n              }\n            }\n          }\n        }\n      }\n      return copy;\n    }\n    __name(copyHistoryArray, "copyHistoryArray");\n    function extendRange(range2, head, other, extend) {\n      if (extend) {\n        var anchor = range2.anchor;\n        if (other) {\n          var posBefore = cmp(head, anchor) < 0;\n          if (posBefore != cmp(other, anchor) < 0) {\n            anchor = head;\n            head = other;\n          } else if (posBefore != cmp(head, other) < 0) {\n            head = other;\n          }\n        }\n        return new Range(anchor, head);\n      } else {\n        return new Range(other || head, head);\n      }\n    }\n    __name(extendRange, "extendRange");\n    function extendSelection(doc, head, other, options, extend) {\n      if (extend == null) {\n        extend = doc.cm && (doc.cm.display.shift || doc.extend);\n      }\n      setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);\n    }\n    __name(extendSelection, "extendSelection");\n    function extendSelections(doc, heads, options) {\n      var out = [];\n      var extend = doc.cm && (doc.cm.display.shift || doc.extend);\n      for (var i2 = 0; i2 < doc.sel.ranges.length; i2++) {\n        out[i2] = extendRange(doc.sel.ranges[i2], heads[i2], null, extend);\n      }\n      var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);\n      setSelection(doc, newSel, options);\n    }\n    __name(extendSelections, "extendSelections");\n    function replaceOneSelection(doc, i2, range2, options) {\n      var ranges = doc.sel.ranges.slice(0);\n      ranges[i2] = range2;\n      setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);\n    }\n    __name(replaceOneSelection, "replaceOneSelection");\n    function setSimpleSelection(doc, anchor, head, options) {\n      setSelection(doc, simpleSelection(anchor, head), options);\n    }\n    __name(setSimpleSelection, "setSimpleSelection");\n    function filterSelectionChange(doc, sel, options) {\n      var obj = {\n        ranges: sel.ranges,\n        update: function(ranges) {\n          this.ranges = [];\n          for (var i2 = 0; i2 < ranges.length; i2++) {\n            this.ranges[i2] = new Range(clipPos(doc, ranges[i2].anchor), clipPos(doc, ranges[i2].head));\n          }\n        },\n        origin: options && options.origin\n      };\n      signal(doc, "beforeSelectionChange", doc, obj);\n      if (doc.cm) {\n        signal(doc.cm, "beforeSelectionChange", doc.cm, obj);\n      }\n      if (obj.ranges != sel.ranges) {\n        return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1);\n      } else {\n        return sel;\n      }\n    }\n    __name(filterSelectionChange, "filterSelectionChange");\n    function setSelectionReplaceHistory(doc, sel, options) {\n      var done = doc.history.done, last = lst(done);\n      if (last && last.ranges) {\n        done[done.length - 1] = sel;\n        setSelectionNoUndo(doc, sel, options);\n      } else {\n        setSelection(doc, sel, options);\n      }\n    }\n    __name(setSelectionReplaceHistory, "setSelectionReplaceHistory");\n    function setSelection(doc, sel, options) {\n      setSelectionNoUndo(doc, sel, options);\n      addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\n    }\n    __name(setSelection, "setSelection");\n    function setSelectionNoUndo(doc, sel, options) {\n      if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange")) {\n        sel = filterSelectionChange(doc, sel, options);\n      }\n      var bias = options && options.bias || (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\n      setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\n      if (!(options && options.scroll === false) && doc.cm && doc.cm.getOption("readOnly") != "nocursor") {\n        ensureCursorVisible(doc.cm);\n      }\n    }\n    __name(setSelectionNoUndo, "setSelectionNoUndo");\n    function setSelectionInner(doc, sel) {\n      if (sel.equals(doc.sel)) {\n        return;\n      }\n      doc.sel = sel;\n      if (doc.cm) {\n        doc.cm.curOp.updateInput = 1;\n        doc.cm.curOp.selectionChanged = true;\n        signalCursorActivity(doc.cm);\n      }\n      signalLater(doc, "cursorActivity", doc);\n    }\n    __name(setSelectionInner, "setSelectionInner");\n    function reCheckSelection(doc) {\n      setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));\n    }\n    __name(reCheckSelection, "reCheckSelection");\n    function skipAtomicInSelection(doc, sel, bias, mayClear) {\n      var out;\n      for (var i2 = 0; i2 < sel.ranges.length; i2++) {\n        var range2 = sel.ranges[i2];\n        var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i2];\n        var newAnchor = skipAtomic(doc, range2.anchor, old && old.anchor, bias, mayClear);\n        var newHead = skipAtomic(doc, range2.head, old && old.head, bias, mayClear);\n        if (out || newAnchor != range2.anchor || newHead != range2.head) {\n          if (!out) {\n            out = sel.ranges.slice(0, i2);\n          }\n          out[i2] = new Range(newAnchor, newHead);\n        }\n      }\n      return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel;\n    }\n    __name(skipAtomicInSelection, "skipAtomicInSelection");\n    function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {\n      var line = getLine(doc, pos.line);\n      if (line.markedSpans) {\n        for (var i2 = 0; i2 < line.markedSpans.length; ++i2) {\n          var sp = line.markedSpans[i2], m = sp.marker;\n          var preventCursorLeft = "selectLeft" in m ? !m.selectLeft : m.inclusiveLeft;\n          var preventCursorRight = "selectRight" in m ? !m.selectRight : m.inclusiveRight;\n          if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) && (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {\n            if (mayClear) {\n              signal(m, "beforeCursorEnter");\n              if (m.explicitlyCleared) {\n                if (!line.markedSpans) {\n                  break;\n                } else {\n                  --i2;\n                  continue;\n                }\n              }\n            }\n            if (!m.atomic) {\n              continue;\n            }\n            if (oldPos) {\n              var near = m.find(dir < 0 ? 1 : -1), diff = void 0;\n              if (dir < 0 ? preventCursorRight : preventCursorLeft) {\n                near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null);\n              }\n              if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0)) {\n                return skipAtomicInner(doc, near, pos, dir, mayClear);\n              }\n            }\n            var far = m.find(dir < 0 ? -1 : 1);\n            if (dir < 0 ? preventCursorLeft : preventCursorRight) {\n              far = movePos(doc, far, dir, far.line == pos.line ? line : null);\n            }\n            return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;\n          }\n        }\n      }\n      return pos;\n    }\n    __name(skipAtomicInner, "skipAtomicInner");\n    function skipAtomic(doc, pos, oldPos, bias, mayClear) {\n      var dir = bias || 1;\n      var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, dir, true) || skipAtomicInner(doc, pos, oldPos, -dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true);\n      if (!found) {\n        doc.cantEdit = true;\n        return Pos(doc.first, 0);\n      }\n      return found;\n    }\n    __name(skipAtomic, "skipAtomic");\n    function movePos(doc, pos, dir, line) {\n      if (dir < 0 && pos.ch == 0) {\n        if (pos.line > doc.first) {\n          return clipPos(doc, Pos(pos.line - 1));\n        } else {\n          return null;\n        }\n      } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {\n        if (pos.line < doc.first + doc.size - 1) {\n          return Pos(pos.line + 1, 0);\n        } else {\n          return null;\n        }\n      } else {\n        return new Pos(pos.line, pos.ch + dir);\n      }\n    }\n    __name(movePos, "movePos");\n    function selectAll(cm) {\n      cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);\n    }\n    __name(selectAll, "selectAll");\n    function filterChange(doc, change, update) {\n      var obj = {\n        canceled: false,\n        from: change.from,\n        to: change.to,\n        text: change.text,\n        origin: change.origin,\n        cancel: function() {\n          return obj.canceled = true;\n        }\n      };\n      if (update) {\n        obj.update = function(from, to, text, origin) {\n          if (from) {\n            obj.from = clipPos(doc, from);\n          }\n          if (to) {\n            obj.to = clipPos(doc, to);\n          }\n          if (text) {\n            obj.text = text;\n          }\n          if (origin !== void 0) {\n            obj.origin = origin;\n          }\n        };\n      }\n      signal(doc, "beforeChange", doc, obj);\n      if (doc.cm) {\n        signal(doc.cm, "beforeChange", doc.cm, obj);\n      }\n      if (obj.canceled) {\n        if (doc.cm) {\n          doc.cm.curOp.updateInput = 2;\n        }\n        return null;\n      }\n      return { from: obj.from, to: obj.to, text: obj.text, origin: obj.origin };\n    }\n    __name(filterChange, "filterChange");\n    function makeChange(doc, change, ignoreReadOnly) {\n      if (doc.cm) {\n        if (!doc.cm.curOp) {\n          return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);\n        }\n        if (doc.cm.state.suppressEdits) {\n          return;\n        }\n      }\n      if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {\n        change = filterChange(doc, change, true);\n        if (!change) {\n          return;\n        }\n      }\n      var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n      if (split) {\n        for (var i2 = split.length - 1; i2 >= 0; --i2) {\n          makeChangeInner(doc, { from: split[i2].from, to: split[i2].to, text: i2 ? [""] : change.text, origin: change.origin });\n        }\n      } else {\n        makeChangeInner(doc, change);\n      }\n    }\n    __name(makeChange, "makeChange");\n    function makeChangeInner(doc, change) {\n      if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) {\n        return;\n      }\n      var selAfter = computeSelAfterChange(doc, change);\n      addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n      makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n      var rebased = [];\n      linkedDocs(doc, function(doc2, sharedHist) {\n        if (!sharedHist && indexOf(rebased, doc2.history) == -1) {\n          rebaseHist(doc2.history, change);\n          rebased.push(doc2.history);\n        }\n        makeChangeSingleDoc(doc2, change, null, stretchSpansOverChange(doc2, change));\n      });\n    }\n    __name(makeChangeInner, "makeChangeInner");\n    function makeChangeFromHistory(doc, type, allowSelectionOnly) {\n      var suppress = doc.cm && doc.cm.state.suppressEdits;\n      if (suppress && !allowSelectionOnly) {\n        return;\n      }\n      var hist = doc.history, event, selAfter = doc.sel;\n      var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;\n      var i2 = 0;\n      for (; i2 < source.length; i2++) {\n        event = source[i2];\n        if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges) {\n          break;\n        }\n      }\n      if (i2 == source.length) {\n        return;\n      }\n      hist.lastOrigin = hist.lastSelOrigin = null;\n      for (; ; ) {\n        event = source.pop();\n        if (event.ranges) {\n          pushSelectionToHistory(event, dest);\n          if (allowSelectionOnly && !event.equals(doc.sel)) {\n            setSelection(doc, event, { clearRedo: false });\n            return;\n          }\n          selAfter = event;\n        } else if (suppress) {\n          source.push(event);\n          return;\n        } else {\n          break;\n        }\n      }\n      var antiChanges = [];\n      pushSelectionToHistory(selAfter, dest);\n      dest.push({ changes: antiChanges, generation: hist.generation });\n      hist.generation = event.generation || ++hist.maxGeneration;\n      var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");\n      var loop = /* @__PURE__ */ __name(function(i3) {\n        var change = event.changes[i3];\n        change.origin = type;\n        if (filter && !filterChange(doc, change, false)) {\n          source.length = 0;\n          return {};\n        }\n        antiChanges.push(historyChangeFromChange(doc, change));\n        var after = i3 ? computeSelAfterChange(doc, change) : lst(source);\n        makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n        if (!i3 && doc.cm) {\n          doc.cm.scrollIntoView({ from: change.from, to: changeEnd(change) });\n        }\n        var rebased = [];\n        linkedDocs(doc, function(doc2, sharedHist) {\n          if (!sharedHist && indexOf(rebased, doc2.history) == -1) {\n            rebaseHist(doc2.history, change);\n            rebased.push(doc2.history);\n          }\n          makeChangeSingleDoc(doc2, change, null, mergeOldSpans(doc2, change));\n        });\n      }, "loop");\n      for (var i$12 = event.changes.length - 1; i$12 >= 0; --i$12) {\n        var returned = loop(i$12);\n        if (returned)\n          return returned.v;\n      }\n    }\n    __name(makeChangeFromHistory, "makeChangeFromHistory");\n    function shiftDoc(doc, distance) {\n      if (distance == 0) {\n        return;\n      }\n      doc.first += distance;\n      doc.sel = new Selection(map(doc.sel.ranges, function(range2) {\n        return new Range(Pos(range2.anchor.line + distance, range2.anchor.ch), Pos(range2.head.line + distance, range2.head.ch));\n      }), doc.sel.primIndex);\n      if (doc.cm) {\n        regChange(doc.cm, doc.first, doc.first - distance, distance);\n        for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++) {\n          regLineChange(doc.cm, l, "gutter");\n        }\n      }\n    }\n    __name(shiftDoc, "shiftDoc");\n    function makeChangeSingleDoc(doc, change, selAfter, spans) {\n      if (doc.cm && !doc.cm.curOp) {\n        return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);\n      }\n      if (change.to.line < doc.first) {\n        shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n        return;\n      }\n      if (change.from.line > doc.lastLine()) {\n        return;\n      }\n      if (change.from.line < doc.first) {\n        var shift = change.text.length - 1 - (doc.first - change.from.line);\n        shiftDoc(doc, shift);\n        change = {\n          from: Pos(doc.first, 0),\n          to: Pos(change.to.line + shift, change.to.ch),\n          text: [lst(change.text)],\n          origin: change.origin\n        };\n      }\n      var last = doc.lastLine();\n      if (change.to.line > last) {\n        change = {\n          from: change.from,\n          to: Pos(last, getLine(doc, last).text.length),\n          text: [change.text[0]],\n          origin: change.origin\n        };\n      }\n      change.removed = getBetween(doc, change.from, change.to);\n      if (!selAfter) {\n        selAfter = computeSelAfterChange(doc, change);\n      }\n      if (doc.cm) {\n        makeChangeSingleDocInEditor(doc.cm, change, spans);\n      } else {\n        updateDoc(doc, change, spans);\n      }\n      setSelectionNoUndo(doc, selAfter, sel_dontScroll);\n      if (doc.cantEdit && skipAtomic(doc, Pos(doc.firstLine(), 0))) {\n        doc.cantEdit = false;\n      }\n    }\n    __name(makeChangeSingleDoc, "makeChangeSingleDoc");\n    function makeChangeSingleDocInEditor(cm, change, spans) {\n      var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\n      var recomputeMaxLength = false, checkWidthStart = from.line;\n      if (!cm.options.lineWrapping) {\n        checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\n        doc.iter(checkWidthStart, to.line + 1, function(line) {\n          if (line == display.maxLine) {\n            recomputeMaxLength = true;\n            return true;\n          }\n        });\n      }\n      if (doc.sel.contains(change.from, change.to) > -1) {\n        signalCursorActivity(cm);\n      }\n      updateDoc(doc, change, spans, estimateHeight(cm));\n      if (!cm.options.lineWrapping) {\n        doc.iter(checkWidthStart, from.line + change.text.length, function(line) {\n          var len = lineLength(line);\n          if (len > display.maxLineLength) {\n            display.maxLine = line;\n            display.maxLineLength = len;\n            display.maxLineChanged = true;\n            recomputeMaxLength = false;\n          }\n        });\n        if (recomputeMaxLength) {\n          cm.curOp.updateMaxLine = true;\n        }\n      }\n      retreatFrontier(doc, from.line);\n      startWorker(cm, 400);\n      var lendiff = change.text.length - (to.line - from.line) - 1;\n      if (change.full) {\n        regChange(cm);\n      } else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change)) {\n        regLineChange(cm, from.line, "text");\n      } else {\n        regChange(cm, from.line, to.line + 1, lendiff);\n      }\n      var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");\n      if (changeHandler || changesHandler) {\n        var obj = {\n          from,\n          to,\n          text: change.text,\n          removed: change.removed,\n          origin: change.origin\n        };\n        if (changeHandler) {\n          signalLater(cm, "change", cm, obj);\n        }\n        if (changesHandler) {\n          (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);\n        }\n      }\n      cm.display.selForContextMenu = null;\n    }\n    __name(makeChangeSingleDocInEditor, "makeChangeSingleDocInEditor");\n    function replaceRange(doc, code, from, to, origin) {\n      var assign;\n      if (!to) {\n        to = from;\n      }\n      if (cmp(to, from) < 0) {\n        assign = [to, from], from = assign[0], to = assign[1];\n      }\n      if (typeof code == "string") {\n        code = doc.splitLines(code);\n      }\n      makeChange(doc, { from, to, text: code, origin });\n    }\n    __name(replaceRange, "replaceRange");\n    function rebaseHistSelSingle(pos, from, to, diff) {\n      if (to < pos.line) {\n        pos.line += diff;\n      } else if (from < pos.line) {\n        pos.line = from;\n        pos.ch = 0;\n      }\n    }\n    __name(rebaseHistSelSingle, "rebaseHistSelSingle");\n    function rebaseHistArray(array, from, to, diff) {\n      for (var i2 = 0; i2 < array.length; ++i2) {\n        var sub = array[i2], ok = true;\n        if (sub.ranges) {\n          if (!sub.copied) {\n            sub = array[i2] = sub.deepCopy();\n            sub.copied = true;\n          }\n          for (var j = 0; j < sub.ranges.length; j++) {\n            rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\n            rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\n          }\n          continue;\n        }\n        for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {\n          var cur = sub.changes[j$1];\n          if (to < cur.from.line) {\n            cur.from = Pos(cur.from.line + diff, cur.from.ch);\n            cur.to = Pos(cur.to.line + diff, cur.to.ch);\n          } else if (from <= cur.to.line) {\n            ok = false;\n            break;\n          }\n        }\n        if (!ok) {\n          array.splice(0, i2 + 1);\n          i2 = 0;\n        }\n      }\n    }\n    __name(rebaseHistArray, "rebaseHistArray");\n    function rebaseHist(hist, change) {\n      var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\n      rebaseHistArray(hist.done, from, to, diff);\n      rebaseHistArray(hist.undone, from, to, diff);\n    }\n    __name(rebaseHist, "rebaseHist");\n    function changeLine(doc, handle, changeType, op) {\n      var no = handle, line = handle;\n      if (typeof handle == "number") {\n        line = getLine(doc, clipLine(doc, handle));\n      } else {\n        no = lineNo(handle);\n      }\n      if (no == null) {\n        return null;\n      }\n      if (op(line, no) && doc.cm) {\n        regLineChange(doc.cm, no, changeType);\n      }\n      return line;\n    }\n    __name(changeLine, "changeLine");\n    function LeafChunk(lines) {\n      this.lines = lines;\n      this.parent = null;\n      var height = 0;\n      for (var i2 = 0; i2 < lines.length; ++i2) {\n        lines[i2].parent = this;\n        height += lines[i2].height;\n      }\n      this.height = height;\n    }\n    __name(LeafChunk, "LeafChunk");\n    LeafChunk.prototype = {\n      chunkSize: function() {\n        return this.lines.length;\n      },\n      removeInner: function(at, n) {\n        for (var i2 = at, e = at + n; i2 < e; ++i2) {\n          var line = this.lines[i2];\n          this.height -= line.height;\n          cleanUpLine(line);\n          signalLater(line, "delete");\n        }\n        this.lines.splice(at, n);\n      },\n      collapse: function(lines) {\n        lines.push.apply(lines, this.lines);\n      },\n      insertInner: function(at, lines, height) {\n        this.height += height;\n        this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n        for (var i2 = 0; i2 < lines.length; ++i2) {\n          lines[i2].parent = this;\n        }\n      },\n      iterN: function(at, n, op) {\n        for (var e = at + n; at < e; ++at) {\n          if (op(this.lines[at])) {\n            return true;\n          }\n        }\n      }\n    };\n    function BranchChunk(children) {\n      this.children = children;\n      var size = 0, height = 0;\n      for (var i2 = 0; i2 < children.length; ++i2) {\n        var ch = children[i2];\n        size += ch.chunkSize();\n        height += ch.height;\n        ch.parent = this;\n      }\n      this.size = size;\n      this.height = height;\n      this.parent = null;\n    }\n    __name(BranchChunk, "BranchChunk");\n    BranchChunk.prototype = {\n      chunkSize: function() {\n        return this.size;\n      },\n      removeInner: function(at, n) {\n        this.size -= n;\n        for (var i2 = 0; i2 < this.children.length; ++i2) {\n          var child = this.children[i2], sz = child.chunkSize();\n          if (at < sz) {\n            var rm = Math.min(n, sz - at), oldHeight = child.height;\n            child.removeInner(at, rm);\n            this.height -= oldHeight - child.height;\n            if (sz == rm) {\n              this.children.splice(i2--, 1);\n              child.parent = null;\n            }\n            if ((n -= rm) == 0) {\n              break;\n            }\n            at = 0;\n          } else {\n            at -= sz;\n          }\n        }\n        if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\n          var lines = [];\n          this.collapse(lines);\n          this.children = [new LeafChunk(lines)];\n          this.children[0].parent = this;\n        }\n      },\n      collapse: function(lines) {\n        for (var i2 = 0; i2 < this.children.length; ++i2) {\n          this.children[i2].collapse(lines);\n        }\n      },\n      insertInner: function(at, lines, height) {\n        this.size += lines.length;\n        this.height += height;\n        for (var i2 = 0; i2 < this.children.length; ++i2) {\n          var child = this.children[i2], sz = child.chunkSize();\n          if (at <= sz) {\n            child.insertInner(at, lines, height);\n            if (child.lines && child.lines.length > 50) {\n              var remaining = child.lines.length % 25 + 25;\n              for (var pos = remaining; pos < child.lines.length; ) {\n                var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));\n                child.height -= leaf.height;\n                this.children.splice(++i2, 0, leaf);\n                leaf.parent = this;\n              }\n              child.lines = child.lines.slice(0, remaining);\n              this.maybeSpill();\n            }\n            break;\n          }\n          at -= sz;\n        }\n      },\n      maybeSpill: function() {\n        if (this.children.length <= 10) {\n          return;\n        }\n        var me = this;\n        do {\n          var spilled = me.children.splice(me.children.length - 5, 5);\n          var sibling = new BranchChunk(spilled);\n          if (!me.parent) {\n            var copy = new BranchChunk(me.children);\n            copy.parent = me;\n            me.children = [copy, sibling];\n            me = copy;\n          } else {\n            me.size -= sibling.size;\n            me.height -= sibling.height;\n            var myIndex = indexOf(me.parent.children, me);\n            me.parent.children.splice(myIndex + 1, 0, sibling);\n          }\n          sibling.parent = me.parent;\n        } while (me.children.length > 10);\n        me.parent.maybeSpill();\n      },\n      iterN: function(at, n, op) {\n        for (var i2 = 0; i2 < this.children.length; ++i2) {\n          var child = this.children[i2], sz = child.chunkSize();\n          if (at < sz) {\n            var used = Math.min(n, sz - at);\n            if (child.iterN(at, used, op)) {\n              return true;\n            }\n            if ((n -= used) == 0) {\n              break;\n            }\n            at = 0;\n          } else {\n            at -= sz;\n          }\n        }\n      }\n    };\n    var LineWidget = /* @__PURE__ */ __name(function(doc, node, options) {\n      if (options) {\n        for (var opt in options) {\n          if (options.hasOwnProperty(opt)) {\n            this[opt] = options[opt];\n          }\n        }\n      }\n      this.doc = doc;\n      this.node = node;\n    }, "LineWidget");\n    LineWidget.prototype.clear = function() {\n      var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);\n      if (no == null || !ws) {\n        return;\n      }\n      for (var i2 = 0; i2 < ws.length; ++i2) {\n        if (ws[i2] == this) {\n          ws.splice(i2--, 1);\n        }\n      }\n      if (!ws.length) {\n        line.widgets = null;\n      }\n      var height = widgetHeight(this);\n      updateLineHeight(line, Math.max(0, line.height - height));\n      if (cm) {\n        runInOp(cm, function() {\n          adjustScrollWhenAboveVisible(cm, line, -height);\n          regLineChange(cm, no, "widget");\n        });\n        signalLater(cm, "lineWidgetCleared", cm, this, no);\n      }\n    };\n    LineWidget.prototype.changed = function() {\n      var this$1$1 = this;\n      var oldH = this.height, cm = this.doc.cm, line = this.line;\n      this.height = null;\n      var diff = widgetHeight(this) - oldH;\n      if (!diff) {\n        return;\n      }\n      if (!lineIsHidden(this.doc, line)) {\n        updateLineHeight(line, line.height + diff);\n      }\n      if (cm) {\n        runInOp(cm, function() {\n          cm.curOp.forceUpdate = true;\n          adjustScrollWhenAboveVisible(cm, line, diff);\n          signalLater(cm, "lineWidgetChanged", cm, this$1$1, lineNo(line));\n        });\n      }\n    };\n    eventMixin(LineWidget);\n    function adjustScrollWhenAboveVisible(cm, line, diff) {\n      if (heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop)) {\n        addToScrollTop(cm, diff);\n      }\n    }\n    __name(adjustScrollWhenAboveVisible, "adjustScrollWhenAboveVisible");\n    function addLineWidget(doc, handle, node, options) {\n      var widget = new LineWidget(doc, node, options);\n      var cm = doc.cm;\n      if (cm && widget.noHScroll) {\n        cm.display.alignWidgets = true;\n      }\n      changeLine(doc, handle, "widget", function(line) {\n        var widgets = line.widgets || (line.widgets = []);\n        if (widget.insertAt == null) {\n          widgets.push(widget);\n        } else {\n          widgets.splice(Math.min(widgets.length, Math.max(0, widget.insertAt)), 0, widget);\n        }\n        widget.line = line;\n        if (cm && !lineIsHidden(doc, line)) {\n          var aboveVisible = heightAtLine(line) < doc.scrollTop;\n          updateLineHeight(line, line.height + widgetHeight(widget));\n          if (aboveVisible) {\n            addToScrollTop(cm, widget.height);\n          }\n          cm.curOp.forceUpdate = true;\n        }\n        return true;\n      });\n      if (cm) {\n        signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle));\n      }\n      return widget;\n    }\n    __name(addLineWidget, "addLineWidget");\n    var nextMarkerId = 0;\n    var TextMarker = /* @__PURE__ */ __name(function(doc, type) {\n      this.lines = [];\n      this.type = type;\n      this.doc = doc;\n      this.id = ++nextMarkerId;\n    }, "TextMarker");\n    TextMarker.prototype.clear = function() {\n      if (this.explicitlyCleared) {\n        return;\n      }\n      var cm = this.doc.cm, withOp = cm && !cm.curOp;\n      if (withOp) {\n        startOperation(cm);\n      }\n      if (hasHandler(this, "clear")) {\n        var found = this.find();\n        if (found) {\n          signalLater(this, "clear", found.from, found.to);\n        }\n      }\n      var min = null, max = null;\n      for (var i2 = 0; i2 < this.lines.length; ++i2) {\n        var line = this.lines[i2];\n        var span = getMarkedSpanFor(line.markedSpans, this);\n        if (cm && !this.collapsed) {\n          regLineChange(cm, lineNo(line), "text");\n        } else if (cm) {\n          if (span.to != null) {\n            max = lineNo(line);\n          }\n          if (span.from != null) {\n            min = lineNo(line);\n          }\n        }\n        line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n        if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm) {\n          updateLineHeight(line, textHeight(cm.display));\n        }\n      }\n      if (cm && this.collapsed && !cm.options.lineWrapping) {\n        for (var i$12 = 0; i$12 < this.lines.length; ++i$12) {\n          var visual = visualLine(this.lines[i$12]), len = lineLength(visual);\n          if (len > cm.display.maxLineLength) {\n            cm.display.maxLine = visual;\n            cm.display.maxLineLength = len;\n            cm.display.maxLineChanged = true;\n          }\n        }\n      }\n      if (min != null && cm && this.collapsed) {\n        regChange(cm, min, max + 1);\n      }\n      this.lines.length = 0;\n      this.explicitlyCleared = true;\n      if (this.atomic && this.doc.cantEdit) {\n        this.doc.cantEdit = false;\n        if (cm) {\n          reCheckSelection(cm.doc);\n        }\n      }\n      if (cm) {\n        signalLater(cm, "markerCleared", cm, this, min, max);\n      }\n      if (withOp) {\n        endOperation(cm);\n      }\n      if (this.parent) {\n        this.parent.clear();\n      }\n    };\n    TextMarker.prototype.find = function(side, lineObj) {\n      if (side == null && this.type == "bookmark") {\n        side = 1;\n      }\n      var from, to;\n      for (var i2 = 0; i2 < this.lines.length; ++i2) {\n        var line = this.lines[i2];\n        var span = getMarkedSpanFor(line.markedSpans, this);\n        if (span.from != null) {\n          from = Pos(lineObj ? line : lineNo(line), span.from);\n          if (side == -1) {\n            return from;\n          }\n        }\n        if (span.to != null) {\n          to = Pos(lineObj ? line : lineNo(line), span.to);\n          if (side == 1) {\n            return to;\n          }\n        }\n      }\n      return from && { from, to };\n    };\n    TextMarker.prototype.changed = function() {\n      var this$1$1 = this;\n      var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\n      if (!pos || !cm) {\n        return;\n      }\n      runInOp(cm, function() {\n        var line = pos.line, lineN = lineNo(pos.line);\n        var view = findViewForLine(cm, lineN);\n        if (view) {\n          clearLineMeasurementCacheFor(view);\n          cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\n        }\n        cm.curOp.updateMaxLine = true;\n        if (!lineIsHidden(widget.doc, line) && widget.height != null) {\n          var oldHeight = widget.height;\n          widget.height = null;\n          var dHeight = widgetHeight(widget) - oldHeight;\n          if (dHeight) {\n            updateLineHeight(line, line.height + dHeight);\n          }\n        }\n        signalLater(cm, "markerChanged", cm, this$1$1);\n      });\n    };\n    TextMarker.prototype.attachLine = function(line) {\n      if (!this.lines.length && this.doc.cm) {\n        var op = this.doc.cm.curOp;\n        if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1) {\n          (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);\n        }\n      }\n      this.lines.push(line);\n    };\n    TextMarker.prototype.detachLine = function(line) {\n      this.lines.splice(indexOf(this.lines, line), 1);\n      if (!this.lines.length && this.doc.cm) {\n        var op = this.doc.cm.curOp;\n        (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n      }\n    };\n    eventMixin(TextMarker);\n    function markText(doc, from, to, options, type) {\n      if (options && options.shared) {\n        return markTextShared(doc, from, to, options, type);\n      }\n      if (doc.cm && !doc.cm.curOp) {\n        return operation(doc.cm, markText)(doc, from, to, options, type);\n      }\n      var marker = new TextMarker(doc, type), diff = cmp(from, to);\n      if (options) {\n        copyObj(options, marker, false);\n      }\n      if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false) {\n        return marker;\n      }\n      if (marker.replacedWith) {\n        marker.collapsed = true;\n        marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");\n        if (!options.handleMouseEvents) {\n          marker.widgetNode.setAttribute("cm-ignore-events", "true");\n        }\n        if (options.insertLeft) {\n          marker.widgetNode.insertLeft = true;\n        }\n      }\n      if (marker.collapsed) {\n        if (conflictingCollapsedRange(doc, from.line, from, to, marker) || from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker)) {\n          throw new Error("Inserting collapsed marker partially overlapping an existing one");\n        }\n        seeCollapsedSpans();\n      }\n      if (marker.addToHistory) {\n        addChangeToHistory(doc, { from, to, origin: "markText" }, doc.sel, NaN);\n      }\n      var curLine = from.line, cm = doc.cm, updateMaxLine;\n      doc.iter(curLine, to.line + 1, function(line) {\n        if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine) {\n          updateMaxLine = true;\n        }\n        if (marker.collapsed && curLine != from.line) {\n          updateLineHeight(line, 0);\n        }\n        addMarkedSpan(line, new MarkedSpan(marker, curLine == from.line ? from.ch : null, curLine == to.line ? to.ch : null), doc.cm && doc.cm.curOp);\n        ++curLine;\n      });\n      if (marker.collapsed) {\n        doc.iter(from.line, to.line + 1, function(line) {\n          if (lineIsHidden(doc, line)) {\n            updateLineHeight(line, 0);\n          }\n        });\n      }\n      if (marker.clearOnEnter) {\n        on(marker, "beforeCursorEnter", function() {\n          return marker.clear();\n        });\n      }\n      if (marker.readOnly) {\n        seeReadOnlySpans();\n        if (doc.history.done.length || doc.history.undone.length) {\n          doc.clearHistory();\n        }\n      }\n      if (marker.collapsed) {\n        marker.id = ++nextMarkerId;\n        marker.atomic = true;\n      }\n      if (cm) {\n        if (updateMaxLine) {\n          cm.curOp.updateMaxLine = true;\n        }\n        if (marker.collapsed) {\n          regChange(cm, from.line, to.line + 1);\n        } else if (marker.className || marker.startStyle || marker.endStyle || marker.css || marker.attributes || marker.title) {\n          for (var i2 = from.line; i2 <= to.line; i2++) {\n            regLineChange(cm, i2, "text");\n          }\n        }\n        if (marker.atomic) {\n          reCheckSelection(cm.doc);\n        }\n        signalLater(cm, "markerAdded", cm, marker);\n      }\n      return marker;\n    }\n    __name(markText, "markText");\n    var SharedTextMarker = /* @__PURE__ */ __name(function(markers, primary) {\n      this.markers = markers;\n      this.primary = primary;\n      for (var i2 = 0; i2 < markers.length; ++i2) {\n        markers[i2].parent = this;\n      }\n    }, "SharedTextMarker");\n    SharedTextMarker.prototype.clear = function() {\n      if (this.explicitlyCleared) {\n        return;\n      }\n      this.explicitlyCleared = true;\n      for (var i2 = 0; i2 < this.markers.length; ++i2) {\n        this.markers[i2].clear();\n      }\n      signalLater(this, "clear");\n    };\n    SharedTextMarker.prototype.find = function(side, lineObj) {\n      return this.primary.find(side, lineObj);\n    };\n    eventMixin(SharedTextMarker);\n    function markTextShared(doc, from, to, options, type) {\n      options = copyObj(options);\n      options.shared = false;\n      var markers = [markText(doc, from, to, options, type)], primary = markers[0];\n      var widget = options.widgetNode;\n      linkedDocs(doc, function(doc2) {\n        if (widget) {\n          options.widgetNode = widget.cloneNode(true);\n        }\n        markers.push(markText(doc2, clipPos(doc2, from), clipPos(doc2, to), options, type));\n        for (var i2 = 0; i2 < doc2.linked.length; ++i2) {\n          if (doc2.linked[i2].isParent) {\n            return;\n          }\n        }\n        primary = lst(markers);\n      });\n      return new SharedTextMarker(markers, primary);\n    }\n    __name(markTextShared, "markTextShared");\n    function findSharedMarkers(doc) {\n      return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function(m) {\n        return m.parent;\n      });\n    }\n    __name(findSharedMarkers, "findSharedMarkers");\n    function copySharedMarkers(doc, markers) {\n      for (var i2 = 0; i2 < markers.length; i2++) {\n        var marker = markers[i2], pos = marker.find();\n        var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\n        if (cmp(mFrom, mTo)) {\n          var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\n          marker.markers.push(subMark);\n          subMark.parent = marker;\n        }\n      }\n    }\n    __name(copySharedMarkers, "copySharedMarkers");\n    function detachSharedMarkers(markers) {\n      var loop = /* @__PURE__ */ __name(function(i3) {\n        var marker = markers[i3], linked = [marker.primary.doc];\n        linkedDocs(marker.primary.doc, function(d) {\n          return linked.push(d);\n        });\n        for (var j = 0; j < marker.markers.length; j++) {\n          var subMarker = marker.markers[j];\n          if (indexOf(linked, subMarker.doc) == -1) {\n            subMarker.parent = null;\n            marker.markers.splice(j--, 1);\n          }\n        }\n      }, "loop");\n      for (var i2 = 0; i2 < markers.length; i2++)\n        loop(i2);\n    }\n    __name(detachSharedMarkers, "detachSharedMarkers");\n    var nextDocId = 0;\n    var Doc = /* @__PURE__ */ __name(function(text, mode, firstLine, lineSep, direction) {\n      if (!(this instanceof Doc)) {\n        return new Doc(text, mode, firstLine, lineSep, direction);\n      }\n      if (firstLine == null) {\n        firstLine = 0;\n      }\n      BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);\n      this.first = firstLine;\n      this.scrollTop = this.scrollLeft = 0;\n      this.cantEdit = false;\n      this.cleanGeneration = 1;\n      this.modeFrontier = this.highlightFrontier = firstLine;\n      var start = Pos(firstLine, 0);\n      this.sel = simpleSelection(start);\n      this.history = new History(null);\n      this.id = ++nextDocId;\n      this.modeOption = mode;\n      this.lineSep = lineSep;\n      this.direction = direction == "rtl" ? "rtl" : "ltr";\n      this.extend = false;\n      if (typeof text == "string") {\n        text = this.splitLines(text);\n      }\n      updateDoc(this, { from: start, to: start, text });\n      setSelection(this, simpleSelection(start), sel_dontScroll);\n    }, "Doc");\n    Doc.prototype = createObj(BranchChunk.prototype, {\n      constructor: Doc,\n      iter: function(from, to, op) {\n        if (op) {\n          this.iterN(from - this.first, to - from, op);\n        } else {\n          this.iterN(this.first, this.first + this.size, from);\n        }\n      },\n      insert: function(at, lines) {\n        var height = 0;\n        for (var i2 = 0; i2 < lines.length; ++i2) {\n          height += lines[i2].height;\n        }\n        this.insertInner(at - this.first, lines, height);\n      },\n      remove: function(at, n) {\n        this.removeInner(at - this.first, n);\n      },\n      getValue: function(lineSep) {\n        var lines = getLines(this, this.first, this.first + this.size);\n        if (lineSep === false) {\n          return lines;\n        }\n        return lines.join(lineSep || this.lineSeparator());\n      },\n      setValue: docMethodOp(function(code) {\n        var top = Pos(this.first, 0), last = this.first + this.size - 1;\n        makeChange(this, {\n          from: top,\n          to: Pos(last, getLine(this, last).text.length),\n          text: this.splitLines(code),\n          origin: "setValue",\n          full: true\n        }, true);\n        if (this.cm) {\n          scrollToCoords(this.cm, 0, 0);\n        }\n        setSelection(this, simpleSelection(top), sel_dontScroll);\n      }),\n      replaceRange: function(code, from, to, origin) {\n        from = clipPos(this, from);\n        to = to ? clipPos(this, to) : from;\n        replaceRange(this, code, from, to, origin);\n      },\n      getRange: function(from, to, lineSep) {\n        var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\n        if (lineSep === false) {\n          return lines;\n        }\n        if (lineSep === "") {\n          return lines.join("");\n        }\n        return lines.join(lineSep || this.lineSeparator());\n      },\n      getLine: function(line) {\n        var l = this.getLineHandle(line);\n        return l && l.text;\n      },\n      getLineHandle: function(line) {\n        if (isLine(this, line)) {\n          return getLine(this, line);\n        }\n      },\n      getLineNumber: function(line) {\n        return lineNo(line);\n      },\n      getLineHandleVisualStart: function(line) {\n        if (typeof line == "number") {\n          line = getLine(this, line);\n        }\n        return visualLine(line);\n      },\n      lineCount: function() {\n        return this.size;\n      },\n      firstLine: function() {\n        return this.first;\n      },\n      lastLine: function() {\n        return this.first + this.size - 1;\n      },\n      clipPos: function(pos) {\n        return clipPos(this, pos);\n      },\n      getCursor: function(start) {\n        var range2 = this.sel.primary(), pos;\n        if (start == null || start == "head") {\n          pos = range2.head;\n        } else if (start == "anchor") {\n          pos = range2.anchor;\n        } else if (start == "end" || start == "to" || start === false) {\n          pos = range2.to();\n        } else {\n          pos = range2.from();\n        }\n        return pos;\n      },\n      listSelections: function() {\n        return this.sel.ranges;\n      },\n      somethingSelected: function() {\n        return this.sel.somethingSelected();\n      },\n      setCursor: docMethodOp(function(line, ch, options) {\n        setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);\n      }),\n      setSelection: docMethodOp(function(anchor, head, options) {\n        setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);\n      }),\n      extendSelection: docMethodOp(function(head, other, options) {\n        extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);\n      }),\n      extendSelections: docMethodOp(function(heads, options) {\n        extendSelections(this, clipPosArray(this, heads), options);\n      }),\n      extendSelectionsBy: docMethodOp(function(f, options) {\n        var heads = map(this.sel.ranges, f);\n        extendSelections(this, clipPosArray(this, heads), options);\n      }),\n      setSelections: docMethodOp(function(ranges, primary, options) {\n        if (!ranges.length) {\n          return;\n        }\n        var out = [];\n        for (var i2 = 0; i2 < ranges.length; i2++) {\n          out[i2] = new Range(clipPos(this, ranges[i2].anchor), clipPos(this, ranges[i2].head || ranges[i2].anchor));\n        }\n        if (primary == null) {\n          primary = Math.min(ranges.length - 1, this.sel.primIndex);\n        }\n        setSelection(this, normalizeSelection(this.cm, out, primary), options);\n      }),\n      addSelection: docMethodOp(function(anchor, head, options) {\n        var ranges = this.sel.ranges.slice(0);\n        ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));\n        setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);\n      }),\n      getSelection: function(lineSep) {\n        var ranges = this.sel.ranges, lines;\n        for (var i2 = 0; i2 < ranges.length; i2++) {\n          var sel = getBetween(this, ranges[i2].from(), ranges[i2].to());\n          lines = lines ? lines.concat(sel) : sel;\n        }\n        if (lineSep === false) {\n          return lines;\n        } else {\n          return lines.join(lineSep || this.lineSeparator());\n        }\n      },\n      getSelections: function(lineSep) {\n        var parts = [], ranges = this.sel.ranges;\n        for (var i2 = 0; i2 < ranges.length; i2++) {\n          var sel = getBetween(this, ranges[i2].from(), ranges[i2].to());\n          if (lineSep !== false) {\n            sel = sel.join(lineSep || this.lineSeparator());\n          }\n          parts[i2] = sel;\n        }\n        return parts;\n      },\n      replaceSelection: function(code, collapse, origin) {\n        var dup = [];\n        for (var i2 = 0; i2 < this.sel.ranges.length; i2++) {\n          dup[i2] = code;\n        }\n        this.replaceSelections(dup, collapse, origin || "+input");\n      },\n      replaceSelections: docMethodOp(function(code, collapse, origin) {\n        var changes = [], sel = this.sel;\n        for (var i2 = 0; i2 < sel.ranges.length; i2++) {\n          var range2 = sel.ranges[i2];\n          changes[i2] = { from: range2.from(), to: range2.to(), text: this.splitLines(code[i2]), origin };\n        }\n        var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);\n        for (var i$12 = changes.length - 1; i$12 >= 0; i$12--) {\n          makeChange(this, changes[i$12]);\n        }\n        if (newSel) {\n          setSelectionReplaceHistory(this, newSel);\n        } else if (this.cm) {\n          ensureCursorVisible(this.cm);\n        }\n      }),\n      undo: docMethodOp(function() {\n        makeChangeFromHistory(this, "undo");\n      }),\n      redo: docMethodOp(function() {\n        makeChangeFromHistory(this, "redo");\n      }),\n      undoSelection: docMethodOp(function() {\n        makeChangeFromHistory(this, "undo", true);\n      }),\n      redoSelection: docMethodOp(function() {\n        makeChangeFromHistory(this, "redo", true);\n      }),\n      setExtending: function(val) {\n        this.extend = val;\n      },\n      getExtending: function() {\n        return this.extend;\n      },\n      historySize: function() {\n        var hist = this.history, done = 0, undone = 0;\n        for (var i2 = 0; i2 < hist.done.length; i2++) {\n          if (!hist.done[i2].ranges) {\n            ++done;\n          }\n        }\n        for (var i$12 = 0; i$12 < hist.undone.length; i$12++) {\n          if (!hist.undone[i$12].ranges) {\n            ++undone;\n          }\n        }\n        return { undo: done, redo: undone };\n      },\n      clearHistory: function() {\n        var this$1$1 = this;\n        this.history = new History(this.history);\n        linkedDocs(this, function(doc) {\n          return doc.history = this$1$1.history;\n        }, true);\n      },\n      markClean: function() {\n        this.cleanGeneration = this.changeGeneration(true);\n      },\n      changeGeneration: function(forceSplit) {\n        if (forceSplit) {\n          this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;\n        }\n        return this.history.generation;\n      },\n      isClean: function(gen) {\n        return this.history.generation == (gen || this.cleanGeneration);\n      },\n      getHistory: function() {\n        return {\n          done: copyHistoryArray(this.history.done),\n          undone: copyHistoryArray(this.history.undone)\n        };\n      },\n      setHistory: function(histData) {\n        var hist = this.history = new History(this.history);\n        hist.done = copyHistoryArray(histData.done.slice(0), null, true);\n        hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\n      },\n      setGutterMarker: docMethodOp(function(line, gutterID, value) {\n        return changeLine(this, line, "gutter", function(line2) {\n          var markers = line2.gutterMarkers || (line2.gutterMarkers = {});\n          markers[gutterID] = value;\n          if (!value && isEmpty(markers)) {\n            line2.gutterMarkers = null;\n          }\n          return true;\n        });\n      }),\n      clearGutter: docMethodOp(function(gutterID) {\n        var this$1$1 = this;\n        this.iter(function(line) {\n          if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n            changeLine(this$1$1, line, "gutter", function() {\n              line.gutterMarkers[gutterID] = null;\n              if (isEmpty(line.gutterMarkers)) {\n                line.gutterMarkers = null;\n              }\n              return true;\n            });\n          }\n        });\n      }),\n      lineInfo: function(line) {\n        var n;\n        if (typeof line == "number") {\n          if (!isLine(this, line)) {\n            return null;\n          }\n          n = line;\n          line = getLine(this, line);\n          if (!line) {\n            return null;\n          }\n        } else {\n          n = lineNo(line);\n          if (n == null) {\n            return null;\n          }\n        }\n        return {\n          line: n,\n          handle: line,\n          text: line.text,\n          gutterMarkers: line.gutterMarkers,\n          textClass: line.textClass,\n          bgClass: line.bgClass,\n          wrapClass: line.wrapClass,\n          widgets: line.widgets\n        };\n      },\n      addLineClass: docMethodOp(function(handle, where, cls) {\n        return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {\n          var prop2 = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";\n          if (!line[prop2]) {\n            line[prop2] = cls;\n          } else if (classTest(cls).test(line[prop2])) {\n            return false;\n          } else {\n            line[prop2] += " " + cls;\n          }\n          return true;\n        });\n      }),\n      removeLineClass: docMethodOp(function(handle, where, cls) {\n        return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {\n          var prop2 = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";\n          var cur = line[prop2];\n          if (!cur) {\n            return false;\n          } else if (cls == null) {\n            line[prop2] = null;\n          } else {\n            var found = cur.match(classTest(cls));\n            if (!found) {\n              return false;\n            }\n            var end = found.index + found[0].length;\n            line[prop2] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;\n          }\n          return true;\n        });\n      }),\n      addLineWidget: docMethodOp(function(handle, node, options) {\n        return addLineWidget(this, handle, node, options);\n      }),\n      removeLineWidget: function(widget) {\n        widget.clear();\n      },\n      markText: function(from, to, options) {\n        return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range");\n      },\n      setBookmark: function(pos, options) {\n        var realOpts = {\n          replacedWith: options && (options.nodeType == null ? options.widget : options),\n          insertLeft: options && options.insertLeft,\n          clearWhenEmpty: false,\n          shared: options && options.shared,\n          handleMouseEvents: options && options.handleMouseEvents\n        };\n        pos = clipPos(this, pos);\n        return markText(this, pos, pos, realOpts, "bookmark");\n      },\n      findMarksAt: function(pos) {\n        pos = clipPos(this, pos);\n        var markers = [], spans = getLine(this, pos.line).markedSpans;\n        if (spans) {\n          for (var i2 = 0; i2 < spans.length; ++i2) {\n            var span = spans[i2];\n            if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch)) {\n              markers.push(span.marker.parent || span.marker);\n            }\n          }\n        }\n        return markers;\n      },\n      findMarks: function(from, to, filter) {\n        from = clipPos(this, from);\n        to = clipPos(this, to);\n        var found = [], lineNo2 = from.line;\n        this.iter(from.line, to.line + 1, function(line) {\n          var spans = line.markedSpans;\n          if (spans) {\n            for (var i2 = 0; i2 < spans.length; i2++) {\n              var span = spans[i2];\n              if (!(span.to != null && lineNo2 == from.line && from.ch >= span.to || span.from == null && lineNo2 != from.line || span.from != null && lineNo2 == to.line && span.from >= to.ch) && (!filter || filter(span.marker))) {\n                found.push(span.marker.parent || span.marker);\n              }\n            }\n          }\n          ++lineNo2;\n        });\n        return found;\n      },\n      getAllMarks: function() {\n        var markers = [];\n        this.iter(function(line) {\n          var sps = line.markedSpans;\n          if (sps) {\n            for (var i2 = 0; i2 < sps.length; ++i2) {\n              if (sps[i2].from != null) {\n                markers.push(sps[i2].marker);\n              }\n            }\n          }\n        });\n        return markers;\n      },\n      posFromIndex: function(off2) {\n        var ch, lineNo2 = this.first, sepSize = this.lineSeparator().length;\n        this.iter(function(line) {\n          var sz = line.text.length + sepSize;\n          if (sz > off2) {\n            ch = off2;\n            return true;\n          }\n          off2 -= sz;\n          ++lineNo2;\n        });\n        return clipPos(this, Pos(lineNo2, ch));\n      },\n      indexFromPos: function(coords) {\n        coords = clipPos(this, coords);\n        var index = coords.ch;\n        if (coords.line < this.first || coords.ch < 0) {\n          return 0;\n        }\n        var sepSize = this.lineSeparator().length;\n        this.iter(this.first, coords.line, function(line) {\n          index += line.text.length + sepSize;\n        });\n        return index;\n      },\n      copy: function(copyHistory) {\n        var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);\n        doc.scrollTop = this.scrollTop;\n        doc.scrollLeft = this.scrollLeft;\n        doc.sel = this.sel;\n        doc.extend = false;\n        if (copyHistory) {\n          doc.history.undoDepth = this.history.undoDepth;\n          doc.setHistory(this.getHistory());\n        }\n        return doc;\n      },\n      linkedDoc: function(options) {\n        if (!options) {\n          options = {};\n        }\n        var from = this.first, to = this.first + this.size;\n        if (options.from != null && options.from > from) {\n          from = options.from;\n        }\n        if (options.to != null && options.to < to) {\n          to = options.to;\n        }\n        var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);\n        if (options.sharedHist) {\n          copy.history = this.history;\n        }\n        (this.linked || (this.linked = [])).push({ doc: copy, sharedHist: options.sharedHist });\n        copy.linked = [{ doc: this, isParent: true, sharedHist: options.sharedHist }];\n        copySharedMarkers(copy, findSharedMarkers(this));\n        return copy;\n      },\n      unlinkDoc: function(other) {\n        if (other instanceof CodeMirror2) {\n          other = other.doc;\n        }\n        if (this.linked) {\n          for (var i2 = 0; i2 < this.linked.length; ++i2) {\n            var link = this.linked[i2];\n            if (link.doc != other) {\n              continue;\n            }\n            this.linked.splice(i2, 1);\n            other.unlinkDoc(this);\n            detachSharedMarkers(findSharedMarkers(this));\n            break;\n          }\n        }\n        if (other.history == this.history) {\n          var splitIds = [other.id];\n          linkedDocs(other, function(doc) {\n            return splitIds.push(doc.id);\n          }, true);\n          other.history = new History(null);\n          other.history.done = copyHistoryArray(this.history.done, splitIds);\n          other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n        }\n      },\n      iterLinkedDocs: function(f) {\n        linkedDocs(this, f);\n      },\n      getMode: function() {\n        return this.mode;\n      },\n      getEditor: function() {\n        return this.cm;\n      },\n      splitLines: function(str) {\n        if (this.lineSep) {\n          return str.split(this.lineSep);\n        }\n        return splitLinesAuto(str);\n      },\n      lineSeparator: function() {\n        return this.lineSep || "\\n";\n      },\n      setDirection: docMethodOp(function(dir) {\n        if (dir != "rtl") {\n          dir = "ltr";\n        }\n        if (dir == this.direction) {\n          return;\n        }\n        this.direction = dir;\n        this.iter(function(line) {\n          return line.order = null;\n        });\n        if (this.cm) {\n          directionChanged(this.cm);\n        }\n      })\n    });\n    Doc.prototype.eachLine = Doc.prototype.iter;\n    var lastDrop = 0;\n    function onDrop(e) {\n      var cm = this;\n      clearDragCursor(cm);\n      if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {\n        return;\n      }\n      e_preventDefault(e);\n      if (ie) {\n        lastDrop = +new Date();\n      }\n      var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n      if (!pos || cm.isReadOnly()) {\n        return;\n      }\n      if (files && files.length && window.FileReader && window.File) {\n        var n = files.length, text = Array(n), read = 0;\n        var markAsReadAndPasteIfAllFilesAreRead = /* @__PURE__ */ __name(function() {\n          if (++read == n) {\n            operation(cm, function() {\n              pos = clipPos(cm.doc, pos);\n              var change = {\n                from: pos,\n                to: pos,\n                text: cm.doc.splitLines(text.filter(function(t) {\n                  return t != null;\n                }).join(cm.doc.lineSeparator())),\n                origin: "paste"\n              };\n              makeChange(cm.doc, change);\n              setSelectionReplaceHistory(cm.doc, simpleSelection(clipPos(cm.doc, pos), clipPos(cm.doc, changeEnd(change))));\n            })();\n          }\n        }, "markAsReadAndPasteIfAllFilesAreRead");\n        var readTextFromFile = /* @__PURE__ */ __name(function(file, i3) {\n          if (cm.options.allowDropFileTypes && indexOf(cm.options.allowDropFileTypes, file.type) == -1) {\n            markAsReadAndPasteIfAllFilesAreRead();\n            return;\n          }\n          var reader = new FileReader();\n          reader.onerror = function() {\n            return markAsReadAndPasteIfAllFilesAreRead();\n          };\n          reader.onload = function() {\n            var content = reader.result;\n            if (/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(content)) {\n              markAsReadAndPasteIfAllFilesAreRead();\n              return;\n            }\n            text[i3] = content;\n            markAsReadAndPasteIfAllFilesAreRead();\n          };\n          reader.readAsText(file);\n        }, "readTextFromFile");\n        for (var i2 = 0; i2 < files.length; i2++) {\n          readTextFromFile(files[i2], i2);\n        }\n      } else {\n        if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\n          cm.state.draggingText(e);\n          setTimeout(function() {\n            return cm.display.input.focus();\n          }, 20);\n          return;\n        }\n        try {\n          var text$1 = e.dataTransfer.getData("Text");\n          if (text$1) {\n            var selected;\n            if (cm.state.draggingText && !cm.state.draggingText.copy) {\n              selected = cm.listSelections();\n            }\n            setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\n            if (selected) {\n              for (var i$12 = 0; i$12 < selected.length; ++i$12) {\n                replaceRange(cm.doc, "", selected[i$12].anchor, selected[i$12].head, "drag");\n              }\n            }\n            cm.replaceSelection(text$1, "around", "paste");\n            cm.display.input.focus();\n          }\n        } catch (e$1) {\n        }\n      }\n    }\n    __name(onDrop, "onDrop");\n    function onDragStart(cm, e) {\n      if (ie && (!cm.state.draggingText || +new Date() - lastDrop < 100)) {\n        e_stop(e);\n        return;\n      }\n      if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {\n        return;\n      }\n      e.dataTransfer.setData("Text", cm.getSelection());\n      e.dataTransfer.effectAllowed = "copyMove";\n      if (e.dataTransfer.setDragImage && !safari) {\n        var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");\n        img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";\n        if (presto) {\n          img.width = img.height = 1;\n          cm.display.wrapper.appendChild(img);\n          img._top = img.offsetTop;\n        }\n        e.dataTransfer.setDragImage(img, 0, 0);\n        if (presto) {\n          img.parentNode.removeChild(img);\n        }\n      }\n    }\n    __name(onDragStart, "onDragStart");\n    function onDragOver(cm, e) {\n      var pos = posFromMouse(cm, e);\n      if (!pos) {\n        return;\n      }\n      var frag = document.createDocumentFragment();\n      drawSelectionCursor(cm, pos, frag);\n      if (!cm.display.dragCursor) {\n        cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");\n        cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);\n      }\n      removeChildrenAndAdd(cm.display.dragCursor, frag);\n    }\n    __name(onDragOver, "onDragOver");\n    function clearDragCursor(cm) {\n      if (cm.display.dragCursor) {\n        cm.display.lineSpace.removeChild(cm.display.dragCursor);\n        cm.display.dragCursor = null;\n      }\n    }\n    __name(clearDragCursor, "clearDragCursor");\n    function forEachCodeMirror(f) {\n      if (!document.getElementsByClassName) {\n        return;\n      }\n      var byClass = document.getElementsByClassName("CodeMirror"), editors = [];\n      for (var i2 = 0; i2 < byClass.length; i2++) {\n        var cm = byClass[i2].CodeMirror;\n        if (cm) {\n          editors.push(cm);\n        }\n      }\n      if (editors.length) {\n        editors[0].operation(function() {\n          for (var i3 = 0; i3 < editors.length; i3++) {\n            f(editors[i3]);\n          }\n        });\n      }\n    }\n    __name(forEachCodeMirror, "forEachCodeMirror");\n    var globalsRegistered = false;\n    function ensureGlobalHandlers() {\n      if (globalsRegistered) {\n        return;\n      }\n      registerGlobalHandlers();\n      globalsRegistered = true;\n    }\n    __name(ensureGlobalHandlers, "ensureGlobalHandlers");\n    function registerGlobalHandlers() {\n      var resizeTimer;\n      on(window, "resize", function() {\n        if (resizeTimer == null) {\n          resizeTimer = setTimeout(function() {\n            resizeTimer = null;\n            forEachCodeMirror(onResize);\n          }, 100);\n        }\n      });\n      on(window, "blur", function() {\n        return forEachCodeMirror(onBlur);\n      });\n    }\n    __name(registerGlobalHandlers, "registerGlobalHandlers");\n    function onResize(cm) {\n      var d = cm.display;\n      d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n      d.scrollbarsClipped = false;\n      cm.setSize();\n    }\n    __name(onResize, "onResize");\n    var keyNames = {\n      3: "Pause",\n      8: "Backspace",\n      9: "Tab",\n      13: "Enter",\n      16: "Shift",\n      17: "Ctrl",\n      18: "Alt",\n      19: "Pause",\n      20: "CapsLock",\n      27: "Esc",\n      32: "Space",\n      33: "PageUp",\n      34: "PageDown",\n      35: "End",\n      36: "Home",\n      37: "Left",\n      38: "Up",\n      39: "Right",\n      40: "Down",\n      44: "PrintScrn",\n      45: "Insert",\n      46: "Delete",\n      59: ";",\n      61: "=",\n      91: "Mod",\n      92: "Mod",\n      93: "Mod",\n      106: "*",\n      107: "=",\n      109: "-",\n      110: ".",\n      111: "/",\n      145: "ScrollLock",\n      173: "-",\n      186: ";",\n      187: "=",\n      188: ",",\n      189: "-",\n      190: ".",\n      191: "/",\n      192: "`",\n      219: "[",\n      220: "\\\\",\n      221: "]",\n      222: "\'",\n      224: "Mod",\n      63232: "Up",\n      63233: "Down",\n      63234: "Left",\n      63235: "Right",\n      63272: "Delete",\n      63273: "Home",\n      63275: "End",\n      63276: "PageUp",\n      63277: "PageDown",\n      63302: "Insert"\n    };\n    for (var i = 0; i < 10; i++) {\n      keyNames[i + 48] = keyNames[i + 96] = String(i);\n    }\n    for (var i$1 = 65; i$1 <= 90; i$1++) {\n      keyNames[i$1] = String.fromCharCode(i$1);\n    }\n    for (var i$2 = 1; i$2 <= 12; i$2++) {\n      keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2;\n    }\n    var keyMap = {};\n    keyMap.basic = {\n      "Left": "goCharLeft",\n      "Right": "goCharRight",\n      "Up": "goLineUp",\n      "Down": "goLineDown",\n      "End": "goLineEnd",\n      "Home": "goLineStartSmart",\n      "PageUp": "goPageUp",\n      "PageDown": "goPageDown",\n      "Delete": "delCharAfter",\n      "Backspace": "delCharBefore",\n      "Shift-Backspace": "delCharBefore",\n      "Tab": "defaultTab",\n      "Shift-Tab": "indentAuto",\n      "Enter": "newlineAndIndent",\n      "Insert": "toggleOverwrite",\n      "Esc": "singleSelection"\n    };\n    keyMap.pcDefault = {\n      "Ctrl-A": "selectAll",\n      "Ctrl-D": "deleteLine",\n      "Ctrl-Z": "undo",\n      "Shift-Ctrl-Z": "redo",\n      "Ctrl-Y": "redo",\n      "Ctrl-Home": "goDocStart",\n      "Ctrl-End": "goDocEnd",\n      "Ctrl-Up": "goLineUp",\n      "Ctrl-Down": "goLineDown",\n      "Ctrl-Left": "goGroupLeft",\n      "Ctrl-Right": "goGroupRight",\n      "Alt-Left": "goLineStart",\n      "Alt-Right": "goLineEnd",\n      "Ctrl-Backspace": "delGroupBefore",\n      "Ctrl-Delete": "delGroupAfter",\n      "Ctrl-S": "save",\n      "Ctrl-F": "find",\n      "Ctrl-G": "findNext",\n      "Shift-Ctrl-G": "findPrev",\n      "Shift-Ctrl-F": "replace",\n      "Shift-Ctrl-R": "replaceAll",\n      "Ctrl-[": "indentLess",\n      "Ctrl-]": "indentMore",\n      "Ctrl-U": "undoSelection",\n      "Shift-Ctrl-U": "redoSelection",\n      "Alt-U": "redoSelection",\n      "fallthrough": "basic"\n    };\n    keyMap.emacsy = {\n      "Ctrl-F": "goCharRight",\n      "Ctrl-B": "goCharLeft",\n      "Ctrl-P": "goLineUp",\n      "Ctrl-N": "goLineDown",\n      "Ctrl-A": "goLineStart",\n      "Ctrl-E": "goLineEnd",\n      "Ctrl-V": "goPageDown",\n      "Shift-Ctrl-V": "goPageUp",\n      "Ctrl-D": "delCharAfter",\n      "Ctrl-H": "delCharBefore",\n      "Alt-Backspace": "delWordBefore",\n      "Ctrl-K": "killLine",\n      "Ctrl-T": "transposeChars",\n      "Ctrl-O": "openLine"\n    };\n    keyMap.macDefault = {\n      "Cmd-A": "selectAll",\n      "Cmd-D": "deleteLine",\n      "Cmd-Z": "undo",\n      "Shift-Cmd-Z": "redo",\n      "Cmd-Y": "redo",\n      "Cmd-Home": "goDocStart",\n      "Cmd-Up": "goDocStart",\n      "Cmd-End": "goDocEnd",\n      "Cmd-Down": "goDocEnd",\n      "Alt-Left": "goGroupLeft",\n      "Alt-Right": "goGroupRight",\n      "Cmd-Left": "goLineLeft",\n      "Cmd-Right": "goLineRight",\n      "Alt-Backspace": "delGroupBefore",\n      "Ctrl-Alt-Backspace": "delGroupAfter",\n      "Alt-Delete": "delGroupAfter",\n      "Cmd-S": "save",\n      "Cmd-F": "find",\n      "Cmd-G": "findNext",\n      "Shift-Cmd-G": "findPrev",\n      "Cmd-Alt-F": "replace",\n      "Shift-Cmd-Alt-F": "replaceAll",\n      "Cmd-[": "indentLess",\n      "Cmd-]": "indentMore",\n      "Cmd-Backspace": "delWrappedLineLeft",\n      "Cmd-Delete": "delWrappedLineRight",\n      "Cmd-U": "undoSelection",\n      "Shift-Cmd-U": "redoSelection",\n      "Ctrl-Up": "goDocStart",\n      "Ctrl-Down": "goDocEnd",\n      "fallthrough": ["basic", "emacsy"]\n    };\n    keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n    function normalizeKeyName(name) {\n      var parts = name.split(/-(?!$)/);\n      name = parts[parts.length - 1];\n      var alt, ctrl, shift, cmd;\n      for (var i2 = 0; i2 < parts.length - 1; i2++) {\n        var mod = parts[i2];\n        if (/^(cmd|meta|m)$/i.test(mod)) {\n          cmd = true;\n        } else if (/^a(lt)?$/i.test(mod)) {\n          alt = true;\n        } else if (/^(c|ctrl|control)$/i.test(mod)) {\n          ctrl = true;\n        } else if (/^s(hift)?$/i.test(mod)) {\n          shift = true;\n        } else {\n          throw new Error("Unrecognized modifier name: " + mod);\n        }\n      }\n      if (alt) {\n        name = "Alt-" + name;\n      }\n      if (ctrl) {\n        name = "Ctrl-" + name;\n      }\n      if (cmd) {\n        name = "Cmd-" + name;\n      }\n      if (shift) {\n        name = "Shift-" + name;\n      }\n      return name;\n    }\n    __name(normalizeKeyName, "normalizeKeyName");\n    function normalizeKeyMap(keymap) {\n      var copy = {};\n      for (var keyname in keymap) {\n        if (keymap.hasOwnProperty(keyname)) {\n          var value = keymap[keyname];\n          if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) {\n            continue;\n          }\n          if (value == "...") {\n            delete keymap[keyname];\n            continue;\n          }\n          var keys = map(keyname.split(" "), normalizeKeyName);\n          for (var i2 = 0; i2 < keys.length; i2++) {\n            var val = void 0, name = void 0;\n            if (i2 == keys.length - 1) {\n              name = keys.join(" ");\n              val = value;\n            } else {\n              name = keys.slice(0, i2 + 1).join(" ");\n              val = "...";\n            }\n            var prev = copy[name];\n            if (!prev) {\n              copy[name] = val;\n            } else if (prev != val) {\n              throw new Error("Inconsistent bindings for " + name);\n            }\n          }\n          delete keymap[keyname];\n        }\n      }\n      for (var prop2 in copy) {\n        keymap[prop2] = copy[prop2];\n      }\n      return keymap;\n    }\n    __name(normalizeKeyMap, "normalizeKeyMap");\n    function lookupKey(key, map2, handle, context) {\n      map2 = getKeyMap(map2);\n      var found = map2.call ? map2.call(key, context) : map2[key];\n      if (found === false) {\n        return "nothing";\n      }\n      if (found === "...") {\n        return "multi";\n      }\n      if (found != null && handle(found)) {\n        return "handled";\n      }\n      if (map2.fallthrough) {\n        if (Object.prototype.toString.call(map2.fallthrough) != "[object Array]") {\n          return lookupKey(key, map2.fallthrough, handle, context);\n        }\n        for (var i2 = 0; i2 < map2.fallthrough.length; i2++) {\n          var result = lookupKey(key, map2.fallthrough[i2], handle, context);\n          if (result) {\n            return result;\n          }\n        }\n      }\n    }\n    __name(lookupKey, "lookupKey");\n    function isModifierKey(value) {\n      var name = typeof value == "string" ? value : keyNames[value.keyCode];\n      return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";\n    }\n    __name(isModifierKey, "isModifierKey");\n    function addModifierNames(name, event, noShift) {\n      var base = name;\n      if (event.altKey && base != "Alt") {\n        name = "Alt-" + name;\n      }\n      if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") {\n        name = "Ctrl-" + name;\n      }\n      if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Mod") {\n        name = "Cmd-" + name;\n      }\n      if (!noShift && event.shiftKey && base != "Shift") {\n        name = "Shift-" + name;\n      }\n      return name;\n    }\n    __name(addModifierNames, "addModifierNames");\n    function keyName(event, noShift) {\n      if (presto && event.keyCode == 34 && event["char"]) {\n        return false;\n      }\n      var name = keyNames[event.keyCode];\n      if (name == null || event.altGraphKey) {\n        return false;\n      }\n      if (event.keyCode == 3 && event.code) {\n        name = event.code;\n      }\n      return addModifierNames(name, event, noShift);\n    }\n    __name(keyName, "keyName");\n    function getKeyMap(val) {\n      return typeof val == "string" ? keyMap[val] : val;\n    }\n    __name(getKeyMap, "getKeyMap");\n    function deleteNearSelection(cm, compute) {\n      var ranges = cm.doc.sel.ranges, kill = [];\n      for (var i2 = 0; i2 < ranges.length; i2++) {\n        var toKill = compute(ranges[i2]);\n        while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\n          var replaced = kill.pop();\n          if (cmp(replaced.from, toKill.from) < 0) {\n            toKill.from = replaced.from;\n            break;\n          }\n        }\n        kill.push(toKill);\n      }\n      runInOp(cm, function() {\n        for (var i3 = kill.length - 1; i3 >= 0; i3--) {\n          replaceRange(cm.doc, "", kill[i3].from, kill[i3].to, "+delete");\n        }\n        ensureCursorVisible(cm);\n      });\n    }\n    __name(deleteNearSelection, "deleteNearSelection");\n    function moveCharLogically(line, ch, dir) {\n      var target = skipExtendingChars(line.text, ch + dir, dir);\n      return target < 0 || target > line.text.length ? null : target;\n    }\n    __name(moveCharLogically, "moveCharLogically");\n    function moveLogically(line, start, dir) {\n      var ch = moveCharLogically(line, start.ch, dir);\n      return ch == null ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before");\n    }\n    __name(moveLogically, "moveLogically");\n    function endOfLine(visually, cm, lineObj, lineNo2, dir) {\n      if (visually) {\n        if (cm.doc.direction == "rtl") {\n          dir = -dir;\n        }\n        var order = getOrder(lineObj, cm.doc.direction);\n        if (order) {\n          var part = dir < 0 ? lst(order) : order[0];\n          var moveInStorageOrder = dir < 0 == (part.level == 1);\n          var sticky = moveInStorageOrder ? "after" : "before";\n          var ch;\n          if (part.level > 0 || cm.doc.direction == "rtl") {\n            var prep = prepareMeasureForLine(cm, lineObj);\n            ch = dir < 0 ? lineObj.text.length - 1 : 0;\n            var targetTop = measureCharPrepared(cm, prep, ch).top;\n            ch = findFirst(function(ch2) {\n              return measureCharPrepared(cm, prep, ch2).top == targetTop;\n            }, dir < 0 == (part.level == 1) ? part.from : part.to - 1, ch);\n            if (sticky == "before") {\n              ch = moveCharLogically(lineObj, ch, 1);\n            }\n          } else {\n            ch = dir < 0 ? part.to : part.from;\n          }\n          return new Pos(lineNo2, ch, sticky);\n        }\n      }\n      return new Pos(lineNo2, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after");\n    }\n    __name(endOfLine, "endOfLine");\n    function moveVisually(cm, line, start, dir) {\n      var bidi = getOrder(line, cm.doc.direction);\n      if (!bidi) {\n        return moveLogically(line, start, dir);\n      }\n      if (start.ch >= line.text.length) {\n        start.ch = line.text.length;\n        start.sticky = "before";\n      } else if (start.ch <= 0) {\n        start.ch = 0;\n        start.sticky = "after";\n      }\n      var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];\n      if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {\n        return moveLogically(line, start, dir);\n      }\n      var mv = /* @__PURE__ */ __name(function(pos, dir2) {\n        return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir2);\n      }, "mv");\n      var prep;\n      var getWrappedLineExtent = /* @__PURE__ */ __name(function(ch2) {\n        if (!cm.options.lineWrapping) {\n          return { begin: 0, end: line.text.length };\n        }\n        prep = prep || prepareMeasureForLine(cm, line);\n        return wrappedLineExtentChar(cm, line, prep, ch2);\n      }, "getWrappedLineExtent");\n      var wrappedLineExtent2 = getWrappedLineExtent(start.sticky == "before" ? mv(start, -1) : start.ch);\n      if (cm.doc.direction == "rtl" || part.level == 1) {\n        var moveInStorageOrder = part.level == 1 == dir < 0;\n        var ch = mv(start, moveInStorageOrder ? 1 : -1);\n        if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent2.begin : ch <= part.to && ch <= wrappedLineExtent2.end)) {\n          var sticky = moveInStorageOrder ? "before" : "after";\n          return new Pos(start.line, ch, sticky);\n        }\n      }\n      var searchInVisualLine = /* @__PURE__ */ __name(function(partPos2, dir2, wrappedLineExtent3) {\n        var getRes = /* @__PURE__ */ __name(function(ch3, moveInStorageOrder3) {\n          return moveInStorageOrder3 ? new Pos(start.line, mv(ch3, 1), "before") : new Pos(start.line, ch3, "after");\n        }, "getRes");\n        for (; partPos2 >= 0 && partPos2 < bidi.length; partPos2 += dir2) {\n          var part2 = bidi[partPos2];\n          var moveInStorageOrder2 = dir2 > 0 == (part2.level != 1);\n          var ch2 = moveInStorageOrder2 ? wrappedLineExtent3.begin : mv(wrappedLineExtent3.end, -1);\n          if (part2.from <= ch2 && ch2 < part2.to) {\n            return getRes(ch2, moveInStorageOrder2);\n          }\n          ch2 = moveInStorageOrder2 ? part2.from : mv(part2.to, -1);\n          if (wrappedLineExtent3.begin <= ch2 && ch2 < wrappedLineExtent3.end) {\n            return getRes(ch2, moveInStorageOrder2);\n          }\n        }\n      }, "searchInVisualLine");\n      var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent2);\n      if (res) {\n        return res;\n      }\n      var nextCh = dir > 0 ? wrappedLineExtent2.end : mv(wrappedLineExtent2.begin, -1);\n      if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {\n        res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));\n        if (res) {\n          return res;\n        }\n      }\n      return null;\n    }\n    __name(moveVisually, "moveVisually");\n    var commands = {\n      selectAll,\n      singleSelection: function(cm) {\n        return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);\n      },\n      killLine: function(cm) {\n        return deleteNearSelection(cm, function(range2) {\n          if (range2.empty()) {\n            var len = getLine(cm.doc, range2.head.line).text.length;\n            if (range2.head.ch == len && range2.head.line < cm.lastLine()) {\n              return { from: range2.head, to: Pos(range2.head.line + 1, 0) };\n            } else {\n              return { from: range2.head, to: Pos(range2.head.line, len) };\n            }\n          } else {\n            return { from: range2.from(), to: range2.to() };\n          }\n        });\n      },\n      deleteLine: function(cm) {\n        return deleteNearSelection(cm, function(range2) {\n          return {\n            from: Pos(range2.from().line, 0),\n            to: clipPos(cm.doc, Pos(range2.to().line + 1, 0))\n          };\n        });\n      },\n      delLineLeft: function(cm) {\n        return deleteNearSelection(cm, function(range2) {\n          return {\n            from: Pos(range2.from().line, 0),\n            to: range2.from()\n          };\n        });\n      },\n      delWrappedLineLeft: function(cm) {\n        return deleteNearSelection(cm, function(range2) {\n          var top = cm.charCoords(range2.head, "div").top + 5;\n          var leftPos = cm.coordsChar({ left: 0, top }, "div");\n          return { from: leftPos, to: range2.from() };\n        });\n      },\n      delWrappedLineRight: function(cm) {\n        return deleteNearSelection(cm, function(range2) {\n          var top = cm.charCoords(range2.head, "div").top + 5;\n          var rightPos = cm.coordsChar({ left: cm.display.lineDiv.offsetWidth + 100, top }, "div");\n          return { from: range2.from(), to: rightPos };\n        });\n      },\n      undo: function(cm) {\n        return cm.undo();\n      },\n      redo: function(cm) {\n        return cm.redo();\n      },\n      undoSelection: function(cm) {\n        return cm.undoSelection();\n      },\n      redoSelection: function(cm) {\n        return cm.redoSelection();\n      },\n      goDocStart: function(cm) {\n        return cm.extendSelection(Pos(cm.firstLine(), 0));\n      },\n      goDocEnd: function(cm) {\n        return cm.extendSelection(Pos(cm.lastLine()));\n      },\n      goLineStart: function(cm) {\n        return cm.extendSelectionsBy(function(range2) {\n          return lineStart(cm, range2.head.line);\n        }, { origin: "+move", bias: 1 });\n      },\n      goLineStartSmart: function(cm) {\n        return cm.extendSelectionsBy(function(range2) {\n          return lineStartSmart(cm, range2.head);\n        }, { origin: "+move", bias: 1 });\n      },\n      goLineEnd: function(cm) {\n        return cm.extendSelectionsBy(function(range2) {\n          return lineEnd(cm, range2.head.line);\n        }, { origin: "+move", bias: -1 });\n      },\n      goLineRight: function(cm) {\n        return cm.extendSelectionsBy(function(range2) {\n          var top = cm.cursorCoords(range2.head, "div").top + 5;\n          return cm.coordsChar({ left: cm.display.lineDiv.offsetWidth + 100, top }, "div");\n        }, sel_move);\n      },\n      goLineLeft: function(cm) {\n        return cm.extendSelectionsBy(function(range2) {\n          var top = cm.cursorCoords(range2.head, "div").top + 5;\n          return cm.coordsChar({ left: 0, top }, "div");\n        }, sel_move);\n      },\n      goLineLeftSmart: function(cm) {\n        return cm.extendSelectionsBy(function(range2) {\n          var top = cm.cursorCoords(range2.head, "div").top + 5;\n          var pos = cm.coordsChar({ left: 0, top }, "div");\n          if (pos.ch < cm.getLine(pos.line).search(/\\S/)) {\n            return lineStartSmart(cm, range2.head);\n          }\n          return pos;\n        }, sel_move);\n      },\n      goLineUp: function(cm) {\n        return cm.moveV(-1, "line");\n      },\n      goLineDown: function(cm) {\n        return cm.moveV(1, "line");\n      },\n      goPageUp: function(cm) {\n        return cm.moveV(-1, "page");\n      },\n      goPageDown: function(cm) {\n        return cm.moveV(1, "page");\n      },\n      goCharLeft: function(cm) {\n        return cm.moveH(-1, "char");\n      },\n      goCharRight: function(cm) {\n        return cm.moveH(1, "char");\n      },\n      goColumnLeft: function(cm) {\n        return cm.moveH(-1, "column");\n      },\n      goColumnRight: function(cm) {\n        return cm.moveH(1, "column");\n      },\n      goWordLeft: function(cm) {\n        return cm.moveH(-1, "word");\n      },\n      goGroupRight: function(cm) {\n        return cm.moveH(1, "group");\n      },\n      goGroupLeft: function(cm) {\n        return cm.moveH(-1, "group");\n      },\n      goWordRight: function(cm) {\n        return cm.moveH(1, "word");\n      },\n      delCharBefore: function(cm) {\n        return cm.deleteH(-1, "codepoint");\n      },\n      delCharAfter: function(cm) {\n        return cm.deleteH(1, "char");\n      },\n      delWordBefore: function(cm) {\n        return cm.deleteH(-1, "word");\n      },\n      delWordAfter: function(cm) {\n        return cm.deleteH(1, "word");\n      },\n      delGroupBefore: function(cm) {\n        return cm.deleteH(-1, "group");\n      },\n      delGroupAfter: function(cm) {\n        return cm.deleteH(1, "group");\n      },\n      indentAuto: function(cm) {\n        return cm.indentSelection("smart");\n      },\n      indentMore: function(cm) {\n        return cm.indentSelection("add");\n      },\n      indentLess: function(cm) {\n        return cm.indentSelection("subtract");\n      },\n      insertTab: function(cm) {\n        return cm.replaceSelection("\t");\n      },\n      insertSoftTab: function(cm) {\n        var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\n        for (var i2 = 0; i2 < ranges.length; i2++) {\n          var pos = ranges[i2].from();\n          var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\n          spaces.push(spaceStr(tabSize - col % tabSize));\n        }\n        cm.replaceSelections(spaces);\n      },\n      defaultTab: function(cm) {\n        if (cm.somethingSelected()) {\n          cm.indentSelection("add");\n        } else {\n          cm.execCommand("insertTab");\n        }\n      },\n      transposeChars: function(cm) {\n        return runInOp(cm, function() {\n          var ranges = cm.listSelections(), newSel = [];\n          for (var i2 = 0; i2 < ranges.length; i2++) {\n            if (!ranges[i2].empty()) {\n              continue;\n            }\n            var cur = ranges[i2].head, line = getLine(cm.doc, cur.line).text;\n            if (line) {\n              if (cur.ch == line.length) {\n                cur = new Pos(cur.line, cur.ch - 1);\n              }\n              if (cur.ch > 0) {\n                cur = new Pos(cur.line, cur.ch + 1);\n                cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2), Pos(cur.line, cur.ch - 2), cur, "+transpose");\n              } else if (cur.line > cm.doc.first) {\n                var prev = getLine(cm.doc, cur.line - 1).text;\n                if (prev) {\n                  cur = new Pos(cur.line, 1);\n                  cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1), Pos(cur.line - 1, prev.length - 1), cur, "+transpose");\n                }\n              }\n            }\n            newSel.push(new Range(cur, cur));\n          }\n          cm.setSelections(newSel);\n        });\n      },\n      newlineAndIndent: function(cm) {\n        return runInOp(cm, function() {\n          var sels = cm.listSelections();\n          for (var i2 = sels.length - 1; i2 >= 0; i2--) {\n            cm.replaceRange(cm.doc.lineSeparator(), sels[i2].anchor, sels[i2].head, "+input");\n          }\n          sels = cm.listSelections();\n          for (var i$12 = 0; i$12 < sels.length; i$12++) {\n            cm.indentLine(sels[i$12].from().line, null, true);\n          }\n          ensureCursorVisible(cm);\n        });\n      },\n      openLine: function(cm) {\n        return cm.replaceSelection("\\n", "start");\n      },\n      toggleOverwrite: function(cm) {\n        return cm.toggleOverwrite();\n      }\n    };\n    function lineStart(cm, lineN) {\n      var line = getLine(cm.doc, lineN);\n      var visual = visualLine(line);\n      if (visual != line) {\n        lineN = lineNo(visual);\n      }\n      return endOfLine(true, cm, visual, lineN, 1);\n    }\n    __name(lineStart, "lineStart");\n    function lineEnd(cm, lineN) {\n      var line = getLine(cm.doc, lineN);\n      var visual = visualLineEnd(line);\n      if (visual != line) {\n        lineN = lineNo(visual);\n      }\n      return endOfLine(true, cm, line, lineN, -1);\n    }\n    __name(lineEnd, "lineEnd");\n    function lineStartSmart(cm, pos) {\n      var start = lineStart(cm, pos.line);\n      var line = getLine(cm.doc, start.line);\n      var order = getOrder(line, cm.doc.direction);\n      if (!order || order[0].level == 0) {\n        var firstNonWS = Math.max(start.ch, line.text.search(/\\S/));\n        var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\n        return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky);\n      }\n      return start;\n    }\n    __name(lineStartSmart, "lineStartSmart");\n    function doHandleBinding(cm, bound, dropShift) {\n      if (typeof bound == "string") {\n        bound = commands[bound];\n        if (!bound) {\n          return false;\n        }\n      }\n      cm.display.input.ensurePolled();\n      var prevShift = cm.display.shift, done = false;\n      try {\n        if (cm.isReadOnly()) {\n          cm.state.suppressEdits = true;\n        }\n        if (dropShift) {\n          cm.display.shift = false;\n        }\n        done = bound(cm) != Pass;\n      } finally {\n        cm.display.shift = prevShift;\n        cm.state.suppressEdits = false;\n      }\n      return done;\n    }\n    __name(doHandleBinding, "doHandleBinding");\n    function lookupKeyForEditor(cm, name, handle) {\n      for (var i2 = 0; i2 < cm.state.keyMaps.length; i2++) {\n        var result = lookupKey(name, cm.state.keyMaps[i2], handle, cm);\n        if (result) {\n          return result;\n        }\n      }\n      return cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm) || lookupKey(name, cm.options.keyMap, handle, cm);\n    }\n    __name(lookupKeyForEditor, "lookupKeyForEditor");\n    var stopSeq = new Delayed();\n    function dispatchKey(cm, name, e, handle) {\n      var seq = cm.state.keySeq;\n      if (seq) {\n        if (isModifierKey(name)) {\n          return "handled";\n        }\n        if (/\\\'$/.test(name)) {\n          cm.state.keySeq = null;\n        } else {\n          stopSeq.set(50, function() {\n            if (cm.state.keySeq == seq) {\n              cm.state.keySeq = null;\n              cm.display.input.reset();\n            }\n          });\n        }\n        if (dispatchKeyInner(cm, seq + " " + name, e, handle)) {\n          return true;\n        }\n      }\n      return dispatchKeyInner(cm, name, e, handle);\n    }\n    __name(dispatchKey, "dispatchKey");\n    function dispatchKeyInner(cm, name, e, handle) {\n      var result = lookupKeyForEditor(cm, name, handle);\n      if (result == "multi") {\n        cm.state.keySeq = name;\n      }\n      if (result == "handled") {\n        signalLater(cm, "keyHandled", cm, name, e);\n      }\n      if (result == "handled" || result == "multi") {\n        e_preventDefault(e);\n        restartBlink(cm);\n      }\n      return !!result;\n    }\n    __name(dispatchKeyInner, "dispatchKeyInner");\n    function handleKeyBinding(cm, e) {\n      var name = keyName(e, true);\n      if (!name) {\n        return false;\n      }\n      if (e.shiftKey && !cm.state.keySeq) {\n        return dispatchKey(cm, "Shift-" + name, e, function(b) {\n          return doHandleBinding(cm, b, true);\n        }) || dispatchKey(cm, name, e, function(b) {\n          if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion) {\n            return doHandleBinding(cm, b);\n          }\n        });\n      } else {\n        return dispatchKey(cm, name, e, function(b) {\n          return doHandleBinding(cm, b);\n        });\n      }\n    }\n    __name(handleKeyBinding, "handleKeyBinding");\n    function handleCharBinding(cm, e, ch) {\n      return dispatchKey(cm, "\'" + ch + "\'", e, function(b) {\n        return doHandleBinding(cm, b, true);\n      });\n    }\n    __name(handleCharBinding, "handleCharBinding");\n    var lastStoppedKey = null;\n    function onKeyDown(e) {\n      var cm = this;\n      if (e.target && e.target != cm.display.input.getField()) {\n        return;\n      }\n      cm.curOp.focus = activeElt();\n      if (signalDOMEvent(cm, e)) {\n        return;\n      }\n      if (ie && ie_version < 11 && e.keyCode == 27) {\n        e.returnValue = false;\n      }\n      var code = e.keyCode;\n      cm.display.shift = code == 16 || e.shiftKey;\n      var handled = handleKeyBinding(cm, e);\n      if (presto) {\n        lastStoppedKey = handled ? code : null;\n        if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey)) {\n          cm.replaceSelection("", null, "cut");\n        }\n      }\n      if (gecko && !mac && !handled && code == 46 && e.shiftKey && !e.ctrlKey && document.execCommand) {\n        document.execCommand("cut");\n      }\n      if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className)) {\n        showCrossHair(cm);\n      }\n    }\n    __name(onKeyDown, "onKeyDown");\n    function showCrossHair(cm) {\n      var lineDiv = cm.display.lineDiv;\n      addClass(lineDiv, "CodeMirror-crosshair");\n      function up(e) {\n        if (e.keyCode == 18 || !e.altKey) {\n          rmClass(lineDiv, "CodeMirror-crosshair");\n          off(document, "keyup", up);\n          off(document, "mouseover", up);\n        }\n      }\n      __name(up, "up");\n      on(document, "keyup", up);\n      on(document, "mouseover", up);\n    }\n    __name(showCrossHair, "showCrossHair");\n    function onKeyUp(e) {\n      if (e.keyCode == 16) {\n        this.doc.sel.shift = false;\n      }\n      signalDOMEvent(this, e);\n    }\n    __name(onKeyUp, "onKeyUp");\n    function onKeyPress(e) {\n      var cm = this;\n      if (e.target && e.target != cm.display.input.getField()) {\n        return;\n      }\n      if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) {\n        return;\n      }\n      var keyCode = e.keyCode, charCode = e.charCode;\n      if (presto && keyCode == lastStoppedKey) {\n        lastStoppedKey = null;\n        e_preventDefault(e);\n        return;\n      }\n      if (presto && (!e.which || e.which < 10) && handleKeyBinding(cm, e)) {\n        return;\n      }\n      var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n      if (ch == "\\b") {\n        return;\n      }\n      if (handleCharBinding(cm, e, ch)) {\n        return;\n      }\n      cm.display.input.onKeyPress(e);\n    }\n    __name(onKeyPress, "onKeyPress");\n    var DOUBLECLICK_DELAY = 400;\n    var PastClick = /* @__PURE__ */ __name(function(time, pos, button) {\n      this.time = time;\n      this.pos = pos;\n      this.button = button;\n    }, "PastClick");\n    PastClick.prototype.compare = function(time, pos, button) {\n      return this.time + DOUBLECLICK_DELAY > time && cmp(pos, this.pos) == 0 && button == this.button;\n    };\n    var lastClick, lastDoubleClick;\n    function clickRepeat(pos, button) {\n      var now = +new Date();\n      if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {\n        lastClick = lastDoubleClick = null;\n        return "triple";\n      } else if (lastClick && lastClick.compare(now, pos, button)) {\n        lastDoubleClick = new PastClick(now, pos, button);\n        lastClick = null;\n        return "double";\n      } else {\n        lastClick = new PastClick(now, pos, button);\n        lastDoubleClick = null;\n        return "single";\n      }\n    }\n    __name(clickRepeat, "clickRepeat");\n    function onMouseDown(e) {\n      var cm = this, display = cm.display;\n      if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) {\n        return;\n      }\n      display.input.ensurePolled();\n      display.shift = e.shiftKey;\n      if (eventInWidget(display, e)) {\n        if (!webkit) {\n          display.scroller.draggable = false;\n          setTimeout(function() {\n            return display.scroller.draggable = true;\n          }, 100);\n        }\n        return;\n      }\n      if (clickInGutter(cm, e)) {\n        return;\n      }\n      var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : "single";\n      window.focus();\n      if (button == 1 && cm.state.selectingText) {\n        cm.state.selectingText(e);\n      }\n      if (pos && handleMappedButton(cm, button, pos, repeat, e)) {\n        return;\n      }\n      if (button == 1) {\n        if (pos) {\n          leftButtonDown(cm, pos, repeat, e);\n        } else if (e_target(e) == display.scroller) {\n          e_preventDefault(e);\n        }\n      } else if (button == 2) {\n        if (pos) {\n          extendSelection(cm.doc, pos);\n        }\n        setTimeout(function() {\n          return display.input.focus();\n        }, 20);\n      } else if (button == 3) {\n        if (captureRightClick) {\n          cm.display.input.onContextMenu(e);\n        } else {\n          delayBlurEvent(cm);\n        }\n      }\n    }\n    __name(onMouseDown, "onMouseDown");\n    function handleMappedButton(cm, button, pos, repeat, event) {\n      var name = "Click";\n      if (repeat == "double") {\n        name = "Double" + name;\n      } else if (repeat == "triple") {\n        name = "Triple" + name;\n      }\n      name = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name;\n      return dispatchKey(cm, addModifierNames(name, event), event, function(bound) {\n        if (typeof bound == "string") {\n          bound = commands[bound];\n        }\n        if (!bound) {\n          return false;\n        }\n        var done = false;\n        try {\n          if (cm.isReadOnly()) {\n            cm.state.suppressEdits = true;\n          }\n          done = bound(cm, pos) != Pass;\n        } finally {\n          cm.state.suppressEdits = false;\n        }\n        return done;\n      });\n    }\n    __name(handleMappedButton, "handleMappedButton");\n    function configureMouse(cm, repeat, event) {\n      var option = cm.getOption("configureMouse");\n      var value = option ? option(cm, repeat, event) : {};\n      if (value.unit == null) {\n        var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;\n        value.unit = rect ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line";\n      }\n      if (value.extend == null || cm.doc.extend) {\n        value.extend = cm.doc.extend || event.shiftKey;\n      }\n      if (value.addNew == null) {\n        value.addNew = mac ? event.metaKey : event.ctrlKey;\n      }\n      if (value.moveOnDrag == null) {\n        value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey);\n      }\n      return value;\n    }\n    __name(configureMouse, "configureMouse");\n    function leftButtonDown(cm, pos, repeat, event) {\n      if (ie) {\n        setTimeout(bind(ensureFocus, cm), 0);\n      } else {\n        cm.curOp.focus = activeElt();\n      }\n      var behavior = configureMouse(cm, repeat, event);\n      var sel = cm.doc.sel, contained;\n      if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() && repeat == "single" && (contained = sel.contains(pos)) > -1 && (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) && (cmp(contained.to(), pos) > 0 || pos.xRel < 0)) {\n        leftButtonStartDrag(cm, event, pos, behavior);\n      } else {\n        leftButtonSelect(cm, event, pos, behavior);\n      }\n    }\n    __name(leftButtonDown, "leftButtonDown");\n    function leftButtonStartDrag(cm, event, pos, behavior) {\n      var display = cm.display, moved = false;\n      var dragEnd = operation(cm, function(e) {\n        if (webkit) {\n          display.scroller.draggable = false;\n        }\n        cm.state.draggingText = false;\n        if (cm.state.delayingBlurEvent) {\n          if (cm.hasFocus()) {\n            cm.state.delayingBlurEvent = false;\n          } else {\n            delayBlurEvent(cm);\n          }\n        }\n        off(display.wrapper.ownerDocument, "mouseup", dragEnd);\n        off(display.wrapper.ownerDocument, "mousemove", mouseMove);\n        off(display.scroller, "dragstart", dragStart);\n        off(display.scroller, "drop", dragEnd);\n        if (!moved) {\n          e_preventDefault(e);\n          if (!behavior.addNew) {\n            extendSelection(cm.doc, pos, null, null, behavior.extend);\n          }\n          if (webkit && !safari || ie && ie_version == 9) {\n            setTimeout(function() {\n              display.wrapper.ownerDocument.body.focus({ preventScroll: true });\n              display.input.focus();\n            }, 20);\n          } else {\n            display.input.focus();\n          }\n        }\n      });\n      var mouseMove = /* @__PURE__ */ __name(function(e2) {\n        moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;\n      }, "mouseMove");\n      var dragStart = /* @__PURE__ */ __name(function() {\n        return moved = true;\n      }, "dragStart");\n      if (webkit) {\n        display.scroller.draggable = true;\n      }\n      cm.state.draggingText = dragEnd;\n      dragEnd.copy = !behavior.moveOnDrag;\n      on(display.wrapper.ownerDocument, "mouseup", dragEnd);\n      on(display.wrapper.ownerDocument, "mousemove", mouseMove);\n      on(display.scroller, "dragstart", dragStart);\n      on(display.scroller, "drop", dragEnd);\n      cm.state.delayingBlurEvent = true;\n      setTimeout(function() {\n        return display.input.focus();\n      }, 20);\n      if (display.scroller.dragDrop) {\n        display.scroller.dragDrop();\n      }\n    }\n    __name(leftButtonStartDrag, "leftButtonStartDrag");\n    function rangeForUnit(cm, pos, unit) {\n      if (unit == "char") {\n        return new Range(pos, pos);\n      }\n      if (unit == "word") {\n        return cm.findWordAt(pos);\n      }\n      if (unit == "line") {\n        return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));\n      }\n      var result = unit(cm, pos);\n      return new Range(result.from, result.to);\n    }\n    __name(rangeForUnit, "rangeForUnit");\n    function leftButtonSelect(cm, event, start, behavior) {\n      if (ie) {\n        delayBlurEvent(cm);\n      }\n      var display = cm.display, doc = cm.doc;\n      e_preventDefault(event);\n      var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;\n      if (behavior.addNew && !behavior.extend) {\n        ourIndex = doc.sel.contains(start);\n        if (ourIndex > -1) {\n          ourRange = ranges[ourIndex];\n        } else {\n          ourRange = new Range(start, start);\n        }\n      } else {\n        ourRange = doc.sel.primary();\n        ourIndex = doc.sel.primIndex;\n      }\n      if (behavior.unit == "rectangle") {\n        if (!behavior.addNew) {\n          ourRange = new Range(start, start);\n        }\n        start = posFromMouse(cm, event, true, true);\n        ourIndex = -1;\n      } else {\n        var range2 = rangeForUnit(cm, start, behavior.unit);\n        if (behavior.extend) {\n          ourRange = extendRange(ourRange, range2.anchor, range2.head, behavior.extend);\n        } else {\n          ourRange = range2;\n        }\n      }\n      if (!behavior.addNew) {\n        ourIndex = 0;\n        setSelection(doc, new Selection([ourRange], 0), sel_mouse);\n        startSel = doc.sel;\n      } else if (ourIndex == -1) {\n        ourIndex = ranges.length;\n        setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex), { scroll: false, origin: "*mouse" });\n      } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {\n        setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0), { scroll: false, origin: "*mouse" });\n        startSel = doc.sel;\n      } else {\n        replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\n      }\n      var lastPos = start;\n      function extendTo(pos) {\n        if (cmp(lastPos, pos) == 0) {\n          return;\n        }\n        lastPos = pos;\n        if (behavior.unit == "rectangle") {\n          var ranges2 = [], tabSize = cm.options.tabSize;\n          var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\n          var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\n          var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\n          for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line)); line <= end; line++) {\n            var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);\n            if (left == right) {\n              ranges2.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));\n            } else if (text.length > leftPos) {\n              ranges2.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));\n            }\n          }\n          if (!ranges2.length) {\n            ranges2.push(new Range(start, start));\n          }\n          setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges2), ourIndex), { origin: "*mouse", scroll: false });\n          cm.scrollIntoView(pos);\n        } else {\n          var oldRange = ourRange;\n          var range3 = rangeForUnit(cm, pos, behavior.unit);\n          var anchor = oldRange.anchor, head;\n          if (cmp(range3.anchor, anchor) > 0) {\n            head = range3.head;\n            anchor = minPos(oldRange.from(), range3.anchor);\n          } else {\n            head = range3.anchor;\n            anchor = maxPos(oldRange.to(), range3.head);\n          }\n          var ranges$1 = startSel.ranges.slice(0);\n          ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));\n          setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);\n        }\n      }\n      __name(extendTo, "extendTo");\n      var editorSize = display.wrapper.getBoundingClientRect();\n      var counter = 0;\n      function extend(e) {\n        var curCount = ++counter;\n        var cur = posFromMouse(cm, e, true, behavior.unit == "rectangle");\n        if (!cur) {\n          return;\n        }\n        if (cmp(cur, lastPos) != 0) {\n          cm.curOp.focus = activeElt();\n          extendTo(cur);\n          var visible = visibleLines(display, doc);\n          if (cur.line >= visible.to || cur.line < visible.from) {\n            setTimeout(operation(cm, function() {\n              if (counter == curCount) {\n                extend(e);\n              }\n            }), 150);\n          }\n        } else {\n          var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n          if (outside) {\n            setTimeout(operation(cm, function() {\n              if (counter != curCount) {\n                return;\n              }\n              display.scroller.scrollTop += outside;\n              extend(e);\n            }), 50);\n          }\n        }\n      }\n      __name(extend, "extend");\n      function done(e) {\n        cm.state.selectingText = false;\n        counter = Infinity;\n        if (e) {\n          e_preventDefault(e);\n          display.input.focus();\n        }\n        off(display.wrapper.ownerDocument, "mousemove", move);\n        off(display.wrapper.ownerDocument, "mouseup", up);\n        doc.history.lastSelOrigin = null;\n      }\n      __name(done, "done");\n      var move = operation(cm, function(e) {\n        if (e.buttons === 0 || !e_button(e)) {\n          done(e);\n        } else {\n          extend(e);\n        }\n      });\n      var up = operation(cm, done);\n      cm.state.selectingText = up;\n      on(display.wrapper.ownerDocument, "mousemove", move);\n      on(display.wrapper.ownerDocument, "mouseup", up);\n    }\n    __name(leftButtonSelect, "leftButtonSelect");\n    function bidiSimplify(cm, range2) {\n      var anchor = range2.anchor;\n      var head = range2.head;\n      var anchorLine = getLine(cm.doc, anchor.line);\n      if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) {\n        return range2;\n      }\n      var order = getOrder(anchorLine);\n      if (!order) {\n        return range2;\n      }\n      var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];\n      if (part.from != anchor.ch && part.to != anchor.ch) {\n        return range2;\n      }\n      var boundary = index + (part.from == anchor.ch == (part.level != 1) ? 0 : 1);\n      if (boundary == 0 || boundary == order.length) {\n        return range2;\n      }\n      var leftSide;\n      if (head.line != anchor.line) {\n        leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;\n      } else {\n        var headIndex = getBidiPartAt(order, head.ch, head.sticky);\n        var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);\n        if (headIndex == boundary - 1 || headIndex == boundary) {\n          leftSide = dir < 0;\n        } else {\n          leftSide = dir > 0;\n        }\n      }\n      var usePart = order[boundary + (leftSide ? -1 : 0)];\n      var from = leftSide == (usePart.level == 1);\n      var ch = from ? usePart.from : usePart.to, sticky = from ? "after" : "before";\n      return anchor.ch == ch && anchor.sticky == sticky ? range2 : new Range(new Pos(anchor.line, ch, sticky), head);\n    }\n    __name(bidiSimplify, "bidiSimplify");\n    function gutterEvent(cm, e, type, prevent) {\n      var mX, mY;\n      if (e.touches) {\n        mX = e.touches[0].clientX;\n        mY = e.touches[0].clientY;\n      } else {\n        try {\n          mX = e.clientX;\n          mY = e.clientY;\n        } catch (e$1) {\n          return false;\n        }\n      }\n      if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) {\n        return false;\n      }\n      if (prevent) {\n        e_preventDefault(e);\n      }\n      var display = cm.display;\n      var lineBox = display.lineDiv.getBoundingClientRect();\n      if (mY > lineBox.bottom || !hasHandler(cm, type)) {\n        return e_defaultPrevented(e);\n      }\n      mY -= lineBox.top - display.viewOffset;\n      for (var i2 = 0; i2 < cm.display.gutterSpecs.length; ++i2) {\n        var g = display.gutters.childNodes[i2];\n        if (g && g.getBoundingClientRect().right >= mX) {\n          var line = lineAtHeight(cm.doc, mY);\n          var gutter = cm.display.gutterSpecs[i2];\n          signal(cm, type, cm, line, gutter.className, e);\n          return e_defaultPrevented(e);\n        }\n      }\n    }\n    __name(gutterEvent, "gutterEvent");\n    function clickInGutter(cm, e) {\n      return gutterEvent(cm, e, "gutterClick", true);\n    }\n    __name(clickInGutter, "clickInGutter");\n    function onContextMenu(cm, e) {\n      if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) {\n        return;\n      }\n      if (signalDOMEvent(cm, e, "contextmenu")) {\n        return;\n      }\n      if (!captureRightClick) {\n        cm.display.input.onContextMenu(e);\n      }\n    }\n    __name(onContextMenu, "onContextMenu");\n    function contextMenuInGutter(cm, e) {\n      if (!hasHandler(cm, "gutterContextMenu")) {\n        return false;\n      }\n      return gutterEvent(cm, e, "gutterContextMenu", false);\n    }\n    __name(contextMenuInGutter, "contextMenuInGutter");\n    function themeChanged(cm) {\n      cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, "") + cm.options.theme.replace(/(^|\\s)\\s*/g, " cm-s-");\n      clearCaches(cm);\n    }\n    __name(themeChanged, "themeChanged");\n    var Init = { toString: function() {\n      return "CodeMirror.Init";\n    } };\n    var defaults = {};\n    var optionHandlers = {};\n    function defineOptions(CodeMirror3) {\n      var optionHandlers2 = CodeMirror3.optionHandlers;\n      function option(name, deflt, handle, notOnInit) {\n        CodeMirror3.defaults[name] = deflt;\n        if (handle) {\n          optionHandlers2[name] = notOnInit ? function(cm, val, old) {\n            if (old != Init) {\n              handle(cm, val, old);\n            }\n          } : handle;\n        }\n      }\n      __name(option, "option");\n      CodeMirror3.defineOption = option;\n      CodeMirror3.Init = Init;\n      option("value", "", function(cm, val) {\n        return cm.setValue(val);\n      }, true);\n      option("mode", null, function(cm, val) {\n        cm.doc.modeOption = val;\n        loadMode(cm);\n      }, true);\n      option("indentUnit", 2, loadMode, true);\n      option("indentWithTabs", false);\n      option("smartIndent", true);\n      option("tabSize", 4, function(cm) {\n        resetModeState(cm);\n        clearCaches(cm);\n        regChange(cm);\n      }, true);\n      option("lineSeparator", null, function(cm, val) {\n        cm.doc.lineSep = val;\n        if (!val) {\n          return;\n        }\n        var newBreaks = [], lineNo2 = cm.doc.first;\n        cm.doc.iter(function(line) {\n          for (var pos = 0; ; ) {\n            var found = line.text.indexOf(val, pos);\n            if (found == -1) {\n              break;\n            }\n            pos = found + val.length;\n            newBreaks.push(Pos(lineNo2, found));\n          }\n          lineNo2++;\n        });\n        for (var i2 = newBreaks.length - 1; i2 >= 0; i2--) {\n          replaceRange(cm.doc, val, newBreaks[i2], Pos(newBreaks[i2].line, newBreaks[i2].ch + val.length));\n        }\n      });\n      option("specialChars", /[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u061c\\u200b\\u200e\\u200f\\u2028\\u2029\\ufeff\\ufff9-\\ufffc]/g, function(cm, val, old) {\n        cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");\n        if (old != Init) {\n          cm.refresh();\n        }\n      });\n      option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {\n        return cm.refresh();\n      }, true);\n      option("electricChars", true);\n      option("inputStyle", mobile ? "contenteditable" : "textarea", function() {\n        throw new Error("inputStyle can not (yet) be changed in a running editor");\n      }, true);\n      option("spellcheck", false, function(cm, val) {\n        return cm.getInputField().spellcheck = val;\n      }, true);\n      option("autocorrect", false, function(cm, val) {\n        return cm.getInputField().autocorrect = val;\n      }, true);\n      option("autocapitalize", false, function(cm, val) {\n        return cm.getInputField().autocapitalize = val;\n      }, true);\n      option("rtlMoveVisually", !windows);\n      option("wholeLineUpdateBefore", true);\n      option("theme", "default", function(cm) {\n        themeChanged(cm);\n        updateGutters(cm);\n      }, true);\n      option("keyMap", "default", function(cm, val, old) {\n        var next = getKeyMap(val);\n        var prev = old != Init && getKeyMap(old);\n        if (prev && prev.detach) {\n          prev.detach(cm, next);\n        }\n        if (next.attach) {\n          next.attach(cm, prev || null);\n        }\n      });\n      option("extraKeys", null);\n      option("configureMouse", null);\n      option("lineWrapping", false, wrappingChanged, true);\n      option("gutters", [], function(cm, val) {\n        cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);\n        updateGutters(cm);\n      }, true);\n      option("fixedGutter", true, function(cm, val) {\n        cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";\n        cm.refresh();\n      }, true);\n      option("coverGutterNextToScrollbar", false, function(cm) {\n        return updateScrollbars(cm);\n      }, true);\n      option("scrollbarStyle", "native", function(cm) {\n        initScrollbars(cm);\n        updateScrollbars(cm);\n        cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\n        cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\n      }, true);\n      option("lineNumbers", false, function(cm, val) {\n        cm.display.gutterSpecs = getGutters(cm.options.gutters, val);\n        updateGutters(cm);\n      }, true);\n      option("firstLineNumber", 1, updateGutters, true);\n      option("lineNumberFormatter", function(integer) {\n        return integer;\n      }, updateGutters, true);\n      option("showCursorWhenSelecting", false, updateSelection, true);\n      option("resetSelectionOnContextMenu", true);\n      option("lineWiseCopyCut", true);\n      option("pasteLinesPerSelection", true);\n      option("selectionsMayTouch", false);\n      option("readOnly", false, function(cm, val) {\n        if (val == "nocursor") {\n          onBlur(cm);\n          cm.display.input.blur();\n        }\n        cm.display.input.readOnlyChanged(val);\n      });\n      option("screenReaderLabel", null, function(cm, val) {\n        val = val === "" ? null : val;\n        cm.display.input.screenReaderLabelChanged(val);\n      });\n      option("disableInput", false, function(cm, val) {\n        if (!val) {\n          cm.display.input.reset();\n        }\n      }, true);\n      option("dragDrop", true, dragDropChanged);\n      option("allowDropFileTypes", null);\n      option("cursorBlinkRate", 530);\n      option("cursorScrollMargin", 0);\n      option("cursorHeight", 1, updateSelection, true);\n      option("singleCursorHeightPerLine", true, updateSelection, true);\n      option("workTime", 100);\n      option("workDelay", 100);\n      option("flattenSpans", true, resetModeState, true);\n      option("addModeClass", false, resetModeState, true);\n      option("pollInterval", 100);\n      option("undoDepth", 200, function(cm, val) {\n        return cm.doc.history.undoDepth = val;\n      });\n      option("historyEventDelay", 1250);\n      option("viewportMargin", 10, function(cm) {\n        return cm.refresh();\n      }, true);\n      option("maxHighlightLength", 1e4, resetModeState, true);\n      option("moveInputWithCursor", true, function(cm, val) {\n        if (!val) {\n          cm.display.input.resetPosition();\n        }\n      });\n      option("tabindex", null, function(cm, val) {\n        return cm.display.input.getField().tabIndex = val || "";\n      });\n      option("autofocus", null);\n      option("direction", "ltr", function(cm, val) {\n        return cm.doc.setDirection(val);\n      }, true);\n      option("phrases", null);\n    }\n    __name(defineOptions, "defineOptions");\n    function dragDropChanged(cm, value, old) {\n      var wasOn = old && old != Init;\n      if (!value != !wasOn) {\n        var funcs = cm.display.dragFunctions;\n        var toggle = value ? on : off;\n        toggle(cm.display.scroller, "dragstart", funcs.start);\n        toggle(cm.display.scroller, "dragenter", funcs.enter);\n        toggle(cm.display.scroller, "dragover", funcs.over);\n        toggle(cm.display.scroller, "dragleave", funcs.leave);\n        toggle(cm.display.scroller, "drop", funcs.drop);\n      }\n    }\n    __name(dragDropChanged, "dragDropChanged");\n    function wrappingChanged(cm) {\n      if (cm.options.lineWrapping) {\n        addClass(cm.display.wrapper, "CodeMirror-wrap");\n        cm.display.sizer.style.minWidth = "";\n        cm.display.sizerWidth = null;\n      } else {\n        rmClass(cm.display.wrapper, "CodeMirror-wrap");\n        findMaxLine(cm);\n      }\n      estimateLineHeights(cm);\n      regChange(cm);\n      clearCaches(cm);\n      setTimeout(function() {\n        return updateScrollbars(cm);\n      }, 100);\n    }\n    __name(wrappingChanged, "wrappingChanged");\n    function CodeMirror2(place, options) {\n      var this$1$1 = this;\n      if (!(this instanceof CodeMirror2)) {\n        return new CodeMirror2(place, options);\n      }\n      this.options = options = options ? copyObj(options) : {};\n      copyObj(defaults, options, false);\n      var doc = options.value;\n      if (typeof doc == "string") {\n        doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction);\n      } else if (options.mode) {\n        doc.modeOption = options.mode;\n      }\n      this.doc = doc;\n      var input = new CodeMirror2.inputStyles[options.inputStyle](this);\n      var display = this.display = new Display(place, doc, input, options);\n      display.wrapper.CodeMirror = this;\n      themeChanged(this);\n      if (options.lineWrapping) {\n        this.display.wrapper.className += " CodeMirror-wrap";\n      }\n      initScrollbars(this);\n      this.state = {\n        keyMaps: [],\n        overlays: [],\n        modeGen: 0,\n        overwrite: false,\n        delayingBlurEvent: false,\n        focused: false,\n        suppressEdits: false,\n        pasteIncoming: -1,\n        cutIncoming: -1,\n        selectingText: false,\n        draggingText: false,\n        highlight: new Delayed(),\n        keySeq: null,\n        specialChars: null\n      };\n      if (options.autofocus && !mobile) {\n        display.input.focus();\n      }\n      if (ie && ie_version < 11) {\n        setTimeout(function() {\n          return this$1$1.display.input.reset(true);\n        }, 20);\n      }\n      registerEventHandlers(this);\n      ensureGlobalHandlers();\n      startOperation(this);\n      this.curOp.forceUpdate = true;\n      attachDoc(this, doc);\n      if (options.autofocus && !mobile || this.hasFocus()) {\n        setTimeout(function() {\n          if (this$1$1.hasFocus() && !this$1$1.state.focused) {\n            onFocus(this$1$1);\n          }\n        }, 20);\n      } else {\n        onBlur(this);\n      }\n      for (var opt in optionHandlers) {\n        if (optionHandlers.hasOwnProperty(opt)) {\n          optionHandlers[opt](this, options[opt], Init);\n        }\n      }\n      maybeUpdateLineNumberWidth(this);\n      if (options.finishInit) {\n        options.finishInit(this);\n      }\n      for (var i2 = 0; i2 < initHooks.length; ++i2) {\n        initHooks[i2](this);\n      }\n      endOperation(this);\n      if (webkit && options.lineWrapping && getComputedStyle(display.lineDiv).textRendering == "optimizelegibility") {\n        display.lineDiv.style.textRendering = "auto";\n      }\n    }\n    __name(CodeMirror2, "CodeMirror");\n    CodeMirror2.defaults = defaults;\n    CodeMirror2.optionHandlers = optionHandlers;\n    function registerEventHandlers(cm) {\n      var d = cm.display;\n      on(d.scroller, "mousedown", operation(cm, onMouseDown));\n      if (ie && ie_version < 11) {\n        on(d.scroller, "dblclick", operation(cm, function(e) {\n          if (signalDOMEvent(cm, e)) {\n            return;\n          }\n          var pos = posFromMouse(cm, e);\n          if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) {\n            return;\n          }\n          e_preventDefault(e);\n          var word = cm.findWordAt(pos);\n          extendSelection(cm.doc, word.anchor, word.head);\n        }));\n      } else {\n        on(d.scroller, "dblclick", function(e) {\n          return signalDOMEvent(cm, e) || e_preventDefault(e);\n        });\n      }\n      on(d.scroller, "contextmenu", function(e) {\n        return onContextMenu(cm, e);\n      });\n      on(d.input.getField(), "contextmenu", function(e) {\n        if (!d.scroller.contains(e.target)) {\n          onContextMenu(cm, e);\n        }\n      });\n      var touchFinished, prevTouch = { end: 0 };\n      function finishTouch() {\n        if (d.activeTouch) {\n          touchFinished = setTimeout(function() {\n            return d.activeTouch = null;\n          }, 1e3);\n          prevTouch = d.activeTouch;\n          prevTouch.end = +new Date();\n        }\n      }\n      __name(finishTouch, "finishTouch");\n      function isMouseLikeTouchEvent(e) {\n        if (e.touches.length != 1) {\n          return false;\n        }\n        var touch = e.touches[0];\n        return touch.radiusX <= 1 && touch.radiusY <= 1;\n      }\n      __name(isMouseLikeTouchEvent, "isMouseLikeTouchEvent");\n      function farAway(touch, other) {\n        if (other.left == null) {\n          return true;\n        }\n        var dx = other.left - touch.left, dy = other.top - touch.top;\n        return dx * dx + dy * dy > 20 * 20;\n      }\n      __name(farAway, "farAway");\n      on(d.scroller, "touchstart", function(e) {\n        if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {\n          d.input.ensurePolled();\n          clearTimeout(touchFinished);\n          var now = +new Date();\n          d.activeTouch = {\n            start: now,\n            moved: false,\n            prev: now - prevTouch.end <= 300 ? prevTouch : null\n          };\n          if (e.touches.length == 1) {\n            d.activeTouch.left = e.touches[0].pageX;\n            d.activeTouch.top = e.touches[0].pageY;\n          }\n        }\n      });\n      on(d.scroller, "touchmove", function() {\n        if (d.activeTouch) {\n          d.activeTouch.moved = true;\n        }\n      });\n      on(d.scroller, "touchend", function(e) {\n        var touch = d.activeTouch;\n        if (touch && !eventInWidget(d, e) && touch.left != null && !touch.moved && new Date() - touch.start < 300) {\n          var pos = cm.coordsChar(d.activeTouch, "page"), range2;\n          if (!touch.prev || farAway(touch, touch.prev)) {\n            range2 = new Range(pos, pos);\n          } else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) {\n            range2 = cm.findWordAt(pos);\n          } else {\n            range2 = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));\n          }\n          cm.setSelection(range2.anchor, range2.head);\n          cm.focus();\n          e_preventDefault(e);\n        }\n        finishTouch();\n      });\n      on(d.scroller, "touchcancel", finishTouch);\n      on(d.scroller, "scroll", function() {\n        if (d.scroller.clientHeight) {\n          updateScrollTop(cm, d.scroller.scrollTop);\n          setScrollLeft(cm, d.scroller.scrollLeft, true);\n          signal(cm, "scroll", cm);\n        }\n      });\n      on(d.scroller, "mousewheel", function(e) {\n        return onScrollWheel(cm, e);\n      });\n      on(d.scroller, "DOMMouseScroll", function(e) {\n        return onScrollWheel(cm, e);\n      });\n      on(d.wrapper, "scroll", function() {\n        return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;\n      });\n      d.dragFunctions = {\n        enter: function(e) {\n          if (!signalDOMEvent(cm, e)) {\n            e_stop(e);\n          }\n        },\n        over: function(e) {\n          if (!signalDOMEvent(cm, e)) {\n            onDragOver(cm, e);\n            e_stop(e);\n          }\n        },\n        start: function(e) {\n          return onDragStart(cm, e);\n        },\n        drop: operation(cm, onDrop),\n        leave: function(e) {\n          if (!signalDOMEvent(cm, e)) {\n            clearDragCursor(cm);\n          }\n        }\n      };\n      var inp = d.input.getField();\n      on(inp, "keyup", function(e) {\n        return onKeyUp.call(cm, e);\n      });\n      on(inp, "keydown", operation(cm, onKeyDown));\n      on(inp, "keypress", operation(cm, onKeyPress));\n      on(inp, "focus", function(e) {\n        return onFocus(cm, e);\n      });\n      on(inp, "blur", function(e) {\n        return onBlur(cm, e);\n      });\n    }\n    __name(registerEventHandlers, "registerEventHandlers");\n    var initHooks = [];\n    CodeMirror2.defineInitHook = function(f) {\n      return initHooks.push(f);\n    };\n    function indentLine(cm, n, how, aggressive) {\n      var doc = cm.doc, state;\n      if (how == null) {\n        how = "add";\n      }\n      if (how == "smart") {\n        if (!doc.mode.indent) {\n          how = "prev";\n        } else {\n          state = getContextBefore(cm, n).state;\n        }\n      }\n      var tabSize = cm.options.tabSize;\n      var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\n      if (line.stateAfter) {\n        line.stateAfter = null;\n      }\n      var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n      if (!aggressive && !/\\S/.test(line.text)) {\n        indentation = 0;\n        how = "not";\n      } else if (how == "smart") {\n        indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n        if (indentation == Pass || indentation > 150) {\n          if (!aggressive) {\n            return;\n          }\n          how = "prev";\n        }\n      }\n      if (how == "prev") {\n        if (n > doc.first) {\n          indentation = countColumn(getLine(doc, n - 1).text, null, tabSize);\n        } else {\n          indentation = 0;\n        }\n      } else if (how == "add") {\n        indentation = curSpace + cm.options.indentUnit;\n      } else if (how == "subtract") {\n        indentation = curSpace - cm.options.indentUnit;\n      } else if (typeof how == "number") {\n        indentation = curSpace + how;\n      }\n      indentation = Math.max(0, indentation);\n      var indentString = "", pos = 0;\n      if (cm.options.indentWithTabs) {\n        for (var i2 = Math.floor(indentation / tabSize); i2; --i2) {\n          pos += tabSize;\n          indentString += "\t";\n        }\n      }\n      if (pos < indentation) {\n        indentString += spaceStr(indentation - pos);\n      }\n      if (indentString != curSpaceString) {\n        replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");\n        line.stateAfter = null;\n        return true;\n      } else {\n        for (var i$12 = 0; i$12 < doc.sel.ranges.length; i$12++) {\n          var range2 = doc.sel.ranges[i$12];\n          if (range2.head.line == n && range2.head.ch < curSpaceString.length) {\n            var pos$1 = Pos(n, curSpaceString.length);\n            replaceOneSelection(doc, i$12, new Range(pos$1, pos$1));\n            break;\n          }\n        }\n      }\n    }\n    __name(indentLine, "indentLine");\n    var lastCopied = null;\n    function setLastCopied(newLastCopied) {\n      lastCopied = newLastCopied;\n    }\n    __name(setLastCopied, "setLastCopied");\n    function applyTextInput(cm, inserted, deleted, sel, origin) {\n      var doc = cm.doc;\n      cm.display.shift = false;\n      if (!sel) {\n        sel = doc.sel;\n      }\n      var recent = +new Date() - 200;\n      var paste = origin == "paste" || cm.state.pasteIncoming > recent;\n      var textLines = splitLinesAuto(inserted), multiPaste = null;\n      if (paste && sel.ranges.length > 1) {\n        if (lastCopied && lastCopied.text.join("\\n") == inserted) {\n          if (sel.ranges.length % lastCopied.text.length == 0) {\n            multiPaste = [];\n            for (var i2 = 0; i2 < lastCopied.text.length; i2++) {\n              multiPaste.push(doc.splitLines(lastCopied.text[i2]));\n            }\n          }\n        } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {\n          multiPaste = map(textLines, function(l) {\n            return [l];\n          });\n        }\n      }\n      var updateInput = cm.curOp.updateInput;\n      for (var i$12 = sel.ranges.length - 1; i$12 >= 0; i$12--) {\n        var range2 = sel.ranges[i$12];\n        var from = range2.from(), to = range2.to();\n        if (range2.empty()) {\n          if (deleted && deleted > 0) {\n            from = Pos(from.line, from.ch - deleted);\n          } else if (cm.state.overwrite && !paste) {\n            to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));\n          } else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join("\\n") == textLines.join("\\n")) {\n            from = to = Pos(from.line, 0);\n          }\n        }\n        var changeEvent = {\n          from,\n          to,\n          text: multiPaste ? multiPaste[i$12 % multiPaste.length] : textLines,\n          origin: origin || (paste ? "paste" : cm.state.cutIncoming > recent ? "cut" : "+input")\n        };\n        makeChange(cm.doc, changeEvent);\n        signalLater(cm, "inputRead", cm, changeEvent);\n      }\n      if (inserted && !paste) {\n        triggerElectric(cm, inserted);\n      }\n      ensureCursorVisible(cm);\n      if (cm.curOp.updateInput < 2) {\n        cm.curOp.updateInput = updateInput;\n      }\n      cm.curOp.typing = true;\n      cm.state.pasteIncoming = cm.state.cutIncoming = -1;\n    }\n    __name(applyTextInput, "applyTextInput");\n    function handlePaste(e, cm) {\n      var pasted = e.clipboardData && e.clipboardData.getData("Text");\n      if (pasted) {\n        e.preventDefault();\n        if (!cm.isReadOnly() && !cm.options.disableInput) {\n          runInOp(cm, function() {\n            return applyTextInput(cm, pasted, 0, null, "paste");\n          });\n        }\n        return true;\n      }\n    }\n    __name(handlePaste, "handlePaste");\n    function triggerElectric(cm, inserted) {\n      if (!cm.options.electricChars || !cm.options.smartIndent) {\n        return;\n      }\n      var sel = cm.doc.sel;\n      for (var i2 = sel.ranges.length - 1; i2 >= 0; i2--) {\n        var range2 = sel.ranges[i2];\n        if (range2.head.ch > 100 || i2 && sel.ranges[i2 - 1].head.line == range2.head.line) {\n          continue;\n        }\n        var mode = cm.getModeAt(range2.head);\n        var indented = false;\n        if (mode.electricChars) {\n          for (var j = 0; j < mode.electricChars.length; j++) {\n            if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\n              indented = indentLine(cm, range2.head.line, "smart");\n              break;\n            }\n          }\n        } else if (mode.electricInput) {\n          if (mode.electricInput.test(getLine(cm.doc, range2.head.line).text.slice(0, range2.head.ch))) {\n            indented = indentLine(cm, range2.head.line, "smart");\n          }\n        }\n        if (indented) {\n          signalLater(cm, "electricInput", cm, range2.head.line);\n        }\n      }\n    }\n    __name(triggerElectric, "triggerElectric");\n    function copyableRanges(cm) {\n      var text = [], ranges = [];\n      for (var i2 = 0; i2 < cm.doc.sel.ranges.length; i2++) {\n        var line = cm.doc.sel.ranges[i2].head.line;\n        var lineRange = { anchor: Pos(line, 0), head: Pos(line + 1, 0) };\n        ranges.push(lineRange);\n        text.push(cm.getRange(lineRange.anchor, lineRange.head));\n      }\n      return { text, ranges };\n    }\n    __name(copyableRanges, "copyableRanges");\n    function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {\n      field.setAttribute("autocorrect", autocorrect ? "" : "off");\n      field.setAttribute("autocapitalize", autocapitalize ? "" : "off");\n      field.setAttribute("spellcheck", !!spellcheck);\n    }\n    __name(disableBrowserMagic, "disableBrowserMagic");\n    function hiddenTextarea() {\n      var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; min-height: 1em; outline: none");\n      var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");\n      if (webkit) {\n        te.style.width = "1000px";\n      } else {\n        te.setAttribute("wrap", "off");\n      }\n      if (ios) {\n        te.style.border = "1px solid black";\n      }\n      disableBrowserMagic(te);\n      return div;\n    }\n    __name(hiddenTextarea, "hiddenTextarea");\n    function addEditorMethods(CodeMirror3) {\n      var optionHandlers2 = CodeMirror3.optionHandlers;\n      var helpers = CodeMirror3.helpers = {};\n      CodeMirror3.prototype = {\n        constructor: CodeMirror3,\n        focus: function() {\n          window.focus();\n          this.display.input.focus();\n        },\n        setOption: function(option, value) {\n          var options = this.options, old = options[option];\n          if (options[option] == value && option != "mode") {\n            return;\n          }\n          options[option] = value;\n          if (optionHandlers2.hasOwnProperty(option)) {\n            operation(this, optionHandlers2[option])(this, value, old);\n          }\n          signal(this, "optionChange", this, option);\n        },\n        getOption: function(option) {\n          return this.options[option];\n        },\n        getDoc: function() {\n          return this.doc;\n        },\n        addKeyMap: function(map2, bottom) {\n          this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map2));\n        },\n        removeKeyMap: function(map2) {\n          var maps = this.state.keyMaps;\n          for (var i2 = 0; i2 < maps.length; ++i2) {\n            if (maps[i2] == map2 || maps[i2].name == map2) {\n              maps.splice(i2, 1);\n              return true;\n            }\n          }\n        },\n        addOverlay: methodOp(function(spec, options) {\n          var mode = spec.token ? spec : CodeMirror3.getMode(this.options, spec);\n          if (mode.startState) {\n            throw new Error("Overlays may not be stateful.");\n          }\n          insertSorted(this.state.overlays, {\n            mode,\n            modeSpec: spec,\n            opaque: options && options.opaque,\n            priority: options && options.priority || 0\n          }, function(overlay) {\n            return overlay.priority;\n          });\n          this.state.modeGen++;\n          regChange(this);\n        }),\n        removeOverlay: methodOp(function(spec) {\n          var overlays = this.state.overlays;\n          for (var i2 = 0; i2 < overlays.length; ++i2) {\n            var cur = overlays[i2].modeSpec;\n            if (cur == spec || typeof spec == "string" && cur.name == spec) {\n              overlays.splice(i2, 1);\n              this.state.modeGen++;\n              regChange(this);\n              return;\n            }\n          }\n        }),\n        indentLine: methodOp(function(n, dir, aggressive) {\n          if (typeof dir != "string" && typeof dir != "number") {\n            if (dir == null) {\n              dir = this.options.smartIndent ? "smart" : "prev";\n            } else {\n              dir = dir ? "add" : "subtract";\n            }\n          }\n          if (isLine(this.doc, n)) {\n            indentLine(this, n, dir, aggressive);\n          }\n        }),\n        indentSelection: methodOp(function(how) {\n          var ranges = this.doc.sel.ranges, end = -1;\n          for (var i2 = 0; i2 < ranges.length; i2++) {\n            var range2 = ranges[i2];\n            if (!range2.empty()) {\n              var from = range2.from(), to = range2.to();\n              var start = Math.max(end, from.line);\n              end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\n              for (var j = start; j < end; ++j) {\n                indentLine(this, j, how);\n              }\n              var newRanges = this.doc.sel.ranges;\n              if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i2].from().ch > 0) {\n                replaceOneSelection(this.doc, i2, new Range(from, newRanges[i2].to()), sel_dontScroll);\n              }\n            } else if (range2.head.line > end) {\n              indentLine(this, range2.head.line, how, true);\n              end = range2.head.line;\n              if (i2 == this.doc.sel.primIndex) {\n                ensureCursorVisible(this);\n              }\n            }\n          }\n        }),\n        getTokenAt: function(pos, precise) {\n          return takeToken(this, pos, precise);\n        },\n        getLineTokens: function(line, precise) {\n          return takeToken(this, Pos(line), precise, true);\n        },\n        getTokenTypeAt: function(pos) {\n          pos = clipPos(this.doc, pos);\n          var styles = getLineStyles(this, getLine(this.doc, pos.line));\n          var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\n          var type;\n          if (ch == 0) {\n            type = styles[2];\n          } else {\n            for (; ; ) {\n              var mid = before + after >> 1;\n              if ((mid ? styles[mid * 2 - 1] : 0) >= ch) {\n                after = mid;\n              } else if (styles[mid * 2 + 1] < ch) {\n                before = mid + 1;\n              } else {\n                type = styles[mid * 2 + 2];\n                break;\n              }\n            }\n          }\n          var cut = type ? type.indexOf("overlay ") : -1;\n          return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);\n        },\n        getModeAt: function(pos) {\n          var mode = this.doc.mode;\n          if (!mode.innerMode) {\n            return mode;\n          }\n          return CodeMirror3.innerMode(mode, this.getTokenAt(pos).state).mode;\n        },\n        getHelper: function(pos, type) {\n          return this.getHelpers(pos, type)[0];\n        },\n        getHelpers: function(pos, type) {\n          var found = [];\n          if (!helpers.hasOwnProperty(type)) {\n            return found;\n          }\n          var help = helpers[type], mode = this.getModeAt(pos);\n          if (typeof mode[type] == "string") {\n            if (help[mode[type]]) {\n              found.push(help[mode[type]]);\n            }\n          } else if (mode[type]) {\n            for (var i2 = 0; i2 < mode[type].length; i2++) {\n              var val = help[mode[type][i2]];\n              if (val) {\n                found.push(val);\n              }\n            }\n          } else if (mode.helperType && help[mode.helperType]) {\n            found.push(help[mode.helperType]);\n          } else if (help[mode.name]) {\n            found.push(help[mode.name]);\n          }\n          for (var i$12 = 0; i$12 < help._global.length; i$12++) {\n            var cur = help._global[i$12];\n            if (cur.pred(mode, this) && indexOf(found, cur.val) == -1) {\n              found.push(cur.val);\n            }\n          }\n          return found;\n        },\n        getStateAfter: function(line, precise) {\n          var doc = this.doc;\n          line = clipLine(doc, line == null ? doc.first + doc.size - 1 : line);\n          return getContextBefore(this, line + 1, precise).state;\n        },\n        cursorCoords: function(start, mode) {\n          var pos, range2 = this.doc.sel.primary();\n          if (start == null) {\n            pos = range2.head;\n          } else if (typeof start == "object") {\n            pos = clipPos(this.doc, start);\n          } else {\n            pos = start ? range2.from() : range2.to();\n          }\n          return cursorCoords(this, pos, mode || "page");\n        },\n        charCoords: function(pos, mode) {\n          return charCoords(this, clipPos(this.doc, pos), mode || "page");\n        },\n        coordsChar: function(coords, mode) {\n          coords = fromCoordSystem(this, coords, mode || "page");\n          return coordsChar(this, coords.left, coords.top);\n        },\n        lineAtHeight: function(height, mode) {\n          height = fromCoordSystem(this, { top: height, left: 0 }, mode || "page").top;\n          return lineAtHeight(this.doc, height + this.display.viewOffset);\n        },\n        heightAtLine: function(line, mode, includeWidgets) {\n          var end = false, lineObj;\n          if (typeof line == "number") {\n            var last = this.doc.first + this.doc.size - 1;\n            if (line < this.doc.first) {\n              line = this.doc.first;\n            } else if (line > last) {\n              line = last;\n              end = true;\n            }\n            lineObj = getLine(this.doc, line);\n          } else {\n            lineObj = line;\n          }\n          return intoCoordSystem(this, lineObj, { top: 0, left: 0 }, mode || "page", includeWidgets || end).top + (end ? this.doc.height - heightAtLine(lineObj) : 0);\n        },\n        defaultTextHeight: function() {\n          return textHeight(this.display);\n        },\n        defaultCharWidth: function() {\n          return charWidth(this.display);\n        },\n        getViewport: function() {\n          return { from: this.display.viewFrom, to: this.display.viewTo };\n        },\n        addWidget: function(pos, node, scroll, vert, horiz) {\n          var display = this.display;\n          pos = cursorCoords(this, clipPos(this.doc, pos));\n          var top = pos.bottom, left = pos.left;\n          node.style.position = "absolute";\n          node.setAttribute("cm-ignore-events", "true");\n          this.display.input.setUneditable(node);\n          display.sizer.appendChild(node);\n          if (vert == "over") {\n            top = pos.top;\n          } else if (vert == "above" || vert == "near") {\n            var vspace = Math.max(display.wrapper.clientHeight, this.doc.height), hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n            if ((vert == "above" || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight) {\n              top = pos.top - node.offsetHeight;\n            } else if (pos.bottom + node.offsetHeight <= vspace) {\n              top = pos.bottom;\n            }\n            if (left + node.offsetWidth > hspace) {\n              left = hspace - node.offsetWidth;\n            }\n          }\n          node.style.top = top + "px";\n          node.style.left = node.style.right = "";\n          if (horiz == "right") {\n            left = display.sizer.clientWidth - node.offsetWidth;\n            node.style.right = "0px";\n          } else {\n            if (horiz == "left") {\n              left = 0;\n            } else if (horiz == "middle") {\n              left = (display.sizer.clientWidth - node.offsetWidth) / 2;\n            }\n            node.style.left = left + "px";\n          }\n          if (scroll) {\n            scrollIntoView(this, { left, top, right: left + node.offsetWidth, bottom: top + node.offsetHeight });\n          }\n        },\n        triggerOnKeyDown: methodOp(onKeyDown),\n        triggerOnKeyPress: methodOp(onKeyPress),\n        triggerOnKeyUp: onKeyUp,\n        triggerOnMouseDown: methodOp(onMouseDown),\n        execCommand: function(cmd) {\n          if (commands.hasOwnProperty(cmd)) {\n            return commands[cmd].call(null, this);\n          }\n        },\n        triggerElectric: methodOp(function(text) {\n          triggerElectric(this, text);\n        }),\n        findPosH: function(from, amount, unit, visually) {\n          var dir = 1;\n          if (amount < 0) {\n            dir = -1;\n            amount = -amount;\n          }\n          var cur = clipPos(this.doc, from);\n          for (var i2 = 0; i2 < amount; ++i2) {\n            cur = findPosH(this.doc, cur, dir, unit, visually);\n            if (cur.hitSide) {\n              break;\n            }\n          }\n          return cur;\n        },\n        moveH: methodOp(function(dir, unit) {\n          var this$1$1 = this;\n          this.extendSelectionsBy(function(range2) {\n            if (this$1$1.display.shift || this$1$1.doc.extend || range2.empty()) {\n              return findPosH(this$1$1.doc, range2.head, dir, unit, this$1$1.options.rtlMoveVisually);\n            } else {\n              return dir < 0 ? range2.from() : range2.to();\n            }\n          }, sel_move);\n        }),\n        deleteH: methodOp(function(dir, unit) {\n          var sel = this.doc.sel, doc = this.doc;\n          if (sel.somethingSelected()) {\n            doc.replaceSelection("", null, "+delete");\n          } else {\n            deleteNearSelection(this, function(range2) {\n              var other = findPosH(doc, range2.head, dir, unit, false);\n              return dir < 0 ? { from: other, to: range2.head } : { from: range2.head, to: other };\n            });\n          }\n        }),\n        findPosV: function(from, amount, unit, goalColumn) {\n          var dir = 1, x = goalColumn;\n          if (amount < 0) {\n            dir = -1;\n            amount = -amount;\n          }\n          var cur = clipPos(this.doc, from);\n          for (var i2 = 0; i2 < amount; ++i2) {\n            var coords = cursorCoords(this, cur, "div");\n            if (x == null) {\n              x = coords.left;\n            } else {\n              coords.left = x;\n            }\n            cur = findPosV(this, coords, dir, unit);\n            if (cur.hitSide) {\n              break;\n            }\n          }\n          return cur;\n        },\n        moveV: methodOp(function(dir, unit) {\n          var this$1$1 = this;\n          var doc = this.doc, goals = [];\n          var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();\n          doc.extendSelectionsBy(function(range2) {\n            if (collapse) {\n              return dir < 0 ? range2.from() : range2.to();\n            }\n            var headPos = cursorCoords(this$1$1, range2.head, "div");\n            if (range2.goalColumn != null) {\n              headPos.left = range2.goalColumn;\n            }\n            goals.push(headPos.left);\n            var pos = findPosV(this$1$1, headPos, dir, unit);\n            if (unit == "page" && range2 == doc.sel.primary()) {\n              addToScrollTop(this$1$1, charCoords(this$1$1, pos, "div").top - headPos.top);\n            }\n            return pos;\n          }, sel_move);\n          if (goals.length) {\n            for (var i2 = 0; i2 < doc.sel.ranges.length; i2++) {\n              doc.sel.ranges[i2].goalColumn = goals[i2];\n            }\n          }\n        }),\n        findWordAt: function(pos) {\n          var doc = this.doc, line = getLine(doc, pos.line).text;\n          var start = pos.ch, end = pos.ch;\n          if (line) {\n            var helper = this.getHelper(pos, "wordChars");\n            if ((pos.sticky == "before" || end == line.length) && start) {\n              --start;\n            } else {\n              ++end;\n            }\n            var startChar = line.charAt(start);\n            var check = isWordChar(startChar, helper) ? function(ch) {\n              return isWordChar(ch, helper);\n            } : /\\s/.test(startChar) ? function(ch) {\n              return /\\s/.test(ch);\n            } : function(ch) {\n              return !/\\s/.test(ch) && !isWordChar(ch);\n            };\n            while (start > 0 && check(line.charAt(start - 1))) {\n              --start;\n            }\n            while (end < line.length && check(line.charAt(end))) {\n              ++end;\n            }\n          }\n          return new Range(Pos(pos.line, start), Pos(pos.line, end));\n        },\n        toggleOverwrite: function(value) {\n          if (value != null && value == this.state.overwrite) {\n            return;\n          }\n          if (this.state.overwrite = !this.state.overwrite) {\n            addClass(this.display.cursorDiv, "CodeMirror-overwrite");\n          } else {\n            rmClass(this.display.cursorDiv, "CodeMirror-overwrite");\n          }\n          signal(this, "overwriteToggle", this, this.state.overwrite);\n        },\n        hasFocus: function() {\n          return this.display.input.getField() == activeElt();\n        },\n        isReadOnly: function() {\n          return !!(this.options.readOnly || this.doc.cantEdit);\n        },\n        scrollTo: methodOp(function(x, y) {\n          scrollToCoords(this, x, y);\n        }),\n        getScrollInfo: function() {\n          var scroller = this.display.scroller;\n          return {\n            left: scroller.scrollLeft,\n            top: scroller.scrollTop,\n            height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\n            width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\n            clientHeight: displayHeight(this),\n            clientWidth: displayWidth(this)\n          };\n        },\n        scrollIntoView: methodOp(function(range2, margin) {\n          if (range2 == null) {\n            range2 = { from: this.doc.sel.primary().head, to: null };\n            if (margin == null) {\n              margin = this.options.cursorScrollMargin;\n            }\n          } else if (typeof range2 == "number") {\n            range2 = { from: Pos(range2, 0), to: null };\n          } else if (range2.from == null) {\n            range2 = { from: range2, to: null };\n          }\n          if (!range2.to) {\n            range2.to = range2.from;\n          }\n          range2.margin = margin || 0;\n          if (range2.from.line != null) {\n            scrollToRange(this, range2);\n          } else {\n            scrollToCoordsRange(this, range2.from, range2.to, range2.margin);\n          }\n        }),\n        setSize: methodOp(function(width, height) {\n          var this$1$1 = this;\n          var interpret = /* @__PURE__ */ __name(function(val) {\n            return typeof val == "number" || /^\\d+$/.test(String(val)) ? val + "px" : val;\n          }, "interpret");\n          if (width != null) {\n            this.display.wrapper.style.width = interpret(width);\n          }\n          if (height != null) {\n            this.display.wrapper.style.height = interpret(height);\n          }\n          if (this.options.lineWrapping) {\n            clearLineMeasurementCache(this);\n          }\n          var lineNo2 = this.display.viewFrom;\n          this.doc.iter(lineNo2, this.display.viewTo, function(line) {\n            if (line.widgets) {\n              for (var i2 = 0; i2 < line.widgets.length; i2++) {\n                if (line.widgets[i2].noHScroll) {\n                  regLineChange(this$1$1, lineNo2, "widget");\n                  break;\n                }\n              }\n            }\n            ++lineNo2;\n          });\n          this.curOp.forceUpdate = true;\n          signal(this, "refresh", this);\n        }),\n        operation: function(f) {\n          return runInOp(this, f);\n        },\n        startOperation: function() {\n          return startOperation(this);\n        },\n        endOperation: function() {\n          return endOperation(this);\n        },\n        refresh: methodOp(function() {\n          var oldHeight = this.display.cachedTextHeight;\n          regChange(this);\n          this.curOp.forceUpdate = true;\n          clearCaches(this);\n          scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);\n          updateGutterSpace(this.display);\n          if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > 0.5 || this.options.lineWrapping) {\n            estimateLineHeights(this);\n          }\n          signal(this, "refresh", this);\n        }),\n        swapDoc: methodOp(function(doc) {\n          var old = this.doc;\n          old.cm = null;\n          if (this.state.selectingText) {\n            this.state.selectingText();\n          }\n          attachDoc(this, doc);\n          clearCaches(this);\n          this.display.input.reset();\n          scrollToCoords(this, doc.scrollLeft, doc.scrollTop);\n          this.curOp.forceScroll = true;\n          signalLater(this, "swapDoc", this, old);\n          return old;\n        }),\n        phrase: function(phraseText) {\n          var phrases = this.options.phrases;\n          return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText;\n        },\n        getInputField: function() {\n          return this.display.input.getField();\n        },\n        getWrapperElement: function() {\n          return this.display.wrapper;\n        },\n        getScrollerElement: function() {\n          return this.display.scroller;\n        },\n        getGutterElement: function() {\n          return this.display.gutters;\n        }\n      };\n      eventMixin(CodeMirror3);\n      CodeMirror3.registerHelper = function(type, name, value) {\n        if (!helpers.hasOwnProperty(type)) {\n          helpers[type] = CodeMirror3[type] = { _global: [] };\n        }\n        helpers[type][name] = value;\n      };\n      CodeMirror3.registerGlobalHelper = function(type, name, predicate, value) {\n        CodeMirror3.registerHelper(type, name, value);\n        helpers[type]._global.push({ pred: predicate, val: value });\n      };\n    }\n    __name(addEditorMethods, "addEditorMethods");\n    function findPosH(doc, pos, dir, unit, visually) {\n      var oldPos = pos;\n      var origDir = dir;\n      var lineObj = getLine(doc, pos.line);\n      var lineDir = visually && doc.direction == "rtl" ? -dir : dir;\n      function findNextLine() {\n        var l = pos.line + lineDir;\n        if (l < doc.first || l >= doc.first + doc.size) {\n          return false;\n        }\n        pos = new Pos(l, pos.ch, pos.sticky);\n        return lineObj = getLine(doc, l);\n      }\n      __name(findNextLine, "findNextLine");\n      function moveOnce(boundToLine) {\n        var next;\n        if (unit == "codepoint") {\n          var ch = lineObj.text.charCodeAt(pos.ch + (dir > 0 ? 0 : -1));\n          if (isNaN(ch)) {\n            next = null;\n          } else {\n            var astral = dir > 0 ? ch >= 55296 && ch < 56320 : ch >= 56320 && ch < 57343;\n            next = new Pos(pos.line, Math.max(0, Math.min(lineObj.text.length, pos.ch + dir * (astral ? 2 : 1))), -dir);\n          }\n        } else if (visually) {\n          next = moveVisually(doc.cm, lineObj, pos, dir);\n        } else {\n          next = moveLogically(lineObj, pos, dir);\n        }\n        if (next == null) {\n          if (!boundToLine && findNextLine()) {\n            pos = endOfLine(visually, doc.cm, lineObj, pos.line, lineDir);\n          } else {\n            return false;\n          }\n        } else {\n          pos = next;\n        }\n        return true;\n      }\n      __name(moveOnce, "moveOnce");\n      if (unit == "char" || unit == "codepoint") {\n        moveOnce();\n      } else if (unit == "column") {\n        moveOnce(true);\n      } else if (unit == "word" || unit == "group") {\n        var sawType = null, group = unit == "group";\n        var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");\n        for (var first = true; ; first = false) {\n          if (dir < 0 && !moveOnce(!first)) {\n            break;\n          }\n          var cur = lineObj.text.charAt(pos.ch) || "\\n";\n          var type = isWordChar(cur, helper) ? "w" : group && cur == "\\n" ? "n" : !group || /\\s/.test(cur) ? null : "p";\n          if (group && !first && !type) {\n            type = "s";\n          }\n          if (sawType && sawType != type) {\n            if (dir < 0) {\n              dir = 1;\n              moveOnce();\n              pos.sticky = "after";\n            }\n            break;\n          }\n          if (type) {\n            sawType = type;\n          }\n          if (dir > 0 && !moveOnce(!first)) {\n            break;\n          }\n        }\n      }\n      var result = skipAtomic(doc, pos, oldPos, origDir, true);\n      if (equalCursorPos(oldPos, result)) {\n        result.hitSide = true;\n      }\n      return result;\n    }\n    __name(findPosH, "findPosH");\n    function findPosV(cm, pos, dir, unit) {\n      var doc = cm.doc, x = pos.left, y;\n      if (unit == "page") {\n        var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n        var moveAmount = Math.max(pageSize - 0.5 * textHeight(cm.display), 3);\n        y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;\n      } else if (unit == "line") {\n        y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n      }\n      var target;\n      for (; ; ) {\n        target = coordsChar(cm, x, y);\n        if (!target.outside) {\n          break;\n        }\n        if (dir < 0 ? y <= 0 : y >= doc.height) {\n          target.hitSide = true;\n          break;\n        }\n        y += dir * 5;\n      }\n      return target;\n    }\n    __name(findPosV, "findPosV");\n    var ContentEditableInput = /* @__PURE__ */ __name(function(cm) {\n      this.cm = cm;\n      this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\n      this.polling = new Delayed();\n      this.composing = null;\n      this.gracePeriod = false;\n      this.readDOMTimeout = null;\n    }, "ContentEditableInput");\n    ContentEditableInput.prototype.init = function(display) {\n      var this$1$1 = this;\n      var input = this, cm = input.cm;\n      var div = input.div = display.lineDiv;\n      div.contentEditable = true;\n      disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);\n      function belongsToInput(e) {\n        for (var t = e.target; t; t = t.parentNode) {\n          if (t == div) {\n            return true;\n          }\n          if (/\\bCodeMirror-(?:line)?widget\\b/.test(t.className)) {\n            break;\n          }\n        }\n        return false;\n      }\n      __name(belongsToInput, "belongsToInput");\n      on(div, "paste", function(e) {\n        if (!belongsToInput(e) || signalDOMEvent(cm, e) || handlePaste(e, cm)) {\n          return;\n        }\n        if (ie_version <= 11) {\n          setTimeout(operation(cm, function() {\n            return this$1$1.updateFromDOM();\n          }), 20);\n        }\n      });\n      on(div, "compositionstart", function(e) {\n        this$1$1.composing = { data: e.data, done: false };\n      });\n      on(div, "compositionupdate", function(e) {\n        if (!this$1$1.composing) {\n          this$1$1.composing = { data: e.data, done: false };\n        }\n      });\n      on(div, "compositionend", function(e) {\n        if (this$1$1.composing) {\n          if (e.data != this$1$1.composing.data) {\n            this$1$1.readFromDOMSoon();\n          }\n          this$1$1.composing.done = true;\n        }\n      });\n      on(div, "touchstart", function() {\n        return input.forceCompositionEnd();\n      });\n      on(div, "input", function() {\n        if (!this$1$1.composing) {\n          this$1$1.readFromDOMSoon();\n        }\n      });\n      function onCopyCut(e) {\n        if (!belongsToInput(e) || signalDOMEvent(cm, e)) {\n          return;\n        }\n        if (cm.somethingSelected()) {\n          setLastCopied({ lineWise: false, text: cm.getSelections() });\n          if (e.type == "cut") {\n            cm.replaceSelection("", null, "cut");\n          }\n        } else if (!cm.options.lineWiseCopyCut) {\n          return;\n        } else {\n          var ranges = copyableRanges(cm);\n          setLastCopied({ lineWise: true, text: ranges.text });\n          if (e.type == "cut") {\n            cm.operation(function() {\n              cm.setSelections(ranges.ranges, 0, sel_dontScroll);\n              cm.replaceSelection("", null, "cut");\n            });\n          }\n        }\n        if (e.clipboardData) {\n          e.clipboardData.clearData();\n          var content = lastCopied.text.join("\\n");\n          e.clipboardData.setData("Text", content);\n          if (e.clipboardData.getData("Text") == content) {\n            e.preventDefault();\n            return;\n          }\n        }\n        var kludge = hiddenTextarea(), te = kludge.firstChild;\n        cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\n        te.value = lastCopied.text.join("\\n");\n        var hadFocus = activeElt();\n        selectInput(te);\n        setTimeout(function() {\n          cm.display.lineSpace.removeChild(kludge);\n          hadFocus.focus();\n          if (hadFocus == div) {\n            input.showPrimarySelection();\n          }\n        }, 50);\n      }\n      __name(onCopyCut, "onCopyCut");\n      on(div, "copy", onCopyCut);\n      on(div, "cut", onCopyCut);\n    };\n    ContentEditableInput.prototype.screenReaderLabelChanged = function(label) {\n      if (label) {\n        this.div.setAttribute("aria-label", label);\n      } else {\n        this.div.removeAttribute("aria-label");\n      }\n    };\n    ContentEditableInput.prototype.prepareSelection = function() {\n      var result = prepareSelection(this.cm, false);\n      result.focus = activeElt() == this.div;\n      return result;\n    };\n    ContentEditableInput.prototype.showSelection = function(info, takeFocus) {\n      if (!info || !this.cm.display.view.length) {\n        return;\n      }\n      if (info.focus || takeFocus) {\n        this.showPrimarySelection();\n      }\n      this.showMultipleSelections(info);\n    };\n    ContentEditableInput.prototype.getSelection = function() {\n      return this.cm.display.wrapper.ownerDocument.getSelection();\n    };\n    ContentEditableInput.prototype.showPrimarySelection = function() {\n      var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();\n      var from = prim.from(), to = prim.to();\n      if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {\n        sel.removeAllRanges();\n        return;\n      }\n      var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n      var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);\n      if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad && cmp(minPos(curAnchor, curFocus), from) == 0 && cmp(maxPos(curAnchor, curFocus), to) == 0) {\n        return;\n      }\n      var view = cm.display.view;\n      var start = from.line >= cm.display.viewFrom && posToDOM(cm, from) || { node: view[0].measure.map[2], offset: 0 };\n      var end = to.line < cm.display.viewTo && posToDOM(cm, to);\n      if (!end) {\n        var measure = view[view.length - 1].measure;\n        var map2 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\n        end = { node: map2[map2.length - 1], offset: map2[map2.length - 2] - map2[map2.length - 3] };\n      }\n      if (!start || !end) {\n        sel.removeAllRanges();\n        return;\n      }\n      var old = sel.rangeCount && sel.getRangeAt(0), rng;\n      try {\n        rng = range(start.node, start.offset, end.offset, end.node);\n      } catch (e) {\n      }\n      if (rng) {\n        if (!gecko && cm.state.focused) {\n          sel.collapse(start.node, start.offset);\n          if (!rng.collapsed) {\n            sel.removeAllRanges();\n            sel.addRange(rng);\n          }\n        } else {\n          sel.removeAllRanges();\n          sel.addRange(rng);\n        }\n        if (old && sel.anchorNode == null) {\n          sel.addRange(old);\n        } else if (gecko) {\n          this.startGracePeriod();\n        }\n      }\n      this.rememberSelection();\n    };\n    ContentEditableInput.prototype.startGracePeriod = function() {\n      var this$1$1 = this;\n      clearTimeout(this.gracePeriod);\n      this.gracePeriod = setTimeout(function() {\n        this$1$1.gracePeriod = false;\n        if (this$1$1.selectionChanged()) {\n          this$1$1.cm.operation(function() {\n            return this$1$1.cm.curOp.selectionChanged = true;\n          });\n        }\n      }, 20);\n    };\n    ContentEditableInput.prototype.showMultipleSelections = function(info) {\n      removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\n      removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\n    };\n    ContentEditableInput.prototype.rememberSelection = function() {\n      var sel = this.getSelection();\n      this.lastAnchorNode = sel.anchorNode;\n      this.lastAnchorOffset = sel.anchorOffset;\n      this.lastFocusNode = sel.focusNode;\n      this.lastFocusOffset = sel.focusOffset;\n    };\n    ContentEditableInput.prototype.selectionInEditor = function() {\n      var sel = this.getSelection();\n      if (!sel.rangeCount) {\n        return false;\n      }\n      var node = sel.getRangeAt(0).commonAncestorContainer;\n      return contains(this.div, node);\n    };\n    ContentEditableInput.prototype.focus = function() {\n      if (this.cm.options.readOnly != "nocursor") {\n        if (!this.selectionInEditor() || activeElt() != this.div) {\n          this.showSelection(this.prepareSelection(), true);\n        }\n        this.div.focus();\n      }\n    };\n    ContentEditableInput.prototype.blur = function() {\n      this.div.blur();\n    };\n    ContentEditableInput.prototype.getField = function() {\n      return this.div;\n    };\n    ContentEditableInput.prototype.supportsTouch = function() {\n      return true;\n    };\n    ContentEditableInput.prototype.receivedFocus = function() {\n      var this$1$1 = this;\n      var input = this;\n      if (this.selectionInEditor()) {\n        setTimeout(function() {\n          return this$1$1.pollSelection();\n        }, 20);\n      } else {\n        runInOp(this.cm, function() {\n          return input.cm.curOp.selectionChanged = true;\n        });\n      }\n      function poll() {\n        if (input.cm.state.focused) {\n          input.pollSelection();\n          input.polling.set(input.cm.options.pollInterval, poll);\n        }\n      }\n      __name(poll, "poll");\n      this.polling.set(this.cm.options.pollInterval, poll);\n    };\n    ContentEditableInput.prototype.selectionChanged = function() {\n      var sel = this.getSelection();\n      return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;\n    };\n    ContentEditableInput.prototype.pollSelection = function() {\n      if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) {\n        return;\n      }\n      var sel = this.getSelection(), cm = this.cm;\n      if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {\n        this.cm.triggerOnKeyDown({ type: "keydown", keyCode: 8, preventDefault: Math.abs });\n        this.blur();\n        this.focus();\n        return;\n      }\n      if (this.composing) {\n        return;\n      }\n      this.rememberSelection();\n      var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n      var head = domToPos(cm, sel.focusNode, sel.focusOffset);\n      if (anchor && head) {\n        runInOp(cm, function() {\n          setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\n          if (anchor.bad || head.bad) {\n            cm.curOp.selectionChanged = true;\n          }\n        });\n      }\n    };\n    ContentEditableInput.prototype.pollContent = function() {\n      if (this.readDOMTimeout != null) {\n        clearTimeout(this.readDOMTimeout);\n        this.readDOMTimeout = null;\n      }\n      var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\n      var from = sel.from(), to = sel.to();\n      if (from.ch == 0 && from.line > cm.firstLine()) {\n        from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length);\n      }\n      if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine()) {\n        to = Pos(to.line + 1, 0);\n      }\n      if (from.line < display.viewFrom || to.line > display.viewTo - 1) {\n        return false;\n      }\n      var fromIndex, fromLine, fromNode;\n      if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\n        fromLine = lineNo(display.view[0].line);\n        fromNode = display.view[0].node;\n      } else {\n        fromLine = lineNo(display.view[fromIndex].line);\n        fromNode = display.view[fromIndex - 1].node.nextSibling;\n      }\n      var toIndex = findViewIndex(cm, to.line);\n      var toLine, toNode;\n      if (toIndex == display.view.length - 1) {\n        toLine = display.viewTo - 1;\n        toNode = display.lineDiv.lastChild;\n      } else {\n        toLine = lineNo(display.view[toIndex + 1].line) - 1;\n        toNode = display.view[toIndex + 1].node.previousSibling;\n      }\n      if (!fromNode) {\n        return false;\n      }\n      var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\n      var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\n      while (newText.length > 1 && oldText.length > 1) {\n        if (lst(newText) == lst(oldText)) {\n          newText.pop();\n          oldText.pop();\n          toLine--;\n        } else if (newText[0] == oldText[0]) {\n          newText.shift();\n          oldText.shift();\n          fromLine++;\n        } else {\n          break;\n        }\n      }\n      var cutFront = 0, cutEnd = 0;\n      var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\n      while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront)) {\n        ++cutFront;\n      }\n      var newBot = lst(newText), oldBot = lst(oldText);\n      var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0), oldBot.length - (oldText.length == 1 ? cutFront : 0));\n      while (cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {\n        ++cutEnd;\n      }\n      if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {\n        while (cutFront && cutFront > from.ch && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {\n          cutFront--;\n          cutEnd++;\n        }\n      }\n      newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\\u200b+/, "");\n      newText[0] = newText[0].slice(cutFront).replace(/\\u200b+$/, "");\n      var chFrom = Pos(fromLine, cutFront);\n      var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\n      if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\n        replaceRange(cm.doc, newText, chFrom, chTo, "+input");\n        return true;\n      }\n    };\n    ContentEditableInput.prototype.ensurePolled = function() {\n      this.forceCompositionEnd();\n    };\n    ContentEditableInput.prototype.reset = function() {\n      this.forceCompositionEnd();\n    };\n    ContentEditableInput.prototype.forceCompositionEnd = function() {\n      if (!this.composing) {\n        return;\n      }\n      clearTimeout(this.readDOMTimeout);\n      this.composing = null;\n      this.updateFromDOM();\n      this.div.blur();\n      this.div.focus();\n    };\n    ContentEditableInput.prototype.readFromDOMSoon = function() {\n      var this$1$1 = this;\n      if (this.readDOMTimeout != null) {\n        return;\n      }\n      this.readDOMTimeout = setTimeout(function() {\n        this$1$1.readDOMTimeout = null;\n        if (this$1$1.composing) {\n          if (this$1$1.composing.done) {\n            this$1$1.composing = null;\n          } else {\n            return;\n          }\n        }\n        this$1$1.updateFromDOM();\n      }, 80);\n    };\n    ContentEditableInput.prototype.updateFromDOM = function() {\n      var this$1$1 = this;\n      if (this.cm.isReadOnly() || !this.pollContent()) {\n        runInOp(this.cm, function() {\n          return regChange(this$1$1.cm);\n        });\n      }\n    };\n    ContentEditableInput.prototype.setUneditable = function(node) {\n      node.contentEditable = "false";\n    };\n    ContentEditableInput.prototype.onKeyPress = function(e) {\n      if (e.charCode == 0 || this.composing) {\n        return;\n      }\n      e.preventDefault();\n      if (!this.cm.isReadOnly()) {\n        operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);\n      }\n    };\n    ContentEditableInput.prototype.readOnlyChanged = function(val) {\n      this.div.contentEditable = String(val != "nocursor");\n    };\n    ContentEditableInput.prototype.onContextMenu = function() {\n    };\n    ContentEditableInput.prototype.resetPosition = function() {\n    };\n    ContentEditableInput.prototype.needsContentAttribute = true;\n    function posToDOM(cm, pos) {\n      var view = findViewForLine(cm, pos.line);\n      if (!view || view.hidden) {\n        return null;\n      }\n      var line = getLine(cm.doc, pos.line);\n      var info = mapFromLineView(view, line, pos.line);\n      var order = getOrder(line, cm.doc.direction), side = "left";\n      if (order) {\n        var partPos = getBidiPartAt(order, pos.ch);\n        side = partPos % 2 ? "right" : "left";\n      }\n      var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);\n      result.offset = result.collapse == "right" ? result.end : result.start;\n      return result;\n    }\n    __name(posToDOM, "posToDOM");\n    function isInGutter(node) {\n      for (var scan = node; scan; scan = scan.parentNode) {\n        if (/CodeMirror-gutter-wrapper/.test(scan.className)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    __name(isInGutter, "isInGutter");\n    function badPos(pos, bad) {\n      if (bad) {\n        pos.bad = true;\n      }\n      return pos;\n    }\n    __name(badPos, "badPos");\n    function domTextBetween(cm, from, to, fromLine, toLine) {\n      var text = "", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;\n      function recognizeMarker(id) {\n        return function(marker) {\n          return marker.id == id;\n        };\n      }\n      __name(recognizeMarker, "recognizeMarker");\n      function close() {\n        if (closing) {\n          text += lineSep;\n          if (extraLinebreak) {\n            text += lineSep;\n          }\n          closing = extraLinebreak = false;\n        }\n      }\n      __name(close, "close");\n      function addText(str) {\n        if (str) {\n          close();\n          text += str;\n        }\n      }\n      __name(addText, "addText");\n      function walk(node) {\n        if (node.nodeType == 1) {\n          var cmText = node.getAttribute("cm-text");\n          if (cmText) {\n            addText(cmText);\n            return;\n          }\n          var markerID = node.getAttribute("cm-marker"), range2;\n          if (markerID) {\n            var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\n            if (found.length && (range2 = found[0].find(0))) {\n              addText(getBetween(cm.doc, range2.from, range2.to).join(lineSep));\n            }\n            return;\n          }\n          if (node.getAttribute("contenteditable") == "false") {\n            return;\n          }\n          var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);\n          if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) {\n            return;\n          }\n          if (isBlock) {\n            close();\n          }\n          for (var i2 = 0; i2 < node.childNodes.length; i2++) {\n            walk(node.childNodes[i2]);\n          }\n          if (/^(pre|p)$/i.test(node.nodeName)) {\n            extraLinebreak = true;\n          }\n          if (isBlock) {\n            closing = true;\n          }\n        } else if (node.nodeType == 3) {\n          addText(node.nodeValue.replace(/\\u200b/g, "").replace(/\\u00a0/g, " "));\n        }\n      }\n      __name(walk, "walk");\n      for (; ; ) {\n        walk(from);\n        if (from == to) {\n          break;\n        }\n        from = from.nextSibling;\n        extraLinebreak = false;\n      }\n      return text;\n    }\n    __name(domTextBetween, "domTextBetween");\n    function domToPos(cm, node, offset) {\n      var lineNode;\n      if (node == cm.display.lineDiv) {\n        lineNode = cm.display.lineDiv.childNodes[offset];\n        if (!lineNode) {\n          return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);\n        }\n        node = null;\n        offset = 0;\n      } else {\n        for (lineNode = node; ; lineNode = lineNode.parentNode) {\n          if (!lineNode || lineNode == cm.display.lineDiv) {\n            return null;\n          }\n          if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) {\n            break;\n          }\n        }\n      }\n      for (var i2 = 0; i2 < cm.display.view.length; i2++) {\n        var lineView = cm.display.view[i2];\n        if (lineView.node == lineNode) {\n          return locateNodeInLineView(lineView, node, offset);\n        }\n      }\n    }\n    __name(domToPos, "domToPos");\n    function locateNodeInLineView(lineView, node, offset) {\n      var wrapper = lineView.text.firstChild, bad = false;\n      if (!node || !contains(wrapper, node)) {\n        return badPos(Pos(lineNo(lineView.line), 0), true);\n      }\n      if (node == wrapper) {\n        bad = true;\n        node = wrapper.childNodes[offset];\n        offset = 0;\n        if (!node) {\n          var line = lineView.rest ? lst(lineView.rest) : lineView.line;\n          return badPos(Pos(lineNo(line), line.text.length), bad);\n        }\n      }\n      var textNode = node.nodeType == 3 ? node : null, topNode = node;\n      if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\n        textNode = node.firstChild;\n        if (offset) {\n          offset = textNode.nodeValue.length;\n        }\n      }\n      while (topNode.parentNode != wrapper) {\n        topNode = topNode.parentNode;\n      }\n      var measure = lineView.measure, maps = measure.maps;\n      function find(textNode2, topNode2, offset2) {\n        for (var i2 = -1; i2 < (maps ? maps.length : 0); i2++) {\n          var map2 = i2 < 0 ? measure.map : maps[i2];\n          for (var j = 0; j < map2.length; j += 3) {\n            var curNode = map2[j + 2];\n            if (curNode == textNode2 || curNode == topNode2) {\n              var line2 = lineNo(i2 < 0 ? lineView.line : lineView.rest[i2]);\n              var ch = map2[j] + offset2;\n              if (offset2 < 0 || curNode != textNode2) {\n                ch = map2[j + (offset2 ? 1 : 0)];\n              }\n              return Pos(line2, ch);\n            }\n          }\n        }\n      }\n      __name(find, "find");\n      var found = find(textNode, topNode, offset);\n      if (found) {\n        return badPos(found, bad);\n      }\n      for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\n        found = find(after, after.firstChild, 0);\n        if (found) {\n          return badPos(Pos(found.line, found.ch - dist), bad);\n        } else {\n          dist += after.textContent.length;\n        }\n      }\n      for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {\n        found = find(before, before.firstChild, -1);\n        if (found) {\n          return badPos(Pos(found.line, found.ch + dist$1), bad);\n        } else {\n          dist$1 += before.textContent.length;\n        }\n      }\n    }\n    __name(locateNodeInLineView, "locateNodeInLineView");\n    var TextareaInput = /* @__PURE__ */ __name(function(cm) {\n      this.cm = cm;\n      this.prevInput = "";\n      this.pollingFast = false;\n      this.polling = new Delayed();\n      this.hasSelection = false;\n      this.composing = null;\n    }, "TextareaInput");\n    TextareaInput.prototype.init = function(display) {\n      var this$1$1 = this;\n      var input = this, cm = this.cm;\n      this.createField(display);\n      var te = this.textarea;\n      display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);\n      if (ios) {\n        te.style.width = "0px";\n      }\n      on(te, "input", function() {\n        if (ie && ie_version >= 9 && this$1$1.hasSelection) {\n          this$1$1.hasSelection = null;\n        }\n        input.poll();\n      });\n      on(te, "paste", function(e) {\n        if (signalDOMEvent(cm, e) || handlePaste(e, cm)) {\n          return;\n        }\n        cm.state.pasteIncoming = +new Date();\n        input.fastPoll();\n      });\n      function prepareCopyCut(e) {\n        if (signalDOMEvent(cm, e)) {\n          return;\n        }\n        if (cm.somethingSelected()) {\n          setLastCopied({ lineWise: false, text: cm.getSelections() });\n        } else if (!cm.options.lineWiseCopyCut) {\n          return;\n        } else {\n          var ranges = copyableRanges(cm);\n          setLastCopied({ lineWise: true, text: ranges.text });\n          if (e.type == "cut") {\n            cm.setSelections(ranges.ranges, null, sel_dontScroll);\n          } else {\n            input.prevInput = "";\n            te.value = ranges.text.join("\\n");\n            selectInput(te);\n          }\n        }\n        if (e.type == "cut") {\n          cm.state.cutIncoming = +new Date();\n        }\n      }\n      __name(prepareCopyCut, "prepareCopyCut");\n      on(te, "cut", prepareCopyCut);\n      on(te, "copy", prepareCopyCut);\n      on(display.scroller, "paste", function(e) {\n        if (eventInWidget(display, e) || signalDOMEvent(cm, e)) {\n          return;\n        }\n        if (!te.dispatchEvent) {\n          cm.state.pasteIncoming = +new Date();\n          input.focus();\n          return;\n        }\n        var event = new Event("paste");\n        event.clipboardData = e.clipboardData;\n        te.dispatchEvent(event);\n      });\n      on(display.lineSpace, "selectstart", function(e) {\n        if (!eventInWidget(display, e)) {\n          e_preventDefault(e);\n        }\n      });\n      on(te, "compositionstart", function() {\n        var start = cm.getCursor("from");\n        if (input.composing) {\n          input.composing.range.clear();\n        }\n        input.composing = {\n          start,\n          range: cm.markText(start, cm.getCursor("to"), { className: "CodeMirror-composing" })\n        };\n      });\n      on(te, "compositionend", function() {\n        if (input.composing) {\n          input.poll();\n          input.composing.range.clear();\n          input.composing = null;\n        }\n      });\n    };\n    TextareaInput.prototype.createField = function(_display) {\n      this.wrapper = hiddenTextarea();\n      this.textarea = this.wrapper.firstChild;\n    };\n    TextareaInput.prototype.screenReaderLabelChanged = function(label) {\n      if (label) {\n        this.textarea.setAttribute("aria-label", label);\n      } else {\n        this.textarea.removeAttribute("aria-label");\n      }\n    };\n    TextareaInput.prototype.prepareSelection = function() {\n      var cm = this.cm, display = cm.display, doc = cm.doc;\n      var result = prepareSelection(cm);\n      if (cm.options.moveInputWithCursor) {\n        var headPos = cursorCoords(cm, doc.sel.primary().head, "div");\n        var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\n        result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top));\n        result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left));\n      }\n      return result;\n    };\n    TextareaInput.prototype.showSelection = function(drawn) {\n      var cm = this.cm, display = cm.display;\n      removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\n      removeChildrenAndAdd(display.selectionDiv, drawn.selection);\n      if (drawn.teTop != null) {\n        this.wrapper.style.top = drawn.teTop + "px";\n        this.wrapper.style.left = drawn.teLeft + "px";\n      }\n    };\n    TextareaInput.prototype.reset = function(typing) {\n      if (this.contextMenuPending || this.composing) {\n        return;\n      }\n      var cm = this.cm;\n      if (cm.somethingSelected()) {\n        this.prevInput = "";\n        var content = cm.getSelection();\n        this.textarea.value = content;\n        if (cm.state.focused) {\n          selectInput(this.textarea);\n        }\n        if (ie && ie_version >= 9) {\n          this.hasSelection = content;\n        }\n      } else if (!typing) {\n        this.prevInput = this.textarea.value = "";\n        if (ie && ie_version >= 9) {\n          this.hasSelection = null;\n        }\n      }\n    };\n    TextareaInput.prototype.getField = function() {\n      return this.textarea;\n    };\n    TextareaInput.prototype.supportsTouch = function() {\n      return false;\n    };\n    TextareaInput.prototype.focus = function() {\n      if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {\n        try {\n          this.textarea.focus();\n        } catch (e) {\n        }\n      }\n    };\n    TextareaInput.prototype.blur = function() {\n      this.textarea.blur();\n    };\n    TextareaInput.prototype.resetPosition = function() {\n      this.wrapper.style.top = this.wrapper.style.left = 0;\n    };\n    TextareaInput.prototype.receivedFocus = function() {\n      this.slowPoll();\n    };\n    TextareaInput.prototype.slowPoll = function() {\n      var this$1$1 = this;\n      if (this.pollingFast) {\n        return;\n      }\n      this.polling.set(this.cm.options.pollInterval, function() {\n        this$1$1.poll();\n        if (this$1$1.cm.state.focused) {\n          this$1$1.slowPoll();\n        }\n      });\n    };\n    TextareaInput.prototype.fastPoll = function() {\n      var missed = false, input = this;\n      input.pollingFast = true;\n      function p() {\n        var changed = input.poll();\n        if (!changed && !missed) {\n          missed = true;\n          input.polling.set(60, p);\n        } else {\n          input.pollingFast = false;\n          input.slowPoll();\n        }\n      }\n      __name(p, "p");\n      input.polling.set(20, p);\n    };\n    TextareaInput.prototype.poll = function() {\n      var this$1$1 = this;\n      var cm = this.cm, input = this.textarea, prevInput = this.prevInput;\n      if (this.contextMenuPending || !cm.state.focused || hasSelection(input) && !prevInput && !this.composing || cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq) {\n        return false;\n      }\n      var text = input.value;\n      if (text == prevInput && !cm.somethingSelected()) {\n        return false;\n      }\n      if (ie && ie_version >= 9 && this.hasSelection === text || mac && /[\\uf700-\\uf7ff]/.test(text)) {\n        cm.display.input.reset();\n        return false;\n      }\n      if (cm.doc.sel == cm.display.selForContextMenu) {\n        var first = text.charCodeAt(0);\n        if (first == 8203 && !prevInput) {\n          prevInput = "\\u200B";\n        }\n        if (first == 8666) {\n          this.reset();\n          return this.cm.execCommand("undo");\n        }\n      }\n      var same = 0, l = Math.min(prevInput.length, text.length);\n      while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) {\n        ++same;\n      }\n      runInOp(cm, function() {\n        applyTextInput(cm, text.slice(same), prevInput.length - same, null, this$1$1.composing ? "*compose" : null);\n        if (text.length > 1e3 || text.indexOf("\\n") > -1) {\n          input.value = this$1$1.prevInput = "";\n        } else {\n          this$1$1.prevInput = text;\n        }\n        if (this$1$1.composing) {\n          this$1$1.composing.range.clear();\n          this$1$1.composing.range = cm.markText(this$1$1.composing.start, cm.getCursor("to"), { className: "CodeMirror-composing" });\n        }\n      });\n      return true;\n    };\n    TextareaInput.prototype.ensurePolled = function() {\n      if (this.pollingFast && this.poll()) {\n        this.pollingFast = false;\n      }\n    };\n    TextareaInput.prototype.onKeyPress = function() {\n      if (ie && ie_version >= 9) {\n        this.hasSelection = null;\n      }\n      this.fastPoll();\n    };\n    TextareaInput.prototype.onContextMenu = function(e) {\n      var input = this, cm = input.cm, display = cm.display, te = input.textarea;\n      if (input.contextMenuPending) {\n        input.contextMenuPending();\n      }\n      var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n      if (!pos || presto) {\n        return;\n      }\n      var reset = cm.options.resetSelectionOnContextMenu;\n      if (reset && cm.doc.sel.contains(pos) == -1) {\n        operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);\n      }\n      var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;\n      var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();\n      input.wrapper.style.cssText = "position: static";\n      te.style.cssText = "position: absolute; width: 30px; height: 30px;\\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";\n      var oldScrollY;\n      if (webkit) {\n        oldScrollY = window.scrollY;\n      }\n      display.input.focus();\n      if (webkit) {\n        window.scrollTo(null, oldScrollY);\n      }\n      display.input.reset();\n      if (!cm.somethingSelected()) {\n        te.value = input.prevInput = " ";\n      }\n      input.contextMenuPending = rehide;\n      display.selForContextMenu = cm.doc.sel;\n      clearTimeout(display.detectingSelectAll);\n      function prepareSelectAllHack() {\n        if (te.selectionStart != null) {\n          var selected = cm.somethingSelected();\n          var extval = "\\u200B" + (selected ? te.value : "");\n          te.value = "\\u21DA";\n          te.value = extval;\n          input.prevInput = selected ? "" : "\\u200B";\n          te.selectionStart = 1;\n          te.selectionEnd = extval.length;\n          display.selForContextMenu = cm.doc.sel;\n        }\n      }\n      __name(prepareSelectAllHack, "prepareSelectAllHack");\n      function rehide() {\n        if (input.contextMenuPending != rehide) {\n          return;\n        }\n        input.contextMenuPending = false;\n        input.wrapper.style.cssText = oldWrapperCSS;\n        te.style.cssText = oldCSS;\n        if (ie && ie_version < 9) {\n          display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);\n        }\n        if (te.selectionStart != null) {\n          if (!ie || ie && ie_version < 9) {\n            prepareSelectAllHack();\n          }\n          var i2 = 0, poll = /* @__PURE__ */ __name(function() {\n            if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 && te.selectionEnd > 0 && input.prevInput == "\\u200B") {\n              operation(cm, selectAll)(cm);\n            } else if (i2++ < 10) {\n              display.detectingSelectAll = setTimeout(poll, 500);\n            } else {\n              display.selForContextMenu = null;\n              display.input.reset();\n            }\n          }, "poll");\n          display.detectingSelectAll = setTimeout(poll, 200);\n        }\n      }\n      __name(rehide, "rehide");\n      if (ie && ie_version >= 9) {\n        prepareSelectAllHack();\n      }\n      if (captureRightClick) {\n        e_stop(e);\n        var mouseup = /* @__PURE__ */ __name(function() {\n          off(window, "mouseup", mouseup);\n          setTimeout(rehide, 20);\n        }, "mouseup");\n        on(window, "mouseup", mouseup);\n      } else {\n        setTimeout(rehide, 50);\n      }\n    };\n    TextareaInput.prototype.readOnlyChanged = function(val) {\n      if (!val) {\n        this.reset();\n      }\n      this.textarea.disabled = val == "nocursor";\n      this.textarea.readOnly = !!val;\n    };\n    TextareaInput.prototype.setUneditable = function() {\n    };\n    TextareaInput.prototype.needsContentAttribute = false;\n    function fromTextArea(textarea, options) {\n      options = options ? copyObj(options) : {};\n      options.value = textarea.value;\n      if (!options.tabindex && textarea.tabIndex) {\n        options.tabindex = textarea.tabIndex;\n      }\n      if (!options.placeholder && textarea.placeholder) {\n        options.placeholder = textarea.placeholder;\n      }\n      if (options.autofocus == null) {\n        var hasFocus = activeElt();\n        options.autofocus = hasFocus == textarea || textarea.getAttribute("autofocus") != null && hasFocus == document.body;\n      }\n      function save() {\n        textarea.value = cm.getValue();\n      }\n      __name(save, "save");\n      var realSubmit;\n      if (textarea.form) {\n        on(textarea.form, "submit", save);\n        if (!options.leaveSubmitMethodAlone) {\n          var form = textarea.form;\n          realSubmit = form.submit;\n          try {\n            var wrappedSubmit = form.submit = function() {\n              save();\n              form.submit = realSubmit;\n              form.submit();\n              form.submit = wrappedSubmit;\n            };\n          } catch (e) {\n          }\n        }\n      }\n      options.finishInit = function(cm2) {\n        cm2.save = save;\n        cm2.getTextArea = function() {\n          return textarea;\n        };\n        cm2.toTextArea = function() {\n          cm2.toTextArea = isNaN;\n          save();\n          textarea.parentNode.removeChild(cm2.getWrapperElement());\n          textarea.style.display = "";\n          if (textarea.form) {\n            off(textarea.form, "submit", save);\n            if (!options.leaveSubmitMethodAlone && typeof textarea.form.submit == "function") {\n              textarea.form.submit = realSubmit;\n            }\n          }\n        };\n      };\n      textarea.style.display = "none";\n      var cm = CodeMirror2(function(node) {\n        return textarea.parentNode.insertBefore(node, textarea.nextSibling);\n      }, options);\n      return cm;\n    }\n    __name(fromTextArea, "fromTextArea");\n    function addLegacyProps(CodeMirror3) {\n      CodeMirror3.off = off;\n      CodeMirror3.on = on;\n      CodeMirror3.wheelEventPixels = wheelEventPixels;\n      CodeMirror3.Doc = Doc;\n      CodeMirror3.splitLines = splitLinesAuto;\n      CodeMirror3.countColumn = countColumn;\n      CodeMirror3.findColumn = findColumn;\n      CodeMirror3.isWordChar = isWordCharBasic;\n      CodeMirror3.Pass = Pass;\n      CodeMirror3.signal = signal;\n      CodeMirror3.Line = Line;\n      CodeMirror3.changeEnd = changeEnd;\n      CodeMirror3.scrollbarModel = scrollbarModel;\n      CodeMirror3.Pos = Pos;\n      CodeMirror3.cmpPos = cmp;\n      CodeMirror3.modes = modes;\n      CodeMirror3.mimeModes = mimeModes;\n      CodeMirror3.resolveMode = resolveMode;\n      CodeMirror3.getMode = getMode;\n      CodeMirror3.modeExtensions = modeExtensions;\n      CodeMirror3.extendMode = extendMode;\n      CodeMirror3.copyState = copyState;\n      CodeMirror3.startState = startState;\n      CodeMirror3.innerMode = innerMode;\n      CodeMirror3.commands = commands;\n      CodeMirror3.keyMap = keyMap;\n      CodeMirror3.keyName = keyName;\n      CodeMirror3.isModifierKey = isModifierKey;\n      CodeMirror3.lookupKey = lookupKey;\n      CodeMirror3.normalizeKeyMap = normalizeKeyMap;\n      CodeMirror3.StringStream = StringStream;\n      CodeMirror3.SharedTextMarker = SharedTextMarker;\n      CodeMirror3.TextMarker = TextMarker;\n      CodeMirror3.LineWidget = LineWidget;\n      CodeMirror3.e_preventDefault = e_preventDefault;\n      CodeMirror3.e_stopPropagation = e_stopPropagation;\n      CodeMirror3.e_stop = e_stop;\n      CodeMirror3.addClass = addClass;\n      CodeMirror3.contains = contains;\n      CodeMirror3.rmClass = rmClass;\n      CodeMirror3.keyNames = keyNames;\n    }\n    __name(addLegacyProps, "addLegacyProps");\n    defineOptions(CodeMirror2);\n    addEditorMethods(CodeMirror2);\n    var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");\n    for (var prop in Doc.prototype) {\n      if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0) {\n        CodeMirror2.prototype[prop] = function(method) {\n          return function() {\n            return method.apply(this.doc, arguments);\n          };\n        }(Doc.prototype[prop]);\n      }\n    }\n    eventMixin(Doc);\n    CodeMirror2.inputStyles = { "textarea": TextareaInput, "contenteditable": ContentEditableInput };\n    CodeMirror2.defineMode = function(name) {\n      if (!CodeMirror2.defaults.mode && name != "null") {\n        CodeMirror2.defaults.mode = name;\n      }\n      defineMode.apply(this, arguments);\n    };\n    CodeMirror2.defineMIME = defineMIME;\n    CodeMirror2.defineMode("null", function() {\n      return { token: function(stream) {\n        return stream.skipToEnd();\n      } };\n    });\n    CodeMirror2.defineMIME("text/plain", "null");\n    CodeMirror2.defineExtension = function(name, func) {\n      CodeMirror2.prototype[name] = func;\n    };\n    CodeMirror2.defineDocExtension = function(name, func) {\n      Doc.prototype[name] = func;\n    };\n    CodeMirror2.fromTextArea = fromTextArea;\n    addLegacyProps(CodeMirror2);\n    CodeMirror2.version = "5.65.3";\n    return CodeMirror2;\n  });\n})(codemirror$1);\nvar CodeMirror = codemirror$1.exports;\nvar codemirror = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  [Symbol.toStringTag]: "Module",\n  "default": CodeMirror\n}, [codemirror$1.exports]));\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsVUFBVTtBQUNuQztBQUNBO0FBQ0EsNkNBQTZDLFlBQVk7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxZQUFZO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsZUFBZTtBQUM1RDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsV0FBVztBQUNyQztBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxnQ0FBZ0MsZ0NBQWdDO0FBQ2hFO0FBQ0E7QUFDQSw4QkFBOEIsU0FBUztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFdBQVc7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixXQUFXO0FBQ3JDO0FBQ0E7QUFDQSxrQ0FBa0MsNkNBQTZDO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFdBQVc7QUFDckM7QUFDQTtBQUNBLHdCQUF3Qiw0Q0FBNEM7QUFDcEU7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLHdCQUF3QixnQ0FBZ0M7QUFDeEQ7QUFDQSxnQ0FBZ0MsV0FBVztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkNBQTJDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyR0FBMkcsWUFBWTtBQUN2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLFFBQVE7QUFDUix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLEdBQUc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQywyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxpQkFBaUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaUJBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGlCQUFpQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw4QkFBOEI7QUFDbEU7QUFDQTtB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QUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwwQkFBMEI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsbUdBQW1HLDBHQUEwRyxzREFBc0QscURBQXFEO0FBQ2hZO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixXQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsVUFBVTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0QkFBNEI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixVQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHlCQUF5QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIseUJBQXlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQSw4QkFBOEIsbUJBQW1CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFvQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQSw0QkFBNEIscURBQXFEO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0QkFBNEI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9CQUFvQjtBQUMvQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw4QkFBOEI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsU0FBUztBQUNqRCxpQ0FBaUMsOEZBQThGO0FBQy9IO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxrQkFBa0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtREFBbUQ7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsMENBQTBDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLGdEQUFnRCxXQUFXO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxxREFBcUQsY0FBYztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhCQUE4QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVCQUF1QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBCQUEwQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdCQUF3QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDhCQUE4QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixtQ0FBbUMsZUFBZTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDhCQUE4QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFvQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxlQUFl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Q0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDhCQUE4QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQscUJBQXFCO0FBQzlFO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EseUZBQXlGLGlDQUFpQztBQUMxSCxRQUFRO0FBQ1IscUhBQXFILGlDQUFpQztBQUN0SjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlIQUF5SCxhQUFhO0FBQ3RJO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvSEFBb0gsaUNBQWlDO0FBQ3JKO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0NBQW9DO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNENBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDJDQUEyQztBQUNyRTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSwwQkFBMEIsbUNBQW1DO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsdURBQXVEO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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bUNBQW1DO0FBQzdGO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxtQ0FBbUM7QUFDcEk7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxhQUFhLGFBQWEseURBQXlELGtEQUFrRCx1QkFBdUIsc0VBQXNFLHVCQUF1QixpQkFBaUIsZUFBZSxrQkFBa0IsY0FBYyx5QkFBeUI7QUFDaFk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUM4RCIsInNvdXJjZXMiOlsid2VicGFjazovL2NhY2hpcWwtZGVtby8uL25vZGVfbW9kdWxlcy9AZ3JhcGhpcWwvcmVhY3QvZGlzdC9jb2RlbWlycm9yLmVzLmpzPzk3YzciXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX25hbWUgPSAodGFyZ2V0LCB2YWx1ZSkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJuYW1lXCIsIHsgdmFsdWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbmltcG9ydCB7IGMgYXMgY29tbW9uanNHbG9iYWwgfSBmcm9tIFwiLi9pbmRleC5lcy5qc1wiO1xuZnVuY3Rpb24gX21lcmdlTmFtZXNwYWNlcyhuLCBtKSB7XG4gIG0uZm9yRWFjaChmdW5jdGlvbihlKSB7XG4gICAgZSAmJiB0eXBlb2YgZSAhPT0gXCJzdHJpbmdcIiAmJiAhQXJyYXkuaXNBcnJheShlKSAmJiBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiAhKGsgaW4gbikpIHtcbiAgICAgICAgdmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGspO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgaywgZC5nZXQgPyBkIDoge1xuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBlW2tdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShuKTtcbn1cbl9fbmFtZShfbWVyZ2VOYW1lc3BhY2VzLCBcIl9tZXJnZU5hbWVzcGFjZXNcIik7XG52YXIgY29kZW1pcnJvciQxID0geyBleHBvcnRzOiB7fSB9O1xuKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuICAoZnVuY3Rpb24oZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gIH0pKGNvbW1vbmpzR2xvYmFsLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgICB2YXIgcGxhdGZvcm0gPSBuYXZpZ2F0b3IucGxhdGZvcm07XG4gICAgdmFyIGdlY2tvID0gL2dlY2tvXFwvXFxkL2kudGVzdCh1c2VyQWdlbnQpO1xuICAgIHZhciBpZV91cHRvMTAgPSAvTVNJRSBcXGQvLnRlc3QodXNlckFnZW50KTtcbiAgICB2YXIgaWVfMTF1cCA9IC9UcmlkZW50XFwvKD86WzctOV18XFxkezIsfSlcXC4uKnJ2OihcXGQrKS8uZXhlYyh1c2VyQWdlbnQpO1xuICAgIHZhciBlZGdlID0gL0VkZ2VcXC8oXFxkKykvLmV4ZWModXNlckFnZW50KTtcbiAgICB2YXIgaWUgPSBpZV91cHRvMTAgfHwgaWVfMTF1cCB8fCBlZGdlO1xuICAgIHZhciBpZV92ZXJzaW9uID0gaWUgJiYgKGllX3VwdG8xMCA/IGRvY3VtZW50LmRvY3VtZW50TW9kZSB8fCA2IDogKyhlZGdlIHx8IGllXzExdXApWzFdKTtcbiAgICB2YXIgd2Via2l0ID0gIWVkZ2UgJiYgL1dlYktpdFxcLy8udGVzdCh1c2VyQWdlbnQpO1xuICAgIHZhciBxdHdlYmtpdCA9IHdlYmtpdCAmJiAvUXRcXC9cXGQrXFwuXFxkKy8udGVzdCh1c2VyQWdlbnQpO1xuICAgIHZhciBjaHJvbWUgPSAhZWRnZSAmJiAvQ2hyb21lXFwvLy50ZXN0KHVzZXJBZ2VudCk7XG4gICAgdmFyIHByZXN0byA9IC9PcGVyYVxcLy8udGVzdCh1c2VyQWdlbnQpO1xuICAgIHZhciBzYWZhcmkgPSAvQXBwbGUgQ29tcHV0ZXIvLnRlc3QobmF2aWdhdG9yLnZlbmRvcik7XG4gICAgdmFyIG1hY19nZU1vdW50YWluTGlvbiA9IC9NYWMgT1MgWCAxXFxkXFxEKFs4LTldfFxcZFxcZClcXEQvLnRlc3QodXNlckFnZW50KTtcbiAgICB2YXIgcGhhbnRvbSA9IC9QaGFudG9tSlMvLnRlc3QodXNlckFnZW50KTtcbiAgICB2YXIgaW9zID0gc2FmYXJpICYmICgvTW9iaWxlXFwvXFx3Ky8udGVzdCh1c2VyQWdlbnQpIHx8IG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDIpO1xuICAgIHZhciBhbmRyb2lkID0gL0FuZHJvaWQvLnRlc3QodXNlckFnZW50KTtcbiAgICB2YXIgbW9iaWxlID0gaW9zIHx8IGFuZHJvaWQgfHwgL3dlYk9TfEJsYWNrQmVycnl8T3BlcmEgTWluaXxPcGVyYSBNb2JpfElFTW9iaWxlL2kudGVzdCh1c2VyQWdlbnQpO1xuICAgIHZhciBtYWMgPSBpb3MgfHwgL01hYy8udGVzdChwbGF0Zm9ybSk7XG4gICAgdmFyIGNocm9tZU9TID0gL1xcYkNyT1NcXGIvLnRlc3QodXNlckFnZW50KTtcbiAgICB2YXIgd2luZG93cyA9IC93aW4vaS50ZXN0KHBsYXRmb3JtKTtcbiAgICB2YXIgcHJlc3RvX3ZlcnNpb24gPSBwcmVzdG8gJiYgdXNlckFnZW50Lm1hdGNoKC9WZXJzaW9uXFwvKFxcZCpcXC5cXGQqKS8pO1xuICAgIGlmIChwcmVzdG9fdmVyc2lvbikge1xuICAgICAgcHJlc3RvX3ZlcnNpb24gPSBOdW1iZXIocHJlc3RvX3ZlcnNpb25bMV0pO1xuICAgIH1cbiAgICBpZiAocHJlc3RvX3ZlcnNpb24gJiYgcHJlc3RvX3ZlcnNpb24gPj0gMTUpIHtcbiAgICAgIHByZXN0byA9IGZhbHNlO1xuICAgICAgd2Via2l0ID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGZsaXBDdHJsQ21kID0gbWFjICYmIChxdHdlYmtpdCB8fCBwcmVzdG8gJiYgKHByZXN0b192ZXJzaW9uID09IG51bGwgfHwgcHJlc3RvX3ZlcnNpb24gPCAxMi4xMSkpO1xuICAgIHZhciBjYXB0dXJlUmlnaHRDbGljayA9IGdlY2tvIHx8IGllICYmIGllX3ZlcnNpb24gPj0gOTtcbiAgICBmdW5jdGlvbiBjbGFzc1Rlc3QoY2xzKSB7XG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cChcIihefFxcXFxzKVwiICsgY2xzICsgXCIoPzokfFxcXFxzKVxcXFxzKlwiKTtcbiAgICB9XG4gICAgX19uYW1lKGNsYXNzVGVzdCwgXCJjbGFzc1Rlc3RcIik7XG4gICAgdmFyIHJtQ2xhc3MgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKG5vZGUsIGNscykge1xuICAgICAgdmFyIGN1cnJlbnQgPSBub2RlLmNsYXNzTmFtZTtcbiAgICAgIHZhciBtYXRjaCA9IGNsYXNzVGVzdChjbHMpLmV4ZWMoY3VycmVudCk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgdmFyIGFmdGVyID0gY3VycmVudC5zbGljZShtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgIG5vZGUuY2xhc3NOYW1lID0gY3VycmVudC5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyAoYWZ0ZXIgPyBtYXRjaFsxXSArIGFmdGVyIDogXCJcIik7XG4gICAgICB9XG4gICAgfSwgXCJybUNsYXNzXCIpO1xuICAgIGZ1bmN0aW9uIHJlbW92ZUNoaWxkcmVuKGUpIHtcbiAgICAgIGZvciAodmFyIGNvdW50ID0gZS5jaGlsZE5vZGVzLmxlbmd0aDsgY291bnQgPiAwOyAtLWNvdW50KSB7XG4gICAgICAgIGUucmVtb3ZlQ2hpbGQoZS5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBfX25hbWUocmVtb3ZlQ2hpbGRyZW4sIFwicmVtb3ZlQ2hpbGRyZW5cIik7XG4gICAgZnVuY3Rpb24gcmVtb3ZlQ2hpbGRyZW5BbmRBZGQocGFyZW50LCBlKSB7XG4gICAgICByZXR1cm4gcmVtb3ZlQ2hpbGRyZW4ocGFyZW50KS5hcHBlbmRDaGlsZChlKTtcbiAgICB9XG4gICAgX19uYW1lKHJlbW92ZUNoaWxkcmVuQW5kQWRkLCBcInJlbW92ZUNoaWxkcmVuQW5kQWRkXCIpO1xuICAgIGZ1bmN0aW9uIGVsdCh0YWcsIGNvbnRlbnQsIGNsYXNzTmFtZSwgc3R5bGUpIHtcbiAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICBlLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHlsZSkge1xuICAgICAgICBlLnN0eWxlLmNzc1RleHQgPSBzdHlsZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY29udGVudCkpO1xuICAgICAgfSBlbHNlIGlmIChjb250ZW50KSB7XG4gICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBjb250ZW50Lmxlbmd0aDsgKytpMikge1xuICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoY29udGVudFtpMl0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgX19uYW1lKGVsdCwgXCJlbHRcIik7XG4gICAgZnVuY3Rpb24gZWx0UCh0YWcsIGNvbnRlbnQsIGNsYXNzTmFtZSwgc3R5bGUpIHtcbiAgICAgIHZhciBlID0gZWx0KHRhZywgY29udGVudCwgY2xhc3NOYW1lLCBzdHlsZSk7XG4gICAgICBlLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJwcmVzZW50YXRpb25cIik7XG4gICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgX19uYW1lKGVsdFAsIFwiZWx0UFwiKTtcbiAgICB2YXIgcmFuZ2U7XG4gICAgaWYgKGRvY3VtZW50LmNyZWF0ZVJhbmdlKSB7XG4gICAgICByYW5nZSA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24obm9kZSwgc3RhcnQsIGVuZCwgZW5kTm9kZSkge1xuICAgICAgICB2YXIgciA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgIHIuc2V0RW5kKGVuZE5vZGUgfHwgbm9kZSwgZW5kKTtcbiAgICAgICAgci5zZXRTdGFydChub2RlLCBzdGFydCk7XG4gICAgICAgIHJldHVybiByO1xuICAgICAgfSwgXCJyYW5nZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2UgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKG5vZGUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdmFyIHIgPSBkb2N1bWVudC5ib2R5LmNyZWF0ZVRleHRSYW5nZSgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHIubW92ZVRvRWxlbWVudFRleHQobm9kZS5wYXJlbnROb2RlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9XG4gICAgICAgIHIuY29sbGFwc2UodHJ1ZSk7XG4gICAgICAgIHIubW92ZUVuZChcImNoYXJhY3RlclwiLCBlbmQpO1xuICAgICAgICByLm1vdmVTdGFydChcImNoYXJhY3RlclwiLCBzdGFydCk7XG4gICAgICAgIHJldHVybiByO1xuICAgICAgfSwgXCJyYW5nZVwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29udGFpbnMocGFyZW50LCBjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDMpIHtcbiAgICAgICAgY2hpbGQgPSBjaGlsZC5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVudC5jb250YWlucykge1xuICAgICAgICByZXR1cm4gcGFyZW50LmNvbnRhaW5zKGNoaWxkKTtcbiAgICAgIH1cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDExKSB7XG4gICAgICAgICAgY2hpbGQgPSBjaGlsZC5ob3N0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZCA9PSBwYXJlbnQpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoY2hpbGQgPSBjaGlsZC5wYXJlbnROb2RlKTtcbiAgICB9XG4gICAgX19uYW1lKGNvbnRhaW5zLCBcImNvbnRhaW5zXCIpO1xuICAgIGZ1bmN0aW9uIGFjdGl2ZUVsdCgpIHtcbiAgICAgIHZhciBhY3RpdmVFbGVtZW50O1xuICAgICAgdHJ5IHtcbiAgICAgICAgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5ib2R5IHx8IG51bGw7XG4gICAgICB9XG4gICAgICB3aGlsZSAoYWN0aXZlRWxlbWVudCAmJiBhY3RpdmVFbGVtZW50LnNoYWRvd1Jvb3QgJiYgYWN0aXZlRWxlbWVudC5zaGFkb3dSb290LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgYWN0aXZlRWxlbWVudCA9IGFjdGl2ZUVsZW1lbnQuc2hhZG93Um9vdC5hY3RpdmVFbGVtZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjdGl2ZUVsZW1lbnQ7XG4gICAgfVxuICAgIF9fbmFtZShhY3RpdmVFbHQsIFwiYWN0aXZlRWx0XCIpO1xuICAgIGZ1bmN0aW9uIGFkZENsYXNzKG5vZGUsIGNscykge1xuICAgICAgdmFyIGN1cnJlbnQgPSBub2RlLmNsYXNzTmFtZTtcbiAgICAgIGlmICghY2xhc3NUZXN0KGNscykudGVzdChjdXJyZW50KSkge1xuICAgICAgICBub2RlLmNsYXNzTmFtZSArPSAoY3VycmVudCA/IFwiIFwiIDogXCJcIikgKyBjbHM7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShhZGRDbGFzcywgXCJhZGRDbGFzc1wiKTtcbiAgICBmdW5jdGlvbiBqb2luQ2xhc3NlcyhhLCBiKSB7XG4gICAgICB2YXIgYXMgPSBhLnNwbGl0KFwiIFwiKTtcbiAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBhcy5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgaWYgKGFzW2kyXSAmJiAhY2xhc3NUZXN0KGFzW2kyXSkudGVzdChiKSkge1xuICAgICAgICAgIGIgKz0gXCIgXCIgKyBhc1tpMl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBiO1xuICAgIH1cbiAgICBfX25hbWUoam9pbkNsYXNzZXMsIFwiam9pbkNsYXNzZXNcIik7XG4gICAgdmFyIHNlbGVjdElucHV0ID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbihub2RlKSB7XG4gICAgICBub2RlLnNlbGVjdCgpO1xuICAgIH0sIFwic2VsZWN0SW5wdXRcIik7XG4gICAgaWYgKGlvcykge1xuICAgICAgc2VsZWN0SW5wdXQgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgbm9kZS5zZWxlY3Rpb25TdGFydCA9IDA7XG4gICAgICAgIG5vZGUuc2VsZWN0aW9uRW5kID0gbm9kZS52YWx1ZS5sZW5ndGg7XG4gICAgICB9LCBcInNlbGVjdElucHV0XCIpO1xuICAgIH0gZWxzZSBpZiAoaWUpIHtcbiAgICAgIHNlbGVjdElucHV0ID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbm9kZS5zZWxlY3QoKTtcbiAgICAgICAgfSBjYXRjaCAoX2UpIHtcbiAgICAgICAgfVxuICAgICAgfSwgXCJzZWxlY3RJbnB1dFwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmluZChmKSB7XG4gICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgfTtcbiAgICB9XG4gICAgX19uYW1lKGJpbmQsIFwiYmluZFwiKTtcbiAgICBmdW5jdGlvbiBjb3B5T2JqKG9iaiwgdGFyZ2V0LCBvdmVyd3JpdGUpIHtcbiAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgIHRhcmdldCA9IHt9O1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgcHJvcDIgaW4gb2JqKSB7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcDIpICYmIChvdmVyd3JpdGUgIT09IGZhbHNlIHx8ICF0YXJnZXQuaGFzT3duUHJvcGVydHkocHJvcDIpKSkge1xuICAgICAgICAgIHRhcmdldFtwcm9wMl0gPSBvYmpbcHJvcDJdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICBfX25hbWUoY29weU9iaiwgXCJjb3B5T2JqXCIpO1xuICAgIGZ1bmN0aW9uIGNvdW50Q29sdW1uKHN0cmluZywgZW5kLCB0YWJTaXplLCBzdGFydEluZGV4LCBzdGFydFZhbHVlKSB7XG4gICAgICBpZiAoZW5kID09IG51bGwpIHtcbiAgICAgICAgZW5kID0gc3RyaW5nLnNlYXJjaCgvW15cXHNcXHUwMGEwXS8pO1xuICAgICAgICBpZiAoZW5kID09IC0xKSB7XG4gICAgICAgICAgZW5kID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgaTIgPSBzdGFydEluZGV4IHx8IDAsIG4gPSBzdGFydFZhbHVlIHx8IDA7IDsgKSB7XG4gICAgICAgIHZhciBuZXh0VGFiID0gc3RyaW5nLmluZGV4T2YoXCJcdFwiLCBpMik7XG4gICAgICAgIGlmIChuZXh0VGFiIDwgMCB8fCBuZXh0VGFiID49IGVuZCkge1xuICAgICAgICAgIHJldHVybiBuICsgKGVuZCAtIGkyKTtcbiAgICAgICAgfVxuICAgICAgICBuICs9IG5leHRUYWIgLSBpMjtcbiAgICAgICAgbiArPSB0YWJTaXplIC0gbiAlIHRhYlNpemU7XG4gICAgICAgIGkyID0gbmV4dFRhYiArIDE7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShjb3VudENvbHVtbiwgXCJjb3VudENvbHVtblwiKTtcbiAgICB2YXIgRGVsYXllZCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmlkID0gbnVsbDtcbiAgICAgIHRoaXMuZiA9IG51bGw7XG4gICAgICB0aGlzLnRpbWUgPSAwO1xuICAgICAgdGhpcy5oYW5kbGVyID0gYmluZCh0aGlzLm9uVGltZW91dCwgdGhpcyk7XG4gICAgfSwgXCJEZWxheWVkXCIpO1xuICAgIERlbGF5ZWQucHJvdG90eXBlLm9uVGltZW91dCA9IGZ1bmN0aW9uKHNlbGYpIHtcbiAgICAgIHNlbGYuaWQgPSAwO1xuICAgICAgaWYgKHNlbGYudGltZSA8PSArbmV3IERhdGUoKSkge1xuICAgICAgICBzZWxmLmYoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFRpbWVvdXQoc2VsZi5oYW5kbGVyLCBzZWxmLnRpbWUgLSArbmV3IERhdGUoKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBEZWxheWVkLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihtcywgZikge1xuICAgICAgdGhpcy5mID0gZjtcbiAgICAgIHZhciB0aW1lID0gK25ldyBEYXRlKCkgKyBtcztcbiAgICAgIGlmICghdGhpcy5pZCB8fCB0aW1lIDwgdGhpcy50aW1lKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmlkKTtcbiAgICAgICAgdGhpcy5pZCA9IHNldFRpbWVvdXQodGhpcy5oYW5kbGVyLCBtcyk7XG4gICAgICAgIHRoaXMudGltZSA9IHRpbWU7XG4gICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCBlbHQyKSB7XG4gICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgYXJyYXkubGVuZ3RoOyArK2kyKSB7XG4gICAgICAgIGlmIChhcnJheVtpMl0gPT0gZWx0Mikge1xuICAgICAgICAgIHJldHVybiBpMjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBfX25hbWUoaW5kZXhPZiwgXCJpbmRleE9mXCIpO1xuICAgIHZhciBzY3JvbGxlckdhcCA9IDUwO1xuICAgIHZhciBQYXNzID0geyB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXCJDb2RlTWlycm9yLlBhc3NcIjtcbiAgICB9IH07XG4gICAgdmFyIHNlbF9kb250U2Nyb2xsID0geyBzY3JvbGw6IGZhbHNlIH0sIHNlbF9tb3VzZSA9IHsgb3JpZ2luOiBcIiptb3VzZVwiIH0sIHNlbF9tb3ZlID0geyBvcmlnaW46IFwiK21vdmVcIiB9O1xuICAgIGZ1bmN0aW9uIGZpbmRDb2x1bW4oc3RyaW5nLCBnb2FsLCB0YWJTaXplKSB7XG4gICAgICBmb3IgKHZhciBwb3MgPSAwLCBjb2wgPSAwOyA7ICkge1xuICAgICAgICB2YXIgbmV4dFRhYiA9IHN0cmluZy5pbmRleE9mKFwiXHRcIiwgcG9zKTtcbiAgICAgICAgaWYgKG5leHRUYWIgPT0gLTEpIHtcbiAgICAgICAgICBuZXh0VGFiID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2tpcHBlZCA9IG5leHRUYWIgLSBwb3M7XG4gICAgICAgIGlmIChuZXh0VGFiID09IHN0cmluZy5sZW5ndGggfHwgY29sICsgc2tpcHBlZCA+PSBnb2FsKSB7XG4gICAgICAgICAgcmV0dXJuIHBvcyArIE1hdGgubWluKHNraXBwZWQsIGdvYWwgLSBjb2wpO1xuICAgICAgICB9XG4gICAgICAgIGNvbCArPSBuZXh0VGFiIC0gcG9zO1xuICAgICAgICBjb2wgKz0gdGFiU2l6ZSAtIGNvbCAlIHRhYlNpemU7XG4gICAgICAgIHBvcyA9IG5leHRUYWIgKyAxO1xuICAgICAgICBpZiAoY29sID49IGdvYWwpIHtcbiAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShmaW5kQ29sdW1uLCBcImZpbmRDb2x1bW5cIik7XG4gICAgdmFyIHNwYWNlU3RycyA9IFtcIlwiXTtcbiAgICBmdW5jdGlvbiBzcGFjZVN0cihuKSB7XG4gICAgICB3aGlsZSAoc3BhY2VTdHJzLmxlbmd0aCA8PSBuKSB7XG4gICAgICAgIHNwYWNlU3Rycy5wdXNoKGxzdChzcGFjZVN0cnMpICsgXCIgXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNwYWNlU3Ryc1tuXTtcbiAgICB9XG4gICAgX19uYW1lKHNwYWNlU3RyLCBcInNwYWNlU3RyXCIpO1xuICAgIGZ1bmN0aW9uIGxzdChhcnIpIHtcbiAgICAgIHJldHVybiBhcnJbYXJyLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBfX25hbWUobHN0LCBcImxzdFwiKTtcbiAgICBmdW5jdGlvbiBtYXAoYXJyYXksIGYpIHtcbiAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBhcnJheS5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgb3V0W2kyXSA9IGYoYXJyYXlbaTJdLCBpMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBfX25hbWUobWFwLCBcIm1hcFwiKTtcbiAgICBmdW5jdGlvbiBpbnNlcnRTb3J0ZWQoYXJyYXksIHZhbHVlLCBzY29yZSkge1xuICAgICAgdmFyIHBvcyA9IDAsIHByaW9yaXR5ID0gc2NvcmUodmFsdWUpO1xuICAgICAgd2hpbGUgKHBvcyA8IGFycmF5Lmxlbmd0aCAmJiBzY29yZShhcnJheVtwb3NdKSA8PSBwcmlvcml0eSkge1xuICAgICAgICBwb3MrKztcbiAgICAgIH1cbiAgICAgIGFycmF5LnNwbGljZShwb3MsIDAsIHZhbHVlKTtcbiAgICB9XG4gICAgX19uYW1lKGluc2VydFNvcnRlZCwgXCJpbnNlcnRTb3J0ZWRcIik7XG4gICAgZnVuY3Rpb24gbm90aGluZygpIHtcbiAgICB9XG4gICAgX19uYW1lKG5vdGhpbmcsIFwibm90aGluZ1wiKTtcbiAgICBmdW5jdGlvbiBjcmVhdGVPYmooYmFzZSwgcHJvcHMpIHtcbiAgICAgIHZhciBpbnN0O1xuICAgICAgaWYgKE9iamVjdC5jcmVhdGUpIHtcbiAgICAgICAgaW5zdCA9IE9iamVjdC5jcmVhdGUoYmFzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub3RoaW5nLnByb3RvdHlwZSA9IGJhc2U7XG4gICAgICAgIGluc3QgPSBuZXcgbm90aGluZygpO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzKSB7XG4gICAgICAgIGNvcHlPYmoocHJvcHMsIGluc3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluc3Q7XG4gICAgfVxuICAgIF9fbmFtZShjcmVhdGVPYmosIFwiY3JlYXRlT2JqXCIpO1xuICAgIHZhciBub25BU0NJSVNpbmdsZUNhc2VXb3JkQ2hhciA9IC9bXFx1MDBkZlxcdTA1ODdcXHUwNTkwLVxcdTA1ZjRcXHUwNjAwLVxcdTA2ZmZcXHUzMDQwLVxcdTMwOWZcXHUzMGEwLVxcdTMwZmZcXHUzNDAwLVxcdTRkYjVcXHU0ZTAwLVxcdTlmY2NcXHVhYzAwLVxcdWQ3YWZdLztcbiAgICBmdW5jdGlvbiBpc1dvcmRDaGFyQmFzaWMoY2gpIHtcbiAgICAgIHJldHVybiAvXFx3Ly50ZXN0KGNoKSB8fCBjaCA+IFwiXFx4ODBcIiAmJiAoY2gudG9VcHBlckNhc2UoKSAhPSBjaC50b0xvd2VyQ2FzZSgpIHx8IG5vbkFTQ0lJU2luZ2xlQ2FzZVdvcmRDaGFyLnRlc3QoY2gpKTtcbiAgICB9XG4gICAgX19uYW1lKGlzV29yZENoYXJCYXNpYywgXCJpc1dvcmRDaGFyQmFzaWNcIik7XG4gICAgZnVuY3Rpb24gaXNXb3JkQ2hhcihjaCwgaGVscGVyKSB7XG4gICAgICBpZiAoIWhlbHBlcikge1xuICAgICAgICByZXR1cm4gaXNXb3JkQ2hhckJhc2ljKGNoKTtcbiAgICAgIH1cbiAgICAgIGlmIChoZWxwZXIuc291cmNlLmluZGV4T2YoXCJcXFxcd1wiKSA+IC0xICYmIGlzV29yZENoYXJCYXNpYyhjaCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGVscGVyLnRlc3QoY2gpO1xuICAgIH1cbiAgICBfX25hbWUoaXNXb3JkQ2hhciwgXCJpc1dvcmRDaGFyXCIpO1xuICAgIGZ1bmN0aW9uIGlzRW1wdHkob2JqKSB7XG4gICAgICBmb3IgKHZhciBuIGluIG9iaikge1xuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KG4pICYmIG9ialtuXSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIF9fbmFtZShpc0VtcHR5LCBcImlzRW1wdHlcIik7XG4gICAgdmFyIGV4dGVuZGluZ0NoYXJzID0gL1tcXHUwMzAwLVxcdTAzNmZcXHUwNDgzLVxcdTA0ODlcXHUwNTkxLVxcdTA1YmRcXHUwNWJmXFx1MDVjMVxcdTA1YzJcXHUwNWM0XFx1MDVjNVxcdTA1YzdcXHUwNjEwLVxcdTA2MWFcXHUwNjRiLVxcdTA2NWVcXHUwNjcwXFx1MDZkNi1cXHUwNmRjXFx1MDZkZS1cXHUwNmU0XFx1MDZlN1xcdTA2ZThcXHUwNmVhLVxcdTA2ZWRcXHUwNzExXFx1MDczMC1cXHUwNzRhXFx1MDdhNi1cXHUwN2IwXFx1MDdlYi1cXHUwN2YzXFx1MDgxNi1cXHUwODE5XFx1MDgxYi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJkXFx1MDkwMC1cXHUwOTAyXFx1MDkzY1xcdTA5NDEtXFx1MDk0OFxcdTA5NGRcXHUwOTUxLVxcdTA5NTVcXHUwOTYyXFx1MDk2M1xcdTA5ODFcXHUwOWJjXFx1MDliZVxcdTA5YzEtXFx1MDljNFxcdTA5Y2RcXHUwOWQ3XFx1MDllMlxcdTA5ZTNcXHUwYTAxXFx1MGEwMlxcdTBhM2NcXHUwYTQxXFx1MGE0MlxcdTBhNDdcXHUwYTQ4XFx1MGE0Yi1cXHUwYTRkXFx1MGE1MVxcdTBhNzBcXHUwYTcxXFx1MGE3NVxcdTBhODFcXHUwYTgyXFx1MGFiY1xcdTBhYzEtXFx1MGFjNVxcdTBhYzdcXHUwYWM4XFx1MGFjZFxcdTBhZTJcXHUwYWUzXFx1MGIwMVxcdTBiM2NcXHUwYjNlXFx1MGIzZlxcdTBiNDEtXFx1MGI0NFxcdTBiNGRcXHUwYjU2XFx1MGI1N1xcdTBiNjJcXHUwYjYzXFx1MGI4MlxcdTBiYmVcXHUwYmMwXFx1MGJjZFxcdTBiZDdcXHUwYzNlLVxcdTBjNDBcXHUwYzQ2LVxcdTBjNDhcXHUwYzRhLVxcdTBjNGRcXHUwYzU1XFx1MGM1NlxcdTBjNjJcXHUwYzYzXFx1MGNiY1xcdTBjYmZcXHUwY2MyXFx1MGNjNlxcdTBjY2NcXHUwY2NkXFx1MGNkNVxcdTBjZDZcXHUwY2UyXFx1MGNlM1xcdTBkM2VcXHUwZDQxLVxcdTBkNDRcXHUwZDRkXFx1MGQ1N1xcdTBkNjJcXHUwZDYzXFx1MGRjYVxcdTBkY2ZcXHUwZGQyLVxcdTBkZDRcXHUwZGQ2XFx1MGRkZlxcdTBlMzFcXHUwZTM0LVxcdTBlM2FcXHUwZTQ3LVxcdTBlNGVcXHUwZWIxXFx1MGViNC1cXHUwZWI5XFx1MGViYlxcdTBlYmNcXHUwZWM4LVxcdTBlY2RcXHUwZjE4XFx1MGYxOVxcdTBmMzVcXHUwZjM3XFx1MGYzOVxcdTBmNzEtXFx1MGY3ZVxcdTBmODAtXFx1MGY4NFxcdTBmODZcXHUwZjg3XFx1MGY5MC1cXHUwZjk3XFx1MGY5OS1cXHUwZmJjXFx1MGZjNlxcdTEwMmQtXFx1MTAzMFxcdTEwMzItXFx1MTAzN1xcdTEwMzlcXHUxMDNhXFx1MTAzZFxcdTEwM2VcXHUxMDU4XFx1MTA1OVxcdTEwNWUtXFx1MTA2MFxcdTEwNzEtXFx1MTA3NFxcdTEwODJcXHUxMDg1XFx1MTA4NlxcdTEwOGRcXHUxMDlkXFx1MTM1ZlxcdTE3MTItXFx1MTcxNFxcdTE3MzItXFx1MTczNFxcdTE3NTJcXHUxNzUzXFx1MTc3MlxcdTE3NzNcXHUxN2I3LVxcdTE3YmRcXHUxN2M2XFx1MTdjOS1cXHUxN2QzXFx1MTdkZFxcdTE4MGItXFx1MTgwZFxcdTE4YTlcXHUxOTIwLVxcdTE5MjJcXHUxOTI3XFx1MTkyOFxcdTE5MzJcXHUxOTM5LVxcdTE5M2JcXHUxYTE3XFx1MWExOFxcdTFhNTZcXHUxYTU4LVxcdTFhNWVcXHUxYTYwXFx1MWE2MlxcdTFhNjUtXFx1MWE2Y1xcdTFhNzMtXFx1MWE3Y1xcdTFhN2ZcXHUxYjAwLVxcdTFiMDNcXHUxYjM0XFx1MWIzNi1cXHUxYjNhXFx1MWIzY1xcdTFiNDJcXHUxYjZiLVxcdTFiNzNcXHUxYjgwXFx1MWI4MVxcdTFiYTItXFx1MWJhNVxcdTFiYThcXHUxYmE5XFx1MWMyYy1cXHUxYzMzXFx1MWMzNlxcdTFjMzdcXHUxY2QwLVxcdTFjZDJcXHUxY2Q0LVxcdTFjZTBcXHUxY2UyLVxcdTFjZThcXHUxY2VkXFx1MWRjMC1cXHUxZGU2XFx1MWRmZC1cXHUxZGZmXFx1MjAwY1xcdTIwMGRcXHUyMGQwLVxcdTIwZjBcXHUyY2VmLVxcdTJjZjFcXHUyZGUwLVxcdTJkZmZcXHUzMDJhLVxcdTMwMmZcXHUzMDk5XFx1MzA5YVxcdWE2NmYtXFx1YTY3MlxcdWE2N2NcXHVhNjdkXFx1YTZmMFxcdWE2ZjFcXHVhODAyXFx1YTgwNlxcdWE4MGJcXHVhODI1XFx1YTgyNlxcdWE4YzRcXHVhOGUwLVxcdWE4ZjFcXHVhOTI2LVxcdWE5MmRcXHVhOTQ3LVxcdWE5NTFcXHVhOTgwLVxcdWE5ODJcXHVhOWIzXFx1YTliNi1cXHVhOWI5XFx1YTliY1xcdWFhMjktXFx1YWEyZVxcdWFhMzFcXHVhYTMyXFx1YWEzNVxcdWFhMzZcXHVhYTQzXFx1YWE0Y1xcdWFhYjBcXHVhYWIyLVxcdWFhYjRcXHVhYWI3XFx1YWFiOFxcdWFhYmVcXHVhYWJmXFx1YWFjMVxcdWFiZTVcXHVhYmU4XFx1YWJlZFxcdWRjMDAtXFx1ZGZmZlxcdWZiMWVcXHVmZTAwLVxcdWZlMGZcXHVmZTIwLVxcdWZlMjZcXHVmZjllXFx1ZmY5Zl0vO1xuICAgIGZ1bmN0aW9uIGlzRXh0ZW5kaW5nQ2hhcihjaCkge1xuICAgICAgcmV0dXJuIGNoLmNoYXJDb2RlQXQoMCkgPj0gNzY4ICYmIGV4dGVuZGluZ0NoYXJzLnRlc3QoY2gpO1xuICAgIH1cbiAgICBfX25hbWUoaXNFeHRlbmRpbmdDaGFyLCBcImlzRXh0ZW5kaW5nQ2hhclwiKTtcbiAgICBmdW5jdGlvbiBza2lwRXh0ZW5kaW5nQ2hhcnMoc3RyLCBwb3MsIGRpcikge1xuICAgICAgd2hpbGUgKChkaXIgPCAwID8gcG9zID4gMCA6IHBvcyA8IHN0ci5sZW5ndGgpICYmIGlzRXh0ZW5kaW5nQ2hhcihzdHIuY2hhckF0KHBvcykpKSB7XG4gICAgICAgIHBvcyArPSBkaXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICBfX25hbWUoc2tpcEV4dGVuZGluZ0NoYXJzLCBcInNraXBFeHRlbmRpbmdDaGFyc1wiKTtcbiAgICBmdW5jdGlvbiBmaW5kRmlyc3QocHJlZCwgZnJvbSwgdG8pIHtcbiAgICAgIHZhciBkaXIgPSBmcm9tID4gdG8gPyAtMSA6IDE7XG4gICAgICBmb3IgKDsgOyApIHtcbiAgICAgICAgaWYgKGZyb20gPT0gdG8pIHtcbiAgICAgICAgICByZXR1cm4gZnJvbTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWlkRiA9IChmcm9tICsgdG8pIC8gMiwgbWlkID0gZGlyIDwgMCA/IE1hdGguY2VpbChtaWRGKSA6IE1hdGguZmxvb3IobWlkRik7XG4gICAgICAgIGlmIChtaWQgPT0gZnJvbSkge1xuICAgICAgICAgIHJldHVybiBwcmVkKG1pZCkgPyBmcm9tIDogdG87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZWQobWlkKSkge1xuICAgICAgICAgIHRvID0gbWlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZyb20gPSBtaWQgKyBkaXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKGZpbmRGaXJzdCwgXCJmaW5kRmlyc3RcIik7XG4gICAgZnVuY3Rpb24gaXRlcmF0ZUJpZGlTZWN0aW9ucyhvcmRlciwgZnJvbSwgdG8sIGYpIHtcbiAgICAgIGlmICghb3JkZXIpIHtcbiAgICAgICAgcmV0dXJuIGYoZnJvbSwgdG8sIFwibHRyXCIsIDApO1xuICAgICAgfVxuICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgb3JkZXIubGVuZ3RoOyArK2kyKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gb3JkZXJbaTJdO1xuICAgICAgICBpZiAocGFydC5mcm9tIDwgdG8gJiYgcGFydC50byA+IGZyb20gfHwgZnJvbSA9PSB0byAmJiBwYXJ0LnRvID09IGZyb20pIHtcbiAgICAgICAgICBmKE1hdGgubWF4KHBhcnQuZnJvbSwgZnJvbSksIE1hdGgubWluKHBhcnQudG8sIHRvKSwgcGFydC5sZXZlbCA9PSAxID8gXCJydGxcIiA6IFwibHRyXCIsIGkyKTtcbiAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgZihmcm9tLCB0bywgXCJsdHJcIik7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShpdGVyYXRlQmlkaVNlY3Rpb25zLCBcIml0ZXJhdGVCaWRpU2VjdGlvbnNcIik7XG4gICAgdmFyIGJpZGlPdGhlciA9IG51bGw7XG4gICAgZnVuY3Rpb24gZ2V0QmlkaVBhcnRBdChvcmRlciwgY2gsIHN0aWNreSkge1xuICAgICAgdmFyIGZvdW5kO1xuICAgICAgYmlkaU90aGVyID0gbnVsbDtcbiAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBvcmRlci5sZW5ndGg7ICsraTIpIHtcbiAgICAgICAgdmFyIGN1ciA9IG9yZGVyW2kyXTtcbiAgICAgICAgaWYgKGN1ci5mcm9tIDwgY2ggJiYgY3VyLnRvID4gY2gpIHtcbiAgICAgICAgICByZXR1cm4gaTI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1ci50byA9PSBjaCkge1xuICAgICAgICAgIGlmIChjdXIuZnJvbSAhPSBjdXIudG8gJiYgc3RpY2t5ID09IFwiYmVmb3JlXCIpIHtcbiAgICAgICAgICAgIGZvdW5kID0gaTI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJpZGlPdGhlciA9IGkyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VyLmZyb20gPT0gY2gpIHtcbiAgICAgICAgICBpZiAoY3VyLmZyb20gIT0gY3VyLnRvICYmIHN0aWNreSAhPSBcImJlZm9yZVwiKSB7XG4gICAgICAgICAgICBmb3VuZCA9IGkyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiaWRpT3RoZXIgPSBpMjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmb3VuZCAhPSBudWxsID8gZm91bmQgOiBiaWRpT3RoZXI7XG4gICAgfVxuICAgIF9fbmFtZShnZXRCaWRpUGFydEF0LCBcImdldEJpZGlQYXJ0QXRcIik7XG4gICAgdmFyIGJpZGlPcmRlcmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxvd1R5cGVzID0gXCJiYmJiYmJiYmJ0c3R3c2JiYmJiYmJiYmJiYmJic3NzdHdOTiUlJU5OTk5OTixOLE4xMTExMTExMTExTk5OTk5OTkxMTExMTExMTExMTExMTExMTExMTExMTExMTk5OTk5OTExMTExMTExMTExMTExMTExMTExMTExMTExOTk5OYmJiYmJic2JiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiLE4lJSUlTk5OTkxOTk5OTiUlMTFOTE5OTjFMTk5OTk5MTExMTExMTExMTExMTExMTExMTExMTE5MTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTlwiO1xuICAgICAgdmFyIGFyYWJpY1R5cGVzID0gXCJubm5ubm5OTnIlJXIsck5ObW1tbW1tbW1tbW1ycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJtbW1tbW1tbW1tbW1tbW1tbW1tbW1ubm5ubm5ubm5uJW5ucnJybXJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJybW1tbW1tbW5ObW1tbW1tcnJtbU5tbW1tcnIxMTExMTExMTExXCI7XG4gICAgICBmdW5jdGlvbiBjaGFyVHlwZShjb2RlKSB7XG4gICAgICAgIGlmIChjb2RlIDw9IDI0Nykge1xuICAgICAgICAgIHJldHVybiBsb3dUeXBlcy5jaGFyQXQoY29kZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoMTQyNCA8PSBjb2RlICYmIGNvZGUgPD0gMTUyNCkge1xuICAgICAgICAgIHJldHVybiBcIlJcIjtcbiAgICAgICAgfSBlbHNlIGlmICgxNTM2IDw9IGNvZGUgJiYgY29kZSA8PSAxNzg1KSB7XG4gICAgICAgICAgcmV0dXJuIGFyYWJpY1R5cGVzLmNoYXJBdChjb2RlIC0gMTUzNik7XG4gICAgICAgIH0gZWxzZSBpZiAoMTc3NCA8PSBjb2RlICYmIGNvZGUgPD0gMjIyMCkge1xuICAgICAgICAgIHJldHVybiBcInJcIjtcbiAgICAgICAgfSBlbHNlIGlmICg4MTkyIDw9IGNvZGUgJiYgY29kZSA8PSA4MjAzKSB7XG4gICAgICAgICAgcmV0dXJuIFwid1wiO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT0gODIwNCkge1xuICAgICAgICAgIHJldHVybiBcImJcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gXCJMXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF9fbmFtZShjaGFyVHlwZSwgXCJjaGFyVHlwZVwiKTtcbiAgICAgIHZhciBiaWRpUkUgPSAvW1xcdTA1OTAtXFx1MDVmNFxcdTA2MDAtXFx1MDZmZlxcdTA3MDAtXFx1MDhhY10vO1xuICAgICAgdmFyIGlzTmV1dHJhbCA9IC9bc3R3Tl0vLCBpc1N0cm9uZyA9IC9bTFJyXS8sIGNvdW50c0FzTGVmdCA9IC9bTGIxbl0vLCBjb3VudHNBc051bSA9IC9bMW5dLztcbiAgICAgIGZ1bmN0aW9uIEJpZGlTcGFuKGxldmVsLCBmcm9tLCB0bykge1xuICAgICAgICB0aGlzLmxldmVsID0gbGV2ZWw7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgIH1cbiAgICAgIF9fbmFtZShCaWRpU3BhbiwgXCJCaWRpU3BhblwiKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbihzdHIsIGRpcmVjdGlvbikge1xuICAgICAgICB2YXIgb3V0ZXJUeXBlID0gZGlyZWN0aW9uID09IFwibHRyXCIgPyBcIkxcIiA6IFwiUlwiO1xuICAgICAgICBpZiAoc3RyLmxlbmd0aCA9PSAwIHx8IGRpcmVjdGlvbiA9PSBcImx0clwiICYmICFiaWRpUkUudGVzdChzdHIpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZW4gPSBzdHIubGVuZ3RoLCB0eXBlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgbGVuOyArK2kyKSB7XG4gICAgICAgICAgdHlwZXMucHVzaChjaGFyVHlwZShzdHIuY2hhckNvZGVBdChpMikpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpJDEyID0gMCwgcHJldiA9IG91dGVyVHlwZTsgaSQxMiA8IGxlbjsgKytpJDEyKSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSB0eXBlc1tpJDEyXTtcbiAgICAgICAgICBpZiAodHlwZSA9PSBcIm1cIikge1xuICAgICAgICAgICAgdHlwZXNbaSQxMl0gPSBwcmV2O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmV2ID0gdHlwZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSQyMiA9IDAsIGN1ciA9IG91dGVyVHlwZTsgaSQyMiA8IGxlbjsgKytpJDIyKSB7XG4gICAgICAgICAgdmFyIHR5cGUkMSA9IHR5cGVzW2kkMjJdO1xuICAgICAgICAgIGlmICh0eXBlJDEgPT0gXCIxXCIgJiYgY3VyID09IFwiclwiKSB7XG4gICAgICAgICAgICB0eXBlc1tpJDIyXSA9IFwiblwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNTdHJvbmcudGVzdCh0eXBlJDEpKSB7XG4gICAgICAgICAgICBjdXIgPSB0eXBlJDE7XG4gICAgICAgICAgICBpZiAodHlwZSQxID09IFwiclwiKSB7XG4gICAgICAgICAgICAgIHR5cGVzW2kkMjJdID0gXCJSXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkkMyA9IDEsIHByZXYkMSA9IHR5cGVzWzBdOyBpJDMgPCBsZW4gLSAxOyArK2kkMykge1xuICAgICAgICAgIHZhciB0eXBlJDIgPSB0eXBlc1tpJDNdO1xuICAgICAgICAgIGlmICh0eXBlJDIgPT0gXCIrXCIgJiYgcHJldiQxID09IFwiMVwiICYmIHR5cGVzW2kkMyArIDFdID09IFwiMVwiKSB7XG4gICAgICAgICAgICB0eXBlc1tpJDNdID0gXCIxXCI7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlJDIgPT0gXCIsXCIgJiYgcHJldiQxID09IHR5cGVzW2kkMyArIDFdICYmIChwcmV2JDEgPT0gXCIxXCIgfHwgcHJldiQxID09IFwiblwiKSkge1xuICAgICAgICAgICAgdHlwZXNbaSQzXSA9IHByZXYkMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJldiQxID0gdHlwZSQyO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkkNCA9IDA7IGkkNCA8IGxlbjsgKytpJDQpIHtcbiAgICAgICAgICB2YXIgdHlwZSQzID0gdHlwZXNbaSQ0XTtcbiAgICAgICAgICBpZiAodHlwZSQzID09IFwiLFwiKSB7XG4gICAgICAgICAgICB0eXBlc1tpJDRdID0gXCJOXCI7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlJDMgPT0gXCIlXCIpIHtcbiAgICAgICAgICAgIHZhciBlbmQgPSB2b2lkIDA7XG4gICAgICAgICAgICBmb3IgKGVuZCA9IGkkNCArIDE7IGVuZCA8IGxlbiAmJiB0eXBlc1tlbmRdID09IFwiJVwiOyArK2VuZCkge1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlcGxhY2UgPSBpJDQgJiYgdHlwZXNbaSQ0IC0gMV0gPT0gXCIhXCIgfHwgZW5kIDwgbGVuICYmIHR5cGVzW2VuZF0gPT0gXCIxXCIgPyBcIjFcIiA6IFwiTlwiO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IGkkNDsgaiA8IGVuZDsgKytqKSB7XG4gICAgICAgICAgICAgIHR5cGVzW2pdID0gcmVwbGFjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkkNCA9IGVuZCAtIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkkNSA9IDAsIGN1ciQxID0gb3V0ZXJUeXBlOyBpJDUgPCBsZW47ICsraSQ1KSB7XG4gICAgICAgICAgdmFyIHR5cGUkNCA9IHR5cGVzW2kkNV07XG4gICAgICAgICAgaWYgKGN1ciQxID09IFwiTFwiICYmIHR5cGUkNCA9PSBcIjFcIikge1xuICAgICAgICAgICAgdHlwZXNbaSQ1XSA9IFwiTFwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNTdHJvbmcudGVzdCh0eXBlJDQpKSB7XG4gICAgICAgICAgICBjdXIkMSA9IHR5cGUkNDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSQ2ID0gMDsgaSQ2IDwgbGVuOyArK2kkNikge1xuICAgICAgICAgIGlmIChpc05ldXRyYWwudGVzdCh0eXBlc1tpJDZdKSkge1xuICAgICAgICAgICAgdmFyIGVuZCQxID0gdm9pZCAwO1xuICAgICAgICAgICAgZm9yIChlbmQkMSA9IGkkNiArIDE7IGVuZCQxIDwgbGVuICYmIGlzTmV1dHJhbC50ZXN0KHR5cGVzW2VuZCQxXSk7ICsrZW5kJDEpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBiZWZvcmUgPSAoaSQ2ID8gdHlwZXNbaSQ2IC0gMV0gOiBvdXRlclR5cGUpID09IFwiTFwiO1xuICAgICAgICAgICAgdmFyIGFmdGVyID0gKGVuZCQxIDwgbGVuID8gdHlwZXNbZW5kJDFdIDogb3V0ZXJUeXBlKSA9PSBcIkxcIjtcbiAgICAgICAgICAgIHZhciByZXBsYWNlJDEgPSBiZWZvcmUgPT0gYWZ0ZXIgPyBiZWZvcmUgPyBcIkxcIiA6IFwiUlwiIDogb3V0ZXJUeXBlO1xuICAgICAgICAgICAgZm9yICh2YXIgaiQxID0gaSQ2OyBqJDEgPCBlbmQkMTsgKytqJDEpIHtcbiAgICAgICAgICAgICAgdHlwZXNbaiQxXSA9IHJlcGxhY2UkMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkkNiA9IGVuZCQxIC0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9yZGVyID0gW10sIG07XG4gICAgICAgIGZvciAodmFyIGkkNyA9IDA7IGkkNyA8IGxlbjsgKSB7XG4gICAgICAgICAgaWYgKGNvdW50c0FzTGVmdC50ZXN0KHR5cGVzW2kkN10pKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBpJDc7XG4gICAgICAgICAgICBmb3IgKCsraSQ3OyBpJDcgPCBsZW4gJiYgY291bnRzQXNMZWZ0LnRlc3QodHlwZXNbaSQ3XSk7ICsraSQ3KSB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcmRlci5wdXNoKG5ldyBCaWRpU3BhbigwLCBzdGFydCwgaSQ3KSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwb3MgPSBpJDcsIGF0ID0gb3JkZXIubGVuZ3RoLCBpc1JUTCA9IGRpcmVjdGlvbiA9PSBcInJ0bFwiID8gMSA6IDA7XG4gICAgICAgICAgICBmb3IgKCsraSQ3OyBpJDcgPCBsZW4gJiYgdHlwZXNbaSQ3XSAhPSBcIkxcIjsgKytpJDcpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGokMiA9IHBvczsgaiQyIDwgaSQ3OyApIHtcbiAgICAgICAgICAgICAgaWYgKGNvdW50c0FzTnVtLnRlc3QodHlwZXNbaiQyXSkpIHtcbiAgICAgICAgICAgICAgICBpZiAocG9zIDwgaiQyKSB7XG4gICAgICAgICAgICAgICAgICBvcmRlci5zcGxpY2UoYXQsIDAsIG5ldyBCaWRpU3BhbigxLCBwb3MsIGokMikpO1xuICAgICAgICAgICAgICAgICAgYXQgKz0gaXNSVEw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBuc3RhcnQgPSBqJDI7XG4gICAgICAgICAgICAgICAgZm9yICgrK2okMjsgaiQyIDwgaSQ3ICYmIGNvdW50c0FzTnVtLnRlc3QodHlwZXNbaiQyXSk7ICsraiQyKSB7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9yZGVyLnNwbGljZShhdCwgMCwgbmV3IEJpZGlTcGFuKDIsIG5zdGFydCwgaiQyKSk7XG4gICAgICAgICAgICAgICAgYXQgKz0gaXNSVEw7XG4gICAgICAgICAgICAgICAgcG9zID0gaiQyO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICsraiQyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zIDwgaSQ3KSB7XG4gICAgICAgICAgICAgIG9yZGVyLnNwbGljZShhdCwgMCwgbmV3IEJpZGlTcGFuKDEsIHBvcywgaSQ3KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT0gXCJsdHJcIikge1xuICAgICAgICAgIGlmIChvcmRlclswXS5sZXZlbCA9PSAxICYmIChtID0gc3RyLm1hdGNoKC9eXFxzKy8pKSkge1xuICAgICAgICAgICAgb3JkZXJbMF0uZnJvbSA9IG1bMF0ubGVuZ3RoO1xuICAgICAgICAgICAgb3JkZXIudW5zaGlmdChuZXcgQmlkaVNwYW4oMCwgMCwgbVswXS5sZW5ndGgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxzdChvcmRlcikubGV2ZWwgPT0gMSAmJiAobSA9IHN0ci5tYXRjaCgvXFxzKyQvKSkpIHtcbiAgICAgICAgICAgIGxzdChvcmRlcikudG8gLT0gbVswXS5sZW5ndGg7XG4gICAgICAgICAgICBvcmRlci5wdXNoKG5ldyBCaWRpU3BhbigwLCBsZW4gLSBtWzBdLmxlbmd0aCwgbGVuKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaXJlY3Rpb24gPT0gXCJydGxcIiA/IG9yZGVyLnJldmVyc2UoKSA6IG9yZGVyO1xuICAgICAgfTtcbiAgICB9KCk7XG4gICAgZnVuY3Rpb24gZ2V0T3JkZXIobGluZSwgZGlyZWN0aW9uKSB7XG4gICAgICB2YXIgb3JkZXIgPSBsaW5lLm9yZGVyO1xuICAgICAgaWYgKG9yZGVyID09IG51bGwpIHtcbiAgICAgICAgb3JkZXIgPSBsaW5lLm9yZGVyID0gYmlkaU9yZGVyaW5nKGxpbmUudGV4dCwgZGlyZWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmRlcjtcbiAgICB9XG4gICAgX19uYW1lKGdldE9yZGVyLCBcImdldE9yZGVyXCIpO1xuICAgIHZhciBub0hhbmRsZXJzID0gW107XG4gICAgdmFyIG9uID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbihlbWl0dGVyLCB0eXBlLCBmKSB7XG4gICAgICBpZiAoZW1pdHRlci5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmLCBmYWxzZSk7XG4gICAgICB9IGVsc2UgaWYgKGVtaXR0ZXIuYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgZW1pdHRlci5hdHRhY2hFdmVudChcIm9uXCIgKyB0eXBlLCBmKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBtYXAyID0gZW1pdHRlci5faGFuZGxlcnMgfHwgKGVtaXR0ZXIuX2hhbmRsZXJzID0ge30pO1xuICAgICAgICBtYXAyW3R5cGVdID0gKG1hcDJbdHlwZV0gfHwgbm9IYW5kbGVycykuY29uY2F0KGYpO1xuICAgICAgfVxuICAgIH0sIFwib25cIik7XG4gICAgZnVuY3Rpb24gZ2V0SGFuZGxlcnMoZW1pdHRlciwgdHlwZSkge1xuICAgICAgcmV0dXJuIGVtaXR0ZXIuX2hhbmRsZXJzICYmIGVtaXR0ZXIuX2hhbmRsZXJzW3R5cGVdIHx8IG5vSGFuZGxlcnM7XG4gICAgfVxuICAgIF9fbmFtZShnZXRIYW5kbGVycywgXCJnZXRIYW5kbGVyc1wiKTtcbiAgICBmdW5jdGlvbiBvZmYoZW1pdHRlciwgdHlwZSwgZikge1xuICAgICAgaWYgKGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZiwgZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmIChlbWl0dGVyLmRldGFjaEV2ZW50KSB7XG4gICAgICAgIGVtaXR0ZXIuZGV0YWNoRXZlbnQoXCJvblwiICsgdHlwZSwgZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbWFwMiA9IGVtaXR0ZXIuX2hhbmRsZXJzLCBhcnIgPSBtYXAyICYmIG1hcDJbdHlwZV07XG4gICAgICAgIGlmIChhcnIpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSBpbmRleE9mKGFyciwgZik7XG4gICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIG1hcDJbdHlwZV0gPSBhcnIuc2xpY2UoMCwgaW5kZXgpLmNvbmNhdChhcnIuc2xpY2UoaW5kZXggKyAxKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShvZmYsIFwib2ZmXCIpO1xuICAgIGZ1bmN0aW9uIHNpZ25hbChlbWl0dGVyLCB0eXBlKSB7XG4gICAgICB2YXIgaGFuZGxlcnMgPSBnZXRIYW5kbGVycyhlbWl0dGVyLCB0eXBlKTtcbiAgICAgIGlmICghaGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBoYW5kbGVycy5sZW5ndGg7ICsraTIpIHtcbiAgICAgICAgaGFuZGxlcnNbaTJdLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoc2lnbmFsLCBcInNpZ25hbFwiKTtcbiAgICBmdW5jdGlvbiBzaWduYWxET01FdmVudChjbSwgZSwgb3ZlcnJpZGUpIHtcbiAgICAgIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGUgPSB7IHR5cGU6IGUsIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgICB9IH07XG4gICAgICB9XG4gICAgICBzaWduYWwoY20sIG92ZXJyaWRlIHx8IGUudHlwZSwgY20sIGUpO1xuICAgICAgcmV0dXJuIGVfZGVmYXVsdFByZXZlbnRlZChlKSB8fCBlLmNvZGVtaXJyb3JJZ25vcmU7XG4gICAgfVxuICAgIF9fbmFtZShzaWduYWxET01FdmVudCwgXCJzaWduYWxET01FdmVudFwiKTtcbiAgICBmdW5jdGlvbiBzaWduYWxDdXJzb3JBY3Rpdml0eShjbSkge1xuICAgICAgdmFyIGFyciA9IGNtLl9oYW5kbGVycyAmJiBjbS5faGFuZGxlcnMuY3Vyc29yQWN0aXZpdHk7XG4gICAgICBpZiAoIWFycikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgc2V0ID0gY20uY3VyT3AuY3Vyc29yQWN0aXZpdHlIYW5kbGVycyB8fCAoY20uY3VyT3AuY3Vyc29yQWN0aXZpdHlIYW5kbGVycyA9IFtdKTtcbiAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBhcnIubGVuZ3RoOyArK2kyKSB7XG4gICAgICAgIGlmIChpbmRleE9mKHNldCwgYXJyW2kyXSkgPT0gLTEpIHtcbiAgICAgICAgICBzZXQucHVzaChhcnJbaTJdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoc2lnbmFsQ3Vyc29yQWN0aXZpdHksIFwic2lnbmFsQ3Vyc29yQWN0aXZpdHlcIik7XG4gICAgZnVuY3Rpb24gaGFzSGFuZGxlcihlbWl0dGVyLCB0eXBlKSB7XG4gICAgICByZXR1cm4gZ2V0SGFuZGxlcnMoZW1pdHRlciwgdHlwZSkubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgX19uYW1lKGhhc0hhbmRsZXIsIFwiaGFzSGFuZGxlclwiKTtcbiAgICBmdW5jdGlvbiBldmVudE1peGluKGN0b3IpIHtcbiAgICAgIGN0b3IucHJvdG90eXBlLm9uID0gZnVuY3Rpb24odHlwZSwgZikge1xuICAgICAgICBvbih0aGlzLCB0eXBlLCBmKTtcbiAgICAgIH07XG4gICAgICBjdG9yLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbih0eXBlLCBmKSB7XG4gICAgICAgIG9mZih0aGlzLCB0eXBlLCBmKTtcbiAgICAgIH07XG4gICAgfVxuICAgIF9fbmFtZShldmVudE1peGluLCBcImV2ZW50TWl4aW5cIik7XG4gICAgZnVuY3Rpb24gZV9wcmV2ZW50RGVmYXVsdChlKSB7XG4gICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShlX3ByZXZlbnREZWZhdWx0LCBcImVfcHJldmVudERlZmF1bHRcIik7XG4gICAgZnVuY3Rpb24gZV9zdG9wUHJvcGFnYXRpb24oZSkge1xuICAgICAgaWYgKGUuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShlX3N0b3BQcm9wYWdhdGlvbiwgXCJlX3N0b3BQcm9wYWdhdGlvblwiKTtcbiAgICBmdW5jdGlvbiBlX2RlZmF1bHRQcmV2ZW50ZWQoZSkge1xuICAgICAgcmV0dXJuIGUuZGVmYXVsdFByZXZlbnRlZCAhPSBudWxsID8gZS5kZWZhdWx0UHJldmVudGVkIDogZS5yZXR1cm5WYWx1ZSA9PSBmYWxzZTtcbiAgICB9XG4gICAgX19uYW1lKGVfZGVmYXVsdFByZXZlbnRlZCwgXCJlX2RlZmF1bHRQcmV2ZW50ZWRcIik7XG4gICAgZnVuY3Rpb24gZV9zdG9wKGUpIHtcbiAgICAgIGVfcHJldmVudERlZmF1bHQoZSk7XG4gICAgICBlX3N0b3BQcm9wYWdhdGlvbihlKTtcbiAgICB9XG4gICAgX19uYW1lKGVfc3RvcCwgXCJlX3N0b3BcIik7XG4gICAgZnVuY3Rpb24gZV90YXJnZXQoZSkge1xuICAgICAgcmV0dXJuIGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcbiAgICB9XG4gICAgX19uYW1lKGVfdGFyZ2V0LCBcImVfdGFyZ2V0XCIpO1xuICAgIGZ1bmN0aW9uIGVfYnV0dG9uKGUpIHtcbiAgICAgIHZhciBiID0gZS53aGljaDtcbiAgICAgIGlmIChiID09IG51bGwpIHtcbiAgICAgICAgaWYgKGUuYnV0dG9uICYgMSkge1xuICAgICAgICAgIGIgPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKGUuYnV0dG9uICYgMikge1xuICAgICAgICAgIGIgPSAzO1xuICAgICAgICB9IGVsc2UgaWYgKGUuYnV0dG9uICYgNCkge1xuICAgICAgICAgIGIgPSAyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWFjICYmIGUuY3RybEtleSAmJiBiID09IDEpIHtcbiAgICAgICAgYiA9IDM7XG4gICAgICB9XG4gICAgICByZXR1cm4gYjtcbiAgICB9XG4gICAgX19uYW1lKGVfYnV0dG9uLCBcImVfYnV0dG9uXCIpO1xuICAgIHZhciBkcmFnQW5kRHJvcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCA5KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBkaXYgPSBlbHQoXCJkaXZcIik7XG4gICAgICByZXR1cm4gXCJkcmFnZ2FibGVcIiBpbiBkaXYgfHwgXCJkcmFnRHJvcFwiIGluIGRpdjtcbiAgICB9KCk7XG4gICAgdmFyIHp3c3BTdXBwb3J0ZWQ7XG4gICAgZnVuY3Rpb24gemVyb1dpZHRoRWxlbWVudChtZWFzdXJlKSB7XG4gICAgICBpZiAoendzcFN1cHBvcnRlZCA9PSBudWxsKSB7XG4gICAgICAgIHZhciB0ZXN0ID0gZWx0KFwic3BhblwiLCBcIlxcdTIwMEJcIik7XG4gICAgICAgIHJlbW92ZUNoaWxkcmVuQW5kQWRkKG1lYXN1cmUsIGVsdChcInNwYW5cIiwgW3Rlc3QsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwieFwiKV0pKTtcbiAgICAgICAgaWYgKG1lYXN1cmUuZmlyc3RDaGlsZC5vZmZzZXRIZWlnaHQgIT0gMCkge1xuICAgICAgICAgIHp3c3BTdXBwb3J0ZWQgPSB0ZXN0Lm9mZnNldFdpZHRoIDw9IDEgJiYgdGVzdC5vZmZzZXRIZWlnaHQgPiAyICYmICEoaWUgJiYgaWVfdmVyc2lvbiA8IDgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgbm9kZSA9IHp3c3BTdXBwb3J0ZWQgPyBlbHQoXCJzcGFuXCIsIFwiXFx1MjAwQlwiKSA6IGVsdChcInNwYW5cIiwgXCJcXHhBMFwiLCBudWxsLCBcImRpc3BsYXk6IGlubGluZS1ibG9jazsgd2lkdGg6IDFweDsgbWFyZ2luLXJpZ2h0OiAtMXB4XCIpO1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJjbS10ZXh0XCIsIFwiXCIpO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIF9fbmFtZSh6ZXJvV2lkdGhFbGVtZW50LCBcInplcm9XaWR0aEVsZW1lbnRcIik7XG4gICAgdmFyIGJhZEJpZGlSZWN0cztcbiAgICBmdW5jdGlvbiBoYXNCYWRCaWRpUmVjdHMobWVhc3VyZSkge1xuICAgICAgaWYgKGJhZEJpZGlSZWN0cyAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBiYWRCaWRpUmVjdHM7XG4gICAgICB9XG4gICAgICB2YXIgdHh0ID0gcmVtb3ZlQ2hpbGRyZW5BbmRBZGQobWVhc3VyZSwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJBXFx1MDYyRUFcIikpO1xuICAgICAgdmFyIHIwID0gcmFuZ2UodHh0LCAwLCAxKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciByMSA9IHJhbmdlKHR4dCwgMSwgMikuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICByZW1vdmVDaGlsZHJlbihtZWFzdXJlKTtcbiAgICAgIGlmICghcjAgfHwgcjAubGVmdCA9PSByMC5yaWdodCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFkQmlkaVJlY3RzID0gcjEucmlnaHQgLSByMC5yaWdodCA8IDM7XG4gICAgfVxuICAgIF9fbmFtZShoYXNCYWRCaWRpUmVjdHMsIFwiaGFzQmFkQmlkaVJlY3RzXCIpO1xuICAgIHZhciBzcGxpdExpbmVzQXV0byA9IFwiXFxuXFxuYlwiLnNwbGl0KC9cXG4vKS5sZW5ndGggIT0gMyA/IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgdmFyIHBvcyA9IDAsIHJlc3VsdCA9IFtdLCBsID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgIHdoaWxlIChwb3MgPD0gbCkge1xuICAgICAgICB2YXIgbmwgPSBzdHJpbmcuaW5kZXhPZihcIlxcblwiLCBwb3MpO1xuICAgICAgICBpZiAobmwgPT0gLTEpIHtcbiAgICAgICAgICBubCA9IHN0cmluZy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxpbmUgPSBzdHJpbmcuc2xpY2UocG9zLCBzdHJpbmcuY2hhckF0KG5sIC0gMSkgPT0gXCJcXHJcIiA/IG5sIC0gMSA6IG5sKTtcbiAgICAgICAgdmFyIHJ0ID0gbGluZS5pbmRleE9mKFwiXFxyXCIpO1xuICAgICAgICBpZiAocnQgIT0gLTEpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChsaW5lLnNsaWNlKDAsIHJ0KSk7XG4gICAgICAgICAgcG9zICs9IHJ0ICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQucHVzaChsaW5lKTtcbiAgICAgICAgICBwb3MgPSBubCArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSA6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgcmV0dXJuIHN0cmluZy5zcGxpdCgvXFxyXFxuP3xcXG4vKTtcbiAgICB9O1xuICAgIHZhciBoYXNTZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uID8gZnVuY3Rpb24odGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0ZS5zZWxlY3Rpb25TdGFydCAhPSB0ZS5zZWxlY3Rpb25FbmQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IDogZnVuY3Rpb24odGUpIHtcbiAgICAgIHZhciByYW5nZTI7XG4gICAgICB0cnkge1xuICAgICAgICByYW5nZTIgPSB0ZS5vd25lckRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgfVxuICAgICAgaWYgKCFyYW5nZTIgfHwgcmFuZ2UyLnBhcmVudEVsZW1lbnQoKSAhPSB0ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmFuZ2UyLmNvbXBhcmVFbmRQb2ludHMoXCJTdGFydFRvRW5kXCIsIHJhbmdlMikgIT0gMDtcbiAgICB9O1xuICAgIHZhciBoYXNDb3B5RXZlbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlID0gZWx0KFwiZGl2XCIpO1xuICAgICAgaWYgKFwib25jb3B5XCIgaW4gZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGUuc2V0QXR0cmlidXRlKFwib25jb3B5XCIsIFwicmV0dXJuO1wiKTtcbiAgICAgIHJldHVybiB0eXBlb2YgZS5vbmNvcHkgPT0gXCJmdW5jdGlvblwiO1xuICAgIH0oKTtcbiAgICB2YXIgYmFkWm9vbWVkUmVjdHMgPSBudWxsO1xuICAgIGZ1bmN0aW9uIGhhc0JhZFpvb21lZFJlY3RzKG1lYXN1cmUpIHtcbiAgICAgIGlmIChiYWRab29tZWRSZWN0cyAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBiYWRab29tZWRSZWN0cztcbiAgICAgIH1cbiAgICAgIHZhciBub2RlID0gcmVtb3ZlQ2hpbGRyZW5BbmRBZGQobWVhc3VyZSwgZWx0KFwic3BhblwiLCBcInhcIikpO1xuICAgICAgdmFyIG5vcm1hbCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgZnJvbVJhbmdlID0gcmFuZ2Uobm9kZSwgMCwgMSkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICByZXR1cm4gYmFkWm9vbWVkUmVjdHMgPSBNYXRoLmFicyhub3JtYWwubGVmdCAtIGZyb21SYW5nZS5sZWZ0KSA+IDE7XG4gICAgfVxuICAgIF9fbmFtZShoYXNCYWRab29tZWRSZWN0cywgXCJoYXNCYWRab29tZWRSZWN0c1wiKTtcbiAgICB2YXIgbW9kZXMgPSB7fSwgbWltZU1vZGVzID0ge307XG4gICAgZnVuY3Rpb24gZGVmaW5lTW9kZShuYW1lLCBtb2RlKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgbW9kZS5kZXBlbmRlbmNpZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgICAgfVxuICAgICAgbW9kZXNbbmFtZV0gPSBtb2RlO1xuICAgIH1cbiAgICBfX25hbWUoZGVmaW5lTW9kZSwgXCJkZWZpbmVNb2RlXCIpO1xuICAgIGZ1bmN0aW9uIGRlZmluZU1JTUUobWltZSwgc3BlYykge1xuICAgICAgbWltZU1vZGVzW21pbWVdID0gc3BlYztcbiAgICB9XG4gICAgX19uYW1lKGRlZmluZU1JTUUsIFwiZGVmaW5lTUlNRVwiKTtcbiAgICBmdW5jdGlvbiByZXNvbHZlTW9kZShzcGVjKSB7XG4gICAgICBpZiAodHlwZW9mIHNwZWMgPT0gXCJzdHJpbmdcIiAmJiBtaW1lTW9kZXMuaGFzT3duUHJvcGVydHkoc3BlYykpIHtcbiAgICAgICAgc3BlYyA9IG1pbWVNb2Rlc1tzcGVjXTtcbiAgICAgIH0gZWxzZSBpZiAoc3BlYyAmJiB0eXBlb2Ygc3BlYy5uYW1lID09IFwic3RyaW5nXCIgJiYgbWltZU1vZGVzLmhhc093blByb3BlcnR5KHNwZWMubmFtZSkpIHtcbiAgICAgICAgdmFyIGZvdW5kID0gbWltZU1vZGVzW3NwZWMubmFtZV07XG4gICAgICAgIGlmICh0eXBlb2YgZm91bmQgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGZvdW5kID0geyBuYW1lOiBmb3VuZCB9O1xuICAgICAgICB9XG4gICAgICAgIHNwZWMgPSBjcmVhdGVPYmooZm91bmQsIHNwZWMpO1xuICAgICAgICBzcGVjLm5hbWUgPSBmb3VuZC5uYW1lO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3BlYyA9PSBcInN0cmluZ1wiICYmIC9eW1xcd1xcLV0rXFwvW1xcd1xcLV0rXFwreG1sJC8udGVzdChzcGVjKSkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZU1vZGUoXCJhcHBsaWNhdGlvbi94bWxcIik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzcGVjID09IFwic3RyaW5nXCIgJiYgL15bXFx3XFwtXStcXC9bXFx3XFwtXStcXCtqc29uJC8udGVzdChzcGVjKSkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZU1vZGUoXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBzcGVjID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHsgbmFtZTogc3BlYyB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNwZWMgfHwgeyBuYW1lOiBcIm51bGxcIiB9O1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUocmVzb2x2ZU1vZGUsIFwicmVzb2x2ZU1vZGVcIik7XG4gICAgZnVuY3Rpb24gZ2V0TW9kZShvcHRpb25zLCBzcGVjKSB7XG4gICAgICBzcGVjID0gcmVzb2x2ZU1vZGUoc3BlYyk7XG4gICAgICB2YXIgbWZhY3RvcnkgPSBtb2Rlc1tzcGVjLm5hbWVdO1xuICAgICAgaWYgKCFtZmFjdG9yeSkge1xuICAgICAgICByZXR1cm4gZ2V0TW9kZShvcHRpb25zLCBcInRleHQvcGxhaW5cIik7XG4gICAgICB9XG4gICAgICB2YXIgbW9kZU9iaiA9IG1mYWN0b3J5KG9wdGlvbnMsIHNwZWMpO1xuICAgICAgaWYgKG1vZGVFeHRlbnNpb25zLmhhc093blByb3BlcnR5KHNwZWMubmFtZSkpIHtcbiAgICAgICAgdmFyIGV4dHMgPSBtb2RlRXh0ZW5zaW9uc1tzcGVjLm5hbWVdO1xuICAgICAgICBmb3IgKHZhciBwcm9wMiBpbiBleHRzKSB7XG4gICAgICAgICAgaWYgKCFleHRzLmhhc093blByb3BlcnR5KHByb3AyKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb2RlT2JqLmhhc093blByb3BlcnR5KHByb3AyKSkge1xuICAgICAgICAgICAgbW9kZU9ialtcIl9cIiArIHByb3AyXSA9IG1vZGVPYmpbcHJvcDJdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtb2RlT2JqW3Byb3AyXSA9IGV4dHNbcHJvcDJdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtb2RlT2JqLm5hbWUgPSBzcGVjLm5hbWU7XG4gICAgICBpZiAoc3BlYy5oZWxwZXJUeXBlKSB7XG4gICAgICAgIG1vZGVPYmouaGVscGVyVHlwZSA9IHNwZWMuaGVscGVyVHlwZTtcbiAgICAgIH1cbiAgICAgIGlmIChzcGVjLm1vZGVQcm9wcykge1xuICAgICAgICBmb3IgKHZhciBwcm9wJDEgaW4gc3BlYy5tb2RlUHJvcHMpIHtcbiAgICAgICAgICBtb2RlT2JqW3Byb3AkMV0gPSBzcGVjLm1vZGVQcm9wc1twcm9wJDFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbW9kZU9iajtcbiAgICB9XG4gICAgX19uYW1lKGdldE1vZGUsIFwiZ2V0TW9kZVwiKTtcbiAgICB2YXIgbW9kZUV4dGVuc2lvbnMgPSB7fTtcbiAgICBmdW5jdGlvbiBleHRlbmRNb2RlKG1vZGUsIHByb3BlcnRpZXMpIHtcbiAgICAgIHZhciBleHRzID0gbW9kZUV4dGVuc2lvbnMuaGFzT3duUHJvcGVydHkobW9kZSkgPyBtb2RlRXh0ZW5zaW9uc1ttb2RlXSA6IG1vZGVFeHRlbnNpb25zW21vZGVdID0ge307XG4gICAgICBjb3B5T2JqKHByb3BlcnRpZXMsIGV4dHMpO1xuICAgIH1cbiAgICBfX25hbWUoZXh0ZW5kTW9kZSwgXCJleHRlbmRNb2RlXCIpO1xuICAgIGZ1bmN0aW9uIGNvcHlTdGF0ZShtb2RlLCBzdGF0ZSkge1xuICAgICAgaWYgKHN0YXRlID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgIH1cbiAgICAgIGlmIChtb2RlLmNvcHlTdGF0ZSkge1xuICAgICAgICByZXR1cm4gbW9kZS5jb3B5U3RhdGUoc3RhdGUpO1xuICAgICAgfVxuICAgICAgdmFyIG5zdGF0ZSA9IHt9O1xuICAgICAgZm9yICh2YXIgbiBpbiBzdGF0ZSkge1xuICAgICAgICB2YXIgdmFsID0gc3RhdGVbbl07XG4gICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgIHZhbCA9IHZhbC5jb25jYXQoW10pO1xuICAgICAgICB9XG4gICAgICAgIG5zdGF0ZVtuXSA9IHZhbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuc3RhdGU7XG4gICAgfVxuICAgIF9fbmFtZShjb3B5U3RhdGUsIFwiY29weVN0YXRlXCIpO1xuICAgIGZ1bmN0aW9uIGlubmVyTW9kZShtb2RlLCBzdGF0ZSkge1xuICAgICAgdmFyIGluZm87XG4gICAgICB3aGlsZSAobW9kZS5pbm5lck1vZGUpIHtcbiAgICAgICAgaW5mbyA9IG1vZGUuaW5uZXJNb2RlKHN0YXRlKTtcbiAgICAgICAgaWYgKCFpbmZvIHx8IGluZm8ubW9kZSA9PSBtb2RlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUgPSBpbmZvLnN0YXRlO1xuICAgICAgICBtb2RlID0gaW5mby5tb2RlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluZm8gfHwgeyBtb2RlLCBzdGF0ZSB9O1xuICAgIH1cbiAgICBfX25hbWUoaW5uZXJNb2RlLCBcImlubmVyTW9kZVwiKTtcbiAgICBmdW5jdGlvbiBzdGFydFN0YXRlKG1vZGUsIGExLCBhMikge1xuICAgICAgcmV0dXJuIG1vZGUuc3RhcnRTdGF0ZSA/IG1vZGUuc3RhcnRTdGF0ZShhMSwgYTIpIDogdHJ1ZTtcbiAgICB9XG4gICAgX19uYW1lKHN0YXJ0U3RhdGUsIFwic3RhcnRTdGF0ZVwiKTtcbiAgICB2YXIgU3RyaW5nU3RyZWFtID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbihzdHJpbmcsIHRhYlNpemUsIGxpbmVPcmFjbGUpIHtcbiAgICAgIHRoaXMucG9zID0gdGhpcy5zdGFydCA9IDA7XG4gICAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICAgIHRoaXMudGFiU2l6ZSA9IHRhYlNpemUgfHwgODtcbiAgICAgIHRoaXMubGFzdENvbHVtblBvcyA9IHRoaXMubGFzdENvbHVtblZhbHVlID0gMDtcbiAgICAgIHRoaXMubGluZVN0YXJ0ID0gMDtcbiAgICAgIHRoaXMubGluZU9yYWNsZSA9IGxpbmVPcmFjbGU7XG4gICAgfSwgXCJTdHJpbmdTdHJlYW1cIik7XG4gICAgU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5lb2wgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnBvcyA+PSB0aGlzLnN0cmluZy5sZW5ndGg7XG4gICAgfTtcbiAgICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLnNvbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucG9zID09IHRoaXMubGluZVN0YXJ0O1xuICAgIH07XG4gICAgU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKSB8fCB2b2lkIDA7XG4gICAgfTtcbiAgICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnBvcyA8IHRoaXMuc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKyspO1xuICAgICAgfVxuICAgIH07XG4gICAgU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5lYXQgPSBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgdmFyIGNoID0gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKTtcbiAgICAgIHZhciBvaztcbiAgICAgIGlmICh0eXBlb2YgbWF0Y2ggPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBvayA9IGNoID09IG1hdGNoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2sgPSBjaCAmJiAobWF0Y2gudGVzdCA/IG1hdGNoLnRlc3QoY2gpIDogbWF0Y2goY2gpKTtcbiAgICAgIH1cbiAgICAgIGlmIChvaykge1xuICAgICAgICArK3RoaXMucG9zO1xuICAgICAgICByZXR1cm4gY2g7XG4gICAgICB9XG4gICAgfTtcbiAgICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLmVhdFdoaWxlID0gZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgIHZhciBzdGFydCA9IHRoaXMucG9zO1xuICAgICAgd2hpbGUgKHRoaXMuZWF0KG1hdGNoKSkge1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucG9zID4gc3RhcnQ7XG4gICAgfTtcbiAgICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLmVhdFNwYWNlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc3RhcnQgPSB0aGlzLnBvcztcbiAgICAgIHdoaWxlICgvW1xcc1xcdTAwYTBdLy50ZXN0KHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcykpKSB7XG4gICAgICAgICsrdGhpcy5wb3M7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5wb3MgPiBzdGFydDtcbiAgICB9O1xuICAgIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUuc2tpcFRvRW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnBvcyA9IHRoaXMuc3RyaW5nLmxlbmd0aDtcbiAgICB9O1xuICAgIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUuc2tpcFRvID0gZnVuY3Rpb24oY2gpIHtcbiAgICAgIHZhciBmb3VuZCA9IHRoaXMuc3RyaW5nLmluZGV4T2YoY2gsIHRoaXMucG9zKTtcbiAgICAgIGlmIChmb3VuZCA+IC0xKSB7XG4gICAgICAgIHRoaXMucG9zID0gZm91bmQ7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gICAgU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5iYWNrVXAgPSBmdW5jdGlvbihuKSB7XG4gICAgICB0aGlzLnBvcyAtPSBuO1xuICAgIH07XG4gICAgU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5jb2x1bW4gPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmxhc3RDb2x1bW5Qb3MgPCB0aGlzLnN0YXJ0KSB7XG4gICAgICAgIHRoaXMubGFzdENvbHVtblZhbHVlID0gY291bnRDb2x1bW4odGhpcy5zdHJpbmcsIHRoaXMuc3RhcnQsIHRoaXMudGFiU2l6ZSwgdGhpcy5sYXN0Q29sdW1uUG9zLCB0aGlzLmxhc3RDb2x1bW5WYWx1ZSk7XG4gICAgICAgIHRoaXMubGFzdENvbHVtblBvcyA9IHRoaXMuc3RhcnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5sYXN0Q29sdW1uVmFsdWUgLSAodGhpcy5saW5lU3RhcnQgPyBjb3VudENvbHVtbih0aGlzLnN0cmluZywgdGhpcy5saW5lU3RhcnQsIHRoaXMudGFiU2l6ZSkgOiAwKTtcbiAgICB9O1xuICAgIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUuaW5kZW50YXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBjb3VudENvbHVtbih0aGlzLnN0cmluZywgbnVsbCwgdGhpcy50YWJTaXplKSAtICh0aGlzLmxpbmVTdGFydCA/IGNvdW50Q29sdW1uKHRoaXMuc3RyaW5nLCB0aGlzLmxpbmVTdGFydCwgdGhpcy50YWJTaXplKSA6IDApO1xuICAgIH07XG4gICAgU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uKHBhdHRlcm4sIGNvbnN1bWUsIGNhc2VJbnNlbnNpdGl2ZSkge1xuICAgICAgaWYgKHR5cGVvZiBwYXR0ZXJuID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFyIGNhc2VkID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICByZXR1cm4gY2FzZUluc2Vuc2l0aXZlID8gc3RyLnRvTG93ZXJDYXNlKCkgOiBzdHI7XG4gICAgICAgIH0sIFwiY2FzZWRcIik7XG4gICAgICAgIHZhciBzdWJzdHIgPSB0aGlzLnN0cmluZy5zdWJzdHIodGhpcy5wb3MsIHBhdHRlcm4ubGVuZ3RoKTtcbiAgICAgICAgaWYgKGNhc2VkKHN1YnN0cikgPT0gY2FzZWQocGF0dGVybikpIHtcbiAgICAgICAgICBpZiAoY29uc3VtZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IHBhdHRlcm4ubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG1hdGNoID0gdGhpcy5zdHJpbmcuc2xpY2UodGhpcy5wb3MpLm1hdGNoKHBhdHRlcm4pO1xuICAgICAgICBpZiAobWF0Y2ggJiYgbWF0Y2guaW5kZXggPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoICYmIGNvbnN1bWUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhpcy5wb3MgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH1cbiAgICB9O1xuICAgIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUuY3VycmVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKHRoaXMuc3RhcnQsIHRoaXMucG9zKTtcbiAgICB9O1xuICAgIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUuaGlkZUZpcnN0Q2hhcnMgPSBmdW5jdGlvbihuLCBpbm5lcikge1xuICAgICAgdGhpcy5saW5lU3RhcnQgKz0gbjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBpbm5lcigpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5saW5lU3RhcnQgLT0gbjtcbiAgICAgIH1cbiAgICB9O1xuICAgIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUubG9va0FoZWFkID0gZnVuY3Rpb24obikge1xuICAgICAgdmFyIG9yYWNsZSA9IHRoaXMubGluZU9yYWNsZTtcbiAgICAgIHJldHVybiBvcmFjbGUgJiYgb3JhY2xlLmxvb2tBaGVhZChuKTtcbiAgICB9O1xuICAgIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUuYmFzZVRva2VuID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb3JhY2xlID0gdGhpcy5saW5lT3JhY2xlO1xuICAgICAgcmV0dXJuIG9yYWNsZSAmJiBvcmFjbGUuYmFzZVRva2VuKHRoaXMucG9zKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGdldExpbmUoZG9jLCBuKSB7XG4gICAgICBuIC09IGRvYy5maXJzdDtcbiAgICAgIGlmIChuIDwgMCB8fCBuID49IGRvYy5zaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZXJlIGlzIG5vIGxpbmUgXCIgKyAobiArIGRvYy5maXJzdCkgKyBcIiBpbiB0aGUgZG9jdW1lbnQuXCIpO1xuICAgICAgfVxuICAgICAgdmFyIGNodW5rID0gZG9jO1xuICAgICAgd2hpbGUgKCFjaHVuay5saW5lcykge1xuICAgICAgICBmb3IgKHZhciBpMiA9IDA7IDsgKytpMikge1xuICAgICAgICAgIHZhciBjaGlsZCA9IGNodW5rLmNoaWxkcmVuW2kyXSwgc3ogPSBjaGlsZC5jaHVua1NpemUoKTtcbiAgICAgICAgICBpZiAobiA8IHN6KSB7XG4gICAgICAgICAgICBjaHVuayA9IGNoaWxkO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIG4gLT0gc3o7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjaHVuay5saW5lc1tuXTtcbiAgICB9XG4gICAgX19uYW1lKGdldExpbmUsIFwiZ2V0TGluZVwiKTtcbiAgICBmdW5jdGlvbiBnZXRCZXR3ZWVuKGRvYywgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIG91dCA9IFtdLCBuID0gc3RhcnQubGluZTtcbiAgICAgIGRvYy5pdGVyKHN0YXJ0LmxpbmUsIGVuZC5saW5lICsgMSwgZnVuY3Rpb24obGluZSkge1xuICAgICAgICB2YXIgdGV4dCA9IGxpbmUudGV4dDtcbiAgICAgICAgaWYgKG4gPT0gZW5kLmxpbmUpIHtcbiAgICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZSgwLCBlbmQuY2gpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuID09IHN0YXJ0LmxpbmUpIHtcbiAgICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZShzdGFydC5jaCk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0LnB1c2godGV4dCk7XG4gICAgICAgICsrbjtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgX19uYW1lKGdldEJldHdlZW4sIFwiZ2V0QmV0d2VlblwiKTtcbiAgICBmdW5jdGlvbiBnZXRMaW5lcyhkb2MsIGZyb20sIHRvKSB7XG4gICAgICB2YXIgb3V0ID0gW107XG4gICAgICBkb2MuaXRlcihmcm9tLCB0bywgZnVuY3Rpb24obGluZSkge1xuICAgICAgICBvdXQucHVzaChsaW5lLnRleHQpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBfX25hbWUoZ2V0TGluZXMsIFwiZ2V0TGluZXNcIik7XG4gICAgZnVuY3Rpb24gdXBkYXRlTGluZUhlaWdodChsaW5lLCBoZWlnaHQpIHtcbiAgICAgIHZhciBkaWZmID0gaGVpZ2h0IC0gbGluZS5oZWlnaHQ7XG4gICAgICBpZiAoZGlmZikge1xuICAgICAgICBmb3IgKHZhciBuID0gbGluZTsgbjsgbiA9IG4ucGFyZW50KSB7XG4gICAgICAgICAgbi5oZWlnaHQgKz0gZGlmZjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUodXBkYXRlTGluZUhlaWdodCwgXCJ1cGRhdGVMaW5lSGVpZ2h0XCIpO1xuICAgIGZ1bmN0aW9uIGxpbmVObyhsaW5lKSB7XG4gICAgICBpZiAobGluZS5wYXJlbnQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBjdXIgPSBsaW5lLnBhcmVudCwgbm8gPSBpbmRleE9mKGN1ci5saW5lcywgbGluZSk7XG4gICAgICBmb3IgKHZhciBjaHVuayA9IGN1ci5wYXJlbnQ7IGNodW5rOyBjdXIgPSBjaHVuaywgY2h1bmsgPSBjaHVuay5wYXJlbnQpIHtcbiAgICAgICAgZm9yICh2YXIgaTIgPSAwOyA7ICsraTIpIHtcbiAgICAgICAgICBpZiAoY2h1bmsuY2hpbGRyZW5baTJdID09IGN1cikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vICs9IGNodW5rLmNoaWxkcmVuW2kyXS5jaHVua1NpemUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5vICsgY3VyLmZpcnN0O1xuICAgIH1cbiAgICBfX25hbWUobGluZU5vLCBcImxpbmVOb1wiKTtcbiAgICBmdW5jdGlvbiBsaW5lQXRIZWlnaHQoY2h1bmssIGgpIHtcbiAgICAgIHZhciBuID0gY2h1bmsuZmlyc3Q7XG4gICAgICBvdXRlcjpcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGZvciAodmFyIGkkMTIgPSAwOyBpJDEyIDwgY2h1bmsuY2hpbGRyZW4ubGVuZ3RoOyArK2kkMTIpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGNodW5rLmNoaWxkcmVuW2kkMTJdLCBjaCA9IGNoaWxkLmhlaWdodDtcbiAgICAgICAgICAgIGlmIChoIDwgY2gpIHtcbiAgICAgICAgICAgICAgY2h1bmsgPSBjaGlsZDtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoIC09IGNoO1xuICAgICAgICAgICAgbiArPSBjaGlsZC5jaHVua1NpemUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH0gd2hpbGUgKCFjaHVuay5saW5lcyk7XG4gICAgICB2YXIgaTIgPSAwO1xuICAgICAgZm9yICg7IGkyIDwgY2h1bmsubGluZXMubGVuZ3RoOyArK2kyKSB7XG4gICAgICAgIHZhciBsaW5lID0gY2h1bmsubGluZXNbaTJdLCBsaCA9IGxpbmUuaGVpZ2h0O1xuICAgICAgICBpZiAoaCA8IGxoKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaCAtPSBsaDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuICsgaTI7XG4gICAgfVxuICAgIF9fbmFtZShsaW5lQXRIZWlnaHQsIFwibGluZUF0SGVpZ2h0XCIpO1xuICAgIGZ1bmN0aW9uIGlzTGluZShkb2MsIGwpIHtcbiAgICAgIHJldHVybiBsID49IGRvYy5maXJzdCAmJiBsIDwgZG9jLmZpcnN0ICsgZG9jLnNpemU7XG4gICAgfVxuICAgIF9fbmFtZShpc0xpbmUsIFwiaXNMaW5lXCIpO1xuICAgIGZ1bmN0aW9uIGxpbmVOdW1iZXJGb3Iob3B0aW9ucywgaTIpIHtcbiAgICAgIHJldHVybiBTdHJpbmcob3B0aW9ucy5saW5lTnVtYmVyRm9ybWF0dGVyKGkyICsgb3B0aW9ucy5maXJzdExpbmVOdW1iZXIpKTtcbiAgICB9XG4gICAgX19uYW1lKGxpbmVOdW1iZXJGb3IsIFwibGluZU51bWJlckZvclwiKTtcbiAgICBmdW5jdGlvbiBQb3MobGluZSwgY2gsIHN0aWNreSkge1xuICAgICAgaWYgKHN0aWNreSA9PT0gdm9pZCAwKVxuICAgICAgICBzdGlja3kgPSBudWxsO1xuICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBvcykpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb3MobGluZSwgY2gsIHN0aWNreSk7XG4gICAgICB9XG4gICAgICB0aGlzLmxpbmUgPSBsaW5lO1xuICAgICAgdGhpcy5jaCA9IGNoO1xuICAgICAgdGhpcy5zdGlja3kgPSBzdGlja3k7XG4gICAgfVxuICAgIF9fbmFtZShQb3MsIFwiUG9zXCIpO1xuICAgIGZ1bmN0aW9uIGNtcChhLCBiKSB7XG4gICAgICByZXR1cm4gYS5saW5lIC0gYi5saW5lIHx8IGEuY2ggLSBiLmNoO1xuICAgIH1cbiAgICBfX25hbWUoY21wLCBcImNtcFwiKTtcbiAgICBmdW5jdGlvbiBlcXVhbEN1cnNvclBvcyhhLCBiKSB7XG4gICAgICByZXR1cm4gYS5zdGlja3kgPT0gYi5zdGlja3kgJiYgY21wKGEsIGIpID09IDA7XG4gICAgfVxuICAgIF9fbmFtZShlcXVhbEN1cnNvclBvcywgXCJlcXVhbEN1cnNvclBvc1wiKTtcbiAgICBmdW5jdGlvbiBjb3B5UG9zKHgpIHtcbiAgICAgIHJldHVybiBQb3MoeC5saW5lLCB4LmNoKTtcbiAgICB9XG4gICAgX19uYW1lKGNvcHlQb3MsIFwiY29weVBvc1wiKTtcbiAgICBmdW5jdGlvbiBtYXhQb3MoYSwgYikge1xuICAgICAgcmV0dXJuIGNtcChhLCBiKSA8IDAgPyBiIDogYTtcbiAgICB9XG4gICAgX19uYW1lKG1heFBvcywgXCJtYXhQb3NcIik7XG4gICAgZnVuY3Rpb24gbWluUG9zKGEsIGIpIHtcbiAgICAgIHJldHVybiBjbXAoYSwgYikgPCAwID8gYSA6IGI7XG4gICAgfVxuICAgIF9fbmFtZShtaW5Qb3MsIFwibWluUG9zXCIpO1xuICAgIGZ1bmN0aW9uIGNsaXBMaW5lKGRvYywgbikge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KGRvYy5maXJzdCwgTWF0aC5taW4obiwgZG9jLmZpcnN0ICsgZG9jLnNpemUgLSAxKSk7XG4gICAgfVxuICAgIF9fbmFtZShjbGlwTGluZSwgXCJjbGlwTGluZVwiKTtcbiAgICBmdW5jdGlvbiBjbGlwUG9zKGRvYywgcG9zKSB7XG4gICAgICBpZiAocG9zLmxpbmUgPCBkb2MuZmlyc3QpIHtcbiAgICAgICAgcmV0dXJuIFBvcyhkb2MuZmlyc3QsIDApO1xuICAgICAgfVxuICAgICAgdmFyIGxhc3QgPSBkb2MuZmlyc3QgKyBkb2Muc2l6ZSAtIDE7XG4gICAgICBpZiAocG9zLmxpbmUgPiBsYXN0KSB7XG4gICAgICAgIHJldHVybiBQb3MobGFzdCwgZ2V0TGluZShkb2MsIGxhc3QpLnRleHQubGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjbGlwVG9MZW4ocG9zLCBnZXRMaW5lKGRvYywgcG9zLmxpbmUpLnRleHQubGVuZ3RoKTtcbiAgICB9XG4gICAgX19uYW1lKGNsaXBQb3MsIFwiY2xpcFBvc1wiKTtcbiAgICBmdW5jdGlvbiBjbGlwVG9MZW4ocG9zLCBsaW5lbGVuKSB7XG4gICAgICB2YXIgY2ggPSBwb3MuY2g7XG4gICAgICBpZiAoY2ggPT0gbnVsbCB8fCBjaCA+IGxpbmVsZW4pIHtcbiAgICAgICAgcmV0dXJuIFBvcyhwb3MubGluZSwgbGluZWxlbik7XG4gICAgICB9IGVsc2UgaWYgKGNoIDwgMCkge1xuICAgICAgICByZXR1cm4gUG9zKHBvcy5saW5lLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShjbGlwVG9MZW4sIFwiY2xpcFRvTGVuXCIpO1xuICAgIGZ1bmN0aW9uIGNsaXBQb3NBcnJheShkb2MsIGFycmF5KSB7XG4gICAgICB2YXIgb3V0ID0gW107XG4gICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgYXJyYXkubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgIG91dFtpMl0gPSBjbGlwUG9zKGRvYywgYXJyYXlbaTJdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIF9fbmFtZShjbGlwUG9zQXJyYXksIFwiY2xpcFBvc0FycmF5XCIpO1xuICAgIHZhciBTYXZlZENvbnRleHQgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKHN0YXRlLCBsb29rQWhlYWQpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgIHRoaXMubG9va0FoZWFkID0gbG9va0FoZWFkO1xuICAgIH0sIFwiU2F2ZWRDb250ZXh0XCIpO1xuICAgIHZhciBDb250ZXh0ID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbihkb2MsIHN0YXRlLCBsaW5lLCBsb29rQWhlYWQpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgIHRoaXMuZG9jID0gZG9jO1xuICAgICAgdGhpcy5saW5lID0gbGluZTtcbiAgICAgIHRoaXMubWF4TG9va0FoZWFkID0gbG9va0FoZWFkIHx8IDA7XG4gICAgICB0aGlzLmJhc2VUb2tlbnMgPSBudWxsO1xuICAgICAgdGhpcy5iYXNlVG9rZW5Qb3MgPSAxO1xuICAgIH0sIFwiQ29udGV4dFwiKTtcbiAgICBDb250ZXh0LnByb3RvdHlwZS5sb29rQWhlYWQgPSBmdW5jdGlvbihuKSB7XG4gICAgICB2YXIgbGluZSA9IHRoaXMuZG9jLmdldExpbmUodGhpcy5saW5lICsgbik7XG4gICAgICBpZiAobGluZSAhPSBudWxsICYmIG4gPiB0aGlzLm1heExvb2tBaGVhZCkge1xuICAgICAgICB0aGlzLm1heExvb2tBaGVhZCA9IG47XG4gICAgICB9XG4gICAgICByZXR1cm4gbGluZTtcbiAgICB9O1xuICAgIENvbnRleHQucHJvdG90eXBlLmJhc2VUb2tlbiA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgIGlmICghdGhpcy5iYXNlVG9rZW5zKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgd2hpbGUgKHRoaXMuYmFzZVRva2Vuc1t0aGlzLmJhc2VUb2tlblBvc10gPD0gbikge1xuICAgICAgICB0aGlzLmJhc2VUb2tlblBvcyArPSAyO1xuICAgICAgfVxuICAgICAgdmFyIHR5cGUgPSB0aGlzLmJhc2VUb2tlbnNbdGhpcy5iYXNlVG9rZW5Qb3MgKyAxXTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHR5cGUgJiYgdHlwZS5yZXBsYWNlKC8oIHxeKW92ZXJsYXkgLiovLCBcIlwiKSxcbiAgICAgICAgc2l6ZTogdGhpcy5iYXNlVG9rZW5zW3RoaXMuYmFzZVRva2VuUG9zXSAtIG5cbiAgICAgIH07XG4gICAgfTtcbiAgICBDb250ZXh0LnByb3RvdHlwZS5uZXh0TGluZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5saW5lKys7XG4gICAgICBpZiAodGhpcy5tYXhMb29rQWhlYWQgPiAwKSB7XG4gICAgICAgIHRoaXMubWF4TG9va0FoZWFkLS07XG4gICAgICB9XG4gICAgfTtcbiAgICBDb250ZXh0LmZyb21TYXZlZCA9IGZ1bmN0aW9uKGRvYywgc2F2ZWQsIGxpbmUpIHtcbiAgICAgIGlmIChzYXZlZCBpbnN0YW5jZW9mIFNhdmVkQ29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRleHQoZG9jLCBjb3B5U3RhdGUoZG9jLm1vZGUsIHNhdmVkLnN0YXRlKSwgbGluZSwgc2F2ZWQubG9va0FoZWFkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udGV4dChkb2MsIGNvcHlTdGF0ZShkb2MubW9kZSwgc2F2ZWQpLCBsaW5lKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIENvbnRleHQucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbihjb3B5KSB7XG4gICAgICB2YXIgc3RhdGUgPSBjb3B5ICE9PSBmYWxzZSA/IGNvcHlTdGF0ZSh0aGlzLmRvYy5tb2RlLCB0aGlzLnN0YXRlKSA6IHRoaXMuc3RhdGU7XG4gICAgICByZXR1cm4gdGhpcy5tYXhMb29rQWhlYWQgPiAwID8gbmV3IFNhdmVkQ29udGV4dChzdGF0ZSwgdGhpcy5tYXhMb29rQWhlYWQpIDogc3RhdGU7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBoaWdobGlnaHRMaW5lKGNtLCBsaW5lLCBjb250ZXh0LCBmb3JjZVRvRW5kKSB7XG4gICAgICB2YXIgc3QgPSBbY20uc3RhdGUubW9kZUdlbl0sIGxpbmVDbGFzc2VzID0ge307XG4gICAgICBydW5Nb2RlKGNtLCBsaW5lLnRleHQsIGNtLmRvYy5tb2RlLCBjb250ZXh0LCBmdW5jdGlvbihlbmQsIHN0eWxlKSB7XG4gICAgICAgIHJldHVybiBzdC5wdXNoKGVuZCwgc3R5bGUpO1xuICAgICAgfSwgbGluZUNsYXNzZXMsIGZvcmNlVG9FbmQpO1xuICAgICAgdmFyIHN0YXRlID0gY29udGV4dC5zdGF0ZTtcbiAgICAgIHZhciBsb29wID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbihvMikge1xuICAgICAgICBjb250ZXh0LmJhc2VUb2tlbnMgPSBzdDtcbiAgICAgICAgdmFyIG92ZXJsYXkgPSBjbS5zdGF0ZS5vdmVybGF5c1tvMl0sIGkyID0gMSwgYXQgPSAwO1xuICAgICAgICBjb250ZXh0LnN0YXRlID0gdHJ1ZTtcbiAgICAgICAgcnVuTW9kZShjbSwgbGluZS50ZXh0LCBvdmVybGF5Lm1vZGUsIGNvbnRleHQsIGZ1bmN0aW9uKGVuZCwgc3R5bGUpIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSBpMjtcbiAgICAgICAgICB3aGlsZSAoYXQgPCBlbmQpIHtcbiAgICAgICAgICAgIHZhciBpX2VuZCA9IHN0W2kyXTtcbiAgICAgICAgICAgIGlmIChpX2VuZCA+IGVuZCkge1xuICAgICAgICAgICAgICBzdC5zcGxpY2UoaTIsIDEsIGVuZCwgc3RbaTIgKyAxXSwgaV9lbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaTIgKz0gMjtcbiAgICAgICAgICAgIGF0ID0gTWF0aC5taW4oZW5kLCBpX2VuZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghc3R5bGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG92ZXJsYXkub3BhcXVlKSB7XG4gICAgICAgICAgICBzdC5zcGxpY2Uoc3RhcnQsIGkyIC0gc3RhcnQsIGVuZCwgXCJvdmVybGF5IFwiICsgc3R5bGUpO1xuICAgICAgICAgICAgaTIgPSBzdGFydCArIDI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoOyBzdGFydCA8IGkyOyBzdGFydCArPSAyKSB7XG4gICAgICAgICAgICAgIHZhciBjdXIgPSBzdFtzdGFydCArIDFdO1xuICAgICAgICAgICAgICBzdFtzdGFydCArIDFdID0gKGN1ciA/IGN1ciArIFwiIFwiIDogXCJcIikgKyBcIm92ZXJsYXkgXCIgKyBzdHlsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIGxpbmVDbGFzc2VzKTtcbiAgICAgICAgY29udGV4dC5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICBjb250ZXh0LmJhc2VUb2tlbnMgPSBudWxsO1xuICAgICAgICBjb250ZXh0LmJhc2VUb2tlblBvcyA9IDE7XG4gICAgICB9LCBcImxvb3BcIik7XG4gICAgICBmb3IgKHZhciBvID0gMDsgbyA8IGNtLnN0YXRlLm92ZXJsYXlzLmxlbmd0aDsgKytvKVxuICAgICAgICBsb29wKG8pO1xuICAgICAgcmV0dXJuIHsgc3R5bGVzOiBzdCwgY2xhc3NlczogbGluZUNsYXNzZXMuYmdDbGFzcyB8fCBsaW5lQ2xhc3Nlcy50ZXh0Q2xhc3MgPyBsaW5lQ2xhc3NlcyA6IG51bGwgfTtcbiAgICB9XG4gICAgX19uYW1lKGhpZ2hsaWdodExpbmUsIFwiaGlnaGxpZ2h0TGluZVwiKTtcbiAgICBmdW5jdGlvbiBnZXRMaW5lU3R5bGVzKGNtLCBsaW5lLCB1cGRhdGVGcm9udGllcikge1xuICAgICAgaWYgKCFsaW5lLnN0eWxlcyB8fCBsaW5lLnN0eWxlc1swXSAhPSBjbS5zdGF0ZS5tb2RlR2VuKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gZ2V0Q29udGV4dEJlZm9yZShjbSwgbGluZU5vKGxpbmUpKTtcbiAgICAgICAgdmFyIHJlc2V0U3RhdGUgPSBsaW5lLnRleHQubGVuZ3RoID4gY20ub3B0aW9ucy5tYXhIaWdobGlnaHRMZW5ndGggJiYgY29weVN0YXRlKGNtLmRvYy5tb2RlLCBjb250ZXh0LnN0YXRlKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGhpZ2hsaWdodExpbmUoY20sIGxpbmUsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVzZXRTdGF0ZSkge1xuICAgICAgICAgIGNvbnRleHQuc3RhdGUgPSByZXNldFN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIGxpbmUuc3RhdGVBZnRlciA9IGNvbnRleHQuc2F2ZSghcmVzZXRTdGF0ZSk7XG4gICAgICAgIGxpbmUuc3R5bGVzID0gcmVzdWx0LnN0eWxlcztcbiAgICAgICAgaWYgKHJlc3VsdC5jbGFzc2VzKSB7XG4gICAgICAgICAgbGluZS5zdHlsZUNsYXNzZXMgPSByZXN1bHQuY2xhc3NlcztcbiAgICAgICAgfSBlbHNlIGlmIChsaW5lLnN0eWxlQ2xhc3Nlcykge1xuICAgICAgICAgIGxpbmUuc3R5bGVDbGFzc2VzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlRnJvbnRpZXIgPT09IGNtLmRvYy5oaWdobGlnaHRGcm9udGllcikge1xuICAgICAgICAgIGNtLmRvYy5tb2RlRnJvbnRpZXIgPSBNYXRoLm1heChjbS5kb2MubW9kZUZyb250aWVyLCArK2NtLmRvYy5oaWdobGlnaHRGcm9udGllcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBsaW5lLnN0eWxlcztcbiAgICB9XG4gICAgX19uYW1lKGdldExpbmVTdHlsZXMsIFwiZ2V0TGluZVN0eWxlc1wiKTtcbiAgICBmdW5jdGlvbiBnZXRDb250ZXh0QmVmb3JlKGNtLCBuLCBwcmVjaXNlKSB7XG4gICAgICB2YXIgZG9jID0gY20uZG9jLCBkaXNwbGF5ID0gY20uZGlzcGxheTtcbiAgICAgIGlmICghZG9jLm1vZGUuc3RhcnRTdGF0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRleHQoZG9jLCB0cnVlLCBuKTtcbiAgICAgIH1cbiAgICAgIHZhciBzdGFydCA9IGZpbmRTdGFydExpbmUoY20sIG4sIHByZWNpc2UpO1xuICAgICAgdmFyIHNhdmVkID0gc3RhcnQgPiBkb2MuZmlyc3QgJiYgZ2V0TGluZShkb2MsIHN0YXJ0IC0gMSkuc3RhdGVBZnRlcjtcbiAgICAgIHZhciBjb250ZXh0ID0gc2F2ZWQgPyBDb250ZXh0LmZyb21TYXZlZChkb2MsIHNhdmVkLCBzdGFydCkgOiBuZXcgQ29udGV4dChkb2MsIHN0YXJ0U3RhdGUoZG9jLm1vZGUpLCBzdGFydCk7XG4gICAgICBkb2MuaXRlcihzdGFydCwgbiwgZnVuY3Rpb24obGluZSkge1xuICAgICAgICBwcm9jZXNzTGluZShjbSwgbGluZS50ZXh0LCBjb250ZXh0KTtcbiAgICAgICAgdmFyIHBvcyA9IGNvbnRleHQubGluZTtcbiAgICAgICAgbGluZS5zdGF0ZUFmdGVyID0gcG9zID09IG4gLSAxIHx8IHBvcyAlIDUgPT0gMCB8fCBwb3MgPj0gZGlzcGxheS52aWV3RnJvbSAmJiBwb3MgPCBkaXNwbGF5LnZpZXdUbyA/IGNvbnRleHQuc2F2ZSgpIDogbnVsbDtcbiAgICAgICAgY29udGV4dC5uZXh0TGluZSgpO1xuICAgICAgfSk7XG4gICAgICBpZiAocHJlY2lzZSkge1xuICAgICAgICBkb2MubW9kZUZyb250aWVyID0gY29udGV4dC5saW5lO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuICAgIF9fbmFtZShnZXRDb250ZXh0QmVmb3JlLCBcImdldENvbnRleHRCZWZvcmVcIik7XG4gICAgZnVuY3Rpb24gcHJvY2Vzc0xpbmUoY20sIHRleHQsIGNvbnRleHQsIHN0YXJ0QXQpIHtcbiAgICAgIHZhciBtb2RlID0gY20uZG9jLm1vZGU7XG4gICAgICB2YXIgc3RyZWFtID0gbmV3IFN0cmluZ1N0cmVhbSh0ZXh0LCBjbS5vcHRpb25zLnRhYlNpemUsIGNvbnRleHQpO1xuICAgICAgc3RyZWFtLnN0YXJ0ID0gc3RyZWFtLnBvcyA9IHN0YXJ0QXQgfHwgMDtcbiAgICAgIGlmICh0ZXh0ID09IFwiXCIpIHtcbiAgICAgICAgY2FsbEJsYW5rTGluZShtb2RlLCBjb250ZXh0LnN0YXRlKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICghc3RyZWFtLmVvbCgpKSB7XG4gICAgICAgIHJlYWRUb2tlbihtb2RlLCBzdHJlYW0sIGNvbnRleHQuc3RhdGUpO1xuICAgICAgICBzdHJlYW0uc3RhcnQgPSBzdHJlYW0ucG9zO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUocHJvY2Vzc0xpbmUsIFwicHJvY2Vzc0xpbmVcIik7XG4gICAgZnVuY3Rpb24gY2FsbEJsYW5rTGluZShtb2RlLCBzdGF0ZSkge1xuICAgICAgaWYgKG1vZGUuYmxhbmtMaW5lKSB7XG4gICAgICAgIHJldHVybiBtb2RlLmJsYW5rTGluZShzdGF0ZSk7XG4gICAgICB9XG4gICAgICBpZiAoIW1vZGUuaW5uZXJNb2RlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBpbm5lciA9IGlubmVyTW9kZShtb2RlLCBzdGF0ZSk7XG4gICAgICBpZiAoaW5uZXIubW9kZS5ibGFua0xpbmUpIHtcbiAgICAgICAgcmV0dXJuIGlubmVyLm1vZGUuYmxhbmtMaW5lKGlubmVyLnN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKGNhbGxCbGFua0xpbmUsIFwiY2FsbEJsYW5rTGluZVwiKTtcbiAgICBmdW5jdGlvbiByZWFkVG9rZW4obW9kZSwgc3RyZWFtLCBzdGF0ZSwgaW5uZXIpIHtcbiAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCAxMDsgaTIrKykge1xuICAgICAgICBpZiAoaW5uZXIpIHtcbiAgICAgICAgICBpbm5lclswXSA9IGlubmVyTW9kZShtb2RlLCBzdGF0ZSkubW9kZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3R5bGUgPSBtb2RlLnRva2VuKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICBpZiAoc3RyZWFtLnBvcyA+IHN0cmVhbS5zdGFydCkge1xuICAgICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTW9kZSBcIiArIG1vZGUubmFtZSArIFwiIGZhaWxlZCB0byBhZHZhbmNlIHN0cmVhbS5cIik7XG4gICAgfVxuICAgIF9fbmFtZShyZWFkVG9rZW4sIFwicmVhZFRva2VuXCIpO1xuICAgIHZhciBUb2tlbiA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24oc3RyZWFtLCB0eXBlLCBzdGF0ZSkge1xuICAgICAgdGhpcy5zdGFydCA9IHN0cmVhbS5zdGFydDtcbiAgICAgIHRoaXMuZW5kID0gc3RyZWFtLnBvcztcbiAgICAgIHRoaXMuc3RyaW5nID0gc3RyZWFtLmN1cnJlbnQoKTtcbiAgICAgIHRoaXMudHlwZSA9IHR5cGUgfHwgbnVsbDtcbiAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB9LCBcIlRva2VuXCIpO1xuICAgIGZ1bmN0aW9uIHRha2VUb2tlbihjbSwgcG9zLCBwcmVjaXNlLCBhc0FycmF5KSB7XG4gICAgICB2YXIgZG9jID0gY20uZG9jLCBtb2RlID0gZG9jLm1vZGUsIHN0eWxlO1xuICAgICAgcG9zID0gY2xpcFBvcyhkb2MsIHBvcyk7XG4gICAgICB2YXIgbGluZSA9IGdldExpbmUoZG9jLCBwb3MubGluZSksIGNvbnRleHQgPSBnZXRDb250ZXh0QmVmb3JlKGNtLCBwb3MubGluZSwgcHJlY2lzZSk7XG4gICAgICB2YXIgc3RyZWFtID0gbmV3IFN0cmluZ1N0cmVhbShsaW5lLnRleHQsIGNtLm9wdGlvbnMudGFiU2l6ZSwgY29udGV4dCksIHRva2VucztcbiAgICAgIGlmIChhc0FycmF5KSB7XG4gICAgICAgIHRva2VucyA9IFtdO1xuICAgICAgfVxuICAgICAgd2hpbGUgKChhc0FycmF5IHx8IHN0cmVhbS5wb3MgPCBwb3MuY2gpICYmICFzdHJlYW0uZW9sKCkpIHtcbiAgICAgICAgc3RyZWFtLnN0YXJ0ID0gc3RyZWFtLnBvcztcbiAgICAgICAgc3R5bGUgPSByZWFkVG9rZW4obW9kZSwgc3RyZWFtLCBjb250ZXh0LnN0YXRlKTtcbiAgICAgICAgaWYgKGFzQXJyYXkpIHtcbiAgICAgICAgICB0b2tlbnMucHVzaChuZXcgVG9rZW4oc3RyZWFtLCBzdHlsZSwgY29weVN0YXRlKGRvYy5tb2RlLCBjb250ZXh0LnN0YXRlKSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXNBcnJheSA/IHRva2VucyA6IG5ldyBUb2tlbihzdHJlYW0sIHN0eWxlLCBjb250ZXh0LnN0YXRlKTtcbiAgICB9XG4gICAgX19uYW1lKHRha2VUb2tlbiwgXCJ0YWtlVG9rZW5cIik7XG4gICAgZnVuY3Rpb24gZXh0cmFjdExpbmVDbGFzc2VzKHR5cGUsIG91dHB1dCkge1xuICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgZm9yICg7IDsgKSB7XG4gICAgICAgICAgdmFyIGxpbmVDbGFzcyA9IHR5cGUubWF0Y2goLyg/Ol58XFxzKylsaW5lLShiYWNrZ3JvdW5kLSk/KFxcUyspLyk7XG4gICAgICAgICAgaWYgKCFsaW5lQ2xhc3MpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0eXBlID0gdHlwZS5zbGljZSgwLCBsaW5lQ2xhc3MuaW5kZXgpICsgdHlwZS5zbGljZShsaW5lQ2xhc3MuaW5kZXggKyBsaW5lQ2xhc3NbMF0ubGVuZ3RoKTtcbiAgICAgICAgICB2YXIgcHJvcDIgPSBsaW5lQ2xhc3NbMV0gPyBcImJnQ2xhc3NcIiA6IFwidGV4dENsYXNzXCI7XG4gICAgICAgICAgaWYgKG91dHB1dFtwcm9wMl0gPT0gbnVsbCkge1xuICAgICAgICAgICAgb3V0cHV0W3Byb3AyXSA9IGxpbmVDbGFzc1syXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFuZXcgUmVnRXhwKFwiKD86XnxcXFxccylcIiArIGxpbmVDbGFzc1syXSArIFwiKD86JHxcXFxccylcIikudGVzdChvdXRwdXRbcHJvcDJdKSkge1xuICAgICAgICAgICAgb3V0cHV0W3Byb3AyXSArPSBcIiBcIiArIGxpbmVDbGFzc1syXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgICBfX25hbWUoZXh0cmFjdExpbmVDbGFzc2VzLCBcImV4dHJhY3RMaW5lQ2xhc3Nlc1wiKTtcbiAgICBmdW5jdGlvbiBydW5Nb2RlKGNtLCB0ZXh0LCBtb2RlLCBjb250ZXh0LCBmLCBsaW5lQ2xhc3NlcywgZm9yY2VUb0VuZCkge1xuICAgICAgdmFyIGZsYXR0ZW5TcGFucyA9IG1vZGUuZmxhdHRlblNwYW5zO1xuICAgICAgaWYgKGZsYXR0ZW5TcGFucyA9PSBudWxsKSB7XG4gICAgICAgIGZsYXR0ZW5TcGFucyA9IGNtLm9wdGlvbnMuZmxhdHRlblNwYW5zO1xuICAgICAgfVxuICAgICAgdmFyIGN1clN0YXJ0ID0gMCwgY3VyU3R5bGUgPSBudWxsO1xuICAgICAgdmFyIHN0cmVhbSA9IG5ldyBTdHJpbmdTdHJlYW0odGV4dCwgY20ub3B0aW9ucy50YWJTaXplLCBjb250ZXh0KSwgc3R5bGU7XG4gICAgICB2YXIgaW5uZXIgPSBjbS5vcHRpb25zLmFkZE1vZGVDbGFzcyAmJiBbbnVsbF07XG4gICAgICBpZiAodGV4dCA9PSBcIlwiKSB7XG4gICAgICAgIGV4dHJhY3RMaW5lQ2xhc3NlcyhjYWxsQmxhbmtMaW5lKG1vZGUsIGNvbnRleHQuc3RhdGUpLCBsaW5lQ2xhc3Nlcyk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xuICAgICAgICBpZiAoc3RyZWFtLnBvcyA+IGNtLm9wdGlvbnMubWF4SGlnaGxpZ2h0TGVuZ3RoKSB7XG4gICAgICAgICAgZmxhdHRlblNwYW5zID0gZmFsc2U7XG4gICAgICAgICAgaWYgKGZvcmNlVG9FbmQpIHtcbiAgICAgICAgICAgIHByb2Nlc3NMaW5lKGNtLCB0ZXh0LCBjb250ZXh0LCBzdHJlYW0ucG9zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RyZWFtLnBvcyA9IHRleHQubGVuZ3RoO1xuICAgICAgICAgIHN0eWxlID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHlsZSA9IGV4dHJhY3RMaW5lQ2xhc3NlcyhyZWFkVG9rZW4obW9kZSwgc3RyZWFtLCBjb250ZXh0LnN0YXRlLCBpbm5lciksIGxpbmVDbGFzc2VzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5uZXIpIHtcbiAgICAgICAgICB2YXIgbU5hbWUgPSBpbm5lclswXS5uYW1lO1xuICAgICAgICAgIGlmIChtTmFtZSkge1xuICAgICAgICAgICAgc3R5bGUgPSBcIm0tXCIgKyAoc3R5bGUgPyBtTmFtZSArIFwiIFwiICsgc3R5bGUgOiBtTmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZmxhdHRlblNwYW5zIHx8IGN1clN0eWxlICE9IHN0eWxlKSB7XG4gICAgICAgICAgd2hpbGUgKGN1clN0YXJ0IDwgc3RyZWFtLnN0YXJ0KSB7XG4gICAgICAgICAgICBjdXJTdGFydCA9IE1hdGgubWluKHN0cmVhbS5zdGFydCwgY3VyU3RhcnQgKyA1ZTMpO1xuICAgICAgICAgICAgZihjdXJTdGFydCwgY3VyU3R5bGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJTdHlsZSA9IHN0eWxlO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3M7XG4gICAgICB9XG4gICAgICB3aGlsZSAoY3VyU3RhcnQgPCBzdHJlYW0ucG9zKSB7XG4gICAgICAgIHZhciBwb3MgPSBNYXRoLm1pbihzdHJlYW0ucG9zLCBjdXJTdGFydCArIDVlMyk7XG4gICAgICAgIGYocG9zLCBjdXJTdHlsZSk7XG4gICAgICAgIGN1clN0YXJ0ID0gcG9zO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUocnVuTW9kZSwgXCJydW5Nb2RlXCIpO1xuICAgIGZ1bmN0aW9uIGZpbmRTdGFydExpbmUoY20sIG4sIHByZWNpc2UpIHtcbiAgICAgIHZhciBtaW5pbmRlbnQsIG1pbmxpbmUsIGRvYyA9IGNtLmRvYztcbiAgICAgIHZhciBsaW0gPSBwcmVjaXNlID8gLTEgOiBuIC0gKGNtLmRvYy5tb2RlLmlubmVyTW9kZSA/IDFlMyA6IDEwMCk7XG4gICAgICBmb3IgKHZhciBzZWFyY2ggPSBuOyBzZWFyY2ggPiBsaW07IC0tc2VhcmNoKSB7XG4gICAgICAgIGlmIChzZWFyY2ggPD0gZG9jLmZpcnN0KSB7XG4gICAgICAgICAgcmV0dXJuIGRvYy5maXJzdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGluZSA9IGdldExpbmUoZG9jLCBzZWFyY2ggLSAxKSwgYWZ0ZXIgPSBsaW5lLnN0YXRlQWZ0ZXI7XG4gICAgICAgIGlmIChhZnRlciAmJiAoIXByZWNpc2UgfHwgc2VhcmNoICsgKGFmdGVyIGluc3RhbmNlb2YgU2F2ZWRDb250ZXh0ID8gYWZ0ZXIubG9va0FoZWFkIDogMCkgPD0gZG9jLm1vZGVGcm9udGllcikpIHtcbiAgICAgICAgICByZXR1cm4gc2VhcmNoO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRlbnRlZCA9IGNvdW50Q29sdW1uKGxpbmUudGV4dCwgbnVsbCwgY20ub3B0aW9ucy50YWJTaXplKTtcbiAgICAgICAgaWYgKG1pbmxpbmUgPT0gbnVsbCB8fCBtaW5pbmRlbnQgPiBpbmRlbnRlZCkge1xuICAgICAgICAgIG1pbmxpbmUgPSBzZWFyY2ggLSAxO1xuICAgICAgICAgIG1pbmluZGVudCA9IGluZGVudGVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWlubGluZTtcbiAgICB9XG4gICAgX19uYW1lKGZpbmRTdGFydExpbmUsIFwiZmluZFN0YXJ0TGluZVwiKTtcbiAgICBmdW5jdGlvbiByZXRyZWF0RnJvbnRpZXIoZG9jLCBuKSB7XG4gICAgICBkb2MubW9kZUZyb250aWVyID0gTWF0aC5taW4oZG9jLm1vZGVGcm9udGllciwgbik7XG4gICAgICBpZiAoZG9jLmhpZ2hsaWdodEZyb250aWVyIDwgbiAtIDEwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBzdGFydCA9IGRvYy5maXJzdDtcbiAgICAgIGZvciAodmFyIGxpbmUgPSBuIC0gMTsgbGluZSA+IHN0YXJ0OyBsaW5lLS0pIHtcbiAgICAgICAgdmFyIHNhdmVkID0gZ2V0TGluZShkb2MsIGxpbmUpLnN0YXRlQWZ0ZXI7XG4gICAgICAgIGlmIChzYXZlZCAmJiAoIShzYXZlZCBpbnN0YW5jZW9mIFNhdmVkQ29udGV4dCkgfHwgbGluZSArIHNhdmVkLmxvb2tBaGVhZCA8IG4pKSB7XG4gICAgICAgICAgc3RhcnQgPSBsaW5lICsgMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZG9jLmhpZ2hsaWdodEZyb250aWVyID0gTWF0aC5taW4oZG9jLmhpZ2hsaWdodEZyb250aWVyLCBzdGFydCk7XG4gICAgfVxuICAgIF9fbmFtZShyZXRyZWF0RnJvbnRpZXIsIFwicmV0cmVhdEZyb250aWVyXCIpO1xuICAgIHZhciBzYXdSZWFkT25seVNwYW5zID0gZmFsc2UsIHNhd0NvbGxhcHNlZFNwYW5zID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gc2VlUmVhZE9ubHlTcGFucygpIHtcbiAgICAgIHNhd1JlYWRPbmx5U3BhbnMgPSB0cnVlO1xuICAgIH1cbiAgICBfX25hbWUoc2VlUmVhZE9ubHlTcGFucywgXCJzZWVSZWFkT25seVNwYW5zXCIpO1xuICAgIGZ1bmN0aW9uIHNlZUNvbGxhcHNlZFNwYW5zKCkge1xuICAgICAgc2F3Q29sbGFwc2VkU3BhbnMgPSB0cnVlO1xuICAgIH1cbiAgICBfX25hbWUoc2VlQ29sbGFwc2VkU3BhbnMsIFwic2VlQ29sbGFwc2VkU3BhbnNcIik7XG4gICAgZnVuY3Rpb24gTWFya2VkU3BhbihtYXJrZXIsIGZyb20sIHRvKSB7XG4gICAgICB0aGlzLm1hcmtlciA9IG1hcmtlcjtcbiAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICB0aGlzLnRvID0gdG87XG4gICAgfVxuICAgIF9fbmFtZShNYXJrZWRTcGFuLCBcIk1hcmtlZFNwYW5cIik7XG4gICAgZnVuY3Rpb24gZ2V0TWFya2VkU3BhbkZvcihzcGFucywgbWFya2VyKSB7XG4gICAgICBpZiAoc3BhbnMpIHtcbiAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IHNwYW5zLmxlbmd0aDsgKytpMikge1xuICAgICAgICAgIHZhciBzcGFuID0gc3BhbnNbaTJdO1xuICAgICAgICAgIGlmIChzcGFuLm1hcmtlciA9PSBtYXJrZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBzcGFuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoZ2V0TWFya2VkU3BhbkZvciwgXCJnZXRNYXJrZWRTcGFuRm9yXCIpO1xuICAgIGZ1bmN0aW9uIHJlbW92ZU1hcmtlZFNwYW4oc3BhbnMsIHNwYW4pIHtcbiAgICAgIHZhciByO1xuICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IHNwYW5zLmxlbmd0aDsgKytpMikge1xuICAgICAgICBpZiAoc3BhbnNbaTJdICE9IHNwYW4pIHtcbiAgICAgICAgICAociB8fCAociA9IFtdKSkucHVzaChzcGFuc1tpMl0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgX19uYW1lKHJlbW92ZU1hcmtlZFNwYW4sIFwicmVtb3ZlTWFya2VkU3BhblwiKTtcbiAgICBmdW5jdGlvbiBhZGRNYXJrZWRTcGFuKGxpbmUsIHNwYW4sIG9wKSB7XG4gICAgICB2YXIgaW5UaGlzT3AgPSBvcCAmJiB3aW5kb3cuV2Vha1NldCAmJiAob3AubWFya2VkU3BhbnMgfHwgKG9wLm1hcmtlZFNwYW5zID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCkpKTtcbiAgICAgIGlmIChpblRoaXNPcCAmJiBsaW5lLm1hcmtlZFNwYW5zICYmIGluVGhpc09wLmhhcyhsaW5lLm1hcmtlZFNwYW5zKSkge1xuICAgICAgICBsaW5lLm1hcmtlZFNwYW5zLnB1c2goc3Bhbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaW5lLm1hcmtlZFNwYW5zID0gbGluZS5tYXJrZWRTcGFucyA/IGxpbmUubWFya2VkU3BhbnMuY29uY2F0KFtzcGFuXSkgOiBbc3Bhbl07XG4gICAgICAgIGlmIChpblRoaXNPcCkge1xuICAgICAgICAgIGluVGhpc09wLmFkZChsaW5lLm1hcmtlZFNwYW5zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3Bhbi5tYXJrZXIuYXR0YWNoTGluZShsaW5lKTtcbiAgICB9XG4gICAgX19uYW1lKGFkZE1hcmtlZFNwYW4sIFwiYWRkTWFya2VkU3BhblwiKTtcbiAgICBmdW5jdGlvbiBtYXJrZWRTcGFuc0JlZm9yZShvbGQsIHN0YXJ0Q2gsIGlzSW5zZXJ0KSB7XG4gICAgICB2YXIgbnc7XG4gICAgICBpZiAob2xkKSB7XG4gICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBvbGQubGVuZ3RoOyArK2kyKSB7XG4gICAgICAgICAgdmFyIHNwYW4gPSBvbGRbaTJdLCBtYXJrZXIgPSBzcGFuLm1hcmtlcjtcbiAgICAgICAgICB2YXIgc3RhcnRzQmVmb3JlID0gc3Bhbi5mcm9tID09IG51bGwgfHwgKG1hcmtlci5pbmNsdXNpdmVMZWZ0ID8gc3Bhbi5mcm9tIDw9IHN0YXJ0Q2ggOiBzcGFuLmZyb20gPCBzdGFydENoKTtcbiAgICAgICAgICBpZiAoc3RhcnRzQmVmb3JlIHx8IHNwYW4uZnJvbSA9PSBzdGFydENoICYmIG1hcmtlci50eXBlID09IFwiYm9va21hcmtcIiAmJiAoIWlzSW5zZXJ0IHx8ICFzcGFuLm1hcmtlci5pbnNlcnRMZWZ0KSkge1xuICAgICAgICAgICAgdmFyIGVuZHNBZnRlciA9IHNwYW4udG8gPT0gbnVsbCB8fCAobWFya2VyLmluY2x1c2l2ZVJpZ2h0ID8gc3Bhbi50byA+PSBzdGFydENoIDogc3Bhbi50byA+IHN0YXJ0Q2gpO1xuICAgICAgICAgICAgKG53IHx8IChudyA9IFtdKSkucHVzaChuZXcgTWFya2VkU3BhbihtYXJrZXIsIHNwYW4uZnJvbSwgZW5kc0FmdGVyID8gbnVsbCA6IHNwYW4udG8pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudztcbiAgICB9XG4gICAgX19uYW1lKG1hcmtlZFNwYW5zQmVmb3JlLCBcIm1hcmtlZFNwYW5zQmVmb3JlXCIpO1xuICAgIGZ1bmN0aW9uIG1hcmtlZFNwYW5zQWZ0ZXIob2xkLCBlbmRDaCwgaXNJbnNlcnQpIHtcbiAgICAgIHZhciBudztcbiAgICAgIGlmIChvbGQpIHtcbiAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IG9sZC5sZW5ndGg7ICsraTIpIHtcbiAgICAgICAgICB2YXIgc3BhbiA9IG9sZFtpMl0sIG1hcmtlciA9IHNwYW4ubWFya2VyO1xuICAgICAgICAgIHZhciBlbmRzQWZ0ZXIgPSBzcGFuLnRvID09IG51bGwgfHwgKG1hcmtlci5pbmNsdXNpdmVSaWdodCA/IHNwYW4udG8gPj0gZW5kQ2ggOiBzcGFuLnRvID4gZW5kQ2gpO1xuICAgICAgICAgIGlmIChlbmRzQWZ0ZXIgfHwgc3Bhbi5mcm9tID09IGVuZENoICYmIG1hcmtlci50eXBlID09IFwiYm9va21hcmtcIiAmJiAoIWlzSW5zZXJ0IHx8IHNwYW4ubWFya2VyLmluc2VydExlZnQpKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRzQmVmb3JlID0gc3Bhbi5mcm9tID09IG51bGwgfHwgKG1hcmtlci5pbmNsdXNpdmVMZWZ0ID8gc3Bhbi5mcm9tIDw9IGVuZENoIDogc3Bhbi5mcm9tIDwgZW5kQ2gpO1xuICAgICAgICAgICAgKG53IHx8IChudyA9IFtdKSkucHVzaChuZXcgTWFya2VkU3BhbihtYXJrZXIsIHN0YXJ0c0JlZm9yZSA/IG51bGwgOiBzcGFuLmZyb20gLSBlbmRDaCwgc3Bhbi50byA9PSBudWxsID8gbnVsbCA6IHNwYW4udG8gLSBlbmRDaCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG53O1xuICAgIH1cbiAgICBfX25hbWUobWFya2VkU3BhbnNBZnRlciwgXCJtYXJrZWRTcGFuc0FmdGVyXCIpO1xuICAgIGZ1bmN0aW9uIHN0cmV0Y2hTcGFuc092ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UpIHtcbiAgICAgIGlmIChjaGFuZ2UuZnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBvbGRGaXJzdCA9IGlzTGluZShkb2MsIGNoYW5nZS5mcm9tLmxpbmUpICYmIGdldExpbmUoZG9jLCBjaGFuZ2UuZnJvbS5saW5lKS5tYXJrZWRTcGFucztcbiAgICAgIHZhciBvbGRMYXN0ID0gaXNMaW5lKGRvYywgY2hhbmdlLnRvLmxpbmUpICYmIGdldExpbmUoZG9jLCBjaGFuZ2UudG8ubGluZSkubWFya2VkU3BhbnM7XG4gICAgICBpZiAoIW9sZEZpcnN0ICYmICFvbGRMYXN0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIHN0YXJ0Q2ggPSBjaGFuZ2UuZnJvbS5jaCwgZW5kQ2ggPSBjaGFuZ2UudG8uY2gsIGlzSW5zZXJ0ID0gY21wKGNoYW5nZS5mcm9tLCBjaGFuZ2UudG8pID09IDA7XG4gICAgICB2YXIgZmlyc3QgPSBtYXJrZWRTcGFuc0JlZm9yZShvbGRGaXJzdCwgc3RhcnRDaCwgaXNJbnNlcnQpO1xuICAgICAgdmFyIGxhc3QgPSBtYXJrZWRTcGFuc0FmdGVyKG9sZExhc3QsIGVuZENoLCBpc0luc2VydCk7XG4gICAgICB2YXIgc2FtZUxpbmUgPSBjaGFuZ2UudGV4dC5sZW5ndGggPT0gMSwgb2Zmc2V0ID0gbHN0KGNoYW5nZS50ZXh0KS5sZW5ndGggKyAoc2FtZUxpbmUgPyBzdGFydENoIDogMCk7XG4gICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IGZpcnN0Lmxlbmd0aDsgKytpMikge1xuICAgICAgICAgIHZhciBzcGFuID0gZmlyc3RbaTJdO1xuICAgICAgICAgIGlmIChzcGFuLnRvID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBmb3VuZCA9IGdldE1hcmtlZFNwYW5Gb3IobGFzdCwgc3Bhbi5tYXJrZXIpO1xuICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgICBzcGFuLnRvID0gc3RhcnRDaDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2FtZUxpbmUpIHtcbiAgICAgICAgICAgICAgc3Bhbi50byA9IGZvdW5kLnRvID09IG51bGwgPyBudWxsIDogZm91bmQudG8gKyBvZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobGFzdCkge1xuICAgICAgICBmb3IgKHZhciBpJDEyID0gMDsgaSQxMiA8IGxhc3QubGVuZ3RoOyArK2kkMTIpIHtcbiAgICAgICAgICB2YXIgc3BhbiQxID0gbGFzdFtpJDEyXTtcbiAgICAgICAgICBpZiAoc3BhbiQxLnRvICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNwYW4kMS50byArPSBvZmZzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzcGFuJDEuZnJvbSA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgZm91bmQkMSA9IGdldE1hcmtlZFNwYW5Gb3IoZmlyc3QsIHNwYW4kMS5tYXJrZXIpO1xuICAgICAgICAgICAgaWYgKCFmb3VuZCQxKSB7XG4gICAgICAgICAgICAgIHNwYW4kMS5mcm9tID0gb2Zmc2V0O1xuICAgICAgICAgICAgICBpZiAoc2FtZUxpbmUpIHtcbiAgICAgICAgICAgICAgICAoZmlyc3QgfHwgKGZpcnN0ID0gW10pKS5wdXNoKHNwYW4kMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3BhbiQxLmZyb20gKz0gb2Zmc2V0O1xuICAgICAgICAgICAgaWYgKHNhbWVMaW5lKSB7XG4gICAgICAgICAgICAgIChmaXJzdCB8fCAoZmlyc3QgPSBbXSkpLnB1c2goc3BhbiQxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICBmaXJzdCA9IGNsZWFyRW1wdHlTcGFucyhmaXJzdCk7XG4gICAgICB9XG4gICAgICBpZiAobGFzdCAmJiBsYXN0ICE9IGZpcnN0KSB7XG4gICAgICAgIGxhc3QgPSBjbGVhckVtcHR5U3BhbnMobGFzdCk7XG4gICAgICB9XG4gICAgICB2YXIgbmV3TWFya2VycyA9IFtmaXJzdF07XG4gICAgICBpZiAoIXNhbWVMaW5lKSB7XG4gICAgICAgIHZhciBnYXAgPSBjaGFuZ2UudGV4dC5sZW5ndGggLSAyLCBnYXBNYXJrZXJzO1xuICAgICAgICBpZiAoZ2FwID4gMCAmJiBmaXJzdCkge1xuICAgICAgICAgIGZvciAodmFyIGkkMjIgPSAwOyBpJDIyIDwgZmlyc3QubGVuZ3RoOyArK2kkMjIpIHtcbiAgICAgICAgICAgIGlmIChmaXJzdFtpJDIyXS50byA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIChnYXBNYXJrZXJzIHx8IChnYXBNYXJrZXJzID0gW10pKS5wdXNoKG5ldyBNYXJrZWRTcGFuKGZpcnN0W2kkMjJdLm1hcmtlciwgbnVsbCwgbnVsbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpJDMgPSAwOyBpJDMgPCBnYXA7ICsraSQzKSB7XG4gICAgICAgICAgbmV3TWFya2Vycy5wdXNoKGdhcE1hcmtlcnMpO1xuICAgICAgICB9XG4gICAgICAgIG5ld01hcmtlcnMucHVzaChsYXN0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdNYXJrZXJzO1xuICAgIH1cbiAgICBfX25hbWUoc3RyZXRjaFNwYW5zT3ZlckNoYW5nZSwgXCJzdHJldGNoU3BhbnNPdmVyQ2hhbmdlXCIpO1xuICAgIGZ1bmN0aW9uIGNsZWFyRW1wdHlTcGFucyhzcGFucykge1xuICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IHNwYW5zLmxlbmd0aDsgKytpMikge1xuICAgICAgICB2YXIgc3BhbiA9IHNwYW5zW2kyXTtcbiAgICAgICAgaWYgKHNwYW4uZnJvbSAhPSBudWxsICYmIHNwYW4uZnJvbSA9PSBzcGFuLnRvICYmIHNwYW4ubWFya2VyLmNsZWFyV2hlbkVtcHR5ICE9PSBmYWxzZSkge1xuICAgICAgICAgIHNwYW5zLnNwbGljZShpMi0tLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFzcGFucy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3BhbnM7XG4gICAgfVxuICAgIF9fbmFtZShjbGVhckVtcHR5U3BhbnMsIFwiY2xlYXJFbXB0eVNwYW5zXCIpO1xuICAgIGZ1bmN0aW9uIHJlbW92ZVJlYWRPbmx5UmFuZ2VzKGRvYywgZnJvbSwgdG8pIHtcbiAgICAgIHZhciBtYXJrZXJzID0gbnVsbDtcbiAgICAgIGRvYy5pdGVyKGZyb20ubGluZSwgdG8ubGluZSArIDEsIGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgaWYgKGxpbmUubWFya2VkU3BhbnMpIHtcbiAgICAgICAgICBmb3IgKHZhciBpMyA9IDA7IGkzIDwgbGluZS5tYXJrZWRTcGFucy5sZW5ndGg7ICsraTMpIHtcbiAgICAgICAgICAgIHZhciBtYXJrID0gbGluZS5tYXJrZWRTcGFuc1tpM10ubWFya2VyO1xuICAgICAgICAgICAgaWYgKG1hcmsucmVhZE9ubHkgJiYgKCFtYXJrZXJzIHx8IGluZGV4T2YobWFya2VycywgbWFyaykgPT0gLTEpKSB7XG4gICAgICAgICAgICAgIChtYXJrZXJzIHx8IChtYXJrZXJzID0gW10pKS5wdXNoKG1hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoIW1hcmtlcnMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgcGFydHMgPSBbeyBmcm9tLCB0byB9XTtcbiAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBtYXJrZXJzLmxlbmd0aDsgKytpMikge1xuICAgICAgICB2YXIgbWsgPSBtYXJrZXJzW2kyXSwgbSA9IG1rLmZpbmQoMCk7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGFydHMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICB2YXIgcCA9IHBhcnRzW2pdO1xuICAgICAgICAgIGlmIChjbXAocC50bywgbS5mcm9tKSA8IDAgfHwgY21wKHAuZnJvbSwgbS50bykgPiAwKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG5ld1BhcnRzID0gW2osIDFdLCBkZnJvbSA9IGNtcChwLmZyb20sIG0uZnJvbSksIGR0byA9IGNtcChwLnRvLCBtLnRvKTtcbiAgICAgICAgICBpZiAoZGZyb20gPCAwIHx8ICFtay5pbmNsdXNpdmVMZWZ0ICYmICFkZnJvbSkge1xuICAgICAgICAgICAgbmV3UGFydHMucHVzaCh7IGZyb206IHAuZnJvbSwgdG86IG0uZnJvbSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGR0byA+IDAgfHwgIW1rLmluY2x1c2l2ZVJpZ2h0ICYmICFkdG8pIHtcbiAgICAgICAgICAgIG5ld1BhcnRzLnB1c2goeyBmcm9tOiBtLnRvLCB0bzogcC50byB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFydHMuc3BsaWNlLmFwcGx5KHBhcnRzLCBuZXdQYXJ0cyk7XG4gICAgICAgICAgaiArPSBuZXdQYXJ0cy5sZW5ndGggLSAzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFydHM7XG4gICAgfVxuICAgIF9fbmFtZShyZW1vdmVSZWFkT25seVJhbmdlcywgXCJyZW1vdmVSZWFkT25seVJhbmdlc1wiKTtcbiAgICBmdW5jdGlvbiBkZXRhY2hNYXJrZWRTcGFucyhsaW5lKSB7XG4gICAgICB2YXIgc3BhbnMgPSBsaW5lLm1hcmtlZFNwYW5zO1xuICAgICAgaWYgKCFzcGFucykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgc3BhbnMubGVuZ3RoOyArK2kyKSB7XG4gICAgICAgIHNwYW5zW2kyXS5tYXJrZXIuZGV0YWNoTGluZShsaW5lKTtcbiAgICAgIH1cbiAgICAgIGxpbmUubWFya2VkU3BhbnMgPSBudWxsO1xuICAgIH1cbiAgICBfX25hbWUoZGV0YWNoTWFya2VkU3BhbnMsIFwiZGV0YWNoTWFya2VkU3BhbnNcIik7XG4gICAgZnVuY3Rpb24gYXR0YWNoTWFya2VkU3BhbnMobGluZSwgc3BhbnMpIHtcbiAgICAgIGlmICghc3BhbnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IHNwYW5zLmxlbmd0aDsgKytpMikge1xuICAgICAgICBzcGFuc1tpMl0ubWFya2VyLmF0dGFjaExpbmUobGluZSk7XG4gICAgICB9XG4gICAgICBsaW5lLm1hcmtlZFNwYW5zID0gc3BhbnM7XG4gICAgfVxuICAgIF9fbmFtZShhdHRhY2hNYXJrZWRTcGFucywgXCJhdHRhY2hNYXJrZWRTcGFuc1wiKTtcbiAgICBmdW5jdGlvbiBleHRyYUxlZnQobWFya2VyKSB7XG4gICAgICByZXR1cm4gbWFya2VyLmluY2x1c2l2ZUxlZnQgPyAtMSA6IDA7XG4gICAgfVxuICAgIF9fbmFtZShleHRyYUxlZnQsIFwiZXh0cmFMZWZ0XCIpO1xuICAgIGZ1bmN0aW9uIGV4dHJhUmlnaHQobWFya2VyKSB7XG4gICAgICByZXR1cm4gbWFya2VyLmluY2x1c2l2ZVJpZ2h0ID8gMSA6IDA7XG4gICAgfVxuICAgIF9fbmFtZShleHRyYVJpZ2h0LCBcImV4dHJhUmlnaHRcIik7XG4gICAgZnVuY3Rpb24gY29tcGFyZUNvbGxhcHNlZE1hcmtlcnMoYSwgYikge1xuICAgICAgdmFyIGxlbkRpZmYgPSBhLmxpbmVzLmxlbmd0aCAtIGIubGluZXMubGVuZ3RoO1xuICAgICAgaWYgKGxlbkRpZmYgIT0gMCkge1xuICAgICAgICByZXR1cm4gbGVuRGlmZjtcbiAgICAgIH1cbiAgICAgIHZhciBhUG9zID0gYS5maW5kKCksIGJQb3MgPSBiLmZpbmQoKTtcbiAgICAgIHZhciBmcm9tQ21wID0gY21wKGFQb3MuZnJvbSwgYlBvcy5mcm9tKSB8fCBleHRyYUxlZnQoYSkgLSBleHRyYUxlZnQoYik7XG4gICAgICBpZiAoZnJvbUNtcCkge1xuICAgICAgICByZXR1cm4gLWZyb21DbXA7XG4gICAgICB9XG4gICAgICB2YXIgdG9DbXAgPSBjbXAoYVBvcy50bywgYlBvcy50bykgfHwgZXh0cmFSaWdodChhKSAtIGV4dHJhUmlnaHQoYik7XG4gICAgICBpZiAodG9DbXApIHtcbiAgICAgICAgcmV0dXJuIHRvQ21wO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGIuaWQgLSBhLmlkO1xuICAgIH1cbiAgICBfX25hbWUoY29tcGFyZUNvbGxhcHNlZE1hcmtlcnMsIFwiY29tcGFyZUNvbGxhcHNlZE1hcmtlcnNcIik7XG4gICAgZnVuY3Rpb24gY29sbGFwc2VkU3BhbkF0U2lkZShsaW5lLCBzdGFydCkge1xuICAgICAgdmFyIHNwcyA9IHNhd0NvbGxhcHNlZFNwYW5zICYmIGxpbmUubWFya2VkU3BhbnMsIGZvdW5kO1xuICAgICAgaWYgKHNwcykge1xuICAgICAgICBmb3IgKHZhciBzcCA9IHZvaWQgMCwgaTIgPSAwOyBpMiA8IHNwcy5sZW5ndGg7ICsraTIpIHtcbiAgICAgICAgICBzcCA9IHNwc1tpMl07XG4gICAgICAgICAgaWYgKHNwLm1hcmtlci5jb2xsYXBzZWQgJiYgKHN0YXJ0ID8gc3AuZnJvbSA6IHNwLnRvKSA9PSBudWxsICYmICghZm91bmQgfHwgY29tcGFyZUNvbGxhcHNlZE1hcmtlcnMoZm91bmQsIHNwLm1hcmtlcikgPCAwKSkge1xuICAgICAgICAgICAgZm91bmQgPSBzcC5tYXJrZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICAgIF9fbmFtZShjb2xsYXBzZWRTcGFuQXRTaWRlLCBcImNvbGxhcHNlZFNwYW5BdFNpZGVcIik7XG4gICAgZnVuY3Rpb24gY29sbGFwc2VkU3BhbkF0U3RhcnQobGluZSkge1xuICAgICAgcmV0dXJuIGNvbGxhcHNlZFNwYW5BdFNpZGUobGluZSwgdHJ1ZSk7XG4gICAgfVxuICAgIF9fbmFtZShjb2xsYXBzZWRTcGFuQXRTdGFydCwgXCJjb2xsYXBzZWRTcGFuQXRTdGFydFwiKTtcbiAgICBmdW5jdGlvbiBjb2xsYXBzZWRTcGFuQXRFbmQobGluZSkge1xuICAgICAgcmV0dXJuIGNvbGxhcHNlZFNwYW5BdFNpZGUobGluZSwgZmFsc2UpO1xuICAgIH1cbiAgICBfX25hbWUoY29sbGFwc2VkU3BhbkF0RW5kLCBcImNvbGxhcHNlZFNwYW5BdEVuZFwiKTtcbiAgICBmdW5jdGlvbiBjb2xsYXBzZWRTcGFuQXJvdW5kKGxpbmUsIGNoKSB7XG4gICAgICB2YXIgc3BzID0gc2F3Q29sbGFwc2VkU3BhbnMgJiYgbGluZS5tYXJrZWRTcGFucywgZm91bmQ7XG4gICAgICBpZiAoc3BzKSB7XG4gICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBzcHMubGVuZ3RoOyArK2kyKSB7XG4gICAgICAgICAgdmFyIHNwID0gc3BzW2kyXTtcbiAgICAgICAgICBpZiAoc3AubWFya2VyLmNvbGxhcHNlZCAmJiAoc3AuZnJvbSA9PSBudWxsIHx8IHNwLmZyb20gPCBjaCkgJiYgKHNwLnRvID09IG51bGwgfHwgc3AudG8gPiBjaCkgJiYgKCFmb3VuZCB8fCBjb21wYXJlQ29sbGFwc2VkTWFya2Vycyhmb3VuZCwgc3AubWFya2VyKSA8IDApKSB7XG4gICAgICAgICAgICBmb3VuZCA9IHNwLm1hcmtlcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG4gICAgX19uYW1lKGNvbGxhcHNlZFNwYW5Bcm91bmQsIFwiY29sbGFwc2VkU3BhbkFyb3VuZFwiKTtcbiAgICBmdW5jdGlvbiBjb25mbGljdGluZ0NvbGxhcHNlZFJhbmdlKGRvYywgbGluZU5vMiwgZnJvbSwgdG8sIG1hcmtlcikge1xuICAgICAgdmFyIGxpbmUgPSBnZXRMaW5lKGRvYywgbGluZU5vMik7XG4gICAgICB2YXIgc3BzID0gc2F3Q29sbGFwc2VkU3BhbnMgJiYgbGluZS5tYXJrZWRTcGFucztcbiAgICAgIGlmIChzcHMpIHtcbiAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IHNwcy5sZW5ndGg7ICsraTIpIHtcbiAgICAgICAgICB2YXIgc3AgPSBzcHNbaTJdO1xuICAgICAgICAgIGlmICghc3AubWFya2VyLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBmb3VuZCA9IHNwLm1hcmtlci5maW5kKDApO1xuICAgICAgICAgIHZhciBmcm9tQ21wID0gY21wKGZvdW5kLmZyb20sIGZyb20pIHx8IGV4dHJhTGVmdChzcC5tYXJrZXIpIC0gZXh0cmFMZWZ0KG1hcmtlcik7XG4gICAgICAgICAgdmFyIHRvQ21wID0gY21wKGZvdW5kLnRvLCB0bykgfHwgZXh0cmFSaWdodChzcC5tYXJrZXIpIC0gZXh0cmFSaWdodChtYXJrZXIpO1xuICAgICAgICAgIGlmIChmcm9tQ21wID49IDAgJiYgdG9DbXAgPD0gMCB8fCBmcm9tQ21wIDw9IDAgJiYgdG9DbXAgPj0gMCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmcm9tQ21wIDw9IDAgJiYgKHNwLm1hcmtlci5pbmNsdXNpdmVSaWdodCAmJiBtYXJrZXIuaW5jbHVzaXZlTGVmdCA/IGNtcChmb3VuZC50bywgZnJvbSkgPj0gMCA6IGNtcChmb3VuZC50bywgZnJvbSkgPiAwKSB8fCBmcm9tQ21wID49IDAgJiYgKHNwLm1hcmtlci5pbmNsdXNpdmVSaWdodCAmJiBtYXJrZXIuaW5jbHVzaXZlTGVmdCA/IGNtcChmb3VuZC5mcm9tLCB0bykgPD0gMCA6IGNtcChmb3VuZC5mcm9tLCB0bykgPCAwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShjb25mbGljdGluZ0NvbGxhcHNlZFJhbmdlLCBcImNvbmZsaWN0aW5nQ29sbGFwc2VkUmFuZ2VcIik7XG4gICAgZnVuY3Rpb24gdmlzdWFsTGluZShsaW5lKSB7XG4gICAgICB2YXIgbWVyZ2VkO1xuICAgICAgd2hpbGUgKG1lcmdlZCA9IGNvbGxhcHNlZFNwYW5BdFN0YXJ0KGxpbmUpKSB7XG4gICAgICAgIGxpbmUgPSBtZXJnZWQuZmluZCgtMSwgdHJ1ZSkubGluZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaW5lO1xuICAgIH1cbiAgICBfX25hbWUodmlzdWFsTGluZSwgXCJ2aXN1YWxMaW5lXCIpO1xuICAgIGZ1bmN0aW9uIHZpc3VhbExpbmVFbmQobGluZSkge1xuICAgICAgdmFyIG1lcmdlZDtcbiAgICAgIHdoaWxlIChtZXJnZWQgPSBjb2xsYXBzZWRTcGFuQXRFbmQobGluZSkpIHtcbiAgICAgICAgbGluZSA9IG1lcmdlZC5maW5kKDEsIHRydWUpLmxpbmU7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGluZTtcbiAgICB9XG4gICAgX19uYW1lKHZpc3VhbExpbmVFbmQsIFwidmlzdWFsTGluZUVuZFwiKTtcbiAgICBmdW5jdGlvbiB2aXN1YWxMaW5lQ29udGludWVkKGxpbmUpIHtcbiAgICAgIHZhciBtZXJnZWQsIGxpbmVzO1xuICAgICAgd2hpbGUgKG1lcmdlZCA9IGNvbGxhcHNlZFNwYW5BdEVuZChsaW5lKSkge1xuICAgICAgICBsaW5lID0gbWVyZ2VkLmZpbmQoMSwgdHJ1ZSkubGluZTtcbiAgICAgICAgKGxpbmVzIHx8IChsaW5lcyA9IFtdKSkucHVzaChsaW5lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaW5lcztcbiAgICB9XG4gICAgX19uYW1lKHZpc3VhbExpbmVDb250aW51ZWQsIFwidmlzdWFsTGluZUNvbnRpbnVlZFwiKTtcbiAgICBmdW5jdGlvbiB2aXN1YWxMaW5lTm8oZG9jLCBsaW5lTikge1xuICAgICAgdmFyIGxpbmUgPSBnZXRMaW5lKGRvYywgbGluZU4pLCB2aXMgPSB2aXN1YWxMaW5lKGxpbmUpO1xuICAgICAgaWYgKGxpbmUgPT0gdmlzKSB7XG4gICAgICAgIHJldHVybiBsaW5lTjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaW5lTm8odmlzKTtcbiAgICB9XG4gICAgX19uYW1lKHZpc3VhbExpbmVObywgXCJ2aXN1YWxMaW5lTm9cIik7XG4gICAgZnVuY3Rpb24gdmlzdWFsTGluZUVuZE5vKGRvYywgbGluZU4pIHtcbiAgICAgIGlmIChsaW5lTiA+IGRvYy5sYXN0TGluZSgpKSB7XG4gICAgICAgIHJldHVybiBsaW5lTjtcbiAgICAgIH1cbiAgICAgIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIGxpbmVOKSwgbWVyZ2VkO1xuICAgICAgaWYgKCFsaW5lSXNIaWRkZW4oZG9jLCBsaW5lKSkge1xuICAgICAgICByZXR1cm4gbGluZU47XG4gICAgICB9XG4gICAgICB3aGlsZSAobWVyZ2VkID0gY29sbGFwc2VkU3BhbkF0RW5kKGxpbmUpKSB7XG4gICAgICAgIGxpbmUgPSBtZXJnZWQuZmluZCgxLCB0cnVlKS5saW5lO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxpbmVObyhsaW5lKSArIDE7XG4gICAgfVxuICAgIF9fbmFtZSh2aXN1YWxMaW5lRW5kTm8sIFwidmlzdWFsTGluZUVuZE5vXCIpO1xuICAgIGZ1bmN0aW9uIGxpbmVJc0hpZGRlbihkb2MsIGxpbmUpIHtcbiAgICAgIHZhciBzcHMgPSBzYXdDb2xsYXBzZWRTcGFucyAmJiBsaW5lLm1hcmtlZFNwYW5zO1xuICAgICAgaWYgKHNwcykge1xuICAgICAgICBmb3IgKHZhciBzcCA9IHZvaWQgMCwgaTIgPSAwOyBpMiA8IHNwcy5sZW5ndGg7ICsraTIpIHtcbiAgICAgICAgICBzcCA9IHNwc1tpMl07XG4gICAgICAgICAgaWYgKCFzcC5tYXJrZXIuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNwLmZyb20gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzcC5tYXJrZXIud2lkZ2V0Tm9kZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzcC5mcm9tID09IDAgJiYgc3AubWFya2VyLmluY2x1c2l2ZUxlZnQgJiYgbGluZUlzSGlkZGVuSW5uZXIoZG9jLCBsaW5lLCBzcCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUobGluZUlzSGlkZGVuLCBcImxpbmVJc0hpZGRlblwiKTtcbiAgICBmdW5jdGlvbiBsaW5lSXNIaWRkZW5Jbm5lcihkb2MsIGxpbmUsIHNwYW4pIHtcbiAgICAgIGlmIChzcGFuLnRvID09IG51bGwpIHtcbiAgICAgICAgdmFyIGVuZCA9IHNwYW4ubWFya2VyLmZpbmQoMSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBsaW5lSXNIaWRkZW5Jbm5lcihkb2MsIGVuZC5saW5lLCBnZXRNYXJrZWRTcGFuRm9yKGVuZC5saW5lLm1hcmtlZFNwYW5zLCBzcGFuLm1hcmtlcikpO1xuICAgICAgfVxuICAgICAgaWYgKHNwYW4ubWFya2VyLmluY2x1c2l2ZVJpZ2h0ICYmIHNwYW4udG8gPT0gbGluZS50ZXh0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIHNwID0gdm9pZCAwLCBpMiA9IDA7IGkyIDwgbGluZS5tYXJrZWRTcGFucy5sZW5ndGg7ICsraTIpIHtcbiAgICAgICAgc3AgPSBsaW5lLm1hcmtlZFNwYW5zW2kyXTtcbiAgICAgICAgaWYgKHNwLm1hcmtlci5jb2xsYXBzZWQgJiYgIXNwLm1hcmtlci53aWRnZXROb2RlICYmIHNwLmZyb20gPT0gc3Bhbi50byAmJiAoc3AudG8gPT0gbnVsbCB8fCBzcC50byAhPSBzcGFuLmZyb20pICYmIChzcC5tYXJrZXIuaW5jbHVzaXZlTGVmdCB8fCBzcGFuLm1hcmtlci5pbmNsdXNpdmVSaWdodCkgJiYgbGluZUlzSGlkZGVuSW5uZXIoZG9jLCBsaW5lLCBzcCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUobGluZUlzSGlkZGVuSW5uZXIsIFwibGluZUlzSGlkZGVuSW5uZXJcIik7XG4gICAgZnVuY3Rpb24gaGVpZ2h0QXRMaW5lKGxpbmVPYmopIHtcbiAgICAgIGxpbmVPYmogPSB2aXN1YWxMaW5lKGxpbmVPYmopO1xuICAgICAgdmFyIGggPSAwLCBjaHVuayA9IGxpbmVPYmoucGFyZW50O1xuICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IGNodW5rLmxpbmVzLmxlbmd0aDsgKytpMikge1xuICAgICAgICB2YXIgbGluZSA9IGNodW5rLmxpbmVzW2kyXTtcbiAgICAgICAgaWYgKGxpbmUgPT0gbGluZU9iaikge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGggKz0gbGluZS5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAodmFyIHAgPSBjaHVuay5wYXJlbnQ7IHA7IGNodW5rID0gcCwgcCA9IGNodW5rLnBhcmVudCkge1xuICAgICAgICBmb3IgKHZhciBpJDEyID0gMDsgaSQxMiA8IHAuY2hpbGRyZW4ubGVuZ3RoOyArK2kkMTIpIHtcbiAgICAgICAgICB2YXIgY3VyID0gcC5jaGlsZHJlbltpJDEyXTtcbiAgICAgICAgICBpZiAoY3VyID09IGNodW5rKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaCArPSBjdXIuaGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGg7XG4gICAgfVxuICAgIF9fbmFtZShoZWlnaHRBdExpbmUsIFwiaGVpZ2h0QXRMaW5lXCIpO1xuICAgIGZ1bmN0aW9uIGxpbmVMZW5ndGgobGluZSkge1xuICAgICAgaWYgKGxpbmUuaGVpZ2h0ID09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICB2YXIgbGVuID0gbGluZS50ZXh0Lmxlbmd0aCwgbWVyZ2VkLCBjdXIgPSBsaW5lO1xuICAgICAgd2hpbGUgKG1lcmdlZCA9IGNvbGxhcHNlZFNwYW5BdFN0YXJ0KGN1cikpIHtcbiAgICAgICAgdmFyIGZvdW5kID0gbWVyZ2VkLmZpbmQoMCwgdHJ1ZSk7XG4gICAgICAgIGN1ciA9IGZvdW5kLmZyb20ubGluZTtcbiAgICAgICAgbGVuICs9IGZvdW5kLmZyb20uY2ggLSBmb3VuZC50by5jaDtcbiAgICAgIH1cbiAgICAgIGN1ciA9IGxpbmU7XG4gICAgICB3aGlsZSAobWVyZ2VkID0gY29sbGFwc2VkU3BhbkF0RW5kKGN1cikpIHtcbiAgICAgICAgdmFyIGZvdW5kJDEgPSBtZXJnZWQuZmluZCgwLCB0cnVlKTtcbiAgICAgICAgbGVuIC09IGN1ci50ZXh0Lmxlbmd0aCAtIGZvdW5kJDEuZnJvbS5jaDtcbiAgICAgICAgY3VyID0gZm91bmQkMS50by5saW5lO1xuICAgICAgICBsZW4gKz0gY3VyLnRleHQubGVuZ3RoIC0gZm91bmQkMS50by5jaDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZW47XG4gICAgfVxuICAgIF9fbmFtZShsaW5lTGVuZ3RoLCBcImxpbmVMZW5ndGhcIik7XG4gICAgZnVuY3Rpb24gZmluZE1heExpbmUoY20pIHtcbiAgICAgIHZhciBkID0gY20uZGlzcGxheSwgZG9jID0gY20uZG9jO1xuICAgICAgZC5tYXhMaW5lID0gZ2V0TGluZShkb2MsIGRvYy5maXJzdCk7XG4gICAgICBkLm1heExpbmVMZW5ndGggPSBsaW5lTGVuZ3RoKGQubWF4TGluZSk7XG4gICAgICBkLm1heExpbmVDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIGRvYy5pdGVyKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgdmFyIGxlbiA9IGxpbmVMZW5ndGgobGluZSk7XG4gICAgICAgIGlmIChsZW4gPiBkLm1heExpbmVMZW5ndGgpIHtcbiAgICAgICAgICBkLm1heExpbmVMZW5ndGggPSBsZW47XG4gICAgICAgICAgZC5tYXhMaW5lID0gbGluZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIF9fbmFtZShmaW5kTWF4TGluZSwgXCJmaW5kTWF4TGluZVwiKTtcbiAgICB2YXIgTGluZSA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24odGV4dCwgbWFya2VkU3BhbnMsIGVzdGltYXRlSGVpZ2h0Mikge1xuICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgIGF0dGFjaE1hcmtlZFNwYW5zKHRoaXMsIG1hcmtlZFNwYW5zKTtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gZXN0aW1hdGVIZWlnaHQyID8gZXN0aW1hdGVIZWlnaHQyKHRoaXMpIDogMTtcbiAgICB9LCBcIkxpbmVcIik7XG4gICAgTGluZS5wcm90b3R5cGUubGluZU5vID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbGluZU5vKHRoaXMpO1xuICAgIH07XG4gICAgZXZlbnRNaXhpbihMaW5lKTtcbiAgICBmdW5jdGlvbiB1cGRhdGVMaW5lKGxpbmUsIHRleHQsIG1hcmtlZFNwYW5zLCBlc3RpbWF0ZUhlaWdodDIpIHtcbiAgICAgIGxpbmUudGV4dCA9IHRleHQ7XG4gICAgICBpZiAobGluZS5zdGF0ZUFmdGVyKSB7XG4gICAgICAgIGxpbmUuc3RhdGVBZnRlciA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAobGluZS5zdHlsZXMpIHtcbiAgICAgICAgbGluZS5zdHlsZXMgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmUub3JkZXIgIT0gbnVsbCkge1xuICAgICAgICBsaW5lLm9yZGVyID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGRldGFjaE1hcmtlZFNwYW5zKGxpbmUpO1xuICAgICAgYXR0YWNoTWFya2VkU3BhbnMobGluZSwgbWFya2VkU3BhbnMpO1xuICAgICAgdmFyIGVzdEhlaWdodCA9IGVzdGltYXRlSGVpZ2h0MiA/IGVzdGltYXRlSGVpZ2h0MihsaW5lKSA6IDE7XG4gICAgICBpZiAoZXN0SGVpZ2h0ICE9IGxpbmUuaGVpZ2h0KSB7XG4gICAgICAgIHVwZGF0ZUxpbmVIZWlnaHQobGluZSwgZXN0SGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKHVwZGF0ZUxpbmUsIFwidXBkYXRlTGluZVwiKTtcbiAgICBmdW5jdGlvbiBjbGVhblVwTGluZShsaW5lKSB7XG4gICAgICBsaW5lLnBhcmVudCA9IG51bGw7XG4gICAgICBkZXRhY2hNYXJrZWRTcGFucyhsaW5lKTtcbiAgICB9XG4gICAgX19uYW1lKGNsZWFuVXBMaW5lLCBcImNsZWFuVXBMaW5lXCIpO1xuICAgIHZhciBzdHlsZVRvQ2xhc3NDYWNoZSA9IHt9LCBzdHlsZVRvQ2xhc3NDYWNoZVdpdGhNb2RlID0ge307XG4gICAgZnVuY3Rpb24gaW50ZXJwcmV0VG9rZW5TdHlsZShzdHlsZSwgb3B0aW9ucykge1xuICAgICAgaWYgKCFzdHlsZSB8fCAvXlxccyokLy50ZXN0KHN0eWxlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBjYWNoZSA9IG9wdGlvbnMuYWRkTW9kZUNsYXNzID8gc3R5bGVUb0NsYXNzQ2FjaGVXaXRoTW9kZSA6IHN0eWxlVG9DbGFzc0NhY2hlO1xuICAgICAgcmV0dXJuIGNhY2hlW3N0eWxlXSB8fCAoY2FjaGVbc3R5bGVdID0gc3R5bGUucmVwbGFjZSgvXFxTKy9nLCBcImNtLSQmXCIpKTtcbiAgICB9XG4gICAgX19uYW1lKGludGVycHJldFRva2VuU3R5bGUsIFwiaW50ZXJwcmV0VG9rZW5TdHlsZVwiKTtcbiAgICBmdW5jdGlvbiBidWlsZExpbmVDb250ZW50KGNtLCBsaW5lVmlldykge1xuICAgICAgdmFyIGNvbnRlbnQgPSBlbHRQKFwic3BhblwiLCBudWxsLCBudWxsLCB3ZWJraXQgPyBcInBhZGRpbmctcmlnaHQ6IC4xcHhcIiA6IG51bGwpO1xuICAgICAgdmFyIGJ1aWxkZXIgPSB7XG4gICAgICAgIHByZTogZWx0UChcInByZVwiLCBbY29udGVudF0sIFwiQ29kZU1pcnJvci1saW5lXCIpLFxuICAgICAgICBjb250ZW50LFxuICAgICAgICBjb2w6IDAsXG4gICAgICAgIHBvczogMCxcbiAgICAgICAgY20sXG4gICAgICAgIHRyYWlsaW5nU3BhY2U6IGZhbHNlLFxuICAgICAgICBzcGxpdFNwYWNlczogY20uZ2V0T3B0aW9uKFwibGluZVdyYXBwaW5nXCIpXG4gICAgICB9O1xuICAgICAgbGluZVZpZXcubWVhc3VyZSA9IHt9O1xuICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8PSAobGluZVZpZXcucmVzdCA/IGxpbmVWaWV3LnJlc3QubGVuZ3RoIDogMCk7IGkyKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSBpMiA/IGxpbmVWaWV3LnJlc3RbaTIgLSAxXSA6IGxpbmVWaWV3LmxpbmUsIG9yZGVyID0gdm9pZCAwO1xuICAgICAgICBidWlsZGVyLnBvcyA9IDA7XG4gICAgICAgIGJ1aWxkZXIuYWRkVG9rZW4gPSBidWlsZFRva2VuO1xuICAgICAgICBpZiAoaGFzQmFkQmlkaVJlY3RzKGNtLmRpc3BsYXkubWVhc3VyZSkgJiYgKG9yZGVyID0gZ2V0T3JkZXIobGluZSwgY20uZG9jLmRpcmVjdGlvbikpKSB7XG4gICAgICAgICAgYnVpbGRlci5hZGRUb2tlbiA9IGJ1aWxkVG9rZW5CYWRCaWRpKGJ1aWxkZXIuYWRkVG9rZW4sIG9yZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBidWlsZGVyLm1hcCA9IFtdO1xuICAgICAgICB2YXIgYWxsb3dGcm9udGllclVwZGF0ZSA9IGxpbmVWaWV3ICE9IGNtLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCAmJiBsaW5lTm8obGluZSk7XG4gICAgICAgIGluc2VydExpbmVDb250ZW50KGxpbmUsIGJ1aWxkZXIsIGdldExpbmVTdHlsZXMoY20sIGxpbmUsIGFsbG93RnJvbnRpZXJVcGRhdGUpKTtcbiAgICAgICAgaWYgKGxpbmUuc3R5bGVDbGFzc2VzKSB7XG4gICAgICAgICAgaWYgKGxpbmUuc3R5bGVDbGFzc2VzLmJnQ2xhc3MpIHtcbiAgICAgICAgICAgIGJ1aWxkZXIuYmdDbGFzcyA9IGpvaW5DbGFzc2VzKGxpbmUuc3R5bGVDbGFzc2VzLmJnQ2xhc3MsIGJ1aWxkZXIuYmdDbGFzcyB8fCBcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxpbmUuc3R5bGVDbGFzc2VzLnRleHRDbGFzcykge1xuICAgICAgICAgICAgYnVpbGRlci50ZXh0Q2xhc3MgPSBqb2luQ2xhc3NlcyhsaW5lLnN0eWxlQ2xhc3Nlcy50ZXh0Q2xhc3MsIGJ1aWxkZXIudGV4dENsYXNzIHx8IFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYnVpbGRlci5tYXAubGVuZ3RoID09IDApIHtcbiAgICAgICAgICBidWlsZGVyLm1hcC5wdXNoKDAsIDAsIGJ1aWxkZXIuY29udGVudC5hcHBlbmRDaGlsZCh6ZXJvV2lkdGhFbGVtZW50KGNtLmRpc3BsYXkubWVhc3VyZSkpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaTIgPT0gMCkge1xuICAgICAgICAgIGxpbmVWaWV3Lm1lYXN1cmUubWFwID0gYnVpbGRlci5tYXA7XG4gICAgICAgICAgbGluZVZpZXcubWVhc3VyZS5jYWNoZSA9IHt9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIChsaW5lVmlldy5tZWFzdXJlLm1hcHMgfHwgKGxpbmVWaWV3Lm1lYXN1cmUubWFwcyA9IFtdKSkucHVzaChidWlsZGVyLm1hcCk7XG4gICAgICAgICAgKGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGVzIHx8IChsaW5lVmlldy5tZWFzdXJlLmNhY2hlcyA9IFtdKSkucHVzaCh7fSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh3ZWJraXQpIHtcbiAgICAgICAgdmFyIGxhc3QgPSBidWlsZGVyLmNvbnRlbnQubGFzdENoaWxkO1xuICAgICAgICBpZiAoL1xcYmNtLXRhYlxcYi8udGVzdChsYXN0LmNsYXNzTmFtZSkgfHwgbGFzdC5xdWVyeVNlbGVjdG9yICYmIGxhc3QucXVlcnlTZWxlY3RvcihcIi5jbS10YWJcIikpIHtcbiAgICAgICAgICBidWlsZGVyLmNvbnRlbnQuY2xhc3NOYW1lID0gXCJjbS10YWItd3JhcC1oYWNrXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNpZ25hbChjbSwgXCJyZW5kZXJMaW5lXCIsIGNtLCBsaW5lVmlldy5saW5lLCBidWlsZGVyLnByZSk7XG4gICAgICBpZiAoYnVpbGRlci5wcmUuY2xhc3NOYW1lKSB7XG4gICAgICAgIGJ1aWxkZXIudGV4dENsYXNzID0gam9pbkNsYXNzZXMoYnVpbGRlci5wcmUuY2xhc3NOYW1lLCBidWlsZGVyLnRleHRDbGFzcyB8fCBcIlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyO1xuICAgIH1cbiAgICBfX25hbWUoYnVpbGRMaW5lQ29udGVudCwgXCJidWlsZExpbmVDb250ZW50XCIpO1xuICAgIGZ1bmN0aW9uIGRlZmF1bHRTcGVjaWFsQ2hhclBsYWNlaG9sZGVyKGNoKSB7XG4gICAgICB2YXIgdG9rZW4gPSBlbHQoXCJzcGFuXCIsIFwiXFx1MjAyMlwiLCBcImNtLWludmFsaWRjaGFyXCIpO1xuICAgICAgdG9rZW4udGl0bGUgPSBcIlxcXFx1XCIgKyBjaC5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KTtcbiAgICAgIHRva2VuLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdG9rZW4udGl0bGUpO1xuICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cbiAgICBfX25hbWUoZGVmYXVsdFNwZWNpYWxDaGFyUGxhY2Vob2xkZXIsIFwiZGVmYXVsdFNwZWNpYWxDaGFyUGxhY2Vob2xkZXJcIik7XG4gICAgZnVuY3Rpb24gYnVpbGRUb2tlbihidWlsZGVyLCB0ZXh0LCBzdHlsZSwgc3RhcnRTdHlsZSwgZW5kU3R5bGUsIGNzcywgYXR0cmlidXRlcykge1xuICAgICAgaWYgKCF0ZXh0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBkaXNwbGF5VGV4dCA9IGJ1aWxkZXIuc3BsaXRTcGFjZXMgPyBzcGxpdFNwYWNlcyh0ZXh0LCBidWlsZGVyLnRyYWlsaW5nU3BhY2UpIDogdGV4dDtcbiAgICAgIHZhciBzcGVjaWFsID0gYnVpbGRlci5jbS5zdGF0ZS5zcGVjaWFsQ2hhcnMsIG11c3RXcmFwID0gZmFsc2U7XG4gICAgICB2YXIgY29udGVudDtcbiAgICAgIGlmICghc3BlY2lhbC50ZXN0KHRleHQpKSB7XG4gICAgICAgIGJ1aWxkZXIuY29sICs9IHRleHQubGVuZ3RoO1xuICAgICAgICBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZGlzcGxheVRleHQpO1xuICAgICAgICBidWlsZGVyLm1hcC5wdXNoKGJ1aWxkZXIucG9zLCBidWlsZGVyLnBvcyArIHRleHQubGVuZ3RoLCBjb250ZW50KTtcbiAgICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCA5KSB7XG4gICAgICAgICAgbXVzdFdyYXAgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGJ1aWxkZXIucG9zICs9IHRleHQubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgdmFyIHBvcyA9IDA7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgc3BlY2lhbC5sYXN0SW5kZXggPSBwb3M7XG4gICAgICAgICAgdmFyIG0gPSBzcGVjaWFsLmV4ZWModGV4dCk7XG4gICAgICAgICAgdmFyIHNraXBwZWQgPSBtID8gbS5pbmRleCAtIHBvcyA6IHRleHQubGVuZ3RoIC0gcG9zO1xuICAgICAgICAgIGlmIChza2lwcGVkKSB7XG4gICAgICAgICAgICB2YXIgdHh0ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZGlzcGxheVRleHQuc2xpY2UocG9zLCBwb3MgKyBza2lwcGVkKSk7XG4gICAgICAgICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDkpIHtcbiAgICAgICAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZChlbHQoXCJzcGFuXCIsIFt0eHRdKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKHR4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWlsZGVyLm1hcC5wdXNoKGJ1aWxkZXIucG9zLCBidWlsZGVyLnBvcyArIHNraXBwZWQsIHR4dCk7XG4gICAgICAgICAgICBidWlsZGVyLmNvbCArPSBza2lwcGVkO1xuICAgICAgICAgICAgYnVpbGRlci5wb3MgKz0gc2tpcHBlZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcG9zICs9IHNraXBwZWQgKyAxO1xuICAgICAgICAgIHZhciB0eHQkMSA9IHZvaWQgMDtcbiAgICAgICAgICBpZiAobVswXSA9PSBcIlx0XCIpIHtcbiAgICAgICAgICAgIHZhciB0YWJTaXplID0gYnVpbGRlci5jbS5vcHRpb25zLnRhYlNpemUsIHRhYldpZHRoID0gdGFiU2l6ZSAtIGJ1aWxkZXIuY29sICUgdGFiU2l6ZTtcbiAgICAgICAgICAgIHR4dCQxID0gY29udGVudC5hcHBlbmRDaGlsZChlbHQoXCJzcGFuXCIsIHNwYWNlU3RyKHRhYldpZHRoKSwgXCJjbS10YWJcIikpO1xuICAgICAgICAgICAgdHh0JDEuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInByZXNlbnRhdGlvblwiKTtcbiAgICAgICAgICAgIHR4dCQxLnNldEF0dHJpYnV0ZShcImNtLXRleHRcIiwgXCJcdFwiKTtcbiAgICAgICAgICAgIGJ1aWxkZXIuY29sICs9IHRhYldpZHRoO1xuICAgICAgICAgIH0gZWxzZSBpZiAobVswXSA9PSBcIlxcclwiIHx8IG1bMF0gPT0gXCJcXG5cIikge1xuICAgICAgICAgICAgdHh0JDEgPSBjb250ZW50LmFwcGVuZENoaWxkKGVsdChcInNwYW5cIiwgbVswXSA9PSBcIlxcclwiID8gXCJcXHUyNDBEXCIgOiBcIlxcdTI0MjRcIiwgXCJjbS1pbnZhbGlkY2hhclwiKSk7XG4gICAgICAgICAgICB0eHQkMS5zZXRBdHRyaWJ1dGUoXCJjbS10ZXh0XCIsIG1bMF0pO1xuICAgICAgICAgICAgYnVpbGRlci5jb2wgKz0gMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHh0JDEgPSBidWlsZGVyLmNtLm9wdGlvbnMuc3BlY2lhbENoYXJQbGFjZWhvbGRlcihtWzBdKTtcbiAgICAgICAgICAgIHR4dCQxLnNldEF0dHJpYnV0ZShcImNtLXRleHRcIiwgbVswXSk7XG4gICAgICAgICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDkpIHtcbiAgICAgICAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZChlbHQoXCJzcGFuXCIsIFt0eHQkMV0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQodHh0JDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVpbGRlci5jb2wgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnVpbGRlci5tYXAucHVzaChidWlsZGVyLnBvcywgYnVpbGRlci5wb3MgKyAxLCB0eHQkMSk7XG4gICAgICAgICAgYnVpbGRlci5wb3MrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnVpbGRlci50cmFpbGluZ1NwYWNlID0gZGlzcGxheVRleHQuY2hhckNvZGVBdCh0ZXh0Lmxlbmd0aCAtIDEpID09IDMyO1xuICAgICAgaWYgKHN0eWxlIHx8IHN0YXJ0U3R5bGUgfHwgZW5kU3R5bGUgfHwgbXVzdFdyYXAgfHwgY3NzIHx8IGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgdmFyIGZ1bGxTdHlsZSA9IHN0eWxlIHx8IFwiXCI7XG4gICAgICAgIGlmIChzdGFydFN0eWxlKSB7XG4gICAgICAgICAgZnVsbFN0eWxlICs9IHN0YXJ0U3R5bGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZFN0eWxlKSB7XG4gICAgICAgICAgZnVsbFN0eWxlICs9IGVuZFN0eWxlO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0b2tlbiA9IGVsdChcInNwYW5cIiwgW2NvbnRlbnRdLCBmdWxsU3R5bGUsIGNzcyk7XG4gICAgICAgIGlmIChhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgZm9yICh2YXIgYXR0ciBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShhdHRyKSAmJiBhdHRyICE9IFwic3R5bGVcIiAmJiBhdHRyICE9IFwiY2xhc3NcIikge1xuICAgICAgICAgICAgICB0b2tlbi5zZXRBdHRyaWJ1dGUoYXR0ciwgYXR0cmlidXRlc1thdHRyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWlsZGVyLmNvbnRlbnQuYXBwZW5kQ2hpbGQodG9rZW4pO1xuICAgICAgfVxuICAgICAgYnVpbGRlci5jb250ZW50LmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgIH1cbiAgICBfX25hbWUoYnVpbGRUb2tlbiwgXCJidWlsZFRva2VuXCIpO1xuICAgIGZ1bmN0aW9uIHNwbGl0U3BhY2VzKHRleHQsIHRyYWlsaW5nQmVmb3JlKSB7XG4gICAgICBpZiAodGV4dC5sZW5ndGggPiAxICYmICEvICAvLnRlc3QodGV4dCkpIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICB9XG4gICAgICB2YXIgc3BhY2VCZWZvcmUgPSB0cmFpbGluZ0JlZm9yZSwgcmVzdWx0ID0gXCJcIjtcbiAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCB0ZXh0Lmxlbmd0aDsgaTIrKykge1xuICAgICAgICB2YXIgY2ggPSB0ZXh0LmNoYXJBdChpMik7XG4gICAgICAgIGlmIChjaCA9PSBcIiBcIiAmJiBzcGFjZUJlZm9yZSAmJiAoaTIgPT0gdGV4dC5sZW5ndGggLSAxIHx8IHRleHQuY2hhckNvZGVBdChpMiArIDEpID09IDMyKSkge1xuICAgICAgICAgIGNoID0gXCJcXHhBMFwiO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSBjaDtcbiAgICAgICAgc3BhY2VCZWZvcmUgPSBjaCA9PSBcIiBcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIF9fbmFtZShzcGxpdFNwYWNlcywgXCJzcGxpdFNwYWNlc1wiKTtcbiAgICBmdW5jdGlvbiBidWlsZFRva2VuQmFkQmlkaShpbm5lciwgb3JkZXIpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihidWlsZGVyLCB0ZXh0LCBzdHlsZSwgc3RhcnRTdHlsZSwgZW5kU3R5bGUsIGNzcywgYXR0cmlidXRlcykge1xuICAgICAgICBzdHlsZSA9IHN0eWxlID8gc3R5bGUgKyBcIiBjbS1mb3JjZS1ib3JkZXJcIiA6IFwiY20tZm9yY2UtYm9yZGVyXCI7XG4gICAgICAgIHZhciBzdGFydCA9IGJ1aWxkZXIucG9zLCBlbmQgPSBzdGFydCArIHRleHQubGVuZ3RoO1xuICAgICAgICBmb3IgKDsgOyApIHtcbiAgICAgICAgICB2YXIgcGFydCA9IHZvaWQgMDtcbiAgICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgb3JkZXIubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgICAgICBwYXJ0ID0gb3JkZXJbaTJdO1xuICAgICAgICAgICAgaWYgKHBhcnQudG8gPiBzdGFydCAmJiBwYXJ0LmZyb20gPD0gc3RhcnQpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYXJ0LnRvID49IGVuZCkge1xuICAgICAgICAgICAgcmV0dXJuIGlubmVyKGJ1aWxkZXIsIHRleHQsIHN0eWxlLCBzdGFydFN0eWxlLCBlbmRTdHlsZSwgY3NzLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5uZXIoYnVpbGRlciwgdGV4dC5zbGljZSgwLCBwYXJ0LnRvIC0gc3RhcnQpLCBzdHlsZSwgc3RhcnRTdHlsZSwgbnVsbCwgY3NzLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgICBzdGFydFN0eWxlID0gbnVsbDtcbiAgICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZShwYXJ0LnRvIC0gc3RhcnQpO1xuICAgICAgICAgIHN0YXJ0ID0gcGFydC50bztcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgX19uYW1lKGJ1aWxkVG9rZW5CYWRCaWRpLCBcImJ1aWxkVG9rZW5CYWRCaWRpXCIpO1xuICAgIGZ1bmN0aW9uIGJ1aWxkQ29sbGFwc2VkU3BhbihidWlsZGVyLCBzaXplLCBtYXJrZXIsIGlnbm9yZVdpZGdldCkge1xuICAgICAgdmFyIHdpZGdldCA9ICFpZ25vcmVXaWRnZXQgJiYgbWFya2VyLndpZGdldE5vZGU7XG4gICAgICBpZiAod2lkZ2V0KSB7XG4gICAgICAgIGJ1aWxkZXIubWFwLnB1c2goYnVpbGRlci5wb3MsIGJ1aWxkZXIucG9zICsgc2l6ZSwgd2lkZ2V0KTtcbiAgICAgIH1cbiAgICAgIGlmICghaWdub3JlV2lkZ2V0ICYmIGJ1aWxkZXIuY20uZGlzcGxheS5pbnB1dC5uZWVkc0NvbnRlbnRBdHRyaWJ1dGUpIHtcbiAgICAgICAgaWYgKCF3aWRnZXQpIHtcbiAgICAgICAgICB3aWRnZXQgPSBidWlsZGVyLmNvbnRlbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHdpZGdldC5zZXRBdHRyaWJ1dGUoXCJjbS1tYXJrZXJcIiwgbWFya2VyLmlkKTtcbiAgICAgIH1cbiAgICAgIGlmICh3aWRnZXQpIHtcbiAgICAgICAgYnVpbGRlci5jbS5kaXNwbGF5LmlucHV0LnNldFVuZWRpdGFibGUod2lkZ2V0KTtcbiAgICAgICAgYnVpbGRlci5jb250ZW50LmFwcGVuZENoaWxkKHdpZGdldCk7XG4gICAgICB9XG4gICAgICBidWlsZGVyLnBvcyArPSBzaXplO1xuICAgICAgYnVpbGRlci50cmFpbGluZ1NwYWNlID0gZmFsc2U7XG4gICAgfVxuICAgIF9fbmFtZShidWlsZENvbGxhcHNlZFNwYW4sIFwiYnVpbGRDb2xsYXBzZWRTcGFuXCIpO1xuICAgIGZ1bmN0aW9uIGluc2VydExpbmVDb250ZW50KGxpbmUsIGJ1aWxkZXIsIHN0eWxlcykge1xuICAgICAgdmFyIHNwYW5zID0gbGluZS5tYXJrZWRTcGFucywgYWxsVGV4dCA9IGxpbmUudGV4dCwgYXQgPSAwO1xuICAgICAgaWYgKCFzcGFucykge1xuICAgICAgICBmb3IgKHZhciBpJDEyID0gMTsgaSQxMiA8IHN0eWxlcy5sZW5ndGg7IGkkMTIgKz0gMikge1xuICAgICAgICAgIGJ1aWxkZXIuYWRkVG9rZW4oYnVpbGRlciwgYWxsVGV4dC5zbGljZShhdCwgYXQgPSBzdHlsZXNbaSQxMl0pLCBpbnRlcnByZXRUb2tlblN0eWxlKHN0eWxlc1tpJDEyICsgMV0sIGJ1aWxkZXIuY20ub3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBsZW4gPSBhbGxUZXh0Lmxlbmd0aCwgcG9zID0gMCwgaTIgPSAxLCB0ZXh0ID0gXCJcIiwgc3R5bGUsIGNzcztcbiAgICAgIHZhciBuZXh0Q2hhbmdlID0gMCwgc3BhblN0eWxlLCBzcGFuRW5kU3R5bGUsIHNwYW5TdGFydFN0eWxlLCBjb2xsYXBzZWQsIGF0dHJpYnV0ZXM7XG4gICAgICBmb3IgKDsgOyApIHtcbiAgICAgICAgaWYgKG5leHRDaGFuZ2UgPT0gcG9zKSB7XG4gICAgICAgICAgc3BhblN0eWxlID0gc3BhbkVuZFN0eWxlID0gc3BhblN0YXJ0U3R5bGUgPSBjc3MgPSBcIlwiO1xuICAgICAgICAgIGF0dHJpYnV0ZXMgPSBudWxsO1xuICAgICAgICAgIGNvbGxhcHNlZCA9IG51bGw7XG4gICAgICAgICAgbmV4dENoYW5nZSA9IEluZmluaXR5O1xuICAgICAgICAgIHZhciBmb3VuZEJvb2ttYXJrcyA9IFtdLCBlbmRTdHlsZXMgPSB2b2lkIDA7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzcGFucy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgdmFyIHNwID0gc3BhbnNbal0sIG0gPSBzcC5tYXJrZXI7XG4gICAgICAgICAgICBpZiAobS50eXBlID09IFwiYm9va21hcmtcIiAmJiBzcC5mcm9tID09IHBvcyAmJiBtLndpZGdldE5vZGUpIHtcbiAgICAgICAgICAgICAgZm91bmRCb29rbWFya3MucHVzaChtKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3AuZnJvbSA8PSBwb3MgJiYgKHNwLnRvID09IG51bGwgfHwgc3AudG8gPiBwb3MgfHwgbS5jb2xsYXBzZWQgJiYgc3AudG8gPT0gcG9zICYmIHNwLmZyb20gPT0gcG9zKSkge1xuICAgICAgICAgICAgICBpZiAoc3AudG8gIT0gbnVsbCAmJiBzcC50byAhPSBwb3MgJiYgbmV4dENoYW5nZSA+IHNwLnRvKSB7XG4gICAgICAgICAgICAgICAgbmV4dENoYW5nZSA9IHNwLnRvO1xuICAgICAgICAgICAgICAgIHNwYW5FbmRTdHlsZSA9IFwiXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG0uY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgc3BhblN0eWxlICs9IFwiIFwiICsgbS5jbGFzc05hbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG0uY3NzKSB7XG4gICAgICAgICAgICAgICAgY3NzID0gKGNzcyA/IGNzcyArIFwiO1wiIDogXCJcIikgKyBtLmNzcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobS5zdGFydFN0eWxlICYmIHNwLmZyb20gPT0gcG9zKSB7XG4gICAgICAgICAgICAgICAgc3BhblN0YXJ0U3R5bGUgKz0gXCIgXCIgKyBtLnN0YXJ0U3R5bGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG0uZW5kU3R5bGUgJiYgc3AudG8gPT0gbmV4dENoYW5nZSkge1xuICAgICAgICAgICAgICAgIChlbmRTdHlsZXMgfHwgKGVuZFN0eWxlcyA9IFtdKSkucHVzaChtLmVuZFN0eWxlLCBzcC50byk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG0udGl0bGUpIHtcbiAgICAgICAgICAgICAgICAoYXR0cmlidXRlcyB8fCAoYXR0cmlidXRlcyA9IHt9KSkudGl0bGUgPSBtLnRpdGxlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChtLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBhdHRyIGluIG0uYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgKGF0dHJpYnV0ZXMgfHwgKGF0dHJpYnV0ZXMgPSB7fSkpW2F0dHJdID0gbS5hdHRyaWJ1dGVzW2F0dHJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobS5jb2xsYXBzZWQgJiYgKCFjb2xsYXBzZWQgfHwgY29tcGFyZUNvbGxhcHNlZE1hcmtlcnMoY29sbGFwc2VkLm1hcmtlciwgbSkgPCAwKSkge1xuICAgICAgICAgICAgICAgIGNvbGxhcHNlZCA9IHNwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNwLmZyb20gPiBwb3MgJiYgbmV4dENoYW5nZSA+IHNwLmZyb20pIHtcbiAgICAgICAgICAgICAgbmV4dENoYW5nZSA9IHNwLmZyb207XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbmRTdHlsZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGokMSA9IDA7IGokMSA8IGVuZFN0eWxlcy5sZW5ndGg7IGokMSArPSAyKSB7XG4gICAgICAgICAgICAgIGlmIChlbmRTdHlsZXNbaiQxICsgMV0gPT0gbmV4dENoYW5nZSkge1xuICAgICAgICAgICAgICAgIHNwYW5FbmRTdHlsZSArPSBcIiBcIiArIGVuZFN0eWxlc1tqJDFdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghY29sbGFwc2VkIHx8IGNvbGxhcHNlZC5mcm9tID09IHBvcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiQyID0gMDsgaiQyIDwgZm91bmRCb29rbWFya3MubGVuZ3RoOyArK2okMikge1xuICAgICAgICAgICAgICBidWlsZENvbGxhcHNlZFNwYW4oYnVpbGRlciwgMCwgZm91bmRCb29rbWFya3NbaiQyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb2xsYXBzZWQgJiYgKGNvbGxhcHNlZC5mcm9tIHx8IDApID09IHBvcykge1xuICAgICAgICAgICAgYnVpbGRDb2xsYXBzZWRTcGFuKGJ1aWxkZXIsIChjb2xsYXBzZWQudG8gPT0gbnVsbCA/IGxlbiArIDEgOiBjb2xsYXBzZWQudG8pIC0gcG9zLCBjb2xsYXBzZWQubWFya2VyLCBjb2xsYXBzZWQuZnJvbSA9PSBudWxsKTtcbiAgICAgICAgICAgIGlmIChjb2xsYXBzZWQudG8gPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29sbGFwc2VkLnRvID09IHBvcykge1xuICAgICAgICAgICAgICBjb2xsYXBzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyA+PSBsZW4pIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXB0byA9IE1hdGgubWluKGxlbiwgbmV4dENoYW5nZSk7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICAgIHZhciBlbmQgPSBwb3MgKyB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmICghY29sbGFwc2VkKSB7XG4gICAgICAgICAgICAgIHZhciB0b2tlblRleHQgPSBlbmQgPiB1cHRvID8gdGV4dC5zbGljZSgwLCB1cHRvIC0gcG9zKSA6IHRleHQ7XG4gICAgICAgICAgICAgIGJ1aWxkZXIuYWRkVG9rZW4oYnVpbGRlciwgdG9rZW5UZXh0LCBzdHlsZSA/IHN0eWxlICsgc3BhblN0eWxlIDogc3BhblN0eWxlLCBzcGFuU3RhcnRTdHlsZSwgcG9zICsgdG9rZW5UZXh0Lmxlbmd0aCA9PSBuZXh0Q2hhbmdlID8gc3BhbkVuZFN0eWxlIDogXCJcIiwgY3NzLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbmQgPj0gdXB0bykge1xuICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZSh1cHRvIC0gcG9zKTtcbiAgICAgICAgICAgICAgcG9zID0gdXB0bztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgPSBlbmQ7XG4gICAgICAgICAgICBzcGFuU3RhcnRTdHlsZSA9IFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRleHQgPSBhbGxUZXh0LnNsaWNlKGF0LCBhdCA9IHN0eWxlc1tpMisrXSk7XG4gICAgICAgICAgc3R5bGUgPSBpbnRlcnByZXRUb2tlblN0eWxlKHN0eWxlc1tpMisrXSwgYnVpbGRlci5jbS5vcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoaW5zZXJ0TGluZUNvbnRlbnQsIFwiaW5zZXJ0TGluZUNvbnRlbnRcIik7XG4gICAgZnVuY3Rpb24gTGluZVZpZXcoZG9jLCBsaW5lLCBsaW5lTikge1xuICAgICAgdGhpcy5saW5lID0gbGluZTtcbiAgICAgIHRoaXMucmVzdCA9IHZpc3VhbExpbmVDb250aW51ZWQobGluZSk7XG4gICAgICB0aGlzLnNpemUgPSB0aGlzLnJlc3QgPyBsaW5lTm8obHN0KHRoaXMucmVzdCkpIC0gbGluZU4gKyAxIDogMTtcbiAgICAgIHRoaXMubm9kZSA9IHRoaXMudGV4dCA9IG51bGw7XG4gICAgICB0aGlzLmhpZGRlbiA9IGxpbmVJc0hpZGRlbihkb2MsIGxpbmUpO1xuICAgIH1cbiAgICBfX25hbWUoTGluZVZpZXcsIFwiTGluZVZpZXdcIik7XG4gICAgZnVuY3Rpb24gYnVpbGRWaWV3QXJyYXkoY20sIGZyb20sIHRvKSB7XG4gICAgICB2YXIgYXJyYXkgPSBbXSwgbmV4dFBvcztcbiAgICAgIGZvciAodmFyIHBvcyA9IGZyb207IHBvcyA8IHRvOyBwb3MgPSBuZXh0UG9zKSB7XG4gICAgICAgIHZhciB2aWV3ID0gbmV3IExpbmVWaWV3KGNtLmRvYywgZ2V0TGluZShjbS5kb2MsIHBvcyksIHBvcyk7XG4gICAgICAgIG5leHRQb3MgPSBwb3MgKyB2aWV3LnNpemU7XG4gICAgICAgIGFycmF5LnB1c2godmlldyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuICAgIF9fbmFtZShidWlsZFZpZXdBcnJheSwgXCJidWlsZFZpZXdBcnJheVwiKTtcbiAgICB2YXIgb3BlcmF0aW9uR3JvdXAgPSBudWxsO1xuICAgIGZ1bmN0aW9uIHB1c2hPcGVyYXRpb24ob3ApIHtcbiAgICAgIGlmIChvcGVyYXRpb25Hcm91cCkge1xuICAgICAgICBvcGVyYXRpb25Hcm91cC5vcHMucHVzaChvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcC5vd25zR3JvdXAgPSBvcGVyYXRpb25Hcm91cCA9IHtcbiAgICAgICAgICBvcHM6IFtvcF0sXG4gICAgICAgICAgZGVsYXllZENhbGxiYWNrczogW11cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKHB1c2hPcGVyYXRpb24sIFwicHVzaE9wZXJhdGlvblwiKTtcbiAgICBmdW5jdGlvbiBmaXJlQ2FsbGJhY2tzRm9yT3BzKGdyb3VwKSB7XG4gICAgICB2YXIgY2FsbGJhY2tzID0gZ3JvdXAuZGVsYXllZENhbGxiYWNrcywgaTIgPSAwO1xuICAgICAgZG8ge1xuICAgICAgICBmb3IgKDsgaTIgPCBjYWxsYmFja3MubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgICAgY2FsbGJhY2tzW2kyXS5jYWxsKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ3JvdXAub3BzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIG9wID0gZ3JvdXAub3BzW2pdO1xuICAgICAgICAgIGlmIChvcC5jdXJzb3JBY3Rpdml0eUhhbmRsZXJzKSB7XG4gICAgICAgICAgICB3aGlsZSAob3AuY3Vyc29yQWN0aXZpdHlDYWxsZWQgPCBvcC5jdXJzb3JBY3Rpdml0eUhhbmRsZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBvcC5jdXJzb3JBY3Rpdml0eUhhbmRsZXJzW29wLmN1cnNvckFjdGl2aXR5Q2FsbGVkKytdLmNhbGwobnVsbCwgb3AuY20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoaTIgPCBjYWxsYmFja3MubGVuZ3RoKTtcbiAgICB9XG4gICAgX19uYW1lKGZpcmVDYWxsYmFja3NGb3JPcHMsIFwiZmlyZUNhbGxiYWNrc0Zvck9wc1wiKTtcbiAgICBmdW5jdGlvbiBmaW5pc2hPcGVyYXRpb24ob3AsIGVuZENiKSB7XG4gICAgICB2YXIgZ3JvdXAgPSBvcC5vd25zR3JvdXA7XG4gICAgICBpZiAoIWdyb3VwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGZpcmVDYWxsYmFja3NGb3JPcHMoZ3JvdXApO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgb3BlcmF0aW9uR3JvdXAgPSBudWxsO1xuICAgICAgICBlbmRDYihncm91cCk7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShmaW5pc2hPcGVyYXRpb24sIFwiZmluaXNoT3BlcmF0aW9uXCIpO1xuICAgIHZhciBvcnBoYW5EZWxheWVkQ2FsbGJhY2tzID0gbnVsbDtcbiAgICBmdW5jdGlvbiBzaWduYWxMYXRlcihlbWl0dGVyLCB0eXBlKSB7XG4gICAgICB2YXIgYXJyID0gZ2V0SGFuZGxlcnMoZW1pdHRlciwgdHlwZSk7XG4gICAgICBpZiAoIWFyci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpLCBsaXN0O1xuICAgICAgaWYgKG9wZXJhdGlvbkdyb3VwKSB7XG4gICAgICAgIGxpc3QgPSBvcGVyYXRpb25Hcm91cC5kZWxheWVkQ2FsbGJhY2tzO1xuICAgICAgfSBlbHNlIGlmIChvcnBoYW5EZWxheWVkQ2FsbGJhY2tzKSB7XG4gICAgICAgIGxpc3QgPSBvcnBoYW5EZWxheWVkQ2FsbGJhY2tzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdCA9IG9ycGhhbkRlbGF5ZWRDYWxsYmFja3MgPSBbXTtcbiAgICAgICAgc2V0VGltZW91dChmaXJlT3JwaGFuRGVsYXllZCwgMCk7XG4gICAgICB9XG4gICAgICB2YXIgbG9vcCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24oaTMpIHtcbiAgICAgICAgbGlzdC5wdXNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBhcnJbaTNdLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICAgIH0sIFwibG9vcFwiKTtcbiAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBhcnIubGVuZ3RoOyArK2kyKVxuICAgICAgICBsb29wKGkyKTtcbiAgICB9XG4gICAgX19uYW1lKHNpZ25hbExhdGVyLCBcInNpZ25hbExhdGVyXCIpO1xuICAgIGZ1bmN0aW9uIGZpcmVPcnBoYW5EZWxheWVkKCkge1xuICAgICAgdmFyIGRlbGF5ZWQgPSBvcnBoYW5EZWxheWVkQ2FsbGJhY2tzO1xuICAgICAgb3JwaGFuRGVsYXllZENhbGxiYWNrcyA9IG51bGw7XG4gICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgZGVsYXllZC5sZW5ndGg7ICsraTIpIHtcbiAgICAgICAgZGVsYXllZFtpMl0oKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKGZpcmVPcnBoYW5EZWxheWVkLCBcImZpcmVPcnBoYW5EZWxheWVkXCIpO1xuICAgIGZ1bmN0aW9uIHVwZGF0ZUxpbmVGb3JDaGFuZ2VzKGNtLCBsaW5lVmlldywgbGluZU4sIGRpbXMpIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGluZVZpZXcuY2hhbmdlcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgdHlwZSA9IGxpbmVWaWV3LmNoYW5nZXNbal07XG4gICAgICAgIGlmICh0eXBlID09IFwidGV4dFwiKSB7XG4gICAgICAgICAgdXBkYXRlTGluZVRleHQoY20sIGxpbmVWaWV3KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09IFwiZ3V0dGVyXCIpIHtcbiAgICAgICAgICB1cGRhdGVMaW5lR3V0dGVyKGNtLCBsaW5lVmlldywgbGluZU4sIGRpbXMpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJjbGFzc1wiKSB7XG4gICAgICAgICAgdXBkYXRlTGluZUNsYXNzZXMoY20sIGxpbmVWaWV3KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09IFwid2lkZ2V0XCIpIHtcbiAgICAgICAgICB1cGRhdGVMaW5lV2lkZ2V0cyhjbSwgbGluZVZpZXcsIGRpbXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsaW5lVmlldy5jaGFuZ2VzID0gbnVsbDtcbiAgICB9XG4gICAgX19uYW1lKHVwZGF0ZUxpbmVGb3JDaGFuZ2VzLCBcInVwZGF0ZUxpbmVGb3JDaGFuZ2VzXCIpO1xuICAgIGZ1bmN0aW9uIGVuc3VyZUxpbmVXcmFwcGVkKGxpbmVWaWV3KSB7XG4gICAgICBpZiAobGluZVZpZXcubm9kZSA9PSBsaW5lVmlldy50ZXh0KSB7XG4gICAgICAgIGxpbmVWaWV3Lm5vZGUgPSBlbHQoXCJkaXZcIiwgbnVsbCwgbnVsbCwgXCJwb3NpdGlvbjogcmVsYXRpdmVcIik7XG4gICAgICAgIGlmIChsaW5lVmlldy50ZXh0LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBsaW5lVmlldy50ZXh0LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGxpbmVWaWV3Lm5vZGUsIGxpbmVWaWV3LnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGxpbmVWaWV3Lm5vZGUuYXBwZW5kQ2hpbGQobGluZVZpZXcudGV4dCk7XG4gICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOCkge1xuICAgICAgICAgIGxpbmVWaWV3Lm5vZGUuc3R5bGUuekluZGV4ID0gMjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGxpbmVWaWV3Lm5vZGU7XG4gICAgfVxuICAgIF9fbmFtZShlbnN1cmVMaW5lV3JhcHBlZCwgXCJlbnN1cmVMaW5lV3JhcHBlZFwiKTtcbiAgICBmdW5jdGlvbiB1cGRhdGVMaW5lQmFja2dyb3VuZChjbSwgbGluZVZpZXcpIHtcbiAgICAgIHZhciBjbHMgPSBsaW5lVmlldy5iZ0NsYXNzID8gbGluZVZpZXcuYmdDbGFzcyArIFwiIFwiICsgKGxpbmVWaWV3LmxpbmUuYmdDbGFzcyB8fCBcIlwiKSA6IGxpbmVWaWV3LmxpbmUuYmdDbGFzcztcbiAgICAgIGlmIChjbHMpIHtcbiAgICAgICAgY2xzICs9IFwiIENvZGVNaXJyb3ItbGluZWJhY2tncm91bmRcIjtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lVmlldy5iYWNrZ3JvdW5kKSB7XG4gICAgICAgIGlmIChjbHMpIHtcbiAgICAgICAgICBsaW5lVmlldy5iYWNrZ3JvdW5kLmNsYXNzTmFtZSA9IGNscztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaW5lVmlldy5iYWNrZ3JvdW5kLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobGluZVZpZXcuYmFja2dyb3VuZCk7XG4gICAgICAgICAgbGluZVZpZXcuYmFja2dyb3VuZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2xzKSB7XG4gICAgICAgIHZhciB3cmFwID0gZW5zdXJlTGluZVdyYXBwZWQobGluZVZpZXcpO1xuICAgICAgICBsaW5lVmlldy5iYWNrZ3JvdW5kID0gd3JhcC5pbnNlcnRCZWZvcmUoZWx0KFwiZGl2XCIsIG51bGwsIGNscyksIHdyYXAuZmlyc3RDaGlsZCk7XG4gICAgICAgIGNtLmRpc3BsYXkuaW5wdXQuc2V0VW5lZGl0YWJsZShsaW5lVmlldy5iYWNrZ3JvdW5kKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKHVwZGF0ZUxpbmVCYWNrZ3JvdW5kLCBcInVwZGF0ZUxpbmVCYWNrZ3JvdW5kXCIpO1xuICAgIGZ1bmN0aW9uIGdldExpbmVDb250ZW50KGNtLCBsaW5lVmlldykge1xuICAgICAgdmFyIGV4dCA9IGNtLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZDtcbiAgICAgIGlmIChleHQgJiYgZXh0LmxpbmUgPT0gbGluZVZpZXcubGluZSkge1xuICAgICAgICBjbS5kaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQgPSBudWxsO1xuICAgICAgICBsaW5lVmlldy5tZWFzdXJlID0gZXh0Lm1lYXN1cmU7XG4gICAgICAgIHJldHVybiBleHQuYnVpbHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRMaW5lQ29udGVudChjbSwgbGluZVZpZXcpO1xuICAgIH1cbiAgICBfX25hbWUoZ2V0TGluZUNvbnRlbnQsIFwiZ2V0TGluZUNvbnRlbnRcIik7XG4gICAgZnVuY3Rpb24gdXBkYXRlTGluZVRleHQoY20sIGxpbmVWaWV3KSB7XG4gICAgICB2YXIgY2xzID0gbGluZVZpZXcudGV4dC5jbGFzc05hbWU7XG4gICAgICB2YXIgYnVpbHQgPSBnZXRMaW5lQ29udGVudChjbSwgbGluZVZpZXcpO1xuICAgICAgaWYgKGxpbmVWaWV3LnRleHQgPT0gbGluZVZpZXcubm9kZSkge1xuICAgICAgICBsaW5lVmlldy5ub2RlID0gYnVpbHQucHJlO1xuICAgICAgfVxuICAgICAgbGluZVZpZXcudGV4dC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChidWlsdC5wcmUsIGxpbmVWaWV3LnRleHQpO1xuICAgICAgbGluZVZpZXcudGV4dCA9IGJ1aWx0LnByZTtcbiAgICAgIGlmIChidWlsdC5iZ0NsYXNzICE9IGxpbmVWaWV3LmJnQ2xhc3MgfHwgYnVpbHQudGV4dENsYXNzICE9IGxpbmVWaWV3LnRleHRDbGFzcykge1xuICAgICAgICBsaW5lVmlldy5iZ0NsYXNzID0gYnVpbHQuYmdDbGFzcztcbiAgICAgICAgbGluZVZpZXcudGV4dENsYXNzID0gYnVpbHQudGV4dENsYXNzO1xuICAgICAgICB1cGRhdGVMaW5lQ2xhc3NlcyhjbSwgbGluZVZpZXcpO1xuICAgICAgfSBlbHNlIGlmIChjbHMpIHtcbiAgICAgICAgbGluZVZpZXcudGV4dC5jbGFzc05hbWUgPSBjbHM7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZSh1cGRhdGVMaW5lVGV4dCwgXCJ1cGRhdGVMaW5lVGV4dFwiKTtcbiAgICBmdW5jdGlvbiB1cGRhdGVMaW5lQ2xhc3NlcyhjbSwgbGluZVZpZXcpIHtcbiAgICAgIHVwZGF0ZUxpbmVCYWNrZ3JvdW5kKGNtLCBsaW5lVmlldyk7XG4gICAgICBpZiAobGluZVZpZXcubGluZS53cmFwQ2xhc3MpIHtcbiAgICAgICAgZW5zdXJlTGluZVdyYXBwZWQobGluZVZpZXcpLmNsYXNzTmFtZSA9IGxpbmVWaWV3LmxpbmUud3JhcENsYXNzO1xuICAgICAgfSBlbHNlIGlmIChsaW5lVmlldy5ub2RlICE9IGxpbmVWaWV3LnRleHQpIHtcbiAgICAgICAgbGluZVZpZXcubm9kZS5jbGFzc05hbWUgPSBcIlwiO1xuICAgICAgfVxuICAgICAgdmFyIHRleHRDbGFzcyA9IGxpbmVWaWV3LnRleHRDbGFzcyA/IGxpbmVWaWV3LnRleHRDbGFzcyArIFwiIFwiICsgKGxpbmVWaWV3LmxpbmUudGV4dENsYXNzIHx8IFwiXCIpIDogbGluZVZpZXcubGluZS50ZXh0Q2xhc3M7XG4gICAgICBsaW5lVmlldy50ZXh0LmNsYXNzTmFtZSA9IHRleHRDbGFzcyB8fCBcIlwiO1xuICAgIH1cbiAgICBfX25hbWUodXBkYXRlTGluZUNsYXNzZXMsIFwidXBkYXRlTGluZUNsYXNzZXNcIik7XG4gICAgZnVuY3Rpb24gdXBkYXRlTGluZUd1dHRlcihjbSwgbGluZVZpZXcsIGxpbmVOLCBkaW1zKSB7XG4gICAgICBpZiAobGluZVZpZXcuZ3V0dGVyKSB7XG4gICAgICAgIGxpbmVWaWV3Lm5vZGUucmVtb3ZlQ2hpbGQobGluZVZpZXcuZ3V0dGVyKTtcbiAgICAgICAgbGluZVZpZXcuZ3V0dGVyID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lVmlldy5ndXR0ZXJCYWNrZ3JvdW5kKSB7XG4gICAgICAgIGxpbmVWaWV3Lm5vZGUucmVtb3ZlQ2hpbGQobGluZVZpZXcuZ3V0dGVyQmFja2dyb3VuZCk7XG4gICAgICAgIGxpbmVWaWV3Lmd1dHRlckJhY2tncm91bmQgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmVWaWV3LmxpbmUuZ3V0dGVyQ2xhc3MpIHtcbiAgICAgICAgdmFyIHdyYXAgPSBlbnN1cmVMaW5lV3JhcHBlZChsaW5lVmlldyk7XG4gICAgICAgIGxpbmVWaWV3Lmd1dHRlckJhY2tncm91bmQgPSBlbHQoXCJkaXZcIiwgbnVsbCwgXCJDb2RlTWlycm9yLWd1dHRlci1iYWNrZ3JvdW5kIFwiICsgbGluZVZpZXcubGluZS5ndXR0ZXJDbGFzcywgXCJsZWZ0OiBcIiArIChjbS5vcHRpb25zLmZpeGVkR3V0dGVyID8gZGltcy5maXhlZFBvcyA6IC1kaW1zLmd1dHRlclRvdGFsV2lkdGgpICsgXCJweDsgd2lkdGg6IFwiICsgZGltcy5ndXR0ZXJUb3RhbFdpZHRoICsgXCJweFwiKTtcbiAgICAgICAgY20uZGlzcGxheS5pbnB1dC5zZXRVbmVkaXRhYmxlKGxpbmVWaWV3Lmd1dHRlckJhY2tncm91bmQpO1xuICAgICAgICB3cmFwLmluc2VydEJlZm9yZShsaW5lVmlldy5ndXR0ZXJCYWNrZ3JvdW5kLCBsaW5lVmlldy50ZXh0KTtcbiAgICAgIH1cbiAgICAgIHZhciBtYXJrZXJzID0gbGluZVZpZXcubGluZS5ndXR0ZXJNYXJrZXJzO1xuICAgICAgaWYgKGNtLm9wdGlvbnMubGluZU51bWJlcnMgfHwgbWFya2Vycykge1xuICAgICAgICB2YXIgd3JhcCQxID0gZW5zdXJlTGluZVdyYXBwZWQobGluZVZpZXcpO1xuICAgICAgICB2YXIgZ3V0dGVyV3JhcCA9IGxpbmVWaWV3Lmd1dHRlciA9IGVsdChcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3ItZ3V0dGVyLXdyYXBwZXJcIiwgXCJsZWZ0OiBcIiArIChjbS5vcHRpb25zLmZpeGVkR3V0dGVyID8gZGltcy5maXhlZFBvcyA6IC1kaW1zLmd1dHRlclRvdGFsV2lkdGgpICsgXCJweFwiKTtcbiAgICAgICAgZ3V0dGVyV3JhcC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgICAgIGNtLmRpc3BsYXkuaW5wdXQuc2V0VW5lZGl0YWJsZShndXR0ZXJXcmFwKTtcbiAgICAgICAgd3JhcCQxLmluc2VydEJlZm9yZShndXR0ZXJXcmFwLCBsaW5lVmlldy50ZXh0KTtcbiAgICAgICAgaWYgKGxpbmVWaWV3LmxpbmUuZ3V0dGVyQ2xhc3MpIHtcbiAgICAgICAgICBndXR0ZXJXcmFwLmNsYXNzTmFtZSArPSBcIiBcIiArIGxpbmVWaWV3LmxpbmUuZ3V0dGVyQ2xhc3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNtLm9wdGlvbnMubGluZU51bWJlcnMgJiYgKCFtYXJrZXJzIHx8ICFtYXJrZXJzW1wiQ29kZU1pcnJvci1saW5lbnVtYmVyc1wiXSkpIHtcbiAgICAgICAgICBsaW5lVmlldy5saW5lTnVtYmVyID0gZ3V0dGVyV3JhcC5hcHBlbmRDaGlsZChlbHQoXCJkaXZcIiwgbGluZU51bWJlckZvcihjbS5vcHRpb25zLCBsaW5lTiksIFwiQ29kZU1pcnJvci1saW5lbnVtYmVyIENvZGVNaXJyb3ItZ3V0dGVyLWVsdFwiLCBcImxlZnQ6IFwiICsgZGltcy5ndXR0ZXJMZWZ0W1wiQ29kZU1pcnJvci1saW5lbnVtYmVyc1wiXSArIFwicHg7IHdpZHRoOiBcIiArIGNtLmRpc3BsYXkubGluZU51bUlubmVyV2lkdGggKyBcInB4XCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFya2Vycykge1xuICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgY20uZGlzcGxheS5ndXR0ZXJTcGVjcy5sZW5ndGg7ICsraykge1xuICAgICAgICAgICAgdmFyIGlkID0gY20uZGlzcGxheS5ndXR0ZXJTcGVjc1trXS5jbGFzc05hbWUsIGZvdW5kID0gbWFya2Vycy5oYXNPd25Qcm9wZXJ0eShpZCkgJiYgbWFya2Vyc1tpZF07XG4gICAgICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgICAgZ3V0dGVyV3JhcC5hcHBlbmRDaGlsZChlbHQoXCJkaXZcIiwgW2ZvdW5kXSwgXCJDb2RlTWlycm9yLWd1dHRlci1lbHRcIiwgXCJsZWZ0OiBcIiArIGRpbXMuZ3V0dGVyTGVmdFtpZF0gKyBcInB4OyB3aWR0aDogXCIgKyBkaW1zLmd1dHRlcldpZHRoW2lkXSArIFwicHhcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUodXBkYXRlTGluZUd1dHRlciwgXCJ1cGRhdGVMaW5lR3V0dGVyXCIpO1xuICAgIGZ1bmN0aW9uIHVwZGF0ZUxpbmVXaWRnZXRzKGNtLCBsaW5lVmlldywgZGltcykge1xuICAgICAgaWYgKGxpbmVWaWV3LmFsaWduYWJsZSkge1xuICAgICAgICBsaW5lVmlldy5hbGlnbmFibGUgPSBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIGlzV2lkZ2V0ID0gY2xhc3NUZXN0KFwiQ29kZU1pcnJvci1saW5ld2lkZ2V0XCIpO1xuICAgICAgZm9yICh2YXIgbm9kZSA9IGxpbmVWaWV3Lm5vZGUuZmlyc3RDaGlsZCwgbmV4dCA9IHZvaWQgMDsgbm9kZTsgbm9kZSA9IG5leHQpIHtcbiAgICAgICAgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIGlmIChpc1dpZGdldC50ZXN0KG5vZGUuY2xhc3NOYW1lKSkge1xuICAgICAgICAgIGxpbmVWaWV3Lm5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGluc2VydExpbmVXaWRnZXRzKGNtLCBsaW5lVmlldywgZGltcyk7XG4gICAgfVxuICAgIF9fbmFtZSh1cGRhdGVMaW5lV2lkZ2V0cywgXCJ1cGRhdGVMaW5lV2lkZ2V0c1wiKTtcbiAgICBmdW5jdGlvbiBidWlsZExpbmVFbGVtZW50KGNtLCBsaW5lVmlldywgbGluZU4sIGRpbXMpIHtcbiAgICAgIHZhciBidWlsdCA9IGdldExpbmVDb250ZW50KGNtLCBsaW5lVmlldyk7XG4gICAgICBsaW5lVmlldy50ZXh0ID0gbGluZVZpZXcubm9kZSA9IGJ1aWx0LnByZTtcbiAgICAgIGlmIChidWlsdC5iZ0NsYXNzKSB7XG4gICAgICAgIGxpbmVWaWV3LmJnQ2xhc3MgPSBidWlsdC5iZ0NsYXNzO1xuICAgICAgfVxuICAgICAgaWYgKGJ1aWx0LnRleHRDbGFzcykge1xuICAgICAgICBsaW5lVmlldy50ZXh0Q2xhc3MgPSBidWlsdC50ZXh0Q2xhc3M7XG4gICAgICB9XG4gICAgICB1cGRhdGVMaW5lQ2xhc3NlcyhjbSwgbGluZVZpZXcpO1xuICAgICAgdXBkYXRlTGluZUd1dHRlcihjbSwgbGluZVZpZXcsIGxpbmVOLCBkaW1zKTtcbiAgICAgIGluc2VydExpbmVXaWRnZXRzKGNtLCBsaW5lVmlldywgZGltcyk7XG4gICAgICByZXR1cm4gbGluZVZpZXcubm9kZTtcbiAgICB9XG4gICAgX19uYW1lKGJ1aWxkTGluZUVsZW1lbnQsIFwiYnVpbGRMaW5lRWxlbWVudFwiKTtcbiAgICBmdW5jdGlvbiBpbnNlcnRMaW5lV2lkZ2V0cyhjbSwgbGluZVZpZXcsIGRpbXMpIHtcbiAgICAgIGluc2VydExpbmVXaWRnZXRzRm9yKGNtLCBsaW5lVmlldy5saW5lLCBsaW5lVmlldywgZGltcywgdHJ1ZSk7XG4gICAgICBpZiAobGluZVZpZXcucmVzdCkge1xuICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgbGluZVZpZXcucmVzdC5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgICBpbnNlcnRMaW5lV2lkZ2V0c0ZvcihjbSwgbGluZVZpZXcucmVzdFtpMl0sIGxpbmVWaWV3LCBkaW1zLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKGluc2VydExpbmVXaWRnZXRzLCBcImluc2VydExpbmVXaWRnZXRzXCIpO1xuICAgIGZ1bmN0aW9uIGluc2VydExpbmVXaWRnZXRzRm9yKGNtLCBsaW5lLCBsaW5lVmlldywgZGltcywgYWxsb3dBYm92ZSkge1xuICAgICAgaWYgKCFsaW5lLndpZGdldHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHdyYXAgPSBlbnN1cmVMaW5lV3JhcHBlZChsaW5lVmlldyk7XG4gICAgICBmb3IgKHZhciBpMiA9IDAsIHdzID0gbGluZS53aWRnZXRzOyBpMiA8IHdzLmxlbmd0aDsgKytpMikge1xuICAgICAgICB2YXIgd2lkZ2V0ID0gd3NbaTJdLCBub2RlID0gZWx0KFwiZGl2XCIsIFt3aWRnZXQubm9kZV0sIFwiQ29kZU1pcnJvci1saW5ld2lkZ2V0XCIgKyAod2lkZ2V0LmNsYXNzTmFtZSA/IFwiIFwiICsgd2lkZ2V0LmNsYXNzTmFtZSA6IFwiXCIpKTtcbiAgICAgICAgaWYgKCF3aWRnZXQuaGFuZGxlTW91c2VFdmVudHMpIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcImNtLWlnbm9yZS1ldmVudHNcIiwgXCJ0cnVlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHBvc2l0aW9uTGluZVdpZGdldCh3aWRnZXQsIG5vZGUsIGxpbmVWaWV3LCBkaW1zKTtcbiAgICAgICAgY20uZGlzcGxheS5pbnB1dC5zZXRVbmVkaXRhYmxlKG5vZGUpO1xuICAgICAgICBpZiAoYWxsb3dBYm92ZSAmJiB3aWRnZXQuYWJvdmUpIHtcbiAgICAgICAgICB3cmFwLmluc2VydEJlZm9yZShub2RlLCBsaW5lVmlldy5ndXR0ZXIgfHwgbGluZVZpZXcudGV4dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd3JhcC5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBzaWduYWxMYXRlcih3aWRnZXQsIFwicmVkcmF3XCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoaW5zZXJ0TGluZVdpZGdldHNGb3IsIFwiaW5zZXJ0TGluZVdpZGdldHNGb3JcIik7XG4gICAgZnVuY3Rpb24gcG9zaXRpb25MaW5lV2lkZ2V0KHdpZGdldCwgbm9kZSwgbGluZVZpZXcsIGRpbXMpIHtcbiAgICAgIGlmICh3aWRnZXQubm9IU2Nyb2xsKSB7XG4gICAgICAgIChsaW5lVmlldy5hbGlnbmFibGUgfHwgKGxpbmVWaWV3LmFsaWduYWJsZSA9IFtdKSkucHVzaChub2RlKTtcbiAgICAgICAgdmFyIHdpZHRoID0gZGltcy53cmFwcGVyV2lkdGg7XG4gICAgICAgIG5vZGUuc3R5bGUubGVmdCA9IGRpbXMuZml4ZWRQb3MgKyBcInB4XCI7XG4gICAgICAgIGlmICghd2lkZ2V0LmNvdmVyR3V0dGVyKSB7XG4gICAgICAgICAgd2lkdGggLT0gZGltcy5ndXR0ZXJUb3RhbFdpZHRoO1xuICAgICAgICAgIG5vZGUuc3R5bGUucGFkZGluZ0xlZnQgPSBkaW1zLmd1dHRlclRvdGFsV2lkdGggKyBcInB4XCI7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5zdHlsZS53aWR0aCA9IHdpZHRoICsgXCJweFwiO1xuICAgICAgfVxuICAgICAgaWYgKHdpZGdldC5jb3Zlckd1dHRlcikge1xuICAgICAgICBub2RlLnN0eWxlLnpJbmRleCA9IDU7XG4gICAgICAgIG5vZGUuc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG4gICAgICAgIGlmICghd2lkZ2V0Lm5vSFNjcm9sbCkge1xuICAgICAgICAgIG5vZGUuc3R5bGUubWFyZ2luTGVmdCA9IC1kaW1zLmd1dHRlclRvdGFsV2lkdGggKyBcInB4XCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKHBvc2l0aW9uTGluZVdpZGdldCwgXCJwb3NpdGlvbkxpbmVXaWRnZXRcIik7XG4gICAgZnVuY3Rpb24gd2lkZ2V0SGVpZ2h0KHdpZGdldCkge1xuICAgICAgaWYgKHdpZGdldC5oZWlnaHQgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gd2lkZ2V0LmhlaWdodDtcbiAgICAgIH1cbiAgICAgIHZhciBjbSA9IHdpZGdldC5kb2MuY207XG4gICAgICBpZiAoIWNtKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgaWYgKCFjb250YWlucyhkb2N1bWVudC5ib2R5LCB3aWRnZXQubm9kZSkpIHtcbiAgICAgICAgdmFyIHBhcmVudFN0eWxlID0gXCJwb3NpdGlvbjogcmVsYXRpdmU7XCI7XG4gICAgICAgIGlmICh3aWRnZXQuY292ZXJHdXR0ZXIpIHtcbiAgICAgICAgICBwYXJlbnRTdHlsZSArPSBcIm1hcmdpbi1sZWZ0OiAtXCIgKyBjbS5kaXNwbGF5Lmd1dHRlcnMub2Zmc2V0V2lkdGggKyBcInB4O1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3aWRnZXQubm9IU2Nyb2xsKSB7XG4gICAgICAgICAgcGFyZW50U3R5bGUgKz0gXCJ3aWR0aDogXCIgKyBjbS5kaXNwbGF5LndyYXBwZXIuY2xpZW50V2lkdGggKyBcInB4O1wiO1xuICAgICAgICB9XG4gICAgICAgIHJlbW92ZUNoaWxkcmVuQW5kQWRkKGNtLmRpc3BsYXkubWVhc3VyZSwgZWx0KFwiZGl2XCIsIFt3aWRnZXQubm9kZV0sIG51bGwsIHBhcmVudFN0eWxlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2lkZ2V0LmhlaWdodCA9IHdpZGdldC5ub2RlLnBhcmVudE5vZGUub2Zmc2V0SGVpZ2h0O1xuICAgIH1cbiAgICBfX25hbWUod2lkZ2V0SGVpZ2h0LCBcIndpZGdldEhlaWdodFwiKTtcbiAgICBmdW5jdGlvbiBldmVudEluV2lkZ2V0KGRpc3BsYXksIGUpIHtcbiAgICAgIGZvciAodmFyIG4gPSBlX3RhcmdldChlKTsgbiAhPSBkaXNwbGF5LndyYXBwZXI7IG4gPSBuLnBhcmVudE5vZGUpIHtcbiAgICAgICAgaWYgKCFuIHx8IG4ubm9kZVR5cGUgPT0gMSAmJiBuLmdldEF0dHJpYnV0ZShcImNtLWlnbm9yZS1ldmVudHNcIikgPT0gXCJ0cnVlXCIgfHwgbi5wYXJlbnROb2RlID09IGRpc3BsYXkuc2l6ZXIgJiYgbiAhPSBkaXNwbGF5Lm1vdmVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKGV2ZW50SW5XaWRnZXQsIFwiZXZlbnRJbldpZGdldFwiKTtcbiAgICBmdW5jdGlvbiBwYWRkaW5nVG9wKGRpc3BsYXkpIHtcbiAgICAgIHJldHVybiBkaXNwbGF5LmxpbmVTcGFjZS5vZmZzZXRUb3A7XG4gICAgfVxuICAgIF9fbmFtZShwYWRkaW5nVG9wLCBcInBhZGRpbmdUb3BcIik7XG4gICAgZnVuY3Rpb24gcGFkZGluZ1ZlcnQoZGlzcGxheSkge1xuICAgICAgcmV0dXJuIGRpc3BsYXkubW92ZXIub2Zmc2V0SGVpZ2h0IC0gZGlzcGxheS5saW5lU3BhY2Uub2Zmc2V0SGVpZ2h0O1xuICAgIH1cbiAgICBfX25hbWUocGFkZGluZ1ZlcnQsIFwicGFkZGluZ1ZlcnRcIik7XG4gICAgZnVuY3Rpb24gcGFkZGluZ0goZGlzcGxheSkge1xuICAgICAgaWYgKGRpc3BsYXkuY2FjaGVkUGFkZGluZ0gpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BsYXkuY2FjaGVkUGFkZGluZ0g7XG4gICAgICB9XG4gICAgICB2YXIgZSA9IHJlbW92ZUNoaWxkcmVuQW5kQWRkKGRpc3BsYXkubWVhc3VyZSwgZWx0KFwicHJlXCIsIFwieFwiLCBcIkNvZGVNaXJyb3ItbGluZS1saWtlXCIpKTtcbiAgICAgIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlID8gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZSkgOiBlLmN1cnJlbnRTdHlsZTtcbiAgICAgIHZhciBkYXRhID0geyBsZWZ0OiBwYXJzZUludChzdHlsZS5wYWRkaW5nTGVmdCksIHJpZ2h0OiBwYXJzZUludChzdHlsZS5wYWRkaW5nUmlnaHQpIH07XG4gICAgICBpZiAoIWlzTmFOKGRhdGEubGVmdCkgJiYgIWlzTmFOKGRhdGEucmlnaHQpKSB7XG4gICAgICAgIGRpc3BsYXkuY2FjaGVkUGFkZGluZ0ggPSBkYXRhO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIF9fbmFtZShwYWRkaW5nSCwgXCJwYWRkaW5nSFwiKTtcbiAgICBmdW5jdGlvbiBzY3JvbGxHYXAoY20pIHtcbiAgICAgIHJldHVybiBzY3JvbGxlckdhcCAtIGNtLmRpc3BsYXkubmF0aXZlQmFyV2lkdGg7XG4gICAgfVxuICAgIF9fbmFtZShzY3JvbGxHYXAsIFwic2Nyb2xsR2FwXCIpO1xuICAgIGZ1bmN0aW9uIGRpc3BsYXlXaWR0aChjbSkge1xuICAgICAgcmV0dXJuIGNtLmRpc3BsYXkuc2Nyb2xsZXIuY2xpZW50V2lkdGggLSBzY3JvbGxHYXAoY20pIC0gY20uZGlzcGxheS5iYXJXaWR0aDtcbiAgICB9XG4gICAgX19uYW1lKGRpc3BsYXlXaWR0aCwgXCJkaXNwbGF5V2lkdGhcIik7XG4gICAgZnVuY3Rpb24gZGlzcGxheUhlaWdodChjbSkge1xuICAgICAgcmV0dXJuIGNtLmRpc3BsYXkuc2Nyb2xsZXIuY2xpZW50SGVpZ2h0IC0gc2Nyb2xsR2FwKGNtKSAtIGNtLmRpc3BsYXkuYmFySGVpZ2h0O1xuICAgIH1cbiAgICBfX25hbWUoZGlzcGxheUhlaWdodCwgXCJkaXNwbGF5SGVpZ2h0XCIpO1xuICAgIGZ1bmN0aW9uIGVuc3VyZUxpbmVIZWlnaHRzKGNtLCBsaW5lVmlldywgcmVjdCkge1xuICAgICAgdmFyIHdyYXBwaW5nID0gY20ub3B0aW9ucy5saW5lV3JhcHBpbmc7XG4gICAgICB2YXIgY3VyV2lkdGggPSB3cmFwcGluZyAmJiBkaXNwbGF5V2lkdGgoY20pO1xuICAgICAgaWYgKCFsaW5lVmlldy5tZWFzdXJlLmhlaWdodHMgfHwgd3JhcHBpbmcgJiYgbGluZVZpZXcubWVhc3VyZS53aWR0aCAhPSBjdXJXaWR0aCkge1xuICAgICAgICB2YXIgaGVpZ2h0cyA9IGxpbmVWaWV3Lm1lYXN1cmUuaGVpZ2h0cyA9IFtdO1xuICAgICAgICBpZiAod3JhcHBpbmcpIHtcbiAgICAgICAgICBsaW5lVmlldy5tZWFzdXJlLndpZHRoID0gY3VyV2lkdGg7XG4gICAgICAgICAgdmFyIHJlY3RzID0gbGluZVZpZXcudGV4dC5maXJzdENoaWxkLmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IHJlY3RzLmxlbmd0aCAtIDE7IGkyKyspIHtcbiAgICAgICAgICAgIHZhciBjdXIgPSByZWN0c1tpMl0sIG5leHQgPSByZWN0c1tpMiArIDFdO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGN1ci5ib3R0b20gLSBuZXh0LmJvdHRvbSkgPiAyKSB7XG4gICAgICAgICAgICAgIGhlaWdodHMucHVzaCgoY3VyLmJvdHRvbSArIG5leHQudG9wKSAvIDIgLSByZWN0LnRvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGhlaWdodHMucHVzaChyZWN0LmJvdHRvbSAtIHJlY3QudG9wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKGVuc3VyZUxpbmVIZWlnaHRzLCBcImVuc3VyZUxpbmVIZWlnaHRzXCIpO1xuICAgIGZ1bmN0aW9uIG1hcEZyb21MaW5lVmlldyhsaW5lVmlldywgbGluZSwgbGluZU4pIHtcbiAgICAgIGlmIChsaW5lVmlldy5saW5lID09IGxpbmUpIHtcbiAgICAgICAgcmV0dXJuIHsgbWFwOiBsaW5lVmlldy5tZWFzdXJlLm1hcCwgY2FjaGU6IGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGUgfTtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lVmlldy5yZXN0KSB7XG4gICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBsaW5lVmlldy5yZXN0Lmxlbmd0aDsgaTIrKykge1xuICAgICAgICAgIGlmIChsaW5lVmlldy5yZXN0W2kyXSA9PSBsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4geyBtYXA6IGxpbmVWaWV3Lm1lYXN1cmUubWFwc1tpMl0sIGNhY2hlOiBsaW5lVmlldy5tZWFzdXJlLmNhY2hlc1tpMl0gfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSQxMiA9IDA7IGkkMTIgPCBsaW5lVmlldy5yZXN0Lmxlbmd0aDsgaSQxMisrKSB7XG4gICAgICAgICAgaWYgKGxpbmVObyhsaW5lVmlldy5yZXN0W2kkMTJdKSA+IGxpbmVOKSB7XG4gICAgICAgICAgICByZXR1cm4geyBtYXA6IGxpbmVWaWV3Lm1lYXN1cmUubWFwc1tpJDEyXSwgY2FjaGU6IGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGVzW2kkMTJdLCBiZWZvcmU6IHRydWUgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKG1hcEZyb21MaW5lVmlldywgXCJtYXBGcm9tTGluZVZpZXdcIik7XG4gICAgZnVuY3Rpb24gdXBkYXRlRXh0ZXJuYWxNZWFzdXJlbWVudChjbSwgbGluZSkge1xuICAgICAgbGluZSA9IHZpc3VhbExpbmUobGluZSk7XG4gICAgICB2YXIgbGluZU4gPSBsaW5lTm8obGluZSk7XG4gICAgICB2YXIgdmlldyA9IGNtLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCA9IG5ldyBMaW5lVmlldyhjbS5kb2MsIGxpbmUsIGxpbmVOKTtcbiAgICAgIHZpZXcubGluZU4gPSBsaW5lTjtcbiAgICAgIHZhciBidWlsdCA9IHZpZXcuYnVpbHQgPSBidWlsZExpbmVDb250ZW50KGNtLCB2aWV3KTtcbiAgICAgIHZpZXcudGV4dCA9IGJ1aWx0LnByZTtcbiAgICAgIHJlbW92ZUNoaWxkcmVuQW5kQWRkKGNtLmRpc3BsYXkubGluZU1lYXN1cmUsIGJ1aWx0LnByZSk7XG4gICAgICByZXR1cm4gdmlldztcbiAgICB9XG4gICAgX19uYW1lKHVwZGF0ZUV4dGVybmFsTWVhc3VyZW1lbnQsIFwidXBkYXRlRXh0ZXJuYWxNZWFzdXJlbWVudFwiKTtcbiAgICBmdW5jdGlvbiBtZWFzdXJlQ2hhcihjbSwgbGluZSwgY2gsIGJpYXMpIHtcbiAgICAgIHJldHVybiBtZWFzdXJlQ2hhclByZXBhcmVkKGNtLCBwcmVwYXJlTWVhc3VyZUZvckxpbmUoY20sIGxpbmUpLCBjaCwgYmlhcyk7XG4gICAgfVxuICAgIF9fbmFtZShtZWFzdXJlQ2hhciwgXCJtZWFzdXJlQ2hhclwiKTtcbiAgICBmdW5jdGlvbiBmaW5kVmlld0ZvckxpbmUoY20sIGxpbmVOKSB7XG4gICAgICBpZiAobGluZU4gPj0gY20uZGlzcGxheS52aWV3RnJvbSAmJiBsaW5lTiA8IGNtLmRpc3BsYXkudmlld1RvKSB7XG4gICAgICAgIHJldHVybiBjbS5kaXNwbGF5LnZpZXdbZmluZFZpZXdJbmRleChjbSwgbGluZU4pXTtcbiAgICAgIH1cbiAgICAgIHZhciBleHQgPSBjbS5kaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQ7XG4gICAgICBpZiAoZXh0ICYmIGxpbmVOID49IGV4dC5saW5lTiAmJiBsaW5lTiA8IGV4dC5saW5lTiArIGV4dC5zaXplKSB7XG4gICAgICAgIHJldHVybiBleHQ7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShmaW5kVmlld0ZvckxpbmUsIFwiZmluZFZpZXdGb3JMaW5lXCIpO1xuICAgIGZ1bmN0aW9uIHByZXBhcmVNZWFzdXJlRm9yTGluZShjbSwgbGluZSkge1xuICAgICAgdmFyIGxpbmVOID0gbGluZU5vKGxpbmUpO1xuICAgICAgdmFyIHZpZXcgPSBmaW5kVmlld0ZvckxpbmUoY20sIGxpbmVOKTtcbiAgICAgIGlmICh2aWV3ICYmICF2aWV3LnRleHQpIHtcbiAgICAgICAgdmlldyA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKHZpZXcgJiYgdmlldy5jaGFuZ2VzKSB7XG4gICAgICAgIHVwZGF0ZUxpbmVGb3JDaGFuZ2VzKGNtLCB2aWV3LCBsaW5lTiwgZ2V0RGltZW5zaW9ucyhjbSkpO1xuICAgICAgICBjbS5jdXJPcC5mb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIXZpZXcpIHtcbiAgICAgICAgdmlldyA9IHVwZGF0ZUV4dGVybmFsTWVhc3VyZW1lbnQoY20sIGxpbmUpO1xuICAgICAgfVxuICAgICAgdmFyIGluZm8gPSBtYXBGcm9tTGluZVZpZXcodmlldywgbGluZSwgbGluZU4pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZSxcbiAgICAgICAgdmlldyxcbiAgICAgICAgcmVjdDogbnVsbCxcbiAgICAgICAgbWFwOiBpbmZvLm1hcCxcbiAgICAgICAgY2FjaGU6IGluZm8uY2FjaGUsXG4gICAgICAgIGJlZm9yZTogaW5mby5iZWZvcmUsXG4gICAgICAgIGhhc0hlaWdodHM6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICBfX25hbWUocHJlcGFyZU1lYXN1cmVGb3JMaW5lLCBcInByZXBhcmVNZWFzdXJlRm9yTGluZVwiKTtcbiAgICBmdW5jdGlvbiBtZWFzdXJlQ2hhclByZXBhcmVkKGNtLCBwcmVwYXJlZCwgY2gsIGJpYXMsIHZhckhlaWdodCkge1xuICAgICAgaWYgKHByZXBhcmVkLmJlZm9yZSkge1xuICAgICAgICBjaCA9IC0xO1xuICAgICAgfVxuICAgICAgdmFyIGtleSA9IGNoICsgKGJpYXMgfHwgXCJcIiksIGZvdW5kO1xuICAgICAgaWYgKHByZXBhcmVkLmNhY2hlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgZm91bmQgPSBwcmVwYXJlZC5jYWNoZVtrZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFwcmVwYXJlZC5yZWN0KSB7XG4gICAgICAgICAgcHJlcGFyZWQucmVjdCA9IHByZXBhcmVkLnZpZXcudGV4dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXByZXBhcmVkLmhhc0hlaWdodHMpIHtcbiAgICAgICAgICBlbnN1cmVMaW5lSGVpZ2h0cyhjbSwgcHJlcGFyZWQudmlldywgcHJlcGFyZWQucmVjdCk7XG4gICAgICAgICAgcHJlcGFyZWQuaGFzSGVpZ2h0cyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZm91bmQgPSBtZWFzdXJlQ2hhcklubmVyKGNtLCBwcmVwYXJlZCwgY2gsIGJpYXMpO1xuICAgICAgICBpZiAoIWZvdW5kLmJvZ3VzKSB7XG4gICAgICAgICAgcHJlcGFyZWQuY2FjaGVba2V5XSA9IGZvdW5kO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBmb3VuZC5sZWZ0LFxuICAgICAgICByaWdodDogZm91bmQucmlnaHQsXG4gICAgICAgIHRvcDogdmFySGVpZ2h0ID8gZm91bmQucnRvcCA6IGZvdW5kLnRvcCxcbiAgICAgICAgYm90dG9tOiB2YXJIZWlnaHQgPyBmb3VuZC5yYm90dG9tIDogZm91bmQuYm90dG9tXG4gICAgICB9O1xuICAgIH1cbiAgICBfX25hbWUobWVhc3VyZUNoYXJQcmVwYXJlZCwgXCJtZWFzdXJlQ2hhclByZXBhcmVkXCIpO1xuICAgIHZhciBudWxsUmVjdCA9IHsgbGVmdDogMCwgcmlnaHQ6IDAsIHRvcDogMCwgYm90dG9tOiAwIH07XG4gICAgZnVuY3Rpb24gbm9kZUFuZE9mZnNldEluTGluZU1hcChtYXAyLCBjaCwgYmlhcykge1xuICAgICAgdmFyIG5vZGUsIHN0YXJ0LCBlbmQsIGNvbGxhcHNlLCBtU3RhcnQsIG1FbmQ7XG4gICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgbWFwMi5sZW5ndGg7IGkyICs9IDMpIHtcbiAgICAgICAgbVN0YXJ0ID0gbWFwMltpMl07XG4gICAgICAgIG1FbmQgPSBtYXAyW2kyICsgMV07XG4gICAgICAgIGlmIChjaCA8IG1TdGFydCkge1xuICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgICBlbmQgPSAxO1xuICAgICAgICAgIGNvbGxhcHNlID0gXCJsZWZ0XCI7XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPCBtRW5kKSB7XG4gICAgICAgICAgc3RhcnQgPSBjaCAtIG1TdGFydDtcbiAgICAgICAgICBlbmQgPSBzdGFydCArIDE7XG4gICAgICAgIH0gZWxzZSBpZiAoaTIgPT0gbWFwMi5sZW5ndGggLSAzIHx8IGNoID09IG1FbmQgJiYgbWFwMltpMiArIDNdID4gY2gpIHtcbiAgICAgICAgICBlbmQgPSBtRW5kIC0gbVN0YXJ0O1xuICAgICAgICAgIHN0YXJ0ID0gZW5kIC0gMTtcbiAgICAgICAgICBpZiAoY2ggPj0gbUVuZCkge1xuICAgICAgICAgICAgY29sbGFwc2UgPSBcInJpZ2h0XCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCAhPSBudWxsKSB7XG4gICAgICAgICAgbm9kZSA9IG1hcDJbaTIgKyAyXTtcbiAgICAgICAgICBpZiAobVN0YXJ0ID09IG1FbmQgJiYgYmlhcyA9PSAobm9kZS5pbnNlcnRMZWZ0ID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIpKSB7XG4gICAgICAgICAgICBjb2xsYXBzZSA9IGJpYXM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChiaWFzID09IFwibGVmdFwiICYmIHN0YXJ0ID09IDApIHtcbiAgICAgICAgICAgIHdoaWxlIChpMiAmJiBtYXAyW2kyIC0gMl0gPT0gbWFwMltpMiAtIDNdICYmIG1hcDJbaTIgLSAxXS5pbnNlcnRMZWZ0KSB7XG4gICAgICAgICAgICAgIG5vZGUgPSBtYXAyWyhpMiAtPSAzKSArIDJdO1xuICAgICAgICAgICAgICBjb2xsYXBzZSA9IFwibGVmdFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYmlhcyA9PSBcInJpZ2h0XCIgJiYgc3RhcnQgPT0gbUVuZCAtIG1TdGFydCkge1xuICAgICAgICAgICAgd2hpbGUgKGkyIDwgbWFwMi5sZW5ndGggLSAzICYmIG1hcDJbaTIgKyAzXSA9PSBtYXAyW2kyICsgNF0gJiYgIW1hcDJbaTIgKyA1XS5pbnNlcnRMZWZ0KSB7XG4gICAgICAgICAgICAgIG5vZGUgPSBtYXAyWyhpMiArPSAzKSArIDJdO1xuICAgICAgICAgICAgICBjb2xsYXBzZSA9IFwicmlnaHRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7IG5vZGUsIHN0YXJ0LCBlbmQsIGNvbGxhcHNlLCBjb3ZlclN0YXJ0OiBtU3RhcnQsIGNvdmVyRW5kOiBtRW5kIH07XG4gICAgfVxuICAgIF9fbmFtZShub2RlQW5kT2Zmc2V0SW5MaW5lTWFwLCBcIm5vZGVBbmRPZmZzZXRJbkxpbmVNYXBcIik7XG4gICAgZnVuY3Rpb24gZ2V0VXNlZnVsUmVjdChyZWN0cywgYmlhcykge1xuICAgICAgdmFyIHJlY3QgPSBudWxsUmVjdDtcbiAgICAgIGlmIChiaWFzID09IFwibGVmdFwiKSB7XG4gICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCByZWN0cy5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgICBpZiAoKHJlY3QgPSByZWN0c1tpMl0pLmxlZnQgIT0gcmVjdC5yaWdodCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpJDEyID0gcmVjdHMubGVuZ3RoIC0gMTsgaSQxMiA+PSAwOyBpJDEyLS0pIHtcbiAgICAgICAgICBpZiAoKHJlY3QgPSByZWN0c1tpJDEyXSkubGVmdCAhPSByZWN0LnJpZ2h0KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZWN0O1xuICAgIH1cbiAgICBfX25hbWUoZ2V0VXNlZnVsUmVjdCwgXCJnZXRVc2VmdWxSZWN0XCIpO1xuICAgIGZ1bmN0aW9uIG1lYXN1cmVDaGFySW5uZXIoY20sIHByZXBhcmVkLCBjaCwgYmlhcykge1xuICAgICAgdmFyIHBsYWNlID0gbm9kZUFuZE9mZnNldEluTGluZU1hcChwcmVwYXJlZC5tYXAsIGNoLCBiaWFzKTtcbiAgICAgIHZhciBub2RlID0gcGxhY2Uubm9kZSwgc3RhcnQgPSBwbGFjZS5zdGFydCwgZW5kID0gcGxhY2UuZW5kLCBjb2xsYXBzZSA9IHBsYWNlLmNvbGxhcHNlO1xuICAgICAgdmFyIHJlY3Q7XG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICAgIGZvciAodmFyIGkkMTIgPSAwOyBpJDEyIDwgNDsgaSQxMisrKSB7XG4gICAgICAgICAgd2hpbGUgKHN0YXJ0ICYmIGlzRXh0ZW5kaW5nQ2hhcihwcmVwYXJlZC5saW5lLnRleHQuY2hhckF0KHBsYWNlLmNvdmVyU3RhcnQgKyBzdGFydCkpKSB7XG4gICAgICAgICAgICAtLXN0YXJ0O1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAocGxhY2UuY292ZXJTdGFydCArIGVuZCA8IHBsYWNlLmNvdmVyRW5kICYmIGlzRXh0ZW5kaW5nQ2hhcihwcmVwYXJlZC5saW5lLnRleHQuY2hhckF0KHBsYWNlLmNvdmVyU3RhcnQgKyBlbmQpKSkge1xuICAgICAgICAgICAgKytlbmQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOSAmJiBzdGFydCA9PSAwICYmIGVuZCA9PSBwbGFjZS5jb3ZlckVuZCAtIHBsYWNlLmNvdmVyU3RhcnQpIHtcbiAgICAgICAgICAgIHJlY3QgPSBub2RlLnBhcmVudE5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlY3QgPSBnZXRVc2VmdWxSZWN0KHJhbmdlKG5vZGUsIHN0YXJ0LCBlbmQpLmdldENsaWVudFJlY3RzKCksIGJpYXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVjdC5sZWZ0IHx8IHJlY3QucmlnaHQgfHwgc3RhcnQgPT0gMCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICAgIHN0YXJ0ID0gc3RhcnQgLSAxO1xuICAgICAgICAgIGNvbGxhcHNlID0gXCJyaWdodFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgMTEpIHtcbiAgICAgICAgICByZWN0ID0gbWF5YmVVcGRhdGVSZWN0Rm9yWm9vbWluZyhjbS5kaXNwbGF5Lm1lYXN1cmUsIHJlY3QpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc3RhcnQgPiAwKSB7XG4gICAgICAgICAgY29sbGFwc2UgPSBiaWFzID0gXCJyaWdodFwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWN0cztcbiAgICAgICAgaWYgKGNtLm9wdGlvbnMubGluZVdyYXBwaW5nICYmIChyZWN0cyA9IG5vZGUuZ2V0Q2xpZW50UmVjdHMoKSkubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHJlY3QgPSByZWN0c1tiaWFzID09IFwicmlnaHRcIiA/IHJlY3RzLmxlbmd0aCAtIDEgOiAwXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCA5ICYmICFzdGFydCAmJiAoIXJlY3QgfHwgIXJlY3QubGVmdCAmJiAhcmVjdC5yaWdodCkpIHtcbiAgICAgICAgdmFyIHJTcGFuID0gbm9kZS5wYXJlbnROb2RlLmdldENsaWVudFJlY3RzKClbMF07XG4gICAgICAgIGlmIChyU3Bhbikge1xuICAgICAgICAgIHJlY3QgPSB7IGxlZnQ6IHJTcGFuLmxlZnQsIHJpZ2h0OiByU3Bhbi5sZWZ0ICsgY2hhcldpZHRoKGNtLmRpc3BsYXkpLCB0b3A6IHJTcGFuLnRvcCwgYm90dG9tOiByU3Bhbi5ib3R0b20gfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWN0ID0gbnVsbFJlY3Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBydG9wID0gcmVjdC50b3AgLSBwcmVwYXJlZC5yZWN0LnRvcCwgcmJvdCA9IHJlY3QuYm90dG9tIC0gcHJlcGFyZWQucmVjdC50b3A7XG4gICAgICB2YXIgbWlkID0gKHJ0b3AgKyByYm90KSAvIDI7XG4gICAgICB2YXIgaGVpZ2h0cyA9IHByZXBhcmVkLnZpZXcubWVhc3VyZS5oZWlnaHRzO1xuICAgICAgdmFyIGkyID0gMDtcbiAgICAgIGZvciAoOyBpMiA8IGhlaWdodHMubGVuZ3RoIC0gMTsgaTIrKykge1xuICAgICAgICBpZiAobWlkIDwgaGVpZ2h0c1tpMl0pIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHRvcCA9IGkyID8gaGVpZ2h0c1tpMiAtIDFdIDogMCwgYm90ID0gaGVpZ2h0c1tpMl07XG4gICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICBsZWZ0OiAoY29sbGFwc2UgPT0gXCJyaWdodFwiID8gcmVjdC5yaWdodCA6IHJlY3QubGVmdCkgLSBwcmVwYXJlZC5yZWN0LmxlZnQsXG4gICAgICAgIHJpZ2h0OiAoY29sbGFwc2UgPT0gXCJsZWZ0XCIgPyByZWN0LmxlZnQgOiByZWN0LnJpZ2h0KSAtIHByZXBhcmVkLnJlY3QubGVmdCxcbiAgICAgICAgdG9wLFxuICAgICAgICBib3R0b206IGJvdFxuICAgICAgfTtcbiAgICAgIGlmICghcmVjdC5sZWZ0ICYmICFyZWN0LnJpZ2h0KSB7XG4gICAgICAgIHJlc3VsdC5ib2d1cyA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIWNtLm9wdGlvbnMuc2luZ2xlQ3Vyc29ySGVpZ2h0UGVyTGluZSkge1xuICAgICAgICByZXN1bHQucnRvcCA9IHJ0b3A7XG4gICAgICAgIHJlc3VsdC5yYm90dG9tID0gcmJvdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIF9fbmFtZShtZWFzdXJlQ2hhcklubmVyLCBcIm1lYXN1cmVDaGFySW5uZXJcIik7XG4gICAgZnVuY3Rpb24gbWF5YmVVcGRhdGVSZWN0Rm9yWm9vbWluZyhtZWFzdXJlLCByZWN0KSB7XG4gICAgICBpZiAoIXdpbmRvdy5zY3JlZW4gfHwgc2NyZWVuLmxvZ2ljYWxYRFBJID09IG51bGwgfHwgc2NyZWVuLmxvZ2ljYWxYRFBJID09IHNjcmVlbi5kZXZpY2VYRFBJIHx8ICFoYXNCYWRab29tZWRSZWN0cyhtZWFzdXJlKSkge1xuICAgICAgICByZXR1cm4gcmVjdDtcbiAgICAgIH1cbiAgICAgIHZhciBzY2FsZVggPSBzY3JlZW4ubG9naWNhbFhEUEkgLyBzY3JlZW4uZGV2aWNlWERQSTtcbiAgICAgIHZhciBzY2FsZVkgPSBzY3JlZW4ubG9naWNhbFlEUEkgLyBzY3JlZW4uZGV2aWNlWURQSTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IHJlY3QubGVmdCAqIHNjYWxlWCxcbiAgICAgICAgcmlnaHQ6IHJlY3QucmlnaHQgKiBzY2FsZVgsXG4gICAgICAgIHRvcDogcmVjdC50b3AgKiBzY2FsZVksXG4gICAgICAgIGJvdHRvbTogcmVjdC5ib3R0b20gKiBzY2FsZVlcbiAgICAgIH07XG4gICAgfVxuICAgIF9fbmFtZShtYXliZVVwZGF0ZVJlY3RGb3Jab29taW5nLCBcIm1heWJlVXBkYXRlUmVjdEZvclpvb21pbmdcIik7XG4gICAgZnVuY3Rpb24gY2xlYXJMaW5lTWVhc3VyZW1lbnRDYWNoZUZvcihsaW5lVmlldykge1xuICAgICAgaWYgKGxpbmVWaWV3Lm1lYXN1cmUpIHtcbiAgICAgICAgbGluZVZpZXcubWVhc3VyZS5jYWNoZSA9IHt9O1xuICAgICAgICBsaW5lVmlldy5tZWFzdXJlLmhlaWdodHMgPSBudWxsO1xuICAgICAgICBpZiAobGluZVZpZXcucmVzdCkge1xuICAgICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBsaW5lVmlldy5yZXN0Lmxlbmd0aDsgaTIrKykge1xuICAgICAgICAgICAgbGluZVZpZXcubWVhc3VyZS5jYWNoZXNbaTJdID0ge307XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShjbGVhckxpbmVNZWFzdXJlbWVudENhY2hlRm9yLCBcImNsZWFyTGluZU1lYXN1cmVtZW50Q2FjaGVGb3JcIik7XG4gICAgZnVuY3Rpb24gY2xlYXJMaW5lTWVhc3VyZW1lbnRDYWNoZShjbSkge1xuICAgICAgY20uZGlzcGxheS5leHRlcm5hbE1lYXN1cmUgPSBudWxsO1xuICAgICAgcmVtb3ZlQ2hpbGRyZW4oY20uZGlzcGxheS5saW5lTWVhc3VyZSk7XG4gICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgY20uZGlzcGxheS52aWV3Lmxlbmd0aDsgaTIrKykge1xuICAgICAgICBjbGVhckxpbmVNZWFzdXJlbWVudENhY2hlRm9yKGNtLmRpc3BsYXkudmlld1tpMl0pO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoY2xlYXJMaW5lTWVhc3VyZW1lbnRDYWNoZSwgXCJjbGVhckxpbmVNZWFzdXJlbWVudENhY2hlXCIpO1xuICAgIGZ1bmN0aW9uIGNsZWFyQ2FjaGVzKGNtKSB7XG4gICAgICBjbGVhckxpbmVNZWFzdXJlbWVudENhY2hlKGNtKTtcbiAgICAgIGNtLmRpc3BsYXkuY2FjaGVkQ2hhcldpZHRoID0gY20uZGlzcGxheS5jYWNoZWRUZXh0SGVpZ2h0ID0gY20uZGlzcGxheS5jYWNoZWRQYWRkaW5nSCA9IG51bGw7XG4gICAgICBpZiAoIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7XG4gICAgICAgIGNtLmRpc3BsYXkubWF4TGluZUNoYW5nZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY20uZGlzcGxheS5saW5lTnVtQ2hhcnMgPSBudWxsO1xuICAgIH1cbiAgICBfX25hbWUoY2xlYXJDYWNoZXMsIFwiY2xlYXJDYWNoZXNcIik7XG4gICAgZnVuY3Rpb24gcGFnZVNjcm9sbFgoKSB7XG4gICAgICBpZiAoY2hyb21lICYmIGFuZHJvaWQpIHtcbiAgICAgICAgcmV0dXJuIC0oZG9jdW1lbnQuYm9keS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC0gcGFyc2VJbnQoZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5ib2R5KS5tYXJnaW5MZWZ0KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2luZG93LnBhZ2VYT2Zmc2V0IHx8IChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keSkuc2Nyb2xsTGVmdDtcbiAgICB9XG4gICAgX19uYW1lKHBhZ2VTY3JvbGxYLCBcInBhZ2VTY3JvbGxYXCIpO1xuICAgIGZ1bmN0aW9uIHBhZ2VTY3JvbGxZKCkge1xuICAgICAgaWYgKGNocm9tZSAmJiBhbmRyb2lkKSB7XG4gICAgICAgIHJldHVybiAtKGRvY3VtZW50LmJvZHkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wIC0gcGFyc2VJbnQoZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5ib2R5KS5tYXJnaW5Ub3ApKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3aW5kb3cucGFnZVlPZmZzZXQgfHwgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCBkb2N1bWVudC5ib2R5KS5zY3JvbGxUb3A7XG4gICAgfVxuICAgIF9fbmFtZShwYWdlU2Nyb2xsWSwgXCJwYWdlU2Nyb2xsWVwiKTtcbiAgICBmdW5jdGlvbiB3aWRnZXRUb3BIZWlnaHQobGluZU9iaikge1xuICAgICAgdmFyIHJlZiA9IHZpc3VhbExpbmUobGluZU9iaik7XG4gICAgICB2YXIgd2lkZ2V0cyA9IHJlZi53aWRnZXRzO1xuICAgICAgdmFyIGhlaWdodCA9IDA7XG4gICAgICBpZiAod2lkZ2V0cykge1xuICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgd2lkZ2V0cy5sZW5ndGg7ICsraTIpIHtcbiAgICAgICAgICBpZiAod2lkZ2V0c1tpMl0uYWJvdmUpIHtcbiAgICAgICAgICAgIGhlaWdodCArPSB3aWRnZXRIZWlnaHQod2lkZ2V0c1tpMl0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICB9XG4gICAgX19uYW1lKHdpZGdldFRvcEhlaWdodCwgXCJ3aWRnZXRUb3BIZWlnaHRcIik7XG4gICAgZnVuY3Rpb24gaW50b0Nvb3JkU3lzdGVtKGNtLCBsaW5lT2JqLCByZWN0LCBjb250ZXh0LCBpbmNsdWRlV2lkZ2V0cykge1xuICAgICAgaWYgKCFpbmNsdWRlV2lkZ2V0cykge1xuICAgICAgICB2YXIgaGVpZ2h0ID0gd2lkZ2V0VG9wSGVpZ2h0KGxpbmVPYmopO1xuICAgICAgICByZWN0LnRvcCArPSBoZWlnaHQ7XG4gICAgICAgIHJlY3QuYm90dG9tICs9IGhlaWdodDtcbiAgICAgIH1cbiAgICAgIGlmIChjb250ZXh0ID09IFwibGluZVwiKSB7XG4gICAgICAgIHJldHVybiByZWN0O1xuICAgICAgfVxuICAgICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQgPSBcImxvY2FsXCI7XG4gICAgICB9XG4gICAgICB2YXIgeU9mZiA9IGhlaWdodEF0TGluZShsaW5lT2JqKTtcbiAgICAgIGlmIChjb250ZXh0ID09IFwibG9jYWxcIikge1xuICAgICAgICB5T2ZmICs9IHBhZGRpbmdUb3AoY20uZGlzcGxheSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5T2ZmIC09IGNtLmRpc3BsYXkudmlld09mZnNldDtcbiAgICAgIH1cbiAgICAgIGlmIChjb250ZXh0ID09IFwicGFnZVwiIHx8IGNvbnRleHQgPT0gXCJ3aW5kb3dcIikge1xuICAgICAgICB2YXIgbE9mZiA9IGNtLmRpc3BsYXkubGluZVNwYWNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB5T2ZmICs9IGxPZmYudG9wICsgKGNvbnRleHQgPT0gXCJ3aW5kb3dcIiA/IDAgOiBwYWdlU2Nyb2xsWSgpKTtcbiAgICAgICAgdmFyIHhPZmYgPSBsT2ZmLmxlZnQgKyAoY29udGV4dCA9PSBcIndpbmRvd1wiID8gMCA6IHBhZ2VTY3JvbGxYKCkpO1xuICAgICAgICByZWN0LmxlZnQgKz0geE9mZjtcbiAgICAgICAgcmVjdC5yaWdodCArPSB4T2ZmO1xuICAgICAgfVxuICAgICAgcmVjdC50b3AgKz0geU9mZjtcbiAgICAgIHJlY3QuYm90dG9tICs9IHlPZmY7XG4gICAgICByZXR1cm4gcmVjdDtcbiAgICB9XG4gICAgX19uYW1lKGludG9Db29yZFN5c3RlbSwgXCJpbnRvQ29vcmRTeXN0ZW1cIik7XG4gICAgZnVuY3Rpb24gZnJvbUNvb3JkU3lzdGVtKGNtLCBjb29yZHMsIGNvbnRleHQpIHtcbiAgICAgIGlmIChjb250ZXh0ID09IFwiZGl2XCIpIHtcbiAgICAgICAgcmV0dXJuIGNvb3JkcztcbiAgICAgIH1cbiAgICAgIHZhciBsZWZ0ID0gY29vcmRzLmxlZnQsIHRvcCA9IGNvb3Jkcy50b3A7XG4gICAgICBpZiAoY29udGV4dCA9PSBcInBhZ2VcIikge1xuICAgICAgICBsZWZ0IC09IHBhZ2VTY3JvbGxYKCk7XG4gICAgICAgIHRvcCAtPSBwYWdlU2Nyb2xsWSgpO1xuICAgICAgfSBlbHNlIGlmIChjb250ZXh0ID09IFwibG9jYWxcIiB8fCAhY29udGV4dCkge1xuICAgICAgICB2YXIgbG9jYWxCb3ggPSBjbS5kaXNwbGF5LnNpemVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsZWZ0ICs9IGxvY2FsQm94LmxlZnQ7XG4gICAgICAgIHRvcCArPSBsb2NhbEJveC50b3A7XG4gICAgICB9XG4gICAgICB2YXIgbGluZVNwYWNlQm94ID0gY20uZGlzcGxheS5saW5lU3BhY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICByZXR1cm4geyBsZWZ0OiBsZWZ0IC0gbGluZVNwYWNlQm94LmxlZnQsIHRvcDogdG9wIC0gbGluZVNwYWNlQm94LnRvcCB9O1xuICAgIH1cbiAgICBfX25hbWUoZnJvbUNvb3JkU3lzdGVtLCBcImZyb21Db29yZFN5c3RlbVwiKTtcbiAgICBmdW5jdGlvbiBjaGFyQ29vcmRzKGNtLCBwb3MsIGNvbnRleHQsIGxpbmVPYmosIGJpYXMpIHtcbiAgICAgIGlmICghbGluZU9iaikge1xuICAgICAgICBsaW5lT2JqID0gZ2V0TGluZShjbS5kb2MsIHBvcy5saW5lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnRvQ29vcmRTeXN0ZW0oY20sIGxpbmVPYmosIG1lYXN1cmVDaGFyKGNtLCBsaW5lT2JqLCBwb3MuY2gsIGJpYXMpLCBjb250ZXh0KTtcbiAgICB9XG4gICAgX19uYW1lKGNoYXJDb29yZHMsIFwiY2hhckNvb3Jkc1wiKTtcbiAgICBmdW5jdGlvbiBjdXJzb3JDb29yZHMoY20sIHBvcywgY29udGV4dCwgbGluZU9iaiwgcHJlcGFyZWRNZWFzdXJlLCB2YXJIZWlnaHQpIHtcbiAgICAgIGxpbmVPYmogPSBsaW5lT2JqIHx8IGdldExpbmUoY20uZG9jLCBwb3MubGluZSk7XG4gICAgICBpZiAoIXByZXBhcmVkTWVhc3VyZSkge1xuICAgICAgICBwcmVwYXJlZE1lYXN1cmUgPSBwcmVwYXJlTWVhc3VyZUZvckxpbmUoY20sIGxpbmVPYmopO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZ2V0KGNoMiwgcmlnaHQpIHtcbiAgICAgICAgdmFyIG0gPSBtZWFzdXJlQ2hhclByZXBhcmVkKGNtLCBwcmVwYXJlZE1lYXN1cmUsIGNoMiwgcmlnaHQgPyBcInJpZ2h0XCIgOiBcImxlZnRcIiwgdmFySGVpZ2h0KTtcbiAgICAgICAgaWYgKHJpZ2h0KSB7XG4gICAgICAgICAgbS5sZWZ0ID0gbS5yaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtLnJpZ2h0ID0gbS5sZWZ0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnRvQ29vcmRTeXN0ZW0oY20sIGxpbmVPYmosIG0sIGNvbnRleHQpO1xuICAgICAgfVxuICAgICAgX19uYW1lKGdldCwgXCJnZXRcIik7XG4gICAgICB2YXIgb3JkZXIgPSBnZXRPcmRlcihsaW5lT2JqLCBjbS5kb2MuZGlyZWN0aW9uKSwgY2ggPSBwb3MuY2gsIHN0aWNreSA9IHBvcy5zdGlja3k7XG4gICAgICBpZiAoY2ggPj0gbGluZU9iai50ZXh0Lmxlbmd0aCkge1xuICAgICAgICBjaCA9IGxpbmVPYmoudGV4dC5sZW5ndGg7XG4gICAgICAgIHN0aWNreSA9IFwiYmVmb3JlXCI7XG4gICAgICB9IGVsc2UgaWYgKGNoIDw9IDApIHtcbiAgICAgICAgY2ggPSAwO1xuICAgICAgICBzdGlja3kgPSBcImFmdGVyXCI7XG4gICAgICB9XG4gICAgICBpZiAoIW9yZGVyKSB7XG4gICAgICAgIHJldHVybiBnZXQoc3RpY2t5ID09IFwiYmVmb3JlXCIgPyBjaCAtIDEgOiBjaCwgc3RpY2t5ID09IFwiYmVmb3JlXCIpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZ2V0QmlkaShjaDIsIHBhcnRQb3MyLCBpbnZlcnQpIHtcbiAgICAgICAgdmFyIHBhcnQgPSBvcmRlcltwYXJ0UG9zMl0sIHJpZ2h0ID0gcGFydC5sZXZlbCA9PSAxO1xuICAgICAgICByZXR1cm4gZ2V0KGludmVydCA/IGNoMiAtIDEgOiBjaDIsIHJpZ2h0ICE9IGludmVydCk7XG4gICAgICB9XG4gICAgICBfX25hbWUoZ2V0QmlkaSwgXCJnZXRCaWRpXCIpO1xuICAgICAgdmFyIHBhcnRQb3MgPSBnZXRCaWRpUGFydEF0KG9yZGVyLCBjaCwgc3RpY2t5KTtcbiAgICAgIHZhciBvdGhlciA9IGJpZGlPdGhlcjtcbiAgICAgIHZhciB2YWwgPSBnZXRCaWRpKGNoLCBwYXJ0UG9zLCBzdGlja3kgPT0gXCJiZWZvcmVcIik7XG4gICAgICBpZiAob3RoZXIgIT0gbnVsbCkge1xuICAgICAgICB2YWwub3RoZXIgPSBnZXRCaWRpKGNoLCBvdGhlciwgc3RpY2t5ICE9IFwiYmVmb3JlXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgX19uYW1lKGN1cnNvckNvb3JkcywgXCJjdXJzb3JDb29yZHNcIik7XG4gICAgZnVuY3Rpb24gZXN0aW1hdGVDb29yZHMoY20sIHBvcykge1xuICAgICAgdmFyIGxlZnQgPSAwO1xuICAgICAgcG9zID0gY2xpcFBvcyhjbS5kb2MsIHBvcyk7XG4gICAgICBpZiAoIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7XG4gICAgICAgIGxlZnQgPSBjaGFyV2lkdGgoY20uZGlzcGxheSkgKiBwb3MuY2g7XG4gICAgICB9XG4gICAgICB2YXIgbGluZU9iaiA9IGdldExpbmUoY20uZG9jLCBwb3MubGluZSk7XG4gICAgICB2YXIgdG9wID0gaGVpZ2h0QXRMaW5lKGxpbmVPYmopICsgcGFkZGluZ1RvcChjbS5kaXNwbGF5KTtcbiAgICAgIHJldHVybiB7IGxlZnQsIHJpZ2h0OiBsZWZ0LCB0b3AsIGJvdHRvbTogdG9wICsgbGluZU9iai5oZWlnaHQgfTtcbiAgICB9XG4gICAgX19uYW1lKGVzdGltYXRlQ29vcmRzLCBcImVzdGltYXRlQ29vcmRzXCIpO1xuICAgIGZ1bmN0aW9uIFBvc1dpdGhJbmZvKGxpbmUsIGNoLCBzdGlja3ksIG91dHNpZGUsIHhSZWwpIHtcbiAgICAgIHZhciBwb3MgPSBQb3MobGluZSwgY2gsIHN0aWNreSk7XG4gICAgICBwb3MueFJlbCA9IHhSZWw7XG4gICAgICBpZiAob3V0c2lkZSkge1xuICAgICAgICBwb3Mub3V0c2lkZSA9IG91dHNpZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICBfX25hbWUoUG9zV2l0aEluZm8sIFwiUG9zV2l0aEluZm9cIik7XG4gICAgZnVuY3Rpb24gY29vcmRzQ2hhcihjbSwgeCwgeSkge1xuICAgICAgdmFyIGRvYyA9IGNtLmRvYztcbiAgICAgIHkgKz0gY20uZGlzcGxheS52aWV3T2Zmc2V0O1xuICAgICAgaWYgKHkgPCAwKSB7XG4gICAgICAgIHJldHVybiBQb3NXaXRoSW5mbyhkb2MuZmlyc3QsIDAsIG51bGwsIC0xLCAtMSk7XG4gICAgICB9XG4gICAgICB2YXIgbGluZU4gPSBsaW5lQXRIZWlnaHQoZG9jLCB5KSwgbGFzdCA9IGRvYy5maXJzdCArIGRvYy5zaXplIC0gMTtcbiAgICAgIGlmIChsaW5lTiA+IGxhc3QpIHtcbiAgICAgICAgcmV0dXJuIFBvc1dpdGhJbmZvKGRvYy5maXJzdCArIGRvYy5zaXplIC0gMSwgZ2V0TGluZShkb2MsIGxhc3QpLnRleHQubGVuZ3RoLCBudWxsLCAxLCAxKTtcbiAgICAgIH1cbiAgICAgIGlmICh4IDwgMCkge1xuICAgICAgICB4ID0gMDtcbiAgICAgIH1cbiAgICAgIHZhciBsaW5lT2JqID0gZ2V0TGluZShkb2MsIGxpbmVOKTtcbiAgICAgIGZvciAoOyA7ICkge1xuICAgICAgICB2YXIgZm91bmQgPSBjb29yZHNDaGFySW5uZXIoY20sIGxpbmVPYmosIGxpbmVOLCB4LCB5KTtcbiAgICAgICAgdmFyIGNvbGxhcHNlZCA9IGNvbGxhcHNlZFNwYW5Bcm91bmQobGluZU9iaiwgZm91bmQuY2ggKyAoZm91bmQueFJlbCA+IDAgfHwgZm91bmQub3V0c2lkZSA+IDAgPyAxIDogMCkpO1xuICAgICAgICBpZiAoIWNvbGxhcHNlZCkge1xuICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmFuZ2VFbmQgPSBjb2xsYXBzZWQuZmluZCgxKTtcbiAgICAgICAgaWYgKHJhbmdlRW5kLmxpbmUgPT0gbGluZU4pIHtcbiAgICAgICAgICByZXR1cm4gcmFuZ2VFbmQ7XG4gICAgICAgIH1cbiAgICAgICAgbGluZU9iaiA9IGdldExpbmUoZG9jLCBsaW5lTiA9IHJhbmdlRW5kLmxpbmUpO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoY29vcmRzQ2hhciwgXCJjb29yZHNDaGFyXCIpO1xuICAgIGZ1bmN0aW9uIHdyYXBwZWRMaW5lRXh0ZW50KGNtLCBsaW5lT2JqLCBwcmVwYXJlZE1lYXN1cmUsIHkpIHtcbiAgICAgIHkgLT0gd2lkZ2V0VG9wSGVpZ2h0KGxpbmVPYmopO1xuICAgICAgdmFyIGVuZCA9IGxpbmVPYmoudGV4dC5sZW5ndGg7XG4gICAgICB2YXIgYmVnaW4gPSBmaW5kRmlyc3QoZnVuY3Rpb24oY2gpIHtcbiAgICAgICAgcmV0dXJuIG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXBhcmVkTWVhc3VyZSwgY2ggLSAxKS5ib3R0b20gPD0geTtcbiAgICAgIH0sIGVuZCwgMCk7XG4gICAgICBlbmQgPSBmaW5kRmlyc3QoZnVuY3Rpb24oY2gpIHtcbiAgICAgICAgcmV0dXJuIG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXBhcmVkTWVhc3VyZSwgY2gpLnRvcCA+IHk7XG4gICAgICB9LCBiZWdpbiwgZW5kKTtcbiAgICAgIHJldHVybiB7IGJlZ2luLCBlbmQgfTtcbiAgICB9XG4gICAgX19uYW1lKHdyYXBwZWRMaW5lRXh0ZW50LCBcIndyYXBwZWRMaW5lRXh0ZW50XCIpO1xuICAgIGZ1bmN0aW9uIHdyYXBwZWRMaW5lRXh0ZW50Q2hhcihjbSwgbGluZU9iaiwgcHJlcGFyZWRNZWFzdXJlLCB0YXJnZXQpIHtcbiAgICAgIGlmICghcHJlcGFyZWRNZWFzdXJlKSB7XG4gICAgICAgIHByZXBhcmVkTWVhc3VyZSA9IHByZXBhcmVNZWFzdXJlRm9yTGluZShjbSwgbGluZU9iaik7XG4gICAgICB9XG4gICAgICB2YXIgdGFyZ2V0VG9wID0gaW50b0Nvb3JkU3lzdGVtKGNtLCBsaW5lT2JqLCBtZWFzdXJlQ2hhclByZXBhcmVkKGNtLCBwcmVwYXJlZE1lYXN1cmUsIHRhcmdldCksIFwibGluZVwiKS50b3A7XG4gICAgICByZXR1cm4gd3JhcHBlZExpbmVFeHRlbnQoY20sIGxpbmVPYmosIHByZXBhcmVkTWVhc3VyZSwgdGFyZ2V0VG9wKTtcbiAgICB9XG4gICAgX19uYW1lKHdyYXBwZWRMaW5lRXh0ZW50Q2hhciwgXCJ3cmFwcGVkTGluZUV4dGVudENoYXJcIik7XG4gICAgZnVuY3Rpb24gYm94SXNBZnRlcihib3gsIHgsIHksIGxlZnQpIHtcbiAgICAgIHJldHVybiBib3guYm90dG9tIDw9IHkgPyBmYWxzZSA6IGJveC50b3AgPiB5ID8gdHJ1ZSA6IChsZWZ0ID8gYm94LmxlZnQgOiBib3gucmlnaHQpID4geDtcbiAgICB9XG4gICAgX19uYW1lKGJveElzQWZ0ZXIsIFwiYm94SXNBZnRlclwiKTtcbiAgICBmdW5jdGlvbiBjb29yZHNDaGFySW5uZXIoY20sIGxpbmVPYmosIGxpbmVObzIsIHgsIHkpIHtcbiAgICAgIHkgLT0gaGVpZ2h0QXRMaW5lKGxpbmVPYmopO1xuICAgICAgdmFyIHByZXBhcmVkTWVhc3VyZSA9IHByZXBhcmVNZWFzdXJlRm9yTGluZShjbSwgbGluZU9iaik7XG4gICAgICB2YXIgd2lkZ2V0SGVpZ2h0MiA9IHdpZGdldFRvcEhlaWdodChsaW5lT2JqKTtcbiAgICAgIHZhciBiZWdpbiA9IDAsIGVuZCA9IGxpbmVPYmoudGV4dC5sZW5ndGgsIGx0ciA9IHRydWU7XG4gICAgICB2YXIgb3JkZXIgPSBnZXRPcmRlcihsaW5lT2JqLCBjbS5kb2MuZGlyZWN0aW9uKTtcbiAgICAgIGlmIChvcmRlcikge1xuICAgICAgICB2YXIgcGFydCA9IChjbS5vcHRpb25zLmxpbmVXcmFwcGluZyA/IGNvb3Jkc0JpZGlQYXJ0V3JhcHBlZCA6IGNvb3Jkc0JpZGlQYXJ0KShjbSwgbGluZU9iaiwgbGluZU5vMiwgcHJlcGFyZWRNZWFzdXJlLCBvcmRlciwgeCwgeSk7XG4gICAgICAgIGx0ciA9IHBhcnQubGV2ZWwgIT0gMTtcbiAgICAgICAgYmVnaW4gPSBsdHIgPyBwYXJ0LmZyb20gOiBwYXJ0LnRvIC0gMTtcbiAgICAgICAgZW5kID0gbHRyID8gcGFydC50byA6IHBhcnQuZnJvbSAtIDE7XG4gICAgICB9XG4gICAgICB2YXIgY2hBcm91bmQgPSBudWxsLCBib3hBcm91bmQgPSBudWxsO1xuICAgICAgdmFyIGNoID0gZmluZEZpcnN0KGZ1bmN0aW9uKGNoMikge1xuICAgICAgICB2YXIgYm94ID0gbWVhc3VyZUNoYXJQcmVwYXJlZChjbSwgcHJlcGFyZWRNZWFzdXJlLCBjaDIpO1xuICAgICAgICBib3gudG9wICs9IHdpZGdldEhlaWdodDI7XG4gICAgICAgIGJveC5ib3R0b20gKz0gd2lkZ2V0SGVpZ2h0MjtcbiAgICAgICAgaWYgKCFib3hJc0FmdGVyKGJveCwgeCwgeSwgZmFsc2UpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChib3gudG9wIDw9IHkgJiYgYm94LmxlZnQgPD0geCkge1xuICAgICAgICAgIGNoQXJvdW5kID0gY2gyO1xuICAgICAgICAgIGJveEFyb3VuZCA9IGJveDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0sIGJlZ2luLCBlbmQpO1xuICAgICAgdmFyIGJhc2VYLCBzdGlja3ksIG91dHNpZGUgPSBmYWxzZTtcbiAgICAgIGlmIChib3hBcm91bmQpIHtcbiAgICAgICAgdmFyIGF0TGVmdCA9IHggLSBib3hBcm91bmQubGVmdCA8IGJveEFyb3VuZC5yaWdodCAtIHgsIGF0U3RhcnQgPSBhdExlZnQgPT0gbHRyO1xuICAgICAgICBjaCA9IGNoQXJvdW5kICsgKGF0U3RhcnQgPyAwIDogMSk7XG4gICAgICAgIHN0aWNreSA9IGF0U3RhcnQgPyBcImFmdGVyXCIgOiBcImJlZm9yZVwiO1xuICAgICAgICBiYXNlWCA9IGF0TGVmdCA/IGJveEFyb3VuZC5sZWZ0IDogYm94QXJvdW5kLnJpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFsdHIgJiYgKGNoID09IGVuZCB8fCBjaCA9PSBiZWdpbikpIHtcbiAgICAgICAgICBjaCsrO1xuICAgICAgICB9XG4gICAgICAgIHN0aWNreSA9IGNoID09IDAgPyBcImFmdGVyXCIgOiBjaCA9PSBsaW5lT2JqLnRleHQubGVuZ3RoID8gXCJiZWZvcmVcIiA6IG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXBhcmVkTWVhc3VyZSwgY2ggLSAobHRyID8gMSA6IDApKS5ib3R0b20gKyB3aWRnZXRIZWlnaHQyIDw9IHkgPT0gbHRyID8gXCJhZnRlclwiIDogXCJiZWZvcmVcIjtcbiAgICAgICAgdmFyIGNvb3JkcyA9IGN1cnNvckNvb3JkcyhjbSwgUG9zKGxpbmVObzIsIGNoLCBzdGlja3kpLCBcImxpbmVcIiwgbGluZU9iaiwgcHJlcGFyZWRNZWFzdXJlKTtcbiAgICAgICAgYmFzZVggPSBjb29yZHMubGVmdDtcbiAgICAgICAgb3V0c2lkZSA9IHkgPCBjb29yZHMudG9wID8gLTEgOiB5ID49IGNvb3Jkcy5ib3R0b20gPyAxIDogMDtcbiAgICAgIH1cbiAgICAgIGNoID0gc2tpcEV4dGVuZGluZ0NoYXJzKGxpbmVPYmoudGV4dCwgY2gsIDEpO1xuICAgICAgcmV0dXJuIFBvc1dpdGhJbmZvKGxpbmVObzIsIGNoLCBzdGlja3ksIG91dHNpZGUsIHggLSBiYXNlWCk7XG4gICAgfVxuICAgIF9fbmFtZShjb29yZHNDaGFySW5uZXIsIFwiY29vcmRzQ2hhcklubmVyXCIpO1xuICAgIGZ1bmN0aW9uIGNvb3Jkc0JpZGlQYXJ0KGNtLCBsaW5lT2JqLCBsaW5lTm8yLCBwcmVwYXJlZE1lYXN1cmUsIG9yZGVyLCB4LCB5KSB7XG4gICAgICB2YXIgaW5kZXggPSBmaW5kRmlyc3QoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgdmFyIHBhcnQyID0gb3JkZXJbaTJdLCBsdHIyID0gcGFydDIubGV2ZWwgIT0gMTtcbiAgICAgICAgcmV0dXJuIGJveElzQWZ0ZXIoY3Vyc29yQ29vcmRzKGNtLCBQb3MobGluZU5vMiwgbHRyMiA/IHBhcnQyLnRvIDogcGFydDIuZnJvbSwgbHRyMiA/IFwiYmVmb3JlXCIgOiBcImFmdGVyXCIpLCBcImxpbmVcIiwgbGluZU9iaiwgcHJlcGFyZWRNZWFzdXJlKSwgeCwgeSwgdHJ1ZSk7XG4gICAgICB9LCAwLCBvcmRlci5sZW5ndGggLSAxKTtcbiAgICAgIHZhciBwYXJ0ID0gb3JkZXJbaW5kZXhdO1xuICAgICAgaWYgKGluZGV4ID4gMCkge1xuICAgICAgICB2YXIgbHRyID0gcGFydC5sZXZlbCAhPSAxO1xuICAgICAgICB2YXIgc3RhcnQgPSBjdXJzb3JDb29yZHMoY20sIFBvcyhsaW5lTm8yLCBsdHIgPyBwYXJ0LmZyb20gOiBwYXJ0LnRvLCBsdHIgPyBcImFmdGVyXCIgOiBcImJlZm9yZVwiKSwgXCJsaW5lXCIsIGxpbmVPYmosIHByZXBhcmVkTWVhc3VyZSk7XG4gICAgICAgIGlmIChib3hJc0FmdGVyKHN0YXJ0LCB4LCB5LCB0cnVlKSAmJiBzdGFydC50b3AgPiB5KSB7XG4gICAgICAgICAgcGFydCA9IG9yZGVyW2luZGV4IC0gMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJ0O1xuICAgIH1cbiAgICBfX25hbWUoY29vcmRzQmlkaVBhcnQsIFwiY29vcmRzQmlkaVBhcnRcIik7XG4gICAgZnVuY3Rpb24gY29vcmRzQmlkaVBhcnRXcmFwcGVkKGNtLCBsaW5lT2JqLCBfbGluZU5vLCBwcmVwYXJlZE1lYXN1cmUsIG9yZGVyLCB4LCB5KSB7XG4gICAgICB2YXIgcmVmID0gd3JhcHBlZExpbmVFeHRlbnQoY20sIGxpbmVPYmosIHByZXBhcmVkTWVhc3VyZSwgeSk7XG4gICAgICB2YXIgYmVnaW4gPSByZWYuYmVnaW47XG4gICAgICB2YXIgZW5kID0gcmVmLmVuZDtcbiAgICAgIGlmICgvXFxzLy50ZXN0KGxpbmVPYmoudGV4dC5jaGFyQXQoZW5kIC0gMSkpKSB7XG4gICAgICAgIGVuZC0tO1xuICAgICAgfVxuICAgICAgdmFyIHBhcnQgPSBudWxsLCBjbG9zZXN0RGlzdCA9IG51bGw7XG4gICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgb3JkZXIubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgIHZhciBwID0gb3JkZXJbaTJdO1xuICAgICAgICBpZiAocC5mcm9tID49IGVuZCB8fCBwLnRvIDw9IGJlZ2luKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGx0ciA9IHAubGV2ZWwgIT0gMTtcbiAgICAgICAgdmFyIGVuZFggPSBtZWFzdXJlQ2hhclByZXBhcmVkKGNtLCBwcmVwYXJlZE1lYXN1cmUsIGx0ciA/IE1hdGgubWluKGVuZCwgcC50bykgLSAxIDogTWF0aC5tYXgoYmVnaW4sIHAuZnJvbSkpLnJpZ2h0O1xuICAgICAgICB2YXIgZGlzdCA9IGVuZFggPCB4ID8geCAtIGVuZFggKyAxZTkgOiBlbmRYIC0geDtcbiAgICAgICAgaWYgKCFwYXJ0IHx8IGNsb3Nlc3REaXN0ID4gZGlzdCkge1xuICAgICAgICAgIHBhcnQgPSBwO1xuICAgICAgICAgIGNsb3Nlc3REaXN0ID0gZGlzdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFwYXJ0KSB7XG4gICAgICAgIHBhcnQgPSBvcmRlcltvcmRlci5sZW5ndGggLSAxXTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJ0LmZyb20gPCBiZWdpbikge1xuICAgICAgICBwYXJ0ID0geyBmcm9tOiBiZWdpbiwgdG86IHBhcnQudG8sIGxldmVsOiBwYXJ0LmxldmVsIH07XG4gICAgICB9XG4gICAgICBpZiAocGFydC50byA+IGVuZCkge1xuICAgICAgICBwYXJ0ID0geyBmcm9tOiBwYXJ0LmZyb20sIHRvOiBlbmQsIGxldmVsOiBwYXJ0LmxldmVsIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFydDtcbiAgICB9XG4gICAgX19uYW1lKGNvb3Jkc0JpZGlQYXJ0V3JhcHBlZCwgXCJjb29yZHNCaWRpUGFydFdyYXBwZWRcIik7XG4gICAgdmFyIG1lYXN1cmVUZXh0O1xuICAgIGZ1bmN0aW9uIHRleHRIZWlnaHQoZGlzcGxheSkge1xuICAgICAgaWYgKGRpc3BsYXkuY2FjaGVkVGV4dEhlaWdodCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBkaXNwbGF5LmNhY2hlZFRleHRIZWlnaHQ7XG4gICAgICB9XG4gICAgICBpZiAobWVhc3VyZVRleHQgPT0gbnVsbCkge1xuICAgICAgICBtZWFzdXJlVGV4dCA9IGVsdChcInByZVwiLCBudWxsLCBcIkNvZGVNaXJyb3ItbGluZS1saWtlXCIpO1xuICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgNDk7ICsraTIpIHtcbiAgICAgICAgICBtZWFzdXJlVGV4dC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcInhcIikpO1xuICAgICAgICAgIG1lYXN1cmVUZXh0LmFwcGVuZENoaWxkKGVsdChcImJyXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBtZWFzdXJlVGV4dC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcInhcIikpO1xuICAgICAgfVxuICAgICAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQoZGlzcGxheS5tZWFzdXJlLCBtZWFzdXJlVGV4dCk7XG4gICAgICB2YXIgaGVpZ2h0ID0gbWVhc3VyZVRleHQub2Zmc2V0SGVpZ2h0IC8gNTA7XG4gICAgICBpZiAoaGVpZ2h0ID4gMykge1xuICAgICAgICBkaXNwbGF5LmNhY2hlZFRleHRIZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB9XG4gICAgICByZW1vdmVDaGlsZHJlbihkaXNwbGF5Lm1lYXN1cmUpO1xuICAgICAgcmV0dXJuIGhlaWdodCB8fCAxO1xuICAgIH1cbiAgICBfX25hbWUodGV4dEhlaWdodCwgXCJ0ZXh0SGVpZ2h0XCIpO1xuICAgIGZ1bmN0aW9uIGNoYXJXaWR0aChkaXNwbGF5KSB7XG4gICAgICBpZiAoZGlzcGxheS5jYWNoZWRDaGFyV2lkdGggIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZGlzcGxheS5jYWNoZWRDaGFyV2lkdGg7XG4gICAgICB9XG4gICAgICB2YXIgYW5jaG9yID0gZWx0KFwic3BhblwiLCBcInh4eHh4eHh4eHhcIik7XG4gICAgICB2YXIgcHJlID0gZWx0KFwicHJlXCIsIFthbmNob3JdLCBcIkNvZGVNaXJyb3ItbGluZS1saWtlXCIpO1xuICAgICAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQoZGlzcGxheS5tZWFzdXJlLCBwcmUpO1xuICAgICAgdmFyIHJlY3QgPSBhbmNob3IuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHdpZHRoID0gKHJlY3QucmlnaHQgLSByZWN0LmxlZnQpIC8gMTA7XG4gICAgICBpZiAod2lkdGggPiAyKSB7XG4gICAgICAgIGRpc3BsYXkuY2FjaGVkQ2hhcldpZHRoID0gd2lkdGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2lkdGggfHwgMTA7XG4gICAgfVxuICAgIF9fbmFtZShjaGFyV2lkdGgsIFwiY2hhcldpZHRoXCIpO1xuICAgIGZ1bmN0aW9uIGdldERpbWVuc2lvbnMoY20pIHtcbiAgICAgIHZhciBkID0gY20uZGlzcGxheSwgbGVmdCA9IHt9LCB3aWR0aCA9IHt9O1xuICAgICAgdmFyIGd1dHRlckxlZnQgPSBkLmd1dHRlcnMuY2xpZW50TGVmdDtcbiAgICAgIGZvciAodmFyIG4gPSBkLmd1dHRlcnMuZmlyc3RDaGlsZCwgaTIgPSAwOyBuOyBuID0gbi5uZXh0U2libGluZywgKytpMikge1xuICAgICAgICB2YXIgaWQgPSBjbS5kaXNwbGF5Lmd1dHRlclNwZWNzW2kyXS5jbGFzc05hbWU7XG4gICAgICAgIGxlZnRbaWRdID0gbi5vZmZzZXRMZWZ0ICsgbi5jbGllbnRMZWZ0ICsgZ3V0dGVyTGVmdDtcbiAgICAgICAgd2lkdGhbaWRdID0gbi5jbGllbnRXaWR0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZpeGVkUG9zOiBjb21wZW5zYXRlRm9ySFNjcm9sbChkKSxcbiAgICAgICAgZ3V0dGVyVG90YWxXaWR0aDogZC5ndXR0ZXJzLm9mZnNldFdpZHRoLFxuICAgICAgICBndXR0ZXJMZWZ0OiBsZWZ0LFxuICAgICAgICBndXR0ZXJXaWR0aDogd2lkdGgsXG4gICAgICAgIHdyYXBwZXJXaWR0aDogZC53cmFwcGVyLmNsaWVudFdpZHRoXG4gICAgICB9O1xuICAgIH1cbiAgICBfX25hbWUoZ2V0RGltZW5zaW9ucywgXCJnZXREaW1lbnNpb25zXCIpO1xuICAgIGZ1bmN0aW9uIGNvbXBlbnNhdGVGb3JIU2Nyb2xsKGRpc3BsYXkpIHtcbiAgICAgIHJldHVybiBkaXNwbGF5LnNjcm9sbGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLSBkaXNwbGF5LnNpemVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG4gICAgfVxuICAgIF9fbmFtZShjb21wZW5zYXRlRm9ySFNjcm9sbCwgXCJjb21wZW5zYXRlRm9ySFNjcm9sbFwiKTtcbiAgICBmdW5jdGlvbiBlc3RpbWF0ZUhlaWdodChjbSkge1xuICAgICAgdmFyIHRoID0gdGV4dEhlaWdodChjbS5kaXNwbGF5KSwgd3JhcHBpbmcgPSBjbS5vcHRpb25zLmxpbmVXcmFwcGluZztcbiAgICAgIHZhciBwZXJMaW5lID0gd3JhcHBpbmcgJiYgTWF0aC5tYXgoNSwgY20uZGlzcGxheS5zY3JvbGxlci5jbGllbnRXaWR0aCAvIGNoYXJXaWR0aChjbS5kaXNwbGF5KSAtIDMpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgaWYgKGxpbmVJc0hpZGRlbihjbS5kb2MsIGxpbmUpKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdpZGdldHNIZWlnaHQgPSAwO1xuICAgICAgICBpZiAobGluZS53aWRnZXRzKSB7XG4gICAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IGxpbmUud2lkZ2V0cy5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgICAgIGlmIChsaW5lLndpZGdldHNbaTJdLmhlaWdodCkge1xuICAgICAgICAgICAgICB3aWRnZXRzSGVpZ2h0ICs9IGxpbmUud2lkZ2V0c1tpMl0uaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAod3JhcHBpbmcpIHtcbiAgICAgICAgICByZXR1cm4gd2lkZ2V0c0hlaWdodCArIChNYXRoLmNlaWwobGluZS50ZXh0Lmxlbmd0aCAvIHBlckxpbmUpIHx8IDEpICogdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHdpZGdldHNIZWlnaHQgKyB0aDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgX19uYW1lKGVzdGltYXRlSGVpZ2h0LCBcImVzdGltYXRlSGVpZ2h0XCIpO1xuICAgIGZ1bmN0aW9uIGVzdGltYXRlTGluZUhlaWdodHMoY20pIHtcbiAgICAgIHZhciBkb2MgPSBjbS5kb2MsIGVzdCA9IGVzdGltYXRlSGVpZ2h0KGNtKTtcbiAgICAgIGRvYy5pdGVyKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgdmFyIGVzdEhlaWdodCA9IGVzdChsaW5lKTtcbiAgICAgICAgaWYgKGVzdEhlaWdodCAhPSBsaW5lLmhlaWdodCkge1xuICAgICAgICAgIHVwZGF0ZUxpbmVIZWlnaHQobGluZSwgZXN0SGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIF9fbmFtZShlc3RpbWF0ZUxpbmVIZWlnaHRzLCBcImVzdGltYXRlTGluZUhlaWdodHNcIik7XG4gICAgZnVuY3Rpb24gcG9zRnJvbU1vdXNlKGNtLCBlLCBsaWJlcmFsLCBmb3JSZWN0KSB7XG4gICAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXk7XG4gICAgICBpZiAoIWxpYmVyYWwgJiYgZV90YXJnZXQoZSkuZ2V0QXR0cmlidXRlKFwiY20tbm90LWNvbnRlbnRcIikgPT0gXCJ0cnVlXCIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgeCwgeSwgc3BhY2UgPSBkaXNwbGF5LmxpbmVTcGFjZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHggPSBlLmNsaWVudFggLSBzcGFjZS5sZWZ0O1xuICAgICAgICB5ID0gZS5jbGllbnRZIC0gc3BhY2UudG9wO1xuICAgICAgfSBjYXRjaCAoZSQxKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIGNvb3JkcyA9IGNvb3Jkc0NoYXIoY20sIHgsIHkpLCBsaW5lO1xuICAgICAgaWYgKGZvclJlY3QgJiYgY29vcmRzLnhSZWwgPiAwICYmIChsaW5lID0gZ2V0TGluZShjbS5kb2MsIGNvb3Jkcy5saW5lKS50ZXh0KS5sZW5ndGggPT0gY29vcmRzLmNoKSB7XG4gICAgICAgIHZhciBjb2xEaWZmID0gY291bnRDb2x1bW4obGluZSwgbGluZS5sZW5ndGgsIGNtLm9wdGlvbnMudGFiU2l6ZSkgLSBsaW5lLmxlbmd0aDtcbiAgICAgICAgY29vcmRzID0gUG9zKGNvb3Jkcy5saW5lLCBNYXRoLm1heCgwLCBNYXRoLnJvdW5kKCh4IC0gcGFkZGluZ0goY20uZGlzcGxheSkubGVmdCkgLyBjaGFyV2lkdGgoY20uZGlzcGxheSkpIC0gY29sRGlmZikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvb3JkcztcbiAgICB9XG4gICAgX19uYW1lKHBvc0Zyb21Nb3VzZSwgXCJwb3NGcm9tTW91c2VcIik7XG4gICAgZnVuY3Rpb24gZmluZFZpZXdJbmRleChjbSwgbikge1xuICAgICAgaWYgKG4gPj0gY20uZGlzcGxheS52aWV3VG8pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBuIC09IGNtLmRpc3BsYXkudmlld0Zyb207XG4gICAgICBpZiAobiA8IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgdmlldyA9IGNtLmRpc3BsYXkudmlldztcbiAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCB2aWV3Lmxlbmd0aDsgaTIrKykge1xuICAgICAgICBuIC09IHZpZXdbaTJdLnNpemU7XG4gICAgICAgIGlmIChuIDwgMCkge1xuICAgICAgICAgIHJldHVybiBpMjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoZmluZFZpZXdJbmRleCwgXCJmaW5kVmlld0luZGV4XCIpO1xuICAgIGZ1bmN0aW9uIHJlZ0NoYW5nZShjbSwgZnJvbSwgdG8sIGxlbmRpZmYpIHtcbiAgICAgIGlmIChmcm9tID09IG51bGwpIHtcbiAgICAgICAgZnJvbSA9IGNtLmRvYy5maXJzdDtcbiAgICAgIH1cbiAgICAgIGlmICh0byA9PSBudWxsKSB7XG4gICAgICAgIHRvID0gY20uZG9jLmZpcnN0ICsgY20uZG9jLnNpemU7XG4gICAgICB9XG4gICAgICBpZiAoIWxlbmRpZmYpIHtcbiAgICAgICAgbGVuZGlmZiA9IDA7XG4gICAgICB9XG4gICAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXk7XG4gICAgICBpZiAobGVuZGlmZiAmJiB0byA8IGRpc3BsYXkudmlld1RvICYmIChkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID09IG51bGwgfHwgZGlzcGxheS51cGRhdGVMaW5lTnVtYmVycyA+IGZyb20pKSB7XG4gICAgICAgIGRpc3BsYXkudXBkYXRlTGluZU51bWJlcnMgPSBmcm9tO1xuICAgICAgfVxuICAgICAgY20uY3VyT3Audmlld0NoYW5nZWQgPSB0cnVlO1xuICAgICAgaWYgKGZyb20gPj0gZGlzcGxheS52aWV3VG8pIHtcbiAgICAgICAgaWYgKHNhd0NvbGxhcHNlZFNwYW5zICYmIHZpc3VhbExpbmVObyhjbS5kb2MsIGZyb20pIDwgZGlzcGxheS52aWV3VG8pIHtcbiAgICAgICAgICByZXNldFZpZXcoY20pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRvIDw9IGRpc3BsYXkudmlld0Zyb20pIHtcbiAgICAgICAgaWYgKHNhd0NvbGxhcHNlZFNwYW5zICYmIHZpc3VhbExpbmVFbmRObyhjbS5kb2MsIHRvICsgbGVuZGlmZikgPiBkaXNwbGF5LnZpZXdGcm9tKSB7XG4gICAgICAgICAgcmVzZXRWaWV3KGNtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkaXNwbGF5LnZpZXdGcm9tICs9IGxlbmRpZmY7XG4gICAgICAgICAgZGlzcGxheS52aWV3VG8gKz0gbGVuZGlmZjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChmcm9tIDw9IGRpc3BsYXkudmlld0Zyb20gJiYgdG8gPj0gZGlzcGxheS52aWV3VG8pIHtcbiAgICAgICAgcmVzZXRWaWV3KGNtKTtcbiAgICAgIH0gZWxzZSBpZiAoZnJvbSA8PSBkaXNwbGF5LnZpZXdGcm9tKSB7XG4gICAgICAgIHZhciBjdXQgPSB2aWV3Q3V0dGluZ1BvaW50KGNtLCB0bywgdG8gKyBsZW5kaWZmLCAxKTtcbiAgICAgICAgaWYgKGN1dCkge1xuICAgICAgICAgIGRpc3BsYXkudmlldyA9IGRpc3BsYXkudmlldy5zbGljZShjdXQuaW5kZXgpO1xuICAgICAgICAgIGRpc3BsYXkudmlld0Zyb20gPSBjdXQubGluZU47XG4gICAgICAgICAgZGlzcGxheS52aWV3VG8gKz0gbGVuZGlmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNldFZpZXcoY20pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRvID49IGRpc3BsYXkudmlld1RvKSB7XG4gICAgICAgIHZhciBjdXQkMSA9IHZpZXdDdXR0aW5nUG9pbnQoY20sIGZyb20sIGZyb20sIC0xKTtcbiAgICAgICAgaWYgKGN1dCQxKSB7XG4gICAgICAgICAgZGlzcGxheS52aWV3ID0gZGlzcGxheS52aWV3LnNsaWNlKDAsIGN1dCQxLmluZGV4KTtcbiAgICAgICAgICBkaXNwbGF5LnZpZXdUbyA9IGN1dCQxLmxpbmVOO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc2V0VmlldyhjbSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjdXRUb3AgPSB2aWV3Q3V0dGluZ1BvaW50KGNtLCBmcm9tLCBmcm9tLCAtMSk7XG4gICAgICAgIHZhciBjdXRCb3QgPSB2aWV3Q3V0dGluZ1BvaW50KGNtLCB0bywgdG8gKyBsZW5kaWZmLCAxKTtcbiAgICAgICAgaWYgKGN1dFRvcCAmJiBjdXRCb3QpIHtcbiAgICAgICAgICBkaXNwbGF5LnZpZXcgPSBkaXNwbGF5LnZpZXcuc2xpY2UoMCwgY3V0VG9wLmluZGV4KS5jb25jYXQoYnVpbGRWaWV3QXJyYXkoY20sIGN1dFRvcC5saW5lTiwgY3V0Qm90LmxpbmVOKSkuY29uY2F0KGRpc3BsYXkudmlldy5zbGljZShjdXRCb3QuaW5kZXgpKTtcbiAgICAgICAgICBkaXNwbGF5LnZpZXdUbyArPSBsZW5kaWZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc2V0VmlldyhjbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBleHQgPSBkaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQ7XG4gICAgICBpZiAoZXh0KSB7XG4gICAgICAgIGlmICh0byA8IGV4dC5saW5lTikge1xuICAgICAgICAgIGV4dC5saW5lTiArPSBsZW5kaWZmO1xuICAgICAgICB9IGVsc2UgaWYgKGZyb20gPCBleHQubGluZU4gKyBleHQuc2l6ZSkge1xuICAgICAgICAgIGRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKHJlZ0NoYW5nZSwgXCJyZWdDaGFuZ2VcIik7XG4gICAgZnVuY3Rpb24gcmVnTGluZUNoYW5nZShjbSwgbGluZSwgdHlwZSkge1xuICAgICAgY20uY3VyT3Audmlld0NoYW5nZWQgPSB0cnVlO1xuICAgICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBleHQgPSBjbS5kaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQ7XG4gICAgICBpZiAoZXh0ICYmIGxpbmUgPj0gZXh0LmxpbmVOICYmIGxpbmUgPCBleHQubGluZU4gKyBleHQuc2l6ZSkge1xuICAgICAgICBkaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmUgPCBkaXNwbGF5LnZpZXdGcm9tIHx8IGxpbmUgPj0gZGlzcGxheS52aWV3VG8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGxpbmVWaWV3ID0gZGlzcGxheS52aWV3W2ZpbmRWaWV3SW5kZXgoY20sIGxpbmUpXTtcbiAgICAgIGlmIChsaW5lVmlldy5ub2RlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGFyciA9IGxpbmVWaWV3LmNoYW5nZXMgfHwgKGxpbmVWaWV3LmNoYW5nZXMgPSBbXSk7XG4gICAgICBpZiAoaW5kZXhPZihhcnIsIHR5cGUpID09IC0xKSB7XG4gICAgICAgIGFyci5wdXNoKHR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUocmVnTGluZUNoYW5nZSwgXCJyZWdMaW5lQ2hhbmdlXCIpO1xuICAgIGZ1bmN0aW9uIHJlc2V0VmlldyhjbSkge1xuICAgICAgY20uZGlzcGxheS52aWV3RnJvbSA9IGNtLmRpc3BsYXkudmlld1RvID0gY20uZG9jLmZpcnN0O1xuICAgICAgY20uZGlzcGxheS52aWV3ID0gW107XG4gICAgICBjbS5kaXNwbGF5LnZpZXdPZmZzZXQgPSAwO1xuICAgIH1cbiAgICBfX25hbWUocmVzZXRWaWV3LCBcInJlc2V0Vmlld1wiKTtcbiAgICBmdW5jdGlvbiB2aWV3Q3V0dGluZ1BvaW50KGNtLCBvbGROLCBuZXdOLCBkaXIpIHtcbiAgICAgIHZhciBpbmRleCA9IGZpbmRWaWV3SW5kZXgoY20sIG9sZE4pLCBkaWZmLCB2aWV3ID0gY20uZGlzcGxheS52aWV3O1xuICAgICAgaWYgKCFzYXdDb2xsYXBzZWRTcGFucyB8fCBuZXdOID09IGNtLmRvYy5maXJzdCArIGNtLmRvYy5zaXplKSB7XG4gICAgICAgIHJldHVybiB7IGluZGV4LCBsaW5lTjogbmV3TiB9O1xuICAgICAgfVxuICAgICAgdmFyIG4gPSBjbS5kaXNwbGF5LnZpZXdGcm9tO1xuICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IGluZGV4OyBpMisrKSB7XG4gICAgICAgIG4gKz0gdmlld1tpMl0uc2l6ZTtcbiAgICAgIH1cbiAgICAgIGlmIChuICE9IG9sZE4pIHtcbiAgICAgICAgaWYgKGRpciA+IDApIHtcbiAgICAgICAgICBpZiAoaW5kZXggPT0gdmlldy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGlmZiA9IG4gKyB2aWV3W2luZGV4XS5zaXplIC0gb2xkTjtcbiAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpZmYgPSBuIC0gb2xkTjtcbiAgICAgICAgfVxuICAgICAgICBvbGROICs9IGRpZmY7XG4gICAgICAgIG5ld04gKz0gZGlmZjtcbiAgICAgIH1cbiAgICAgIHdoaWxlICh2aXN1YWxMaW5lTm8oY20uZG9jLCBuZXdOKSAhPSBuZXdOKSB7XG4gICAgICAgIGlmIChpbmRleCA9PSAoZGlyIDwgMCA/IDAgOiB2aWV3Lmxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbmV3TiArPSBkaXIgKiB2aWV3W2luZGV4IC0gKGRpciA8IDAgPyAxIDogMCldLnNpemU7XG4gICAgICAgIGluZGV4ICs9IGRpcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGluZGV4LCBsaW5lTjogbmV3TiB9O1xuICAgIH1cbiAgICBfX25hbWUodmlld0N1dHRpbmdQb2ludCwgXCJ2aWV3Q3V0dGluZ1BvaW50XCIpO1xuICAgIGZ1bmN0aW9uIGFkanVzdFZpZXcoY20sIGZyb20sIHRvKSB7XG4gICAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIHZpZXcgPSBkaXNwbGF5LnZpZXc7XG4gICAgICBpZiAodmlldy5sZW5ndGggPT0gMCB8fCBmcm9tID49IGRpc3BsYXkudmlld1RvIHx8IHRvIDw9IGRpc3BsYXkudmlld0Zyb20pIHtcbiAgICAgICAgZGlzcGxheS52aWV3ID0gYnVpbGRWaWV3QXJyYXkoY20sIGZyb20sIHRvKTtcbiAgICAgICAgZGlzcGxheS52aWV3RnJvbSA9IGZyb207XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZGlzcGxheS52aWV3RnJvbSA+IGZyb20pIHtcbiAgICAgICAgICBkaXNwbGF5LnZpZXcgPSBidWlsZFZpZXdBcnJheShjbSwgZnJvbSwgZGlzcGxheS52aWV3RnJvbSkuY29uY2F0KGRpc3BsYXkudmlldyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGlzcGxheS52aWV3RnJvbSA8IGZyb20pIHtcbiAgICAgICAgICBkaXNwbGF5LnZpZXcgPSBkaXNwbGF5LnZpZXcuc2xpY2UoZmluZFZpZXdJbmRleChjbSwgZnJvbSkpO1xuICAgICAgICB9XG4gICAgICAgIGRpc3BsYXkudmlld0Zyb20gPSBmcm9tO1xuICAgICAgICBpZiAoZGlzcGxheS52aWV3VG8gPCB0bykge1xuICAgICAgICAgIGRpc3BsYXkudmlldyA9IGRpc3BsYXkudmlldy5jb25jYXQoYnVpbGRWaWV3QXJyYXkoY20sIGRpc3BsYXkudmlld1RvLCB0bykpO1xuICAgICAgICB9IGVsc2UgaWYgKGRpc3BsYXkudmlld1RvID4gdG8pIHtcbiAgICAgICAgICBkaXNwbGF5LnZpZXcgPSBkaXNwbGF5LnZpZXcuc2xpY2UoMCwgZmluZFZpZXdJbmRleChjbSwgdG8pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGlzcGxheS52aWV3VG8gPSB0bztcbiAgICB9XG4gICAgX19uYW1lKGFkanVzdFZpZXcsIFwiYWRqdXN0Vmlld1wiKTtcbiAgICBmdW5jdGlvbiBjb3VudERpcnR5VmlldyhjbSkge1xuICAgICAgdmFyIHZpZXcgPSBjbS5kaXNwbGF5LnZpZXcsIGRpcnR5ID0gMDtcbiAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCB2aWV3Lmxlbmd0aDsgaTIrKykge1xuICAgICAgICB2YXIgbGluZVZpZXcgPSB2aWV3W2kyXTtcbiAgICAgICAgaWYgKCFsaW5lVmlldy5oaWRkZW4gJiYgKCFsaW5lVmlldy5ub2RlIHx8IGxpbmVWaWV3LmNoYW5nZXMpKSB7XG4gICAgICAgICAgKytkaXJ0eTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRpcnR5O1xuICAgIH1cbiAgICBfX25hbWUoY291bnREaXJ0eVZpZXcsIFwiY291bnREaXJ0eVZpZXdcIik7XG4gICAgZnVuY3Rpb24gdXBkYXRlU2VsZWN0aW9uKGNtKSB7XG4gICAgICBjbS5kaXNwbGF5LmlucHV0LnNob3dTZWxlY3Rpb24oY20uZGlzcGxheS5pbnB1dC5wcmVwYXJlU2VsZWN0aW9uKCkpO1xuICAgIH1cbiAgICBfX25hbWUodXBkYXRlU2VsZWN0aW9uLCBcInVwZGF0ZVNlbGVjdGlvblwiKTtcbiAgICBmdW5jdGlvbiBwcmVwYXJlU2VsZWN0aW9uKGNtLCBwcmltYXJ5KSB7XG4gICAgICBpZiAocHJpbWFyeSA9PT0gdm9pZCAwKVxuICAgICAgICBwcmltYXJ5ID0gdHJ1ZTtcbiAgICAgIHZhciBkb2MgPSBjbS5kb2MsIHJlc3VsdCA9IHt9O1xuICAgICAgdmFyIGN1ckZyYWdtZW50ID0gcmVzdWx0LmN1cnNvcnMgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICB2YXIgc2VsRnJhZ21lbnQgPSByZXN1bHQuc2VsZWN0aW9uID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgdmFyIGN1c3RvbUN1cnNvciA9IGNtLm9wdGlvbnMuJGN1c3RvbUN1cnNvcjtcbiAgICAgIGlmIChjdXN0b21DdXJzb3IpIHtcbiAgICAgICAgcHJpbWFyeSA9IHRydWU7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgZG9jLnNlbC5yYW5nZXMubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgIGlmICghcHJpbWFyeSAmJiBpMiA9PSBkb2Muc2VsLnByaW1JbmRleCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciByYW5nZTIgPSBkb2Muc2VsLnJhbmdlc1tpMl07XG4gICAgICAgIGlmIChyYW5nZTIuZnJvbSgpLmxpbmUgPj0gY20uZGlzcGxheS52aWV3VG8gfHwgcmFuZ2UyLnRvKCkubGluZSA8IGNtLmRpc3BsYXkudmlld0Zyb20pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29sbGFwc2VkID0gcmFuZ2UyLmVtcHR5KCk7XG4gICAgICAgIGlmIChjdXN0b21DdXJzb3IpIHtcbiAgICAgICAgICB2YXIgaGVhZCA9IGN1c3RvbUN1cnNvcihjbSwgcmFuZ2UyKTtcbiAgICAgICAgICBpZiAoaGVhZCkge1xuICAgICAgICAgICAgZHJhd1NlbGVjdGlvbkN1cnNvcihjbSwgaGVhZCwgY3VyRnJhZ21lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjb2xsYXBzZWQgfHwgY20ub3B0aW9ucy5zaG93Q3Vyc29yV2hlblNlbGVjdGluZykge1xuICAgICAgICAgIGRyYXdTZWxlY3Rpb25DdXJzb3IoY20sIHJhbmdlMi5oZWFkLCBjdXJGcmFnbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb2xsYXBzZWQpIHtcbiAgICAgICAgICBkcmF3U2VsZWN0aW9uUmFuZ2UoY20sIHJhbmdlMiwgc2VsRnJhZ21lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBfX25hbWUocHJlcGFyZVNlbGVjdGlvbiwgXCJwcmVwYXJlU2VsZWN0aW9uXCIpO1xuICAgIGZ1bmN0aW9uIGRyYXdTZWxlY3Rpb25DdXJzb3IoY20sIGhlYWQsIG91dHB1dCkge1xuICAgICAgdmFyIHBvcyA9IGN1cnNvckNvb3JkcyhjbSwgaGVhZCwgXCJkaXZcIiwgbnVsbCwgbnVsbCwgIWNtLm9wdGlvbnMuc2luZ2xlQ3Vyc29ySGVpZ2h0UGVyTGluZSk7XG4gICAgICB2YXIgY3Vyc29yID0gb3V0cHV0LmFwcGVuZENoaWxkKGVsdChcImRpdlwiLCBcIlxceEEwXCIsIFwiQ29kZU1pcnJvci1jdXJzb3JcIikpO1xuICAgICAgY3Vyc29yLnN0eWxlLmxlZnQgPSBwb3MubGVmdCArIFwicHhcIjtcbiAgICAgIGN1cnNvci5zdHlsZS50b3AgPSBwb3MudG9wICsgXCJweFwiO1xuICAgICAgY3Vyc29yLnN0eWxlLmhlaWdodCA9IE1hdGgubWF4KDAsIHBvcy5ib3R0b20gLSBwb3MudG9wKSAqIGNtLm9wdGlvbnMuY3Vyc29ySGVpZ2h0ICsgXCJweFwiO1xuICAgICAgaWYgKC9cXGJjbS1mYXQtY3Vyc29yXFxiLy50ZXN0KGNtLmdldFdyYXBwZXJFbGVtZW50KCkuY2xhc3NOYW1lKSkge1xuICAgICAgICB2YXIgY2hhclBvcyA9IGNoYXJDb29yZHMoY20sIGhlYWQsIFwiZGl2XCIsIG51bGwsIG51bGwpO1xuICAgICAgICB2YXIgd2lkdGggPSBjaGFyUG9zLnJpZ2h0IC0gY2hhclBvcy5sZWZ0O1xuICAgICAgICBjdXJzb3Iuc3R5bGUud2lkdGggPSAod2lkdGggPiAwID8gd2lkdGggOiBjbS5kZWZhdWx0Q2hhcldpZHRoKCkpICsgXCJweFwiO1xuICAgICAgfVxuICAgICAgaWYgKHBvcy5vdGhlcikge1xuICAgICAgICB2YXIgb3RoZXJDdXJzb3IgPSBvdXRwdXQuYXBwZW5kQ2hpbGQoZWx0KFwiZGl2XCIsIFwiXFx4QTBcIiwgXCJDb2RlTWlycm9yLWN1cnNvciBDb2RlTWlycm9yLXNlY29uZGFyeWN1cnNvclwiKSk7XG4gICAgICAgIG90aGVyQ3Vyc29yLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICAgICAgICBvdGhlckN1cnNvci5zdHlsZS5sZWZ0ID0gcG9zLm90aGVyLmxlZnQgKyBcInB4XCI7XG4gICAgICAgIG90aGVyQ3Vyc29yLnN0eWxlLnRvcCA9IHBvcy5vdGhlci50b3AgKyBcInB4XCI7XG4gICAgICAgIG90aGVyQ3Vyc29yLnN0eWxlLmhlaWdodCA9IChwb3Mub3RoZXIuYm90dG9tIC0gcG9zLm90aGVyLnRvcCkgKiAwLjg1ICsgXCJweFwiO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoZHJhd1NlbGVjdGlvbkN1cnNvciwgXCJkcmF3U2VsZWN0aW9uQ3Vyc29yXCIpO1xuICAgIGZ1bmN0aW9uIGNtcENvb3JkcyhhLCBiKSB7XG4gICAgICByZXR1cm4gYS50b3AgLSBiLnRvcCB8fCBhLmxlZnQgLSBiLmxlZnQ7XG4gICAgfVxuICAgIF9fbmFtZShjbXBDb29yZHMsIFwiY21wQ29vcmRzXCIpO1xuICAgIGZ1bmN0aW9uIGRyYXdTZWxlY3Rpb25SYW5nZShjbSwgcmFuZ2UyLCBvdXRwdXQpIHtcbiAgICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgZG9jID0gY20uZG9jO1xuICAgICAgdmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgdmFyIHBhZGRpbmcgPSBwYWRkaW5nSChjbS5kaXNwbGF5KSwgbGVmdFNpZGUgPSBwYWRkaW5nLmxlZnQ7XG4gICAgICB2YXIgcmlnaHRTaWRlID0gTWF0aC5tYXgoZGlzcGxheS5zaXplcldpZHRoLCBkaXNwbGF5V2lkdGgoY20pIC0gZGlzcGxheS5zaXplci5vZmZzZXRMZWZ0KSAtIHBhZGRpbmcucmlnaHQ7XG4gICAgICB2YXIgZG9jTFRSID0gZG9jLmRpcmVjdGlvbiA9PSBcImx0clwiO1xuICAgICAgZnVuY3Rpb24gYWRkKGxlZnQsIHRvcCwgd2lkdGgsIGJvdHRvbSkge1xuICAgICAgICBpZiAodG9wIDwgMCkge1xuICAgICAgICAgIHRvcCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdG9wID0gTWF0aC5yb3VuZCh0b3ApO1xuICAgICAgICBib3R0b20gPSBNYXRoLnJvdW5kKGJvdHRvbSk7XG4gICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGVsdChcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3Itc2VsZWN0ZWRcIiwgXCJwb3NpdGlvbjogYWJzb2x1dGU7IGxlZnQ6IFwiICsgbGVmdCArIFwicHg7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IFwiICsgdG9wICsgXCJweDsgd2lkdGg6IFwiICsgKHdpZHRoID09IG51bGwgPyByaWdodFNpZGUgLSBsZWZ0IDogd2lkdGgpICsgXCJweDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogXCIgKyAoYm90dG9tIC0gdG9wKSArIFwicHhcIikpO1xuICAgICAgfVxuICAgICAgX19uYW1lKGFkZCwgXCJhZGRcIik7XG4gICAgICBmdW5jdGlvbiBkcmF3Rm9yTGluZShsaW5lLCBmcm9tQXJnLCB0b0FyZykge1xuICAgICAgICB2YXIgbGluZU9iaiA9IGdldExpbmUoZG9jLCBsaW5lKTtcbiAgICAgICAgdmFyIGxpbmVMZW4gPSBsaW5lT2JqLnRleHQubGVuZ3RoO1xuICAgICAgICB2YXIgc3RhcnQsIGVuZDtcbiAgICAgICAgZnVuY3Rpb24gY29vcmRzKGNoLCBiaWFzKSB7XG4gICAgICAgICAgcmV0dXJuIGNoYXJDb29yZHMoY20sIFBvcyhsaW5lLCBjaCksIFwiZGl2XCIsIGxpbmVPYmosIGJpYXMpO1xuICAgICAgICB9XG4gICAgICAgIF9fbmFtZShjb29yZHMsIFwiY29vcmRzXCIpO1xuICAgICAgICBmdW5jdGlvbiB3cmFwWChwb3MsIGRpciwgc2lkZSkge1xuICAgICAgICAgIHZhciBleHRlbnQgPSB3cmFwcGVkTGluZUV4dGVudENoYXIoY20sIGxpbmVPYmosIG51bGwsIHBvcyk7XG4gICAgICAgICAgdmFyIHByb3AyID0gZGlyID09IFwibHRyXCIgPT0gKHNpZGUgPT0gXCJhZnRlclwiKSA/IFwibGVmdFwiIDogXCJyaWdodFwiO1xuICAgICAgICAgIHZhciBjaCA9IHNpZGUgPT0gXCJhZnRlclwiID8gZXh0ZW50LmJlZ2luIDogZXh0ZW50LmVuZCAtICgvXFxzLy50ZXN0KGxpbmVPYmoudGV4dC5jaGFyQXQoZXh0ZW50LmVuZCAtIDEpKSA/IDIgOiAxKTtcbiAgICAgICAgICByZXR1cm4gY29vcmRzKGNoLCBwcm9wMilbcHJvcDJdO1xuICAgICAgICB9XG4gICAgICAgIF9fbmFtZSh3cmFwWCwgXCJ3cmFwWFwiKTtcbiAgICAgICAgdmFyIG9yZGVyID0gZ2V0T3JkZXIobGluZU9iaiwgZG9jLmRpcmVjdGlvbik7XG4gICAgICAgIGl0ZXJhdGVCaWRpU2VjdGlvbnMob3JkZXIsIGZyb21BcmcgfHwgMCwgdG9BcmcgPT0gbnVsbCA/IGxpbmVMZW4gOiB0b0FyZywgZnVuY3Rpb24oZnJvbSwgdG8sIGRpciwgaTIpIHtcbiAgICAgICAgICB2YXIgbHRyID0gZGlyID09IFwibHRyXCI7XG4gICAgICAgICAgdmFyIGZyb21Qb3MgPSBjb29yZHMoZnJvbSwgbHRyID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIpO1xuICAgICAgICAgIHZhciB0b1BvcyA9IGNvb3Jkcyh0byAtIDEsIGx0ciA/IFwicmlnaHRcIiA6IFwibGVmdFwiKTtcbiAgICAgICAgICB2YXIgb3BlblN0YXJ0ID0gZnJvbUFyZyA9PSBudWxsICYmIGZyb20gPT0gMCwgb3BlbkVuZCA9IHRvQXJnID09IG51bGwgJiYgdG8gPT0gbGluZUxlbjtcbiAgICAgICAgICB2YXIgZmlyc3QgPSBpMiA9PSAwLCBsYXN0ID0gIW9yZGVyIHx8IGkyID09IG9yZGVyLmxlbmd0aCAtIDE7XG4gICAgICAgICAgaWYgKHRvUG9zLnRvcCAtIGZyb21Qb3MudG9wIDw9IDMpIHtcbiAgICAgICAgICAgIHZhciBvcGVuTGVmdCA9IChkb2NMVFIgPyBvcGVuU3RhcnQgOiBvcGVuRW5kKSAmJiBmaXJzdDtcbiAgICAgICAgICAgIHZhciBvcGVuUmlnaHQgPSAoZG9jTFRSID8gb3BlbkVuZCA6IG9wZW5TdGFydCkgJiYgbGFzdDtcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gb3BlbkxlZnQgPyBsZWZ0U2lkZSA6IChsdHIgPyBmcm9tUG9zIDogdG9Qb3MpLmxlZnQ7XG4gICAgICAgICAgICB2YXIgcmlnaHQgPSBvcGVuUmlnaHQgPyByaWdodFNpZGUgOiAobHRyID8gdG9Qb3MgOiBmcm9tUG9zKS5yaWdodDtcbiAgICAgICAgICAgIGFkZChsZWZ0LCBmcm9tUG9zLnRvcCwgcmlnaHQgLSBsZWZ0LCBmcm9tUG9zLmJvdHRvbSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0b3BMZWZ0LCB0b3BSaWdodCwgYm90TGVmdCwgYm90UmlnaHQ7XG4gICAgICAgICAgICBpZiAobHRyKSB7XG4gICAgICAgICAgICAgIHRvcExlZnQgPSBkb2NMVFIgJiYgb3BlblN0YXJ0ICYmIGZpcnN0ID8gbGVmdFNpZGUgOiBmcm9tUG9zLmxlZnQ7XG4gICAgICAgICAgICAgIHRvcFJpZ2h0ID0gZG9jTFRSID8gcmlnaHRTaWRlIDogd3JhcFgoZnJvbSwgZGlyLCBcImJlZm9yZVwiKTtcbiAgICAgICAgICAgICAgYm90TGVmdCA9IGRvY0xUUiA/IGxlZnRTaWRlIDogd3JhcFgodG8sIGRpciwgXCJhZnRlclwiKTtcbiAgICAgICAgICAgICAgYm90UmlnaHQgPSBkb2NMVFIgJiYgb3BlbkVuZCAmJiBsYXN0ID8gcmlnaHRTaWRlIDogdG9Qb3MucmlnaHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0b3BMZWZ0ID0gIWRvY0xUUiA/IGxlZnRTaWRlIDogd3JhcFgoZnJvbSwgZGlyLCBcImJlZm9yZVwiKTtcbiAgICAgICAgICAgICAgdG9wUmlnaHQgPSAhZG9jTFRSICYmIG9wZW5TdGFydCAmJiBmaXJzdCA/IHJpZ2h0U2lkZSA6IGZyb21Qb3MucmlnaHQ7XG4gICAgICAgICAgICAgIGJvdExlZnQgPSAhZG9jTFRSICYmIG9wZW5FbmQgJiYgbGFzdCA/IGxlZnRTaWRlIDogdG9Qb3MubGVmdDtcbiAgICAgICAgICAgICAgYm90UmlnaHQgPSAhZG9jTFRSID8gcmlnaHRTaWRlIDogd3JhcFgodG8sIGRpciwgXCJhZnRlclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZCh0b3BMZWZ0LCBmcm9tUG9zLnRvcCwgdG9wUmlnaHQgLSB0b3BMZWZ0LCBmcm9tUG9zLmJvdHRvbSk7XG4gICAgICAgICAgICBpZiAoZnJvbVBvcy5ib3R0b20gPCB0b1Bvcy50b3ApIHtcbiAgICAgICAgICAgICAgYWRkKGxlZnRTaWRlLCBmcm9tUG9zLmJvdHRvbSwgbnVsbCwgdG9Qb3MudG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZChib3RMZWZ0LCB0b1Bvcy50b3AsIGJvdFJpZ2h0IC0gYm90TGVmdCwgdG9Qb3MuYm90dG9tKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFzdGFydCB8fCBjbXBDb29yZHMoZnJvbVBvcywgc3RhcnQpIDwgMCkge1xuICAgICAgICAgICAgc3RhcnQgPSBmcm9tUG9zO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY21wQ29vcmRzKHRvUG9zLCBzdGFydCkgPCAwKSB7XG4gICAgICAgICAgICBzdGFydCA9IHRvUG9zO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWVuZCB8fCBjbXBDb29yZHMoZnJvbVBvcywgZW5kKSA8IDApIHtcbiAgICAgICAgICAgIGVuZCA9IGZyb21Qb3M7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjbXBDb29yZHModG9Qb3MsIGVuZCkgPCAwKSB7XG4gICAgICAgICAgICBlbmQgPSB0b1BvcztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyBzdGFydCwgZW5kIH07XG4gICAgICB9XG4gICAgICBfX25hbWUoZHJhd0ZvckxpbmUsIFwiZHJhd0ZvckxpbmVcIik7XG4gICAgICB2YXIgc0Zyb20gPSByYW5nZTIuZnJvbSgpLCBzVG8gPSByYW5nZTIudG8oKTtcbiAgICAgIGlmIChzRnJvbS5saW5lID09IHNUby5saW5lKSB7XG4gICAgICAgIGRyYXdGb3JMaW5lKHNGcm9tLmxpbmUsIHNGcm9tLmNoLCBzVG8uY2gpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGZyb21MaW5lID0gZ2V0TGluZShkb2MsIHNGcm9tLmxpbmUpLCB0b0xpbmUgPSBnZXRMaW5lKGRvYywgc1RvLmxpbmUpO1xuICAgICAgICB2YXIgc2luZ2xlVkxpbmUgPSB2aXN1YWxMaW5lKGZyb21MaW5lKSA9PSB2aXN1YWxMaW5lKHRvTGluZSk7XG4gICAgICAgIHZhciBsZWZ0RW5kID0gZHJhd0ZvckxpbmUoc0Zyb20ubGluZSwgc0Zyb20uY2gsIHNpbmdsZVZMaW5lID8gZnJvbUxpbmUudGV4dC5sZW5ndGggKyAxIDogbnVsbCkuZW5kO1xuICAgICAgICB2YXIgcmlnaHRTdGFydCA9IGRyYXdGb3JMaW5lKHNUby5saW5lLCBzaW5nbGVWTGluZSA/IDAgOiBudWxsLCBzVG8uY2gpLnN0YXJ0O1xuICAgICAgICBpZiAoc2luZ2xlVkxpbmUpIHtcbiAgICAgICAgICBpZiAobGVmdEVuZC50b3AgPCByaWdodFN0YXJ0LnRvcCAtIDIpIHtcbiAgICAgICAgICAgIGFkZChsZWZ0RW5kLnJpZ2h0LCBsZWZ0RW5kLnRvcCwgbnVsbCwgbGVmdEVuZC5ib3R0b20pO1xuICAgICAgICAgICAgYWRkKGxlZnRTaWRlLCByaWdodFN0YXJ0LnRvcCwgcmlnaHRTdGFydC5sZWZ0LCByaWdodFN0YXJ0LmJvdHRvbSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFkZChsZWZ0RW5kLnJpZ2h0LCBsZWZ0RW5kLnRvcCwgcmlnaHRTdGFydC5sZWZ0IC0gbGVmdEVuZC5yaWdodCwgbGVmdEVuZC5ib3R0b20pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGVmdEVuZC5ib3R0b20gPCByaWdodFN0YXJ0LnRvcCkge1xuICAgICAgICAgIGFkZChsZWZ0U2lkZSwgbGVmdEVuZC5ib3R0b20sIG51bGwsIHJpZ2h0U3RhcnQudG9wKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb3V0cHV0LmFwcGVuZENoaWxkKGZyYWdtZW50KTtcbiAgICB9XG4gICAgX19uYW1lKGRyYXdTZWxlY3Rpb25SYW5nZSwgXCJkcmF3U2VsZWN0aW9uUmFuZ2VcIik7XG4gICAgZnVuY3Rpb24gcmVzdGFydEJsaW5rKGNtKSB7XG4gICAgICBpZiAoIWNtLnN0YXRlLmZvY3VzZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xuICAgICAgY2xlYXJJbnRlcnZhbChkaXNwbGF5LmJsaW5rZXIpO1xuICAgICAgdmFyIG9uMiA9IHRydWU7XG4gICAgICBkaXNwbGF5LmN1cnNvckRpdi5zdHlsZS52aXNpYmlsaXR5ID0gXCJcIjtcbiAgICAgIGlmIChjbS5vcHRpb25zLmN1cnNvckJsaW5rUmF0ZSA+IDApIHtcbiAgICAgICAgZGlzcGxheS5ibGlua2VyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKCFjbS5oYXNGb2N1cygpKSB7XG4gICAgICAgICAgICBvbkJsdXIoY20pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkaXNwbGF5LmN1cnNvckRpdi5zdHlsZS52aXNpYmlsaXR5ID0gKG9uMiA9ICFvbjIpID8gXCJcIiA6IFwiaGlkZGVuXCI7XG4gICAgICAgIH0sIGNtLm9wdGlvbnMuY3Vyc29yQmxpbmtSYXRlKTtcbiAgICAgIH0gZWxzZSBpZiAoY20ub3B0aW9ucy5jdXJzb3JCbGlua1JhdGUgPCAwKSB7XG4gICAgICAgIGRpc3BsYXkuY3Vyc29yRGl2LnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUocmVzdGFydEJsaW5rLCBcInJlc3RhcnRCbGlua1wiKTtcbiAgICBmdW5jdGlvbiBlbnN1cmVGb2N1cyhjbSkge1xuICAgICAgaWYgKCFjbS5oYXNGb2N1cygpKSB7XG4gICAgICAgIGNtLmRpc3BsYXkuaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgaWYgKCFjbS5zdGF0ZS5mb2N1c2VkKSB7XG4gICAgICAgICAgb25Gb2N1cyhjbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKGVuc3VyZUZvY3VzLCBcImVuc3VyZUZvY3VzXCIpO1xuICAgIGZ1bmN0aW9uIGRlbGF5Qmx1ckV2ZW50KGNtKSB7XG4gICAgICBjbS5zdGF0ZS5kZWxheWluZ0JsdXJFdmVudCA9IHRydWU7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoY20uc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQpIHtcbiAgICAgICAgICBjbS5zdGF0ZS5kZWxheWluZ0JsdXJFdmVudCA9IGZhbHNlO1xuICAgICAgICAgIGlmIChjbS5zdGF0ZS5mb2N1c2VkKSB7XG4gICAgICAgICAgICBvbkJsdXIoY20pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgMTAwKTtcbiAgICB9XG4gICAgX19uYW1lKGRlbGF5Qmx1ckV2ZW50LCBcImRlbGF5Qmx1ckV2ZW50XCIpO1xuICAgIGZ1bmN0aW9uIG9uRm9jdXMoY20sIGUpIHtcbiAgICAgIGlmIChjbS5zdGF0ZS5kZWxheWluZ0JsdXJFdmVudCAmJiAhY20uc3RhdGUuZHJhZ2dpbmdUZXh0KSB7XG4gICAgICAgIGNtLnN0YXRlLmRlbGF5aW5nQmx1ckV2ZW50ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoY20ub3B0aW9ucy5yZWFkT25seSA9PSBcIm5vY3Vyc29yXCIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFjbS5zdGF0ZS5mb2N1c2VkKSB7XG4gICAgICAgIHNpZ25hbChjbSwgXCJmb2N1c1wiLCBjbSwgZSk7XG4gICAgICAgIGNtLnN0YXRlLmZvY3VzZWQgPSB0cnVlO1xuICAgICAgICBhZGRDbGFzcyhjbS5kaXNwbGF5LndyYXBwZXIsIFwiQ29kZU1pcnJvci1mb2N1c2VkXCIpO1xuICAgICAgICBpZiAoIWNtLmN1ck9wICYmIGNtLmRpc3BsYXkuc2VsRm9yQ29udGV4dE1lbnUgIT0gY20uZG9jLnNlbCkge1xuICAgICAgICAgIGNtLmRpc3BsYXkuaW5wdXQucmVzZXQoKTtcbiAgICAgICAgICBpZiAod2Via2l0KSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gY20uZGlzcGxheS5pbnB1dC5yZXNldCh0cnVlKTtcbiAgICAgICAgICAgIH0sIDIwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY20uZGlzcGxheS5pbnB1dC5yZWNlaXZlZEZvY3VzKCk7XG4gICAgICB9XG4gICAgICByZXN0YXJ0QmxpbmsoY20pO1xuICAgIH1cbiAgICBfX25hbWUob25Gb2N1cywgXCJvbkZvY3VzXCIpO1xuICAgIGZ1bmN0aW9uIG9uQmx1cihjbSwgZSkge1xuICAgICAgaWYgKGNtLnN0YXRlLmRlbGF5aW5nQmx1ckV2ZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChjbS5zdGF0ZS5mb2N1c2VkKSB7XG4gICAgICAgIHNpZ25hbChjbSwgXCJibHVyXCIsIGNtLCBlKTtcbiAgICAgICAgY20uc3RhdGUuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICBybUNsYXNzKGNtLmRpc3BsYXkud3JhcHBlciwgXCJDb2RlTWlycm9yLWZvY3VzZWRcIik7XG4gICAgICB9XG4gICAgICBjbGVhckludGVydmFsKGNtLmRpc3BsYXkuYmxpbmtlcik7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIWNtLnN0YXRlLmZvY3VzZWQpIHtcbiAgICAgICAgICBjbS5kaXNwbGF5LnNoaWZ0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0sIDE1MCk7XG4gICAgfVxuICAgIF9fbmFtZShvbkJsdXIsIFwib25CbHVyXCIpO1xuICAgIGZ1bmN0aW9uIHVwZGF0ZUhlaWdodHNJblZpZXdwb3J0KGNtKSB7XG4gICAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXk7XG4gICAgICB2YXIgcHJldkJvdHRvbSA9IGRpc3BsYXkubGluZURpdi5vZmZzZXRUb3A7XG4gICAgICB2YXIgdmlld1RvcCA9IE1hdGgubWF4KDAsIGRpc3BsYXkuc2Nyb2xsZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wKTtcbiAgICAgIHZhciBvbGRIZWlnaHQgPSBkaXNwbGF5LmxpbmVEaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xuICAgICAgdmFyIG11c3RTY3JvbGwgPSAwO1xuICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IGRpc3BsYXkudmlldy5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgdmFyIGN1ciA9IGRpc3BsYXkudmlld1tpMl0sIHdyYXBwaW5nID0gY20ub3B0aW9ucy5saW5lV3JhcHBpbmc7XG4gICAgICAgIHZhciBoZWlnaHQgPSB2b2lkIDAsIHdpZHRoID0gMDtcbiAgICAgICAgaWYgKGN1ci5oaWRkZW4pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBvbGRIZWlnaHQgKz0gY3VyLmxpbmUuaGVpZ2h0O1xuICAgICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDgpIHtcbiAgICAgICAgICB2YXIgYm90ID0gY3VyLm5vZGUub2Zmc2V0VG9wICsgY3VyLm5vZGUub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgIGhlaWdodCA9IGJvdCAtIHByZXZCb3R0b207XG4gICAgICAgICAgcHJldkJvdHRvbSA9IGJvdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgYm94ID0gY3VyLm5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgaGVpZ2h0ID0gYm94LmJvdHRvbSAtIGJveC50b3A7XG4gICAgICAgICAgaWYgKCF3cmFwcGluZyAmJiBjdXIudGV4dC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICB3aWR0aCA9IGN1ci50ZXh0LmZpcnN0Q2hpbGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkucmlnaHQgLSBib3gubGVmdCAtIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBkaWZmID0gY3VyLmxpbmUuaGVpZ2h0IC0gaGVpZ2h0O1xuICAgICAgICBpZiAoZGlmZiA+IDVlLTMgfHwgZGlmZiA8IC01ZS0zKSB7XG4gICAgICAgICAgaWYgKG9sZEhlaWdodCA8IHZpZXdUb3ApIHtcbiAgICAgICAgICAgIG11c3RTY3JvbGwgLT0gZGlmZjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdXBkYXRlTGluZUhlaWdodChjdXIubGluZSwgaGVpZ2h0KTtcbiAgICAgICAgICB1cGRhdGVXaWRnZXRIZWlnaHQoY3VyLmxpbmUpO1xuICAgICAgICAgIGlmIChjdXIucmVzdCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjdXIucmVzdC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICB1cGRhdGVXaWRnZXRIZWlnaHQoY3VyLnJlc3Rbal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAod2lkdGggPiBjbS5kaXNwbGF5LnNpemVyV2lkdGgpIHtcbiAgICAgICAgICB2YXIgY2hXaWR0aCA9IE1hdGguY2VpbCh3aWR0aCAvIGNoYXJXaWR0aChjbS5kaXNwbGF5KSk7XG4gICAgICAgICAgaWYgKGNoV2lkdGggPiBjbS5kaXNwbGF5Lm1heExpbmVMZW5ndGgpIHtcbiAgICAgICAgICAgIGNtLmRpc3BsYXkubWF4TGluZUxlbmd0aCA9IGNoV2lkdGg7XG4gICAgICAgICAgICBjbS5kaXNwbGF5Lm1heExpbmUgPSBjdXIubGluZTtcbiAgICAgICAgICAgIGNtLmRpc3BsYXkubWF4TGluZUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKE1hdGguYWJzKG11c3RTY3JvbGwpID4gMikge1xuICAgICAgICBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcCArPSBtdXN0U2Nyb2xsO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUodXBkYXRlSGVpZ2h0c0luVmlld3BvcnQsIFwidXBkYXRlSGVpZ2h0c0luVmlld3BvcnRcIik7XG4gICAgZnVuY3Rpb24gdXBkYXRlV2lkZ2V0SGVpZ2h0KGxpbmUpIHtcbiAgICAgIGlmIChsaW5lLndpZGdldHMpIHtcbiAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IGxpbmUud2lkZ2V0cy5sZW5ndGg7ICsraTIpIHtcbiAgICAgICAgICB2YXIgdyA9IGxpbmUud2lkZ2V0c1tpMl0sIHBhcmVudCA9IHcubm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHcuaGVpZ2h0ID0gcGFyZW50Lm9mZnNldEhlaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKHVwZGF0ZVdpZGdldEhlaWdodCwgXCJ1cGRhdGVXaWRnZXRIZWlnaHRcIik7XG4gICAgZnVuY3Rpb24gdmlzaWJsZUxpbmVzKGRpc3BsYXksIGRvYywgdmlld3BvcnQpIHtcbiAgICAgIHZhciB0b3AgPSB2aWV3cG9ydCAmJiB2aWV3cG9ydC50b3AgIT0gbnVsbCA/IE1hdGgubWF4KDAsIHZpZXdwb3J0LnRvcCkgOiBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcDtcbiAgICAgIHRvcCA9IE1hdGguZmxvb3IodG9wIC0gcGFkZGluZ1RvcChkaXNwbGF5KSk7XG4gICAgICB2YXIgYm90dG9tID0gdmlld3BvcnQgJiYgdmlld3BvcnQuYm90dG9tICE9IG51bGwgPyB2aWV3cG9ydC5ib3R0b20gOiB0b3AgKyBkaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0O1xuICAgICAgdmFyIGZyb20gPSBsaW5lQXRIZWlnaHQoZG9jLCB0b3ApLCB0byA9IGxpbmVBdEhlaWdodChkb2MsIGJvdHRvbSk7XG4gICAgICBpZiAodmlld3BvcnQgJiYgdmlld3BvcnQuZW5zdXJlKSB7XG4gICAgICAgIHZhciBlbnN1cmVGcm9tID0gdmlld3BvcnQuZW5zdXJlLmZyb20ubGluZSwgZW5zdXJlVG8gPSB2aWV3cG9ydC5lbnN1cmUudG8ubGluZTtcbiAgICAgICAgaWYgKGVuc3VyZUZyb20gPCBmcm9tKSB7XG4gICAgICAgICAgZnJvbSA9IGVuc3VyZUZyb207XG4gICAgICAgICAgdG8gPSBsaW5lQXRIZWlnaHQoZG9jLCBoZWlnaHRBdExpbmUoZ2V0TGluZShkb2MsIGVuc3VyZUZyb20pKSArIGRpc3BsYXkud3JhcHBlci5jbGllbnRIZWlnaHQpO1xuICAgICAgICB9IGVsc2UgaWYgKE1hdGgubWluKGVuc3VyZVRvLCBkb2MubGFzdExpbmUoKSkgPj0gdG8pIHtcbiAgICAgICAgICBmcm9tID0gbGluZUF0SGVpZ2h0KGRvYywgaGVpZ2h0QXRMaW5lKGdldExpbmUoZG9jLCBlbnN1cmVUbykpIC0gZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodCk7XG4gICAgICAgICAgdG8gPSBlbnN1cmVUbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgZnJvbSwgdG86IE1hdGgubWF4KHRvLCBmcm9tICsgMSkgfTtcbiAgICB9XG4gICAgX19uYW1lKHZpc2libGVMaW5lcywgXCJ2aXNpYmxlTGluZXNcIik7XG4gICAgZnVuY3Rpb24gbWF5YmVTY3JvbGxXaW5kb3coY20sIHJlY3QpIHtcbiAgICAgIGlmIChzaWduYWxET01FdmVudChjbSwgXCJzY3JvbGxDdXJzb3JJbnRvVmlld1wiKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIGJveCA9IGRpc3BsYXkuc2l6ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGRvU2Nyb2xsID0gbnVsbDtcbiAgICAgIGlmIChyZWN0LnRvcCArIGJveC50b3AgPCAwKSB7XG4gICAgICAgIGRvU2Nyb2xsID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAocmVjdC5ib3R0b20gKyBib3gudG9wID4gKHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0KSkge1xuICAgICAgICBkb1Njcm9sbCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGRvU2Nyb2xsICE9IG51bGwgJiYgIXBoYW50b20pIHtcbiAgICAgICAgdmFyIHNjcm9sbE5vZGUgPSBlbHQoXCJkaXZcIiwgXCJcXHUyMDBCXCIsIG51bGwsIFwicG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IFwiICsgKHJlY3QudG9wIC0gZGlzcGxheS52aWV3T2Zmc2V0IC0gcGFkZGluZ1RvcChjbS5kaXNwbGF5KSkgKyBcInB4O1xcbiAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiICsgKHJlY3QuYm90dG9tIC0gcmVjdC50b3AgKyBzY3JvbGxHYXAoY20pICsgZGlzcGxheS5iYXJIZWlnaHQpICsgXCJweDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogXCIgKyByZWN0LmxlZnQgKyBcInB4OyB3aWR0aDogXCIgKyBNYXRoLm1heCgyLCByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0KSArIFwicHg7XCIpO1xuICAgICAgICBjbS5kaXNwbGF5LmxpbmVTcGFjZS5hcHBlbmRDaGlsZChzY3JvbGxOb2RlKTtcbiAgICAgICAgc2Nyb2xsTm9kZS5zY3JvbGxJbnRvVmlldyhkb1Njcm9sbCk7XG4gICAgICAgIGNtLmRpc3BsYXkubGluZVNwYWNlLnJlbW92ZUNoaWxkKHNjcm9sbE5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUobWF5YmVTY3JvbGxXaW5kb3csIFwibWF5YmVTY3JvbGxXaW5kb3dcIik7XG4gICAgZnVuY3Rpb24gc2Nyb2xsUG9zSW50b1ZpZXcoY20sIHBvcywgZW5kLCBtYXJnaW4pIHtcbiAgICAgIGlmIChtYXJnaW4gPT0gbnVsbCkge1xuICAgICAgICBtYXJnaW4gPSAwO1xuICAgICAgfVxuICAgICAgdmFyIHJlY3Q7XG4gICAgICBpZiAoIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nICYmIHBvcyA9PSBlbmQpIHtcbiAgICAgICAgZW5kID0gcG9zLnN0aWNreSA9PSBcImJlZm9yZVwiID8gUG9zKHBvcy5saW5lLCBwb3MuY2ggKyAxLCBcImJlZm9yZVwiKSA6IHBvcztcbiAgICAgICAgcG9zID0gcG9zLmNoID8gUG9zKHBvcy5saW5lLCBwb3Muc3RpY2t5ID09IFwiYmVmb3JlXCIgPyBwb3MuY2ggLSAxIDogcG9zLmNoLCBcImFmdGVyXCIpIDogcG9zO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgbGltaXQgPSAwOyBsaW1pdCA8IDU7IGxpbWl0KyspIHtcbiAgICAgICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGNvb3JkcyA9IGN1cnNvckNvb3JkcyhjbSwgcG9zKTtcbiAgICAgICAgdmFyIGVuZENvb3JkcyA9ICFlbmQgfHwgZW5kID09IHBvcyA/IGNvb3JkcyA6IGN1cnNvckNvb3JkcyhjbSwgZW5kKTtcbiAgICAgICAgcmVjdCA9IHtcbiAgICAgICAgICBsZWZ0OiBNYXRoLm1pbihjb29yZHMubGVmdCwgZW5kQ29vcmRzLmxlZnQpLFxuICAgICAgICAgIHRvcDogTWF0aC5taW4oY29vcmRzLnRvcCwgZW5kQ29vcmRzLnRvcCkgLSBtYXJnaW4sXG4gICAgICAgICAgcmlnaHQ6IE1hdGgubWF4KGNvb3Jkcy5sZWZ0LCBlbmRDb29yZHMubGVmdCksXG4gICAgICAgICAgYm90dG9tOiBNYXRoLm1heChjb29yZHMuYm90dG9tLCBlbmRDb29yZHMuYm90dG9tKSArIG1hcmdpblxuICAgICAgICB9O1xuICAgICAgICB2YXIgc2Nyb2xsUG9zID0gY2FsY3VsYXRlU2Nyb2xsUG9zKGNtLCByZWN0KTtcbiAgICAgICAgdmFyIHN0YXJ0VG9wID0gY20uZG9jLnNjcm9sbFRvcCwgc3RhcnRMZWZ0ID0gY20uZG9jLnNjcm9sbExlZnQ7XG4gICAgICAgIGlmIChzY3JvbGxQb3Muc2Nyb2xsVG9wICE9IG51bGwpIHtcbiAgICAgICAgICB1cGRhdGVTY3JvbGxUb3AoY20sIHNjcm9sbFBvcy5zY3JvbGxUb3ApO1xuICAgICAgICAgIGlmIChNYXRoLmFicyhjbS5kb2Muc2Nyb2xsVG9wIC0gc3RhcnRUb3ApID4gMSkge1xuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzY3JvbGxQb3Muc2Nyb2xsTGVmdCAhPSBudWxsKSB7XG4gICAgICAgICAgc2V0U2Nyb2xsTGVmdChjbSwgc2Nyb2xsUG9zLnNjcm9sbExlZnQpO1xuICAgICAgICAgIGlmIChNYXRoLmFicyhjbS5kb2Muc2Nyb2xsTGVmdCAtIHN0YXJ0TGVmdCkgPiAxKSB7XG4gICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaGFuZ2VkKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZWN0O1xuICAgIH1cbiAgICBfX25hbWUoc2Nyb2xsUG9zSW50b1ZpZXcsIFwic2Nyb2xsUG9zSW50b1ZpZXdcIik7XG4gICAgZnVuY3Rpb24gc2Nyb2xsSW50b1ZpZXcoY20sIHJlY3QpIHtcbiAgICAgIHZhciBzY3JvbGxQb3MgPSBjYWxjdWxhdGVTY3JvbGxQb3MoY20sIHJlY3QpO1xuICAgICAgaWYgKHNjcm9sbFBvcy5zY3JvbGxUb3AgIT0gbnVsbCkge1xuICAgICAgICB1cGRhdGVTY3JvbGxUb3AoY20sIHNjcm9sbFBvcy5zY3JvbGxUb3ApO1xuICAgICAgfVxuICAgICAgaWYgKHNjcm9sbFBvcy5zY3JvbGxMZWZ0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0U2Nyb2xsTGVmdChjbSwgc2Nyb2xsUG9zLnNjcm9sbExlZnQpO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoc2Nyb2xsSW50b1ZpZXcsIFwic2Nyb2xsSW50b1ZpZXdcIik7XG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlU2Nyb2xsUG9zKGNtLCByZWN0KSB7XG4gICAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIHNuYXBNYXJnaW4gPSB0ZXh0SGVpZ2h0KGNtLmRpc3BsYXkpO1xuICAgICAgaWYgKHJlY3QudG9wIDwgMCkge1xuICAgICAgICByZWN0LnRvcCA9IDA7XG4gICAgICB9XG4gICAgICB2YXIgc2NyZWVudG9wID0gY20uY3VyT3AgJiYgY20uY3VyT3Auc2Nyb2xsVG9wICE9IG51bGwgPyBjbS5jdXJPcC5zY3JvbGxUb3AgOiBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcDtcbiAgICAgIHZhciBzY3JlZW4yID0gZGlzcGxheUhlaWdodChjbSksIHJlc3VsdCA9IHt9O1xuICAgICAgaWYgKHJlY3QuYm90dG9tIC0gcmVjdC50b3AgPiBzY3JlZW4yKSB7XG4gICAgICAgIHJlY3QuYm90dG9tID0gcmVjdC50b3AgKyBzY3JlZW4yO1xuICAgICAgfVxuICAgICAgdmFyIGRvY0JvdHRvbSA9IGNtLmRvYy5oZWlnaHQgKyBwYWRkaW5nVmVydChkaXNwbGF5KTtcbiAgICAgIHZhciBhdFRvcCA9IHJlY3QudG9wIDwgc25hcE1hcmdpbiwgYXRCb3R0b20gPSByZWN0LmJvdHRvbSA+IGRvY0JvdHRvbSAtIHNuYXBNYXJnaW47XG4gICAgICBpZiAocmVjdC50b3AgPCBzY3JlZW50b3ApIHtcbiAgICAgICAgcmVzdWx0LnNjcm9sbFRvcCA9IGF0VG9wID8gMCA6IHJlY3QudG9wO1xuICAgICAgfSBlbHNlIGlmIChyZWN0LmJvdHRvbSA+IHNjcmVlbnRvcCArIHNjcmVlbjIpIHtcbiAgICAgICAgdmFyIG5ld1RvcCA9IE1hdGgubWluKHJlY3QudG9wLCAoYXRCb3R0b20gPyBkb2NCb3R0b20gOiByZWN0LmJvdHRvbSkgLSBzY3JlZW4yKTtcbiAgICAgICAgaWYgKG5ld1RvcCAhPSBzY3JlZW50b3ApIHtcbiAgICAgICAgICByZXN1bHQuc2Nyb2xsVG9wID0gbmV3VG9wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgZ3V0dGVyU3BhY2UgPSBjbS5vcHRpb25zLmZpeGVkR3V0dGVyID8gMCA6IGRpc3BsYXkuZ3V0dGVycy5vZmZzZXRXaWR0aDtcbiAgICAgIHZhciBzY3JlZW5sZWZ0ID0gY20uY3VyT3AgJiYgY20uY3VyT3Auc2Nyb2xsTGVmdCAhPSBudWxsID8gY20uY3VyT3Auc2Nyb2xsTGVmdCA6IGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsTGVmdCAtIGd1dHRlclNwYWNlO1xuICAgICAgdmFyIHNjcmVlbncgPSBkaXNwbGF5V2lkdGgoY20pIC0gZGlzcGxheS5ndXR0ZXJzLm9mZnNldFdpZHRoO1xuICAgICAgdmFyIHRvb1dpZGUgPSByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0ID4gc2NyZWVudztcbiAgICAgIGlmICh0b29XaWRlKSB7XG4gICAgICAgIHJlY3QucmlnaHQgPSByZWN0LmxlZnQgKyBzY3JlZW53O1xuICAgICAgfVxuICAgICAgaWYgKHJlY3QubGVmdCA8IDEwKSB7XG4gICAgICAgIHJlc3VsdC5zY3JvbGxMZWZ0ID0gMDtcbiAgICAgIH0gZWxzZSBpZiAocmVjdC5sZWZ0IDwgc2NyZWVubGVmdCkge1xuICAgICAgICByZXN1bHQuc2Nyb2xsTGVmdCA9IE1hdGgubWF4KDAsIHJlY3QubGVmdCArIGd1dHRlclNwYWNlIC0gKHRvb1dpZGUgPyAwIDogMTApKTtcbiAgICAgIH0gZWxzZSBpZiAocmVjdC5yaWdodCA+IHNjcmVlbncgKyBzY3JlZW5sZWZ0IC0gMykge1xuICAgICAgICByZXN1bHQuc2Nyb2xsTGVmdCA9IHJlY3QucmlnaHQgKyAodG9vV2lkZSA/IDAgOiAxMCkgLSBzY3JlZW53O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgX19uYW1lKGNhbGN1bGF0ZVNjcm9sbFBvcywgXCJjYWxjdWxhdGVTY3JvbGxQb3NcIik7XG4gICAgZnVuY3Rpb24gYWRkVG9TY3JvbGxUb3AoY20sIHRvcCkge1xuICAgICAgaWYgKHRvcCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlc29sdmVTY3JvbGxUb1BvcyhjbSk7XG4gICAgICBjbS5jdXJPcC5zY3JvbGxUb3AgPSAoY20uY3VyT3Auc2Nyb2xsVG9wID09IG51bGwgPyBjbS5kb2Muc2Nyb2xsVG9wIDogY20uY3VyT3Auc2Nyb2xsVG9wKSArIHRvcDtcbiAgICB9XG4gICAgX19uYW1lKGFkZFRvU2Nyb2xsVG9wLCBcImFkZFRvU2Nyb2xsVG9wXCIpO1xuICAgIGZ1bmN0aW9uIGVuc3VyZUN1cnNvclZpc2libGUoY20pIHtcbiAgICAgIHJlc29sdmVTY3JvbGxUb1BvcyhjbSk7XG4gICAgICB2YXIgY3VyID0gY20uZ2V0Q3Vyc29yKCk7XG4gICAgICBjbS5jdXJPcC5zY3JvbGxUb1BvcyA9IHsgZnJvbTogY3VyLCB0bzogY3VyLCBtYXJnaW46IGNtLm9wdGlvbnMuY3Vyc29yU2Nyb2xsTWFyZ2luIH07XG4gICAgfVxuICAgIF9fbmFtZShlbnN1cmVDdXJzb3JWaXNpYmxlLCBcImVuc3VyZUN1cnNvclZpc2libGVcIik7XG4gICAgZnVuY3Rpb24gc2Nyb2xsVG9Db29yZHMoY20sIHgsIHkpIHtcbiAgICAgIGlmICh4ICE9IG51bGwgfHwgeSAhPSBudWxsKSB7XG4gICAgICAgIHJlc29sdmVTY3JvbGxUb1BvcyhjbSk7XG4gICAgICB9XG4gICAgICBpZiAoeCAhPSBudWxsKSB7XG4gICAgICAgIGNtLmN1ck9wLnNjcm9sbExlZnQgPSB4O1xuICAgICAgfVxuICAgICAgaWYgKHkgIT0gbnVsbCkge1xuICAgICAgICBjbS5jdXJPcC5zY3JvbGxUb3AgPSB5O1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoc2Nyb2xsVG9Db29yZHMsIFwic2Nyb2xsVG9Db29yZHNcIik7XG4gICAgZnVuY3Rpb24gc2Nyb2xsVG9SYW5nZShjbSwgcmFuZ2UyKSB7XG4gICAgICByZXNvbHZlU2Nyb2xsVG9Qb3MoY20pO1xuICAgICAgY20uY3VyT3Auc2Nyb2xsVG9Qb3MgPSByYW5nZTI7XG4gICAgfVxuICAgIF9fbmFtZShzY3JvbGxUb1JhbmdlLCBcInNjcm9sbFRvUmFuZ2VcIik7XG4gICAgZnVuY3Rpb24gcmVzb2x2ZVNjcm9sbFRvUG9zKGNtKSB7XG4gICAgICB2YXIgcmFuZ2UyID0gY20uY3VyT3Auc2Nyb2xsVG9Qb3M7XG4gICAgICBpZiAocmFuZ2UyKSB7XG4gICAgICAgIGNtLmN1ck9wLnNjcm9sbFRvUG9zID0gbnVsbDtcbiAgICAgICAgdmFyIGZyb20gPSBlc3RpbWF0ZUNvb3JkcyhjbSwgcmFuZ2UyLmZyb20pLCB0byA9IGVzdGltYXRlQ29vcmRzKGNtLCByYW5nZTIudG8pO1xuICAgICAgICBzY3JvbGxUb0Nvb3Jkc1JhbmdlKGNtLCBmcm9tLCB0bywgcmFuZ2UyLm1hcmdpbik7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShyZXNvbHZlU2Nyb2xsVG9Qb3MsIFwicmVzb2x2ZVNjcm9sbFRvUG9zXCIpO1xuICAgIGZ1bmN0aW9uIHNjcm9sbFRvQ29vcmRzUmFuZ2UoY20sIGZyb20sIHRvLCBtYXJnaW4pIHtcbiAgICAgIHZhciBzUG9zID0gY2FsY3VsYXRlU2Nyb2xsUG9zKGNtLCB7XG4gICAgICAgIGxlZnQ6IE1hdGgubWluKGZyb20ubGVmdCwgdG8ubGVmdCksXG4gICAgICAgIHRvcDogTWF0aC5taW4oZnJvbS50b3AsIHRvLnRvcCkgLSBtYXJnaW4sXG4gICAgICAgIHJpZ2h0OiBNYXRoLm1heChmcm9tLnJpZ2h0LCB0by5yaWdodCksXG4gICAgICAgIGJvdHRvbTogTWF0aC5tYXgoZnJvbS5ib3R0b20sIHRvLmJvdHRvbSkgKyBtYXJnaW5cbiAgICAgIH0pO1xuICAgICAgc2Nyb2xsVG9Db29yZHMoY20sIHNQb3Muc2Nyb2xsTGVmdCwgc1Bvcy5zY3JvbGxUb3ApO1xuICAgIH1cbiAgICBfX25hbWUoc2Nyb2xsVG9Db29yZHNSYW5nZSwgXCJzY3JvbGxUb0Nvb3Jkc1JhbmdlXCIpO1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVNjcm9sbFRvcChjbSwgdmFsKSB7XG4gICAgICBpZiAoTWF0aC5hYnMoY20uZG9jLnNjcm9sbFRvcCAtIHZhbCkgPCAyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghZ2Vja28pIHtcbiAgICAgICAgdXBkYXRlRGlzcGxheVNpbXBsZShjbSwgeyB0b3A6IHZhbCB9KTtcbiAgICAgIH1cbiAgICAgIHNldFNjcm9sbFRvcChjbSwgdmFsLCB0cnVlKTtcbiAgICAgIGlmIChnZWNrbykge1xuICAgICAgICB1cGRhdGVEaXNwbGF5U2ltcGxlKGNtKTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0V29ya2VyKGNtLCAxMDApO1xuICAgIH1cbiAgICBfX25hbWUodXBkYXRlU2Nyb2xsVG9wLCBcInVwZGF0ZVNjcm9sbFRvcFwiKTtcbiAgICBmdW5jdGlvbiBzZXRTY3JvbGxUb3AoY20sIHZhbCwgZm9yY2VTY3JvbGwpIHtcbiAgICAgIHZhbCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGNtLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsSGVpZ2h0IC0gY20uZGlzcGxheS5zY3JvbGxlci5jbGllbnRIZWlnaHQsIHZhbCkpO1xuICAgICAgaWYgKGNtLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wID09IHZhbCAmJiAhZm9yY2VTY3JvbGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY20uZG9jLnNjcm9sbFRvcCA9IHZhbDtcbiAgICAgIGNtLmRpc3BsYXkuc2Nyb2xsYmFycy5zZXRTY3JvbGxUb3AodmFsKTtcbiAgICAgIGlmIChjbS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcCAhPSB2YWwpIHtcbiAgICAgICAgY20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3AgPSB2YWw7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShzZXRTY3JvbGxUb3AsIFwic2V0U2Nyb2xsVG9wXCIpO1xuICAgIGZ1bmN0aW9uIHNldFNjcm9sbExlZnQoY20sIHZhbCwgaXNTY3JvbGxlciwgZm9yY2VTY3JvbGwpIHtcbiAgICAgIHZhbCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHZhbCwgY20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxXaWR0aCAtIGNtLmRpc3BsYXkuc2Nyb2xsZXIuY2xpZW50V2lkdGgpKTtcbiAgICAgIGlmICgoaXNTY3JvbGxlciA/IHZhbCA9PSBjbS5kb2Muc2Nyb2xsTGVmdCA6IE1hdGguYWJzKGNtLmRvYy5zY3JvbGxMZWZ0IC0gdmFsKSA8IDIpICYmICFmb3JjZVNjcm9sbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjbS5kb2Muc2Nyb2xsTGVmdCA9IHZhbDtcbiAgICAgIGFsaWduSG9yaXpvbnRhbGx5KGNtKTtcbiAgICAgIGlmIChjbS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbExlZnQgIT0gdmFsKSB7XG4gICAgICAgIGNtLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsTGVmdCA9IHZhbDtcbiAgICAgIH1cbiAgICAgIGNtLmRpc3BsYXkuc2Nyb2xsYmFycy5zZXRTY3JvbGxMZWZ0KHZhbCk7XG4gICAgfVxuICAgIF9fbmFtZShzZXRTY3JvbGxMZWZ0LCBcInNldFNjcm9sbExlZnRcIik7XG4gICAgZnVuY3Rpb24gbWVhc3VyZUZvclNjcm9sbGJhcnMoY20pIHtcbiAgICAgIHZhciBkID0gY20uZGlzcGxheSwgZ3V0dGVyVyA9IGQuZ3V0dGVycy5vZmZzZXRXaWR0aDtcbiAgICAgIHZhciBkb2NIID0gTWF0aC5yb3VuZChjbS5kb2MuaGVpZ2h0ICsgcGFkZGluZ1ZlcnQoY20uZGlzcGxheSkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2xpZW50SGVpZ2h0OiBkLnNjcm9sbGVyLmNsaWVudEhlaWdodCxcbiAgICAgICAgdmlld0hlaWdodDogZC53cmFwcGVyLmNsaWVudEhlaWdodCxcbiAgICAgICAgc2Nyb2xsV2lkdGg6IGQuc2Nyb2xsZXIuc2Nyb2xsV2lkdGgsXG4gICAgICAgIGNsaWVudFdpZHRoOiBkLnNjcm9sbGVyLmNsaWVudFdpZHRoLFxuICAgICAgICB2aWV3V2lkdGg6IGQud3JhcHBlci5jbGllbnRXaWR0aCxcbiAgICAgICAgYmFyTGVmdDogY20ub3B0aW9ucy5maXhlZEd1dHRlciA/IGd1dHRlclcgOiAwLFxuICAgICAgICBkb2NIZWlnaHQ6IGRvY0gsXG4gICAgICAgIHNjcm9sbEhlaWdodDogZG9jSCArIHNjcm9sbEdhcChjbSkgKyBkLmJhckhlaWdodCxcbiAgICAgICAgbmF0aXZlQmFyV2lkdGg6IGQubmF0aXZlQmFyV2lkdGgsXG4gICAgICAgIGd1dHRlcldpZHRoOiBndXR0ZXJXXG4gICAgICB9O1xuICAgIH1cbiAgICBfX25hbWUobWVhc3VyZUZvclNjcm9sbGJhcnMsIFwibWVhc3VyZUZvclNjcm9sbGJhcnNcIik7XG4gICAgdmFyIE5hdGl2ZVNjcm9sbGJhcnMgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKHBsYWNlLCBzY3JvbGwsIGNtKSB7XG4gICAgICB0aGlzLmNtID0gY207XG4gICAgICB2YXIgdmVydCA9IHRoaXMudmVydCA9IGVsdChcImRpdlwiLCBbZWx0KFwiZGl2XCIsIG51bGwsIG51bGwsIFwibWluLXdpZHRoOiAxcHhcIildLCBcIkNvZGVNaXJyb3ItdnNjcm9sbGJhclwiKTtcbiAgICAgIHZhciBob3JpeiA9IHRoaXMuaG9yaXogPSBlbHQoXCJkaXZcIiwgW2VsdChcImRpdlwiLCBudWxsLCBudWxsLCBcImhlaWdodDogMTAwJTsgbWluLWhlaWdodDogMXB4XCIpXSwgXCJDb2RlTWlycm9yLWhzY3JvbGxiYXJcIik7XG4gICAgICB2ZXJ0LnRhYkluZGV4ID0gaG9yaXoudGFiSW5kZXggPSAtMTtcbiAgICAgIHBsYWNlKHZlcnQpO1xuICAgICAgcGxhY2UoaG9yaXopO1xuICAgICAgb24odmVydCwgXCJzY3JvbGxcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh2ZXJ0LmNsaWVudEhlaWdodCkge1xuICAgICAgICAgIHNjcm9sbCh2ZXJ0LnNjcm9sbFRvcCwgXCJ2ZXJ0aWNhbFwiKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBvbihob3JpeiwgXCJzY3JvbGxcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChob3Jpei5jbGllbnRXaWR0aCkge1xuICAgICAgICAgIHNjcm9sbChob3Jpei5zY3JvbGxMZWZ0LCBcImhvcml6b250YWxcIik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5jaGVja2VkWmVyb1dpZHRoID0gZmFsc2U7XG4gICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDgpIHtcbiAgICAgICAgdGhpcy5ob3Jpei5zdHlsZS5taW5IZWlnaHQgPSB0aGlzLnZlcnQuc3R5bGUubWluV2lkdGggPSBcIjE4cHhcIjtcbiAgICAgIH1cbiAgICB9LCBcIk5hdGl2ZVNjcm9sbGJhcnNcIik7XG4gICAgTmF0aXZlU2Nyb2xsYmFycy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24obWVhc3VyZSkge1xuICAgICAgdmFyIG5lZWRzSCA9IG1lYXN1cmUuc2Nyb2xsV2lkdGggPiBtZWFzdXJlLmNsaWVudFdpZHRoICsgMTtcbiAgICAgIHZhciBuZWVkc1YgPSBtZWFzdXJlLnNjcm9sbEhlaWdodCA+IG1lYXN1cmUuY2xpZW50SGVpZ2h0ICsgMTtcbiAgICAgIHZhciBzV2lkdGggPSBtZWFzdXJlLm5hdGl2ZUJhcldpZHRoO1xuICAgICAgaWYgKG5lZWRzVikge1xuICAgICAgICB0aGlzLnZlcnQuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgdGhpcy52ZXJ0LnN0eWxlLmJvdHRvbSA9IG5lZWRzSCA/IHNXaWR0aCArIFwicHhcIiA6IFwiMFwiO1xuICAgICAgICB2YXIgdG90YWxIZWlnaHQgPSBtZWFzdXJlLnZpZXdIZWlnaHQgLSAobmVlZHNIID8gc1dpZHRoIDogMCk7XG4gICAgICAgIHRoaXMudmVydC5maXJzdENoaWxkLnN0eWxlLmhlaWdodCA9IE1hdGgubWF4KDAsIG1lYXN1cmUuc2Nyb2xsSGVpZ2h0IC0gbWVhc3VyZS5jbGllbnRIZWlnaHQgKyB0b3RhbEhlaWdodCkgKyBcInB4XCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnZlcnQuc2Nyb2xsVG9wID0gMDtcbiAgICAgICAgdGhpcy52ZXJ0LnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICAgICAgICB0aGlzLnZlcnQuZmlyc3RDaGlsZC5zdHlsZS5oZWlnaHQgPSBcIjBcIjtcbiAgICAgIH1cbiAgICAgIGlmIChuZWVkc0gpIHtcbiAgICAgICAgdGhpcy5ob3Jpei5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICB0aGlzLmhvcml6LnN0eWxlLnJpZ2h0ID0gbmVlZHNWID8gc1dpZHRoICsgXCJweFwiIDogXCIwXCI7XG4gICAgICAgIHRoaXMuaG9yaXouc3R5bGUubGVmdCA9IG1lYXN1cmUuYmFyTGVmdCArIFwicHhcIjtcbiAgICAgICAgdmFyIHRvdGFsV2lkdGggPSBtZWFzdXJlLnZpZXdXaWR0aCAtIG1lYXN1cmUuYmFyTGVmdCAtIChuZWVkc1YgPyBzV2lkdGggOiAwKTtcbiAgICAgICAgdGhpcy5ob3Jpei5maXJzdENoaWxkLnN0eWxlLndpZHRoID0gTWF0aC5tYXgoMCwgbWVhc3VyZS5zY3JvbGxXaWR0aCAtIG1lYXN1cmUuY2xpZW50V2lkdGggKyB0b3RhbFdpZHRoKSArIFwicHhcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaG9yaXouc3R5bGUuZGlzcGxheSA9IFwiXCI7XG4gICAgICAgIHRoaXMuaG9yaXouZmlyc3RDaGlsZC5zdHlsZS53aWR0aCA9IFwiMFwiO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmNoZWNrZWRaZXJvV2lkdGggJiYgbWVhc3VyZS5jbGllbnRIZWlnaHQgPiAwKSB7XG4gICAgICAgIGlmIChzV2lkdGggPT0gMCkge1xuICAgICAgICAgIHRoaXMuemVyb1dpZHRoSGFjaygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hlY2tlZFplcm9XaWR0aCA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4geyByaWdodDogbmVlZHNWID8gc1dpZHRoIDogMCwgYm90dG9tOiBuZWVkc0ggPyBzV2lkdGggOiAwIH07XG4gICAgfTtcbiAgICBOYXRpdmVTY3JvbGxiYXJzLnByb3RvdHlwZS5zZXRTY3JvbGxMZWZ0ID0gZnVuY3Rpb24ocG9zKSB7XG4gICAgICBpZiAodGhpcy5ob3Jpei5zY3JvbGxMZWZ0ICE9IHBvcykge1xuICAgICAgICB0aGlzLmhvcml6LnNjcm9sbExlZnQgPSBwb3M7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5kaXNhYmxlSG9yaXopIHtcbiAgICAgICAgdGhpcy5lbmFibGVaZXJvV2lkdGhCYXIodGhpcy5ob3JpeiwgdGhpcy5kaXNhYmxlSG9yaXosIFwiaG9yaXpcIik7XG4gICAgICB9XG4gICAgfTtcbiAgICBOYXRpdmVTY3JvbGxiYXJzLnByb3RvdHlwZS5zZXRTY3JvbGxUb3AgPSBmdW5jdGlvbihwb3MpIHtcbiAgICAgIGlmICh0aGlzLnZlcnQuc2Nyb2xsVG9wICE9IHBvcykge1xuICAgICAgICB0aGlzLnZlcnQuc2Nyb2xsVG9wID0gcG9zO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZGlzYWJsZVZlcnQpIHtcbiAgICAgICAgdGhpcy5lbmFibGVaZXJvV2lkdGhCYXIodGhpcy52ZXJ0LCB0aGlzLmRpc2FibGVWZXJ0LCBcInZlcnRcIik7XG4gICAgICB9XG4gICAgfTtcbiAgICBOYXRpdmVTY3JvbGxiYXJzLnByb3RvdHlwZS56ZXJvV2lkdGhIYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdyA9IG1hYyAmJiAhbWFjX2dlTW91bnRhaW5MaW9uID8gXCIxMnB4XCIgOiBcIjE4cHhcIjtcbiAgICAgIHRoaXMuaG9yaXouc3R5bGUuaGVpZ2h0ID0gdGhpcy52ZXJ0LnN0eWxlLndpZHRoID0gdztcbiAgICAgIHRoaXMuaG9yaXouc3R5bGUucG9pbnRlckV2ZW50cyA9IHRoaXMudmVydC5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7XG4gICAgICB0aGlzLmRpc2FibGVIb3JpeiA9IG5ldyBEZWxheWVkKCk7XG4gICAgICB0aGlzLmRpc2FibGVWZXJ0ID0gbmV3IERlbGF5ZWQoKTtcbiAgICB9O1xuICAgIE5hdGl2ZVNjcm9sbGJhcnMucHJvdG90eXBlLmVuYWJsZVplcm9XaWR0aEJhciA9IGZ1bmN0aW9uKGJhciwgZGVsYXksIHR5cGUpIHtcbiAgICAgIGJhci5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJhdXRvXCI7XG4gICAgICBmdW5jdGlvbiBtYXliZURpc2FibGUoKSB7XG4gICAgICAgIHZhciBib3ggPSBiYXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBlbHQyID0gdHlwZSA9PSBcInZlcnRcIiA/IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoYm94LnJpZ2h0IC0gMSwgKGJveC50b3AgKyBib3guYm90dG9tKSAvIDIpIDogZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCgoYm94LnJpZ2h0ICsgYm94LmxlZnQpIC8gMiwgYm94LmJvdHRvbSAtIDEpO1xuICAgICAgICBpZiAoZWx0MiAhPSBiYXIpIHtcbiAgICAgICAgICBiYXIuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGF5LnNldCgxZTMsIG1heWJlRGlzYWJsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF9fbmFtZShtYXliZURpc2FibGUsIFwibWF5YmVEaXNhYmxlXCIpO1xuICAgICAgZGVsYXkuc2V0KDFlMywgbWF5YmVEaXNhYmxlKTtcbiAgICB9O1xuICAgIE5hdGl2ZVNjcm9sbGJhcnMucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpcy5ob3Jpei5wYXJlbnROb2RlO1xuICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKHRoaXMuaG9yaXopO1xuICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKHRoaXMudmVydCk7XG4gICAgfTtcbiAgICB2YXIgTnVsbFNjcm9sbGJhcnMgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKCkge1xuICAgIH0sIFwiTnVsbFNjcm9sbGJhcnNcIik7XG4gICAgTnVsbFNjcm9sbGJhcnMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHsgYm90dG9tOiAwLCByaWdodDogMCB9O1xuICAgIH07XG4gICAgTnVsbFNjcm9sbGJhcnMucHJvdG90eXBlLnNldFNjcm9sbExlZnQgPSBmdW5jdGlvbigpIHtcbiAgICB9O1xuICAgIE51bGxTY3JvbGxiYXJzLnByb3RvdHlwZS5zZXRTY3JvbGxUb3AgPSBmdW5jdGlvbigpIHtcbiAgICB9O1xuICAgIE51bGxTY3JvbGxiYXJzLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgIH07XG4gICAgZnVuY3Rpb24gdXBkYXRlU2Nyb2xsYmFycyhjbSwgbWVhc3VyZSkge1xuICAgICAgaWYgKCFtZWFzdXJlKSB7XG4gICAgICAgIG1lYXN1cmUgPSBtZWFzdXJlRm9yU2Nyb2xsYmFycyhjbSk7XG4gICAgICB9XG4gICAgICB2YXIgc3RhcnRXaWR0aCA9IGNtLmRpc3BsYXkuYmFyV2lkdGgsIHN0YXJ0SGVpZ2h0ID0gY20uZGlzcGxheS5iYXJIZWlnaHQ7XG4gICAgICB1cGRhdGVTY3JvbGxiYXJzSW5uZXIoY20sIG1lYXN1cmUpO1xuICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IDQgJiYgc3RhcnRXaWR0aCAhPSBjbS5kaXNwbGF5LmJhcldpZHRoIHx8IHN0YXJ0SGVpZ2h0ICE9IGNtLmRpc3BsYXkuYmFySGVpZ2h0OyBpMisrKSB7XG4gICAgICAgIGlmIChzdGFydFdpZHRoICE9IGNtLmRpc3BsYXkuYmFyV2lkdGggJiYgY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHtcbiAgICAgICAgICB1cGRhdGVIZWlnaHRzSW5WaWV3cG9ydChjbSk7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlU2Nyb2xsYmFyc0lubmVyKGNtLCBtZWFzdXJlRm9yU2Nyb2xsYmFycyhjbSkpO1xuICAgICAgICBzdGFydFdpZHRoID0gY20uZGlzcGxheS5iYXJXaWR0aDtcbiAgICAgICAgc3RhcnRIZWlnaHQgPSBjbS5kaXNwbGF5LmJhckhlaWdodDtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKHVwZGF0ZVNjcm9sbGJhcnMsIFwidXBkYXRlU2Nyb2xsYmFyc1wiKTtcbiAgICBmdW5jdGlvbiB1cGRhdGVTY3JvbGxiYXJzSW5uZXIoY20sIG1lYXN1cmUpIHtcbiAgICAgIHZhciBkID0gY20uZGlzcGxheTtcbiAgICAgIHZhciBzaXplcyA9IGQuc2Nyb2xsYmFycy51cGRhdGUobWVhc3VyZSk7XG4gICAgICBkLnNpemVyLnN0eWxlLnBhZGRpbmdSaWdodCA9IChkLmJhcldpZHRoID0gc2l6ZXMucmlnaHQpICsgXCJweFwiO1xuICAgICAgZC5zaXplci5zdHlsZS5wYWRkaW5nQm90dG9tID0gKGQuYmFySGVpZ2h0ID0gc2l6ZXMuYm90dG9tKSArIFwicHhcIjtcbiAgICAgIGQuaGVpZ2h0Rm9yY2VyLnN0eWxlLmJvcmRlckJvdHRvbSA9IHNpemVzLmJvdHRvbSArIFwicHggc29saWQgdHJhbnNwYXJlbnRcIjtcbiAgICAgIGlmIChzaXplcy5yaWdodCAmJiBzaXplcy5ib3R0b20pIHtcbiAgICAgICAgZC5zY3JvbGxiYXJGaWxsZXIuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgZC5zY3JvbGxiYXJGaWxsZXIuc3R5bGUuaGVpZ2h0ID0gc2l6ZXMuYm90dG9tICsgXCJweFwiO1xuICAgICAgICBkLnNjcm9sbGJhckZpbGxlci5zdHlsZS53aWR0aCA9IHNpemVzLnJpZ2h0ICsgXCJweFwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZC5zY3JvbGxiYXJGaWxsZXIuc3R5bGUuZGlzcGxheSA9IFwiXCI7XG4gICAgICB9XG4gICAgICBpZiAoc2l6ZXMuYm90dG9tICYmIGNtLm9wdGlvbnMuY292ZXJHdXR0ZXJOZXh0VG9TY3JvbGxiYXIgJiYgY20ub3B0aW9ucy5maXhlZEd1dHRlcikge1xuICAgICAgICBkLmd1dHRlckZpbGxlci5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICBkLmd1dHRlckZpbGxlci5zdHlsZS5oZWlnaHQgPSBzaXplcy5ib3R0b20gKyBcInB4XCI7XG4gICAgICAgIGQuZ3V0dGVyRmlsbGVyLnN0eWxlLndpZHRoID0gbWVhc3VyZS5ndXR0ZXJXaWR0aCArIFwicHhcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGQuZ3V0dGVyRmlsbGVyLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUodXBkYXRlU2Nyb2xsYmFyc0lubmVyLCBcInVwZGF0ZVNjcm9sbGJhcnNJbm5lclwiKTtcbiAgICB2YXIgc2Nyb2xsYmFyTW9kZWwgPSB7IFwibmF0aXZlXCI6IE5hdGl2ZVNjcm9sbGJhcnMsIFwibnVsbFwiOiBOdWxsU2Nyb2xsYmFycyB9O1xuICAgIGZ1bmN0aW9uIGluaXRTY3JvbGxiYXJzKGNtKSB7XG4gICAgICBpZiAoY20uZGlzcGxheS5zY3JvbGxiYXJzKSB7XG4gICAgICAgIGNtLmRpc3BsYXkuc2Nyb2xsYmFycy5jbGVhcigpO1xuICAgICAgICBpZiAoY20uZGlzcGxheS5zY3JvbGxiYXJzLmFkZENsYXNzKSB7XG4gICAgICAgICAgcm1DbGFzcyhjbS5kaXNwbGF5LndyYXBwZXIsIGNtLmRpc3BsYXkuc2Nyb2xsYmFycy5hZGRDbGFzcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNtLmRpc3BsYXkuc2Nyb2xsYmFycyA9IG5ldyBzY3JvbGxiYXJNb2RlbFtjbS5vcHRpb25zLnNjcm9sbGJhclN0eWxlXShmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIGNtLmRpc3BsYXkud3JhcHBlci5pbnNlcnRCZWZvcmUobm9kZSwgY20uZGlzcGxheS5zY3JvbGxiYXJGaWxsZXIpO1xuICAgICAgICBvbihub2RlLCBcIm1vdXNlZG93blwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoY20uc3RhdGUuZm9jdXNlZCkge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNtLmRpc3BsYXkuaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiY20tbm90LWNvbnRlbnRcIiwgXCJ0cnVlXCIpO1xuICAgICAgfSwgZnVuY3Rpb24ocG9zLCBheGlzKSB7XG4gICAgICAgIGlmIChheGlzID09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICAgICAgc2V0U2Nyb2xsTGVmdChjbSwgcG9zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1cGRhdGVTY3JvbGxUb3AoY20sIHBvcyk7XG4gICAgICAgIH1cbiAgICAgIH0sIGNtKTtcbiAgICAgIGlmIChjbS5kaXNwbGF5LnNjcm9sbGJhcnMuYWRkQ2xhc3MpIHtcbiAgICAgICAgYWRkQ2xhc3MoY20uZGlzcGxheS53cmFwcGVyLCBjbS5kaXNwbGF5LnNjcm9sbGJhcnMuYWRkQ2xhc3MpO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoaW5pdFNjcm9sbGJhcnMsIFwiaW5pdFNjcm9sbGJhcnNcIik7XG4gICAgdmFyIG5leHRPcElkID0gMDtcbiAgICBmdW5jdGlvbiBzdGFydE9wZXJhdGlvbihjbSkge1xuICAgICAgY20uY3VyT3AgPSB7XG4gICAgICAgIGNtLFxuICAgICAgICB2aWV3Q2hhbmdlZDogZmFsc2UsXG4gICAgICAgIHN0YXJ0SGVpZ2h0OiBjbS5kb2MuaGVpZ2h0LFxuICAgICAgICBmb3JjZVVwZGF0ZTogZmFsc2UsXG4gICAgICAgIHVwZGF0ZUlucHV0OiAwLFxuICAgICAgICB0eXBpbmc6IGZhbHNlLFxuICAgICAgICBjaGFuZ2VPYmpzOiBudWxsLFxuICAgICAgICBjdXJzb3JBY3Rpdml0eUhhbmRsZXJzOiBudWxsLFxuICAgICAgICBjdXJzb3JBY3Rpdml0eUNhbGxlZDogMCxcbiAgICAgICAgc2VsZWN0aW9uQ2hhbmdlZDogZmFsc2UsXG4gICAgICAgIHVwZGF0ZU1heExpbmU6IGZhbHNlLFxuICAgICAgICBzY3JvbGxMZWZ0OiBudWxsLFxuICAgICAgICBzY3JvbGxUb3A6IG51bGwsXG4gICAgICAgIHNjcm9sbFRvUG9zOiBudWxsLFxuICAgICAgICBmb2N1czogZmFsc2UsXG4gICAgICAgIGlkOiArK25leHRPcElkLFxuICAgICAgICBtYXJrQXJyYXlzOiBudWxsXG4gICAgICB9O1xuICAgICAgcHVzaE9wZXJhdGlvbihjbS5jdXJPcCk7XG4gICAgfVxuICAgIF9fbmFtZShzdGFydE9wZXJhdGlvbiwgXCJzdGFydE9wZXJhdGlvblwiKTtcbiAgICBmdW5jdGlvbiBlbmRPcGVyYXRpb24oY20pIHtcbiAgICAgIHZhciBvcCA9IGNtLmN1ck9wO1xuICAgICAgaWYgKG9wKSB7XG4gICAgICAgIGZpbmlzaE9wZXJhdGlvbihvcCwgZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgZ3JvdXAub3BzLmxlbmd0aDsgaTIrKykge1xuICAgICAgICAgICAgZ3JvdXAub3BzW2kyXS5jbS5jdXJPcCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVuZE9wZXJhdGlvbnMoZ3JvdXApO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKGVuZE9wZXJhdGlvbiwgXCJlbmRPcGVyYXRpb25cIik7XG4gICAgZnVuY3Rpb24gZW5kT3BlcmF0aW9ucyhncm91cCkge1xuICAgICAgdmFyIG9wcyA9IGdyb3VwLm9wcztcbiAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBvcHMubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgIGVuZE9wZXJhdGlvbl9SMShvcHNbaTJdKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkkMTIgPSAwOyBpJDEyIDwgb3BzLmxlbmd0aDsgaSQxMisrKSB7XG4gICAgICAgIGVuZE9wZXJhdGlvbl9XMShvcHNbaSQxMl0pO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSQyMiA9IDA7IGkkMjIgPCBvcHMubGVuZ3RoOyBpJDIyKyspIHtcbiAgICAgICAgZW5kT3BlcmF0aW9uX1IyKG9wc1tpJDIyXSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpJDMgPSAwOyBpJDMgPCBvcHMubGVuZ3RoOyBpJDMrKykge1xuICAgICAgICBlbmRPcGVyYXRpb25fVzIob3BzW2kkM10pO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSQ0ID0gMDsgaSQ0IDwgb3BzLmxlbmd0aDsgaSQ0KyspIHtcbiAgICAgICAgZW5kT3BlcmF0aW9uX2ZpbmlzaChvcHNbaSQ0XSk7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShlbmRPcGVyYXRpb25zLCBcImVuZE9wZXJhdGlvbnNcIik7XG4gICAgZnVuY3Rpb24gZW5kT3BlcmF0aW9uX1IxKG9wKSB7XG4gICAgICB2YXIgY20gPSBvcC5jbSwgZGlzcGxheSA9IGNtLmRpc3BsYXk7XG4gICAgICBtYXliZUNsaXBTY3JvbGxiYXJzKGNtKTtcbiAgICAgIGlmIChvcC51cGRhdGVNYXhMaW5lKSB7XG4gICAgICAgIGZpbmRNYXhMaW5lKGNtKTtcbiAgICAgIH1cbiAgICAgIG9wLm11c3RVcGRhdGUgPSBvcC52aWV3Q2hhbmdlZCB8fCBvcC5mb3JjZVVwZGF0ZSB8fCBvcC5zY3JvbGxUb3AgIT0gbnVsbCB8fCBvcC5zY3JvbGxUb1BvcyAmJiAob3Auc2Nyb2xsVG9Qb3MuZnJvbS5saW5lIDwgZGlzcGxheS52aWV3RnJvbSB8fCBvcC5zY3JvbGxUb1Bvcy50by5saW5lID49IGRpc3BsYXkudmlld1RvKSB8fCBkaXNwbGF5Lm1heExpbmVDaGFuZ2VkICYmIGNtLm9wdGlvbnMubGluZVdyYXBwaW5nO1xuICAgICAgb3AudXBkYXRlID0gb3AubXVzdFVwZGF0ZSAmJiBuZXcgRGlzcGxheVVwZGF0ZShjbSwgb3AubXVzdFVwZGF0ZSAmJiB7IHRvcDogb3Auc2Nyb2xsVG9wLCBlbnN1cmU6IG9wLnNjcm9sbFRvUG9zIH0sIG9wLmZvcmNlVXBkYXRlKTtcbiAgICB9XG4gICAgX19uYW1lKGVuZE9wZXJhdGlvbl9SMSwgXCJlbmRPcGVyYXRpb25fUjFcIik7XG4gICAgZnVuY3Rpb24gZW5kT3BlcmF0aW9uX1cxKG9wKSB7XG4gICAgICBvcC51cGRhdGVkRGlzcGxheSA9IG9wLm11c3RVcGRhdGUgJiYgdXBkYXRlRGlzcGxheUlmTmVlZGVkKG9wLmNtLCBvcC51cGRhdGUpO1xuICAgIH1cbiAgICBfX25hbWUoZW5kT3BlcmF0aW9uX1cxLCBcImVuZE9wZXJhdGlvbl9XMVwiKTtcbiAgICBmdW5jdGlvbiBlbmRPcGVyYXRpb25fUjIob3ApIHtcbiAgICAgIHZhciBjbSA9IG9wLmNtLCBkaXNwbGF5ID0gY20uZGlzcGxheTtcbiAgICAgIGlmIChvcC51cGRhdGVkRGlzcGxheSkge1xuICAgICAgICB1cGRhdGVIZWlnaHRzSW5WaWV3cG9ydChjbSk7XG4gICAgICB9XG4gICAgICBvcC5iYXJNZWFzdXJlID0gbWVhc3VyZUZvclNjcm9sbGJhcnMoY20pO1xuICAgICAgaWYgKGRpc3BsYXkubWF4TGluZUNoYW5nZWQgJiYgIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7XG4gICAgICAgIG9wLmFkanVzdFdpZHRoVG8gPSBtZWFzdXJlQ2hhcihjbSwgZGlzcGxheS5tYXhMaW5lLCBkaXNwbGF5Lm1heExpbmUudGV4dC5sZW5ndGgpLmxlZnQgKyAzO1xuICAgICAgICBjbS5kaXNwbGF5LnNpemVyV2lkdGggPSBvcC5hZGp1c3RXaWR0aFRvO1xuICAgICAgICBvcC5iYXJNZWFzdXJlLnNjcm9sbFdpZHRoID0gTWF0aC5tYXgoZGlzcGxheS5zY3JvbGxlci5jbGllbnRXaWR0aCwgZGlzcGxheS5zaXplci5vZmZzZXRMZWZ0ICsgb3AuYWRqdXN0V2lkdGhUbyArIHNjcm9sbEdhcChjbSkgKyBjbS5kaXNwbGF5LmJhcldpZHRoKTtcbiAgICAgICAgb3AubWF4U2Nyb2xsTGVmdCA9IE1hdGgubWF4KDAsIGRpc3BsYXkuc2l6ZXIub2Zmc2V0TGVmdCArIG9wLmFkanVzdFdpZHRoVG8gLSBkaXNwbGF5V2lkdGgoY20pKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcC51cGRhdGVkRGlzcGxheSB8fCBvcC5zZWxlY3Rpb25DaGFuZ2VkKSB7XG4gICAgICAgIG9wLnByZXBhcmVkU2VsZWN0aW9uID0gZGlzcGxheS5pbnB1dC5wcmVwYXJlU2VsZWN0aW9uKCk7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShlbmRPcGVyYXRpb25fUjIsIFwiZW5kT3BlcmF0aW9uX1IyXCIpO1xuICAgIGZ1bmN0aW9uIGVuZE9wZXJhdGlvbl9XMihvcCkge1xuICAgICAgdmFyIGNtID0gb3AuY207XG4gICAgICBpZiAob3AuYWRqdXN0V2lkdGhUbyAhPSBudWxsKSB7XG4gICAgICAgIGNtLmRpc3BsYXkuc2l6ZXIuc3R5bGUubWluV2lkdGggPSBvcC5hZGp1c3RXaWR0aFRvICsgXCJweFwiO1xuICAgICAgICBpZiAob3AubWF4U2Nyb2xsTGVmdCA8IGNtLmRvYy5zY3JvbGxMZWZ0KSB7XG4gICAgICAgICAgc2V0U2Nyb2xsTGVmdChjbSwgTWF0aC5taW4oY20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxMZWZ0LCBvcC5tYXhTY3JvbGxMZWZ0KSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY20uZGlzcGxheS5tYXhMaW5lQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHRha2VGb2N1cyA9IG9wLmZvY3VzICYmIG9wLmZvY3VzID09IGFjdGl2ZUVsdCgpO1xuICAgICAgaWYgKG9wLnByZXBhcmVkU2VsZWN0aW9uKSB7XG4gICAgICAgIGNtLmRpc3BsYXkuaW5wdXQuc2hvd1NlbGVjdGlvbihvcC5wcmVwYXJlZFNlbGVjdGlvbiwgdGFrZUZvY3VzKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcC51cGRhdGVkRGlzcGxheSB8fCBvcC5zdGFydEhlaWdodCAhPSBjbS5kb2MuaGVpZ2h0KSB7XG4gICAgICAgIHVwZGF0ZVNjcm9sbGJhcnMoY20sIG9wLmJhck1lYXN1cmUpO1xuICAgICAgfVxuICAgICAgaWYgKG9wLnVwZGF0ZWREaXNwbGF5KSB7XG4gICAgICAgIHNldERvY3VtZW50SGVpZ2h0KGNtLCBvcC5iYXJNZWFzdXJlKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcC5zZWxlY3Rpb25DaGFuZ2VkKSB7XG4gICAgICAgIHJlc3RhcnRCbGluayhjbSk7XG4gICAgICB9XG4gICAgICBpZiAoY20uc3RhdGUuZm9jdXNlZCAmJiBvcC51cGRhdGVJbnB1dCkge1xuICAgICAgICBjbS5kaXNwbGF5LmlucHV0LnJlc2V0KG9wLnR5cGluZyk7XG4gICAgICB9XG4gICAgICBpZiAodGFrZUZvY3VzKSB7XG4gICAgICAgIGVuc3VyZUZvY3VzKG9wLmNtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKGVuZE9wZXJhdGlvbl9XMiwgXCJlbmRPcGVyYXRpb25fVzJcIik7XG4gICAgZnVuY3Rpb24gZW5kT3BlcmF0aW9uX2ZpbmlzaChvcCkge1xuICAgICAgdmFyIGNtID0gb3AuY20sIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBkb2MgPSBjbS5kb2M7XG4gICAgICBpZiAob3AudXBkYXRlZERpc3BsYXkpIHtcbiAgICAgICAgcG9zdFVwZGF0ZURpc3BsYXkoY20sIG9wLnVwZGF0ZSk7XG4gICAgICB9XG4gICAgICBpZiAoZGlzcGxheS53aGVlbFN0YXJ0WCAhPSBudWxsICYmIChvcC5zY3JvbGxUb3AgIT0gbnVsbCB8fCBvcC5zY3JvbGxMZWZ0ICE9IG51bGwgfHwgb3Auc2Nyb2xsVG9Qb3MpKSB7XG4gICAgICAgIGRpc3BsYXkud2hlZWxTdGFydFggPSBkaXNwbGF5LndoZWVsU3RhcnRZID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChvcC5zY3JvbGxUb3AgIT0gbnVsbCkge1xuICAgICAgICBzZXRTY3JvbGxUb3AoY20sIG9wLnNjcm9sbFRvcCwgb3AuZm9yY2VTY3JvbGwpO1xuICAgICAgfVxuICAgICAgaWYgKG9wLnNjcm9sbExlZnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRTY3JvbGxMZWZ0KGNtLCBvcC5zY3JvbGxMZWZ0LCB0cnVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcC5zY3JvbGxUb1Bvcykge1xuICAgICAgICB2YXIgcmVjdCA9IHNjcm9sbFBvc0ludG9WaWV3KGNtLCBjbGlwUG9zKGRvYywgb3Auc2Nyb2xsVG9Qb3MuZnJvbSksIGNsaXBQb3MoZG9jLCBvcC5zY3JvbGxUb1Bvcy50byksIG9wLnNjcm9sbFRvUG9zLm1hcmdpbik7XG4gICAgICAgIG1heWJlU2Nyb2xsV2luZG93KGNtLCByZWN0KTtcbiAgICAgIH1cbiAgICAgIHZhciBoaWRkZW4gPSBvcC5tYXliZUhpZGRlbk1hcmtlcnMsIHVuaGlkZGVuID0gb3AubWF5YmVVbmhpZGRlbk1hcmtlcnM7XG4gICAgICBpZiAoaGlkZGVuKSB7XG4gICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBoaWRkZW4ubGVuZ3RoOyArK2kyKSB7XG4gICAgICAgICAgaWYgKCFoaWRkZW5baTJdLmxpbmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgc2lnbmFsKGhpZGRlbltpMl0sIFwiaGlkZVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh1bmhpZGRlbikge1xuICAgICAgICBmb3IgKHZhciBpJDEyID0gMDsgaSQxMiA8IHVuaGlkZGVuLmxlbmd0aDsgKytpJDEyKSB7XG4gICAgICAgICAgaWYgKHVuaGlkZGVuW2kkMTJdLmxpbmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgc2lnbmFsKHVuaGlkZGVuW2kkMTJdLCBcInVuaGlkZVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkaXNwbGF5LndyYXBwZXIub2Zmc2V0SGVpZ2h0KSB7XG4gICAgICAgIGRvYy5zY3JvbGxUb3AgPSBjbS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcDtcbiAgICAgIH1cbiAgICAgIGlmIChvcC5jaGFuZ2VPYmpzKSB7XG4gICAgICAgIHNpZ25hbChjbSwgXCJjaGFuZ2VzXCIsIGNtLCBvcC5jaGFuZ2VPYmpzKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcC51cGRhdGUpIHtcbiAgICAgICAgb3AudXBkYXRlLmZpbmlzaCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoZW5kT3BlcmF0aW9uX2ZpbmlzaCwgXCJlbmRPcGVyYXRpb25fZmluaXNoXCIpO1xuICAgIGZ1bmN0aW9uIHJ1bkluT3AoY20sIGYpIHtcbiAgICAgIGlmIChjbS5jdXJPcCkge1xuICAgICAgICByZXR1cm4gZigpO1xuICAgICAgfVxuICAgICAgc3RhcnRPcGVyYXRpb24oY20pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGYoKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGVuZE9wZXJhdGlvbihjbSk7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShydW5Jbk9wLCBcInJ1bkluT3BcIik7XG4gICAgZnVuY3Rpb24gb3BlcmF0aW9uKGNtLCBmKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChjbS5jdXJPcCkge1xuICAgICAgICAgIHJldHVybiBmLmFwcGx5KGNtLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0T3BlcmF0aW9uKGNtKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gZi5hcHBseShjbSwgYXJndW1lbnRzKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBlbmRPcGVyYXRpb24oY20pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBfX25hbWUob3BlcmF0aW9uLCBcIm9wZXJhdGlvblwiKTtcbiAgICBmdW5jdGlvbiBtZXRob2RPcChmKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmN1ck9wKSB7XG4gICAgICAgICAgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBzdGFydE9wZXJhdGlvbih0aGlzKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGVuZE9wZXJhdGlvbih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgX19uYW1lKG1ldGhvZE9wLCBcIm1ldGhvZE9wXCIpO1xuICAgIGZ1bmN0aW9uIGRvY01ldGhvZE9wKGYpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNtID0gdGhpcy5jbTtcbiAgICAgICAgaWYgKCFjbSB8fCBjbS5jdXJPcCkge1xuICAgICAgICAgIHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhcnRPcGVyYXRpb24oY20pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgZW5kT3BlcmF0aW9uKGNtKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgX19uYW1lKGRvY01ldGhvZE9wLCBcImRvY01ldGhvZE9wXCIpO1xuICAgIGZ1bmN0aW9uIHN0YXJ0V29ya2VyKGNtLCB0aW1lKSB7XG4gICAgICBpZiAoY20uZG9jLmhpZ2hsaWdodEZyb250aWVyIDwgY20uZGlzcGxheS52aWV3VG8pIHtcbiAgICAgICAgY20uc3RhdGUuaGlnaGxpZ2h0LnNldCh0aW1lLCBiaW5kKGhpZ2hsaWdodFdvcmtlciwgY20pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKHN0YXJ0V29ya2VyLCBcInN0YXJ0V29ya2VyXCIpO1xuICAgIGZ1bmN0aW9uIGhpZ2hsaWdodFdvcmtlcihjbSkge1xuICAgICAgdmFyIGRvYyA9IGNtLmRvYztcbiAgICAgIGlmIChkb2MuaGlnaGxpZ2h0RnJvbnRpZXIgPj0gY20uZGlzcGxheS52aWV3VG8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGVuZCA9ICtuZXcgRGF0ZSgpICsgY20ub3B0aW9ucy53b3JrVGltZTtcbiAgICAgIHZhciBjb250ZXh0ID0gZ2V0Q29udGV4dEJlZm9yZShjbSwgZG9jLmhpZ2hsaWdodEZyb250aWVyKTtcbiAgICAgIHZhciBjaGFuZ2VkTGluZXMgPSBbXTtcbiAgICAgIGRvYy5pdGVyKGNvbnRleHQubGluZSwgTWF0aC5taW4oZG9jLmZpcnN0ICsgZG9jLnNpemUsIGNtLmRpc3BsYXkudmlld1RvICsgNTAwKSwgZnVuY3Rpb24obGluZSkge1xuICAgICAgICBpZiAoY29udGV4dC5saW5lID49IGNtLmRpc3BsYXkudmlld0Zyb20pIHtcbiAgICAgICAgICB2YXIgb2xkU3R5bGVzID0gbGluZS5zdHlsZXM7XG4gICAgICAgICAgdmFyIHJlc2V0U3RhdGUgPSBsaW5lLnRleHQubGVuZ3RoID4gY20ub3B0aW9ucy5tYXhIaWdobGlnaHRMZW5ndGggPyBjb3B5U3RhdGUoZG9jLm1vZGUsIGNvbnRleHQuc3RhdGUpIDogbnVsbDtcbiAgICAgICAgICB2YXIgaGlnaGxpZ2h0ZWQgPSBoaWdobGlnaHRMaW5lKGNtLCBsaW5lLCBjb250ZXh0LCB0cnVlKTtcbiAgICAgICAgICBpZiAocmVzZXRTdGF0ZSkge1xuICAgICAgICAgICAgY29udGV4dC5zdGF0ZSA9IHJlc2V0U3RhdGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxpbmUuc3R5bGVzID0gaGlnaGxpZ2h0ZWQuc3R5bGVzO1xuICAgICAgICAgIHZhciBvbGRDbHMgPSBsaW5lLnN0eWxlQ2xhc3NlcywgbmV3Q2xzID0gaGlnaGxpZ2h0ZWQuY2xhc3NlcztcbiAgICAgICAgICBpZiAobmV3Q2xzKSB7XG4gICAgICAgICAgICBsaW5lLnN0eWxlQ2xhc3NlcyA9IG5ld0NscztcbiAgICAgICAgICB9IGVsc2UgaWYgKG9sZENscykge1xuICAgICAgICAgICAgbGluZS5zdHlsZUNsYXNzZXMgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaXNjaGFuZ2UgPSAhb2xkU3R5bGVzIHx8IG9sZFN0eWxlcy5sZW5ndGggIT0gbGluZS5zdHlsZXMubGVuZ3RoIHx8IG9sZENscyAhPSBuZXdDbHMgJiYgKCFvbGRDbHMgfHwgIW5ld0NscyB8fCBvbGRDbHMuYmdDbGFzcyAhPSBuZXdDbHMuYmdDbGFzcyB8fCBvbGRDbHMudGV4dENsYXNzICE9IG5ld0Nscy50ZXh0Q2xhc3MpO1xuICAgICAgICAgIGZvciAodmFyIGkyID0gMDsgIWlzY2hhbmdlICYmIGkyIDwgb2xkU3R5bGVzLmxlbmd0aDsgKytpMikge1xuICAgICAgICAgICAgaXNjaGFuZ2UgPSBvbGRTdHlsZXNbaTJdICE9IGxpbmUuc3R5bGVzW2kyXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzY2hhbmdlKSB7XG4gICAgICAgICAgICBjaGFuZ2VkTGluZXMucHVzaChjb250ZXh0LmxpbmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsaW5lLnN0YXRlQWZ0ZXIgPSBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICBjb250ZXh0Lm5leHRMaW5lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGxpbmUudGV4dC5sZW5ndGggPD0gY20ub3B0aW9ucy5tYXhIaWdobGlnaHRMZW5ndGgpIHtcbiAgICAgICAgICAgIHByb2Nlc3NMaW5lKGNtLCBsaW5lLnRleHQsIGNvbnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsaW5lLnN0YXRlQWZ0ZXIgPSBjb250ZXh0LmxpbmUgJSA1ID09IDAgPyBjb250ZXh0LnNhdmUoKSA6IG51bGw7XG4gICAgICAgICAgY29udGV4dC5uZXh0TGluZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgrbmV3IERhdGUoKSA+IGVuZCkge1xuICAgICAgICAgIHN0YXJ0V29ya2VyKGNtLCBjbS5vcHRpb25zLndvcmtEZWxheSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZG9jLmhpZ2hsaWdodEZyb250aWVyID0gY29udGV4dC5saW5lO1xuICAgICAgZG9jLm1vZGVGcm9udGllciA9IE1hdGgubWF4KGRvYy5tb2RlRnJvbnRpZXIsIGNvbnRleHQubGluZSk7XG4gICAgICBpZiAoY2hhbmdlZExpbmVzLmxlbmd0aCkge1xuICAgICAgICBydW5Jbk9wKGNtLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgY2hhbmdlZExpbmVzLmxlbmd0aDsgaTIrKykge1xuICAgICAgICAgICAgcmVnTGluZUNoYW5nZShjbSwgY2hhbmdlZExpbmVzW2kyXSwgXCJ0ZXh0XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShoaWdobGlnaHRXb3JrZXIsIFwiaGlnaGxpZ2h0V29ya2VyXCIpO1xuICAgIHZhciBEaXNwbGF5VXBkYXRlID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbihjbSwgdmlld3BvcnQsIGZvcmNlKSB7XG4gICAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXk7XG4gICAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgICB0aGlzLnZpc2libGUgPSB2aXNpYmxlTGluZXMoZGlzcGxheSwgY20uZG9jLCB2aWV3cG9ydCk7XG4gICAgICB0aGlzLmVkaXRvcklzSGlkZGVuID0gIWRpc3BsYXkud3JhcHBlci5vZmZzZXRXaWR0aDtcbiAgICAgIHRoaXMud3JhcHBlckhlaWdodCA9IGRpc3BsYXkud3JhcHBlci5jbGllbnRIZWlnaHQ7XG4gICAgICB0aGlzLndyYXBwZXJXaWR0aCA9IGRpc3BsYXkud3JhcHBlci5jbGllbnRXaWR0aDtcbiAgICAgIHRoaXMub2xkRGlzcGxheVdpZHRoID0gZGlzcGxheVdpZHRoKGNtKTtcbiAgICAgIHRoaXMuZm9yY2UgPSBmb3JjZTtcbiAgICAgIHRoaXMuZGltcyA9IGdldERpbWVuc2lvbnMoY20pO1xuICAgICAgdGhpcy5ldmVudHMgPSBbXTtcbiAgICB9LCBcIkRpc3BsYXlVcGRhdGVcIik7XG4gICAgRGlzcGxheVVwZGF0ZS5wcm90b3R5cGUuc2lnbmFsID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICAgICAgaWYgKGhhc0hhbmRsZXIoZW1pdHRlciwgdHlwZSkpIHtcbiAgICAgICAgdGhpcy5ldmVudHMucHVzaChhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH07XG4gICAgRGlzcGxheVVwZGF0ZS5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgdGhpcy5ldmVudHMubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgIHNpZ25hbC5hcHBseShudWxsLCB0aGlzLmV2ZW50c1tpMl0pO1xuICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gbWF5YmVDbGlwU2Nyb2xsYmFycyhjbSkge1xuICAgICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xuICAgICAgaWYgKCFkaXNwbGF5LnNjcm9sbGJhcnNDbGlwcGVkICYmIGRpc3BsYXkuc2Nyb2xsZXIub2Zmc2V0V2lkdGgpIHtcbiAgICAgICAgZGlzcGxheS5uYXRpdmVCYXJXaWR0aCA9IGRpc3BsYXkuc2Nyb2xsZXIub2Zmc2V0V2lkdGggLSBkaXNwbGF5LnNjcm9sbGVyLmNsaWVudFdpZHRoO1xuICAgICAgICBkaXNwbGF5LmhlaWdodEZvcmNlci5zdHlsZS5oZWlnaHQgPSBzY3JvbGxHYXAoY20pICsgXCJweFwiO1xuICAgICAgICBkaXNwbGF5LnNpemVyLnN0eWxlLm1hcmdpbkJvdHRvbSA9IC1kaXNwbGF5Lm5hdGl2ZUJhcldpZHRoICsgXCJweFwiO1xuICAgICAgICBkaXNwbGF5LnNpemVyLnN0eWxlLmJvcmRlclJpZ2h0V2lkdGggPSBzY3JvbGxHYXAoY20pICsgXCJweFwiO1xuICAgICAgICBkaXNwbGF5LnNjcm9sbGJhcnNDbGlwcGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKG1heWJlQ2xpcFNjcm9sbGJhcnMsIFwibWF5YmVDbGlwU2Nyb2xsYmFyc1wiKTtcbiAgICBmdW5jdGlvbiBzZWxlY3Rpb25TbmFwc2hvdChjbSkge1xuICAgICAgaWYgKGNtLmhhc0ZvY3VzKCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgYWN0aXZlID0gYWN0aXZlRWx0KCk7XG4gICAgICBpZiAoIWFjdGl2ZSB8fCAhY29udGFpbnMoY20uZGlzcGxheS5saW5lRGl2LCBhY3RpdmUpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHsgYWN0aXZlRWx0OiBhY3RpdmUgfTtcbiAgICAgIGlmICh3aW5kb3cuZ2V0U2VsZWN0aW9uKSB7XG4gICAgICAgIHZhciBzZWwgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIGlmIChzZWwuYW5jaG9yTm9kZSAmJiBzZWwuZXh0ZW5kICYmIGNvbnRhaW5zKGNtLmRpc3BsYXkubGluZURpdiwgc2VsLmFuY2hvck5vZGUpKSB7XG4gICAgICAgICAgcmVzdWx0LmFuY2hvck5vZGUgPSBzZWwuYW5jaG9yTm9kZTtcbiAgICAgICAgICByZXN1bHQuYW5jaG9yT2Zmc2V0ID0gc2VsLmFuY2hvck9mZnNldDtcbiAgICAgICAgICByZXN1bHQuZm9jdXNOb2RlID0gc2VsLmZvY3VzTm9kZTtcbiAgICAgICAgICByZXN1bHQuZm9jdXNPZmZzZXQgPSBzZWwuZm9jdXNPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIF9fbmFtZShzZWxlY3Rpb25TbmFwc2hvdCwgXCJzZWxlY3Rpb25TbmFwc2hvdFwiKTtcbiAgICBmdW5jdGlvbiByZXN0b3JlU2VsZWN0aW9uKHNuYXBzaG90KSB7XG4gICAgICBpZiAoIXNuYXBzaG90IHx8ICFzbmFwc2hvdC5hY3RpdmVFbHQgfHwgc25hcHNob3QuYWN0aXZlRWx0ID09IGFjdGl2ZUVsdCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNuYXBzaG90LmFjdGl2ZUVsdC5mb2N1cygpO1xuICAgICAgaWYgKCEvXihJTlBVVHxURVhUQVJFQSkkLy50ZXN0KHNuYXBzaG90LmFjdGl2ZUVsdC5ub2RlTmFtZSkgJiYgc25hcHNob3QuYW5jaG9yTm9kZSAmJiBjb250YWlucyhkb2N1bWVudC5ib2R5LCBzbmFwc2hvdC5hbmNob3JOb2RlKSAmJiBjb250YWlucyhkb2N1bWVudC5ib2R5LCBzbmFwc2hvdC5mb2N1c05vZGUpKSB7XG4gICAgICAgIHZhciBzZWwgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCksIHJhbmdlMiA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgIHJhbmdlMi5zZXRFbmQoc25hcHNob3QuYW5jaG9yTm9kZSwgc25hcHNob3QuYW5jaG9yT2Zmc2V0KTtcbiAgICAgICAgcmFuZ2UyLmNvbGxhcHNlKGZhbHNlKTtcbiAgICAgICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICBzZWwuYWRkUmFuZ2UocmFuZ2UyKTtcbiAgICAgICAgc2VsLmV4dGVuZChzbmFwc2hvdC5mb2N1c05vZGUsIHNuYXBzaG90LmZvY3VzT2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKHJlc3RvcmVTZWxlY3Rpb24sIFwicmVzdG9yZVNlbGVjdGlvblwiKTtcbiAgICBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5SWZOZWVkZWQoY20sIHVwZGF0ZSkge1xuICAgICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBkb2MgPSBjbS5kb2M7XG4gICAgICBpZiAodXBkYXRlLmVkaXRvcklzSGlkZGVuKSB7XG4gICAgICAgIHJlc2V0VmlldyhjbSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghdXBkYXRlLmZvcmNlICYmIHVwZGF0ZS52aXNpYmxlLmZyb20gPj0gZGlzcGxheS52aWV3RnJvbSAmJiB1cGRhdGUudmlzaWJsZS50byA8PSBkaXNwbGF5LnZpZXdUbyAmJiAoZGlzcGxheS51cGRhdGVMaW5lTnVtYmVycyA9PSBudWxsIHx8IGRpc3BsYXkudXBkYXRlTGluZU51bWJlcnMgPj0gZGlzcGxheS52aWV3VG8pICYmIGRpc3BsYXkucmVuZGVyZWRWaWV3ID09IGRpc3BsYXkudmlldyAmJiBjb3VudERpcnR5VmlldyhjbSkgPT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAobWF5YmVVcGRhdGVMaW5lTnVtYmVyV2lkdGgoY20pKSB7XG4gICAgICAgIHJlc2V0VmlldyhjbSk7XG4gICAgICAgIHVwZGF0ZS5kaW1zID0gZ2V0RGltZW5zaW9ucyhjbSk7XG4gICAgICB9XG4gICAgICB2YXIgZW5kID0gZG9jLmZpcnN0ICsgZG9jLnNpemU7XG4gICAgICB2YXIgZnJvbSA9IE1hdGgubWF4KHVwZGF0ZS52aXNpYmxlLmZyb20gLSBjbS5vcHRpb25zLnZpZXdwb3J0TWFyZ2luLCBkb2MuZmlyc3QpO1xuICAgICAgdmFyIHRvID0gTWF0aC5taW4oZW5kLCB1cGRhdGUudmlzaWJsZS50byArIGNtLm9wdGlvbnMudmlld3BvcnRNYXJnaW4pO1xuICAgICAgaWYgKGRpc3BsYXkudmlld0Zyb20gPCBmcm9tICYmIGZyb20gLSBkaXNwbGF5LnZpZXdGcm9tIDwgMjApIHtcbiAgICAgICAgZnJvbSA9IE1hdGgubWF4KGRvYy5maXJzdCwgZGlzcGxheS52aWV3RnJvbSk7XG4gICAgICB9XG4gICAgICBpZiAoZGlzcGxheS52aWV3VG8gPiB0byAmJiBkaXNwbGF5LnZpZXdUbyAtIHRvIDwgMjApIHtcbiAgICAgICAgdG8gPSBNYXRoLm1pbihlbmQsIGRpc3BsYXkudmlld1RvKTtcbiAgICAgIH1cbiAgICAgIGlmIChzYXdDb2xsYXBzZWRTcGFucykge1xuICAgICAgICBmcm9tID0gdmlzdWFsTGluZU5vKGNtLmRvYywgZnJvbSk7XG4gICAgICAgIHRvID0gdmlzdWFsTGluZUVuZE5vKGNtLmRvYywgdG8pO1xuICAgICAgfVxuICAgICAgdmFyIGRpZmZlcmVudCA9IGZyb20gIT0gZGlzcGxheS52aWV3RnJvbSB8fCB0byAhPSBkaXNwbGF5LnZpZXdUbyB8fCBkaXNwbGF5Lmxhc3RXcmFwSGVpZ2h0ICE9IHVwZGF0ZS53cmFwcGVySGVpZ2h0IHx8IGRpc3BsYXkubGFzdFdyYXBXaWR0aCAhPSB1cGRhdGUud3JhcHBlcldpZHRoO1xuICAgICAgYWRqdXN0VmlldyhjbSwgZnJvbSwgdG8pO1xuICAgICAgZGlzcGxheS52aWV3T2Zmc2V0ID0gaGVpZ2h0QXRMaW5lKGdldExpbmUoY20uZG9jLCBkaXNwbGF5LnZpZXdGcm9tKSk7XG4gICAgICBjbS5kaXNwbGF5Lm1vdmVyLnN0eWxlLnRvcCA9IGRpc3BsYXkudmlld09mZnNldCArIFwicHhcIjtcbiAgICAgIHZhciB0b1VwZGF0ZSA9IGNvdW50RGlydHlWaWV3KGNtKTtcbiAgICAgIGlmICghZGlmZmVyZW50ICYmIHRvVXBkYXRlID09IDAgJiYgIXVwZGF0ZS5mb3JjZSAmJiBkaXNwbGF5LnJlbmRlcmVkVmlldyA9PSBkaXNwbGF5LnZpZXcgJiYgKGRpc3BsYXkudXBkYXRlTGluZU51bWJlcnMgPT0gbnVsbCB8fCBkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID49IGRpc3BsYXkudmlld1RvKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgc2VsU25hcHNob3QgPSBzZWxlY3Rpb25TbmFwc2hvdChjbSk7XG4gICAgICBpZiAodG9VcGRhdGUgPiA0KSB7XG4gICAgICAgIGRpc3BsYXkubGluZURpdi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICB9XG4gICAgICBwYXRjaERpc3BsYXkoY20sIGRpc3BsYXkudXBkYXRlTGluZU51bWJlcnMsIHVwZGF0ZS5kaW1zKTtcbiAgICAgIGlmICh0b1VwZGF0ZSA+IDQpIHtcbiAgICAgICAgZGlzcGxheS5saW5lRGl2LnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICAgICAgfVxuICAgICAgZGlzcGxheS5yZW5kZXJlZFZpZXcgPSBkaXNwbGF5LnZpZXc7XG4gICAgICByZXN0b3JlU2VsZWN0aW9uKHNlbFNuYXBzaG90KTtcbiAgICAgIHJlbW92ZUNoaWxkcmVuKGRpc3BsYXkuY3Vyc29yRGl2KTtcbiAgICAgIHJlbW92ZUNoaWxkcmVuKGRpc3BsYXkuc2VsZWN0aW9uRGl2KTtcbiAgICAgIGRpc3BsYXkuZ3V0dGVycy5zdHlsZS5oZWlnaHQgPSBkaXNwbGF5LnNpemVyLnN0eWxlLm1pbkhlaWdodCA9IDA7XG4gICAgICBpZiAoZGlmZmVyZW50KSB7XG4gICAgICAgIGRpc3BsYXkubGFzdFdyYXBIZWlnaHQgPSB1cGRhdGUud3JhcHBlckhlaWdodDtcbiAgICAgICAgZGlzcGxheS5sYXN0V3JhcFdpZHRoID0gdXBkYXRlLndyYXBwZXJXaWR0aDtcbiAgICAgICAgc3RhcnRXb3JrZXIoY20sIDQwMCk7XG4gICAgICB9XG4gICAgICBkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID0gbnVsbDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBfX25hbWUodXBkYXRlRGlzcGxheUlmTmVlZGVkLCBcInVwZGF0ZURpc3BsYXlJZk5lZWRlZFwiKTtcbiAgICBmdW5jdGlvbiBwb3N0VXBkYXRlRGlzcGxheShjbSwgdXBkYXRlKSB7XG4gICAgICB2YXIgdmlld3BvcnQgPSB1cGRhdGUudmlld3BvcnQ7XG4gICAgICBmb3IgKHZhciBmaXJzdCA9IHRydWU7IDsgZmlyc3QgPSBmYWxzZSkge1xuICAgICAgICBpZiAoIWZpcnN0IHx8ICFjbS5vcHRpb25zLmxpbmVXcmFwcGluZyB8fCB1cGRhdGUub2xkRGlzcGxheVdpZHRoID09IGRpc3BsYXlXaWR0aChjbSkpIHtcbiAgICAgICAgICBpZiAodmlld3BvcnQgJiYgdmlld3BvcnQudG9wICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZpZXdwb3J0ID0geyB0b3A6IE1hdGgubWluKGNtLmRvYy5oZWlnaHQgKyBwYWRkaW5nVmVydChjbS5kaXNwbGF5KSAtIGRpc3BsYXlIZWlnaHQoY20pLCB2aWV3cG9ydC50b3ApIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZS52aXNpYmxlID0gdmlzaWJsZUxpbmVzKGNtLmRpc3BsYXksIGNtLmRvYywgdmlld3BvcnQpO1xuICAgICAgICAgIGlmICh1cGRhdGUudmlzaWJsZS5mcm9tID49IGNtLmRpc3BsYXkudmlld0Zyb20gJiYgdXBkYXRlLnZpc2libGUudG8gPD0gY20uZGlzcGxheS52aWV3VG8pIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChmaXJzdCkge1xuICAgICAgICAgIHVwZGF0ZS52aXNpYmxlID0gdmlzaWJsZUxpbmVzKGNtLmRpc3BsYXksIGNtLmRvYywgdmlld3BvcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdXBkYXRlRGlzcGxheUlmTmVlZGVkKGNtLCB1cGRhdGUpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlSGVpZ2h0c0luVmlld3BvcnQoY20pO1xuICAgICAgICB2YXIgYmFyTWVhc3VyZSA9IG1lYXN1cmVGb3JTY3JvbGxiYXJzKGNtKTtcbiAgICAgICAgdXBkYXRlU2VsZWN0aW9uKGNtKTtcbiAgICAgICAgdXBkYXRlU2Nyb2xsYmFycyhjbSwgYmFyTWVhc3VyZSk7XG4gICAgICAgIHNldERvY3VtZW50SGVpZ2h0KGNtLCBiYXJNZWFzdXJlKTtcbiAgICAgICAgdXBkYXRlLmZvcmNlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB1cGRhdGUuc2lnbmFsKGNtLCBcInVwZGF0ZVwiLCBjbSk7XG4gICAgICBpZiAoY20uZGlzcGxheS52aWV3RnJvbSAhPSBjbS5kaXNwbGF5LnJlcG9ydGVkVmlld0Zyb20gfHwgY20uZGlzcGxheS52aWV3VG8gIT0gY20uZGlzcGxheS5yZXBvcnRlZFZpZXdUbykge1xuICAgICAgICB1cGRhdGUuc2lnbmFsKGNtLCBcInZpZXdwb3J0Q2hhbmdlXCIsIGNtLCBjbS5kaXNwbGF5LnZpZXdGcm9tLCBjbS5kaXNwbGF5LnZpZXdUbyk7XG4gICAgICAgIGNtLmRpc3BsYXkucmVwb3J0ZWRWaWV3RnJvbSA9IGNtLmRpc3BsYXkudmlld0Zyb207XG4gICAgICAgIGNtLmRpc3BsYXkucmVwb3J0ZWRWaWV3VG8gPSBjbS5kaXNwbGF5LnZpZXdUbztcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKHBvc3RVcGRhdGVEaXNwbGF5LCBcInBvc3RVcGRhdGVEaXNwbGF5XCIpO1xuICAgIGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXlTaW1wbGUoY20sIHZpZXdwb3J0KSB7XG4gICAgICB2YXIgdXBkYXRlID0gbmV3IERpc3BsYXlVcGRhdGUoY20sIHZpZXdwb3J0KTtcbiAgICAgIGlmICh1cGRhdGVEaXNwbGF5SWZOZWVkZWQoY20sIHVwZGF0ZSkpIHtcbiAgICAgICAgdXBkYXRlSGVpZ2h0c0luVmlld3BvcnQoY20pO1xuICAgICAgICBwb3N0VXBkYXRlRGlzcGxheShjbSwgdXBkYXRlKTtcbiAgICAgICAgdmFyIGJhck1lYXN1cmUgPSBtZWFzdXJlRm9yU2Nyb2xsYmFycyhjbSk7XG4gICAgICAgIHVwZGF0ZVNlbGVjdGlvbihjbSk7XG4gICAgICAgIHVwZGF0ZVNjcm9sbGJhcnMoY20sIGJhck1lYXN1cmUpO1xuICAgICAgICBzZXREb2N1bWVudEhlaWdodChjbSwgYmFyTWVhc3VyZSk7XG4gICAgICAgIHVwZGF0ZS5maW5pc2goKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKHVwZGF0ZURpc3BsYXlTaW1wbGUsIFwidXBkYXRlRGlzcGxheVNpbXBsZVwiKTtcbiAgICBmdW5jdGlvbiBwYXRjaERpc3BsYXkoY20sIHVwZGF0ZU51bWJlcnNGcm9tLCBkaW1zKSB7XG4gICAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIGxpbmVOdW1iZXJzID0gY20ub3B0aW9ucy5saW5lTnVtYmVycztcbiAgICAgIHZhciBjb250YWluZXIgPSBkaXNwbGF5LmxpbmVEaXYsIGN1ciA9IGNvbnRhaW5lci5maXJzdENoaWxkO1xuICAgICAgZnVuY3Rpb24gcm0obm9kZTIpIHtcbiAgICAgICAgdmFyIG5leHQgPSBub2RlMi5uZXh0U2libGluZztcbiAgICAgICAgaWYgKHdlYmtpdCAmJiBtYWMgJiYgY20uZGlzcGxheS5jdXJyZW50V2hlZWxUYXJnZXQgPT0gbm9kZTIpIHtcbiAgICAgICAgICBub2RlMi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZTIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICB9XG4gICAgICBfX25hbWUocm0sIFwicm1cIik7XG4gICAgICB2YXIgdmlldyA9IGRpc3BsYXkudmlldywgbGluZU4gPSBkaXNwbGF5LnZpZXdGcm9tO1xuICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IHZpZXcubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgIHZhciBsaW5lVmlldyA9IHZpZXdbaTJdO1xuICAgICAgICBpZiAobGluZVZpZXcuaGlkZGVuKVxuICAgICAgICAgIDtcbiAgICAgICAgZWxzZSBpZiAoIWxpbmVWaWV3Lm5vZGUgfHwgbGluZVZpZXcubm9kZS5wYXJlbnROb2RlICE9IGNvbnRhaW5lcikge1xuICAgICAgICAgIHZhciBub2RlID0gYnVpbGRMaW5lRWxlbWVudChjbSwgbGluZVZpZXcsIGxpbmVOLCBkaW1zKTtcbiAgICAgICAgICBjb250YWluZXIuaW5zZXJ0QmVmb3JlKG5vZGUsIGN1cik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2hpbGUgKGN1ciAhPSBsaW5lVmlldy5ub2RlKSB7XG4gICAgICAgICAgICBjdXIgPSBybShjdXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdXBkYXRlTnVtYmVyID0gbGluZU51bWJlcnMgJiYgdXBkYXRlTnVtYmVyc0Zyb20gIT0gbnVsbCAmJiB1cGRhdGVOdW1iZXJzRnJvbSA8PSBsaW5lTiAmJiBsaW5lVmlldy5saW5lTnVtYmVyO1xuICAgICAgICAgIGlmIChsaW5lVmlldy5jaGFuZ2VzKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXhPZihsaW5lVmlldy5jaGFuZ2VzLCBcImd1dHRlclwiKSA+IC0xKSB7XG4gICAgICAgICAgICAgIHVwZGF0ZU51bWJlciA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlTGluZUZvckNoYW5nZXMoY20sIGxpbmVWaWV3LCBsaW5lTiwgZGltcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh1cGRhdGVOdW1iZXIpIHtcbiAgICAgICAgICAgIHJlbW92ZUNoaWxkcmVuKGxpbmVWaWV3LmxpbmVOdW1iZXIpO1xuICAgICAgICAgICAgbGluZVZpZXcubGluZU51bWJlci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsaW5lTnVtYmVyRm9yKGNtLm9wdGlvbnMsIGxpbmVOKSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXIgPSBsaW5lVmlldy5ub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICAgIGxpbmVOICs9IGxpbmVWaWV3LnNpemU7XG4gICAgICB9XG4gICAgICB3aGlsZSAoY3VyKSB7XG4gICAgICAgIGN1ciA9IHJtKGN1cik7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShwYXRjaERpc3BsYXksIFwicGF0Y2hEaXNwbGF5XCIpO1xuICAgIGZ1bmN0aW9uIHVwZGF0ZUd1dHRlclNwYWNlKGRpc3BsYXkpIHtcbiAgICAgIHZhciB3aWR0aCA9IGRpc3BsYXkuZ3V0dGVycy5vZmZzZXRXaWR0aDtcbiAgICAgIGRpc3BsYXkuc2l6ZXIuc3R5bGUubWFyZ2luTGVmdCA9IHdpZHRoICsgXCJweFwiO1xuICAgICAgc2lnbmFsTGF0ZXIoZGlzcGxheSwgXCJndXR0ZXJDaGFuZ2VkXCIsIGRpc3BsYXkpO1xuICAgIH1cbiAgICBfX25hbWUodXBkYXRlR3V0dGVyU3BhY2UsIFwidXBkYXRlR3V0dGVyU3BhY2VcIik7XG4gICAgZnVuY3Rpb24gc2V0RG9jdW1lbnRIZWlnaHQoY20sIG1lYXN1cmUpIHtcbiAgICAgIGNtLmRpc3BsYXkuc2l6ZXIuc3R5bGUubWluSGVpZ2h0ID0gbWVhc3VyZS5kb2NIZWlnaHQgKyBcInB4XCI7XG4gICAgICBjbS5kaXNwbGF5LmhlaWdodEZvcmNlci5zdHlsZS50b3AgPSBtZWFzdXJlLmRvY0hlaWdodCArIFwicHhcIjtcbiAgICAgIGNtLmRpc3BsYXkuZ3V0dGVycy5zdHlsZS5oZWlnaHQgPSBtZWFzdXJlLmRvY0hlaWdodCArIGNtLmRpc3BsYXkuYmFySGVpZ2h0ICsgc2Nyb2xsR2FwKGNtKSArIFwicHhcIjtcbiAgICB9XG4gICAgX19uYW1lKHNldERvY3VtZW50SGVpZ2h0LCBcInNldERvY3VtZW50SGVpZ2h0XCIpO1xuICAgIGZ1bmN0aW9uIGFsaWduSG9yaXpvbnRhbGx5KGNtKSB7XG4gICAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIHZpZXcgPSBkaXNwbGF5LnZpZXc7XG4gICAgICBpZiAoIWRpc3BsYXkuYWxpZ25XaWRnZXRzICYmICghZGlzcGxheS5ndXR0ZXJzLmZpcnN0Q2hpbGQgfHwgIWNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBjb21wID0gY29tcGVuc2F0ZUZvckhTY3JvbGwoZGlzcGxheSkgLSBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbExlZnQgKyBjbS5kb2Muc2Nyb2xsTGVmdDtcbiAgICAgIHZhciBndXR0ZXJXID0gZGlzcGxheS5ndXR0ZXJzLm9mZnNldFdpZHRoLCBsZWZ0ID0gY29tcCArIFwicHhcIjtcbiAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCB2aWV3Lmxlbmd0aDsgaTIrKykge1xuICAgICAgICBpZiAoIXZpZXdbaTJdLmhpZGRlbikge1xuICAgICAgICAgIGlmIChjbS5vcHRpb25zLmZpeGVkR3V0dGVyKSB7XG4gICAgICAgICAgICBpZiAodmlld1tpMl0uZ3V0dGVyKSB7XG4gICAgICAgICAgICAgIHZpZXdbaTJdLmd1dHRlci5zdHlsZS5sZWZ0ID0gbGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2aWV3W2kyXS5ndXR0ZXJCYWNrZ3JvdW5kKSB7XG4gICAgICAgICAgICAgIHZpZXdbaTJdLmd1dHRlckJhY2tncm91bmQuc3R5bGUubGVmdCA9IGxlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBhbGlnbiA9IHZpZXdbaTJdLmFsaWduYWJsZTtcbiAgICAgICAgICBpZiAoYWxpZ24pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYWxpZ24ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgYWxpZ25bal0uc3R5bGUubGVmdCA9IGxlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY20ub3B0aW9ucy5maXhlZEd1dHRlcikge1xuICAgICAgICBkaXNwbGF5Lmd1dHRlcnMuc3R5bGUubGVmdCA9IGNvbXAgKyBndXR0ZXJXICsgXCJweFwiO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoYWxpZ25Ib3Jpem9udGFsbHksIFwiYWxpZ25Ib3Jpem9udGFsbHlcIik7XG4gICAgZnVuY3Rpb24gbWF5YmVVcGRhdGVMaW5lTnVtYmVyV2lkdGgoY20pIHtcbiAgICAgIGlmICghY20ub3B0aW9ucy5saW5lTnVtYmVycykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgZG9jID0gY20uZG9jLCBsYXN0ID0gbGluZU51bWJlckZvcihjbS5vcHRpb25zLCBkb2MuZmlyc3QgKyBkb2Muc2l6ZSAtIDEpLCBkaXNwbGF5ID0gY20uZGlzcGxheTtcbiAgICAgIGlmIChsYXN0Lmxlbmd0aCAhPSBkaXNwbGF5LmxpbmVOdW1DaGFycykge1xuICAgICAgICB2YXIgdGVzdCA9IGRpc3BsYXkubWVhc3VyZS5hcHBlbmRDaGlsZChlbHQoXCJkaXZcIiwgW2VsdChcImRpdlwiLCBsYXN0KV0sIFwiQ29kZU1pcnJvci1saW5lbnVtYmVyIENvZGVNaXJyb3ItZ3V0dGVyLWVsdFwiKSk7XG4gICAgICAgIHZhciBpbm5lclcgPSB0ZXN0LmZpcnN0Q2hpbGQub2Zmc2V0V2lkdGgsIHBhZGRpbmcgPSB0ZXN0Lm9mZnNldFdpZHRoIC0gaW5uZXJXO1xuICAgICAgICBkaXNwbGF5LmxpbmVHdXR0ZXIuc3R5bGUud2lkdGggPSBcIlwiO1xuICAgICAgICBkaXNwbGF5LmxpbmVOdW1Jbm5lcldpZHRoID0gTWF0aC5tYXgoaW5uZXJXLCBkaXNwbGF5LmxpbmVHdXR0ZXIub2Zmc2V0V2lkdGggLSBwYWRkaW5nKSArIDE7XG4gICAgICAgIGRpc3BsYXkubGluZU51bVdpZHRoID0gZGlzcGxheS5saW5lTnVtSW5uZXJXaWR0aCArIHBhZGRpbmc7XG4gICAgICAgIGRpc3BsYXkubGluZU51bUNoYXJzID0gZGlzcGxheS5saW5lTnVtSW5uZXJXaWR0aCA/IGxhc3QubGVuZ3RoIDogLTE7XG4gICAgICAgIGRpc3BsYXkubGluZUd1dHRlci5zdHlsZS53aWR0aCA9IGRpc3BsYXkubGluZU51bVdpZHRoICsgXCJweFwiO1xuICAgICAgICB1cGRhdGVHdXR0ZXJTcGFjZShjbS5kaXNwbGF5KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIF9fbmFtZShtYXliZVVwZGF0ZUxpbmVOdW1iZXJXaWR0aCwgXCJtYXliZVVwZGF0ZUxpbmVOdW1iZXJXaWR0aFwiKTtcbiAgICBmdW5jdGlvbiBnZXRHdXR0ZXJzKGd1dHRlcnMsIGxpbmVOdW1iZXJzKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW10sIHNhd0xpbmVOdW1iZXJzID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgZ3V0dGVycy5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgdmFyIG5hbWUgPSBndXR0ZXJzW2kyXSwgc3R5bGUgPSBudWxsO1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHN0eWxlID0gbmFtZS5zdHlsZTtcbiAgICAgICAgICBuYW1lID0gbmFtZS5jbGFzc05hbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUgPT0gXCJDb2RlTWlycm9yLWxpbmVudW1iZXJzXCIpIHtcbiAgICAgICAgICBpZiAoIWxpbmVOdW1iZXJzKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2F3TGluZU51bWJlcnMgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaCh7IGNsYXNzTmFtZTogbmFtZSwgc3R5bGUgfSk7XG4gICAgICB9XG4gICAgICBpZiAobGluZU51bWJlcnMgJiYgIXNhd0xpbmVOdW1iZXJzKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHsgY2xhc3NOYW1lOiBcIkNvZGVNaXJyb3ItbGluZW51bWJlcnNcIiwgc3R5bGU6IG51bGwgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBfX25hbWUoZ2V0R3V0dGVycywgXCJnZXRHdXR0ZXJzXCIpO1xuICAgIGZ1bmN0aW9uIHJlbmRlckd1dHRlcnMoZGlzcGxheSkge1xuICAgICAgdmFyIGd1dHRlcnMgPSBkaXNwbGF5Lmd1dHRlcnMsIHNwZWNzID0gZGlzcGxheS5ndXR0ZXJTcGVjcztcbiAgICAgIHJlbW92ZUNoaWxkcmVuKGd1dHRlcnMpO1xuICAgICAgZGlzcGxheS5saW5lR3V0dGVyID0gbnVsbDtcbiAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBzcGVjcy5sZW5ndGg7ICsraTIpIHtcbiAgICAgICAgdmFyIHJlZiA9IHNwZWNzW2kyXTtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IHJlZi5jbGFzc05hbWU7XG4gICAgICAgIHZhciBzdHlsZSA9IHJlZi5zdHlsZTtcbiAgICAgICAgdmFyIGdFbHQgPSBndXR0ZXJzLmFwcGVuZENoaWxkKGVsdChcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3ItZ3V0dGVyIFwiICsgY2xhc3NOYW1lKSk7XG4gICAgICAgIGlmIChzdHlsZSkge1xuICAgICAgICAgIGdFbHQuc3R5bGUuY3NzVGV4dCA9IHN0eWxlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGFzc05hbWUgPT0gXCJDb2RlTWlycm9yLWxpbmVudW1iZXJzXCIpIHtcbiAgICAgICAgICBkaXNwbGF5LmxpbmVHdXR0ZXIgPSBnRWx0O1xuICAgICAgICAgIGdFbHQuc3R5bGUud2lkdGggPSAoZGlzcGxheS5saW5lTnVtV2lkdGggfHwgMSkgKyBcInB4XCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGd1dHRlcnMuc3R5bGUuZGlzcGxheSA9IHNwZWNzLmxlbmd0aCA/IFwiXCIgOiBcIm5vbmVcIjtcbiAgICAgIHVwZGF0ZUd1dHRlclNwYWNlKGRpc3BsYXkpO1xuICAgIH1cbiAgICBfX25hbWUocmVuZGVyR3V0dGVycywgXCJyZW5kZXJHdXR0ZXJzXCIpO1xuICAgIGZ1bmN0aW9uIHVwZGF0ZUd1dHRlcnMoY20pIHtcbiAgICAgIHJlbmRlckd1dHRlcnMoY20uZGlzcGxheSk7XG4gICAgICByZWdDaGFuZ2UoY20pO1xuICAgICAgYWxpZ25Ib3Jpem9udGFsbHkoY20pO1xuICAgIH1cbiAgICBfX25hbWUodXBkYXRlR3V0dGVycywgXCJ1cGRhdGVHdXR0ZXJzXCIpO1xuICAgIGZ1bmN0aW9uIERpc3BsYXkocGxhY2UsIGRvYywgaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBkID0gdGhpcztcbiAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgIGQuc2Nyb2xsYmFyRmlsbGVyID0gZWx0KFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1zY3JvbGxiYXItZmlsbGVyXCIpO1xuICAgICAgZC5zY3JvbGxiYXJGaWxsZXIuc2V0QXR0cmlidXRlKFwiY20tbm90LWNvbnRlbnRcIiwgXCJ0cnVlXCIpO1xuICAgICAgZC5ndXR0ZXJGaWxsZXIgPSBlbHQoXCJkaXZcIiwgbnVsbCwgXCJDb2RlTWlycm9yLWd1dHRlci1maWxsZXJcIik7XG4gICAgICBkLmd1dHRlckZpbGxlci5zZXRBdHRyaWJ1dGUoXCJjbS1ub3QtY29udGVudFwiLCBcInRydWVcIik7XG4gICAgICBkLmxpbmVEaXYgPSBlbHRQKFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1jb2RlXCIpO1xuICAgICAgZC5zZWxlY3Rpb25EaXYgPSBlbHQoXCJkaXZcIiwgbnVsbCwgbnVsbCwgXCJwb3NpdGlvbjogcmVsYXRpdmU7IHotaW5kZXg6IDFcIik7XG4gICAgICBkLmN1cnNvckRpdiA9IGVsdChcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3ItY3Vyc29yc1wiKTtcbiAgICAgIGQubWVhc3VyZSA9IGVsdChcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3ItbWVhc3VyZVwiKTtcbiAgICAgIGQubGluZU1lYXN1cmUgPSBlbHQoXCJkaXZcIiwgbnVsbCwgXCJDb2RlTWlycm9yLW1lYXN1cmVcIik7XG4gICAgICBkLmxpbmVTcGFjZSA9IGVsdFAoXCJkaXZcIiwgW2QubWVhc3VyZSwgZC5saW5lTWVhc3VyZSwgZC5zZWxlY3Rpb25EaXYsIGQuY3Vyc29yRGl2LCBkLmxpbmVEaXZdLCBudWxsLCBcInBvc2l0aW9uOiByZWxhdGl2ZTsgb3V0bGluZTogbm9uZVwiKTtcbiAgICAgIHZhciBsaW5lcyA9IGVsdFAoXCJkaXZcIiwgW2QubGluZVNwYWNlXSwgXCJDb2RlTWlycm9yLWxpbmVzXCIpO1xuICAgICAgZC5tb3ZlciA9IGVsdChcImRpdlwiLCBbbGluZXNdLCBudWxsLCBcInBvc2l0aW9uOiByZWxhdGl2ZVwiKTtcbiAgICAgIGQuc2l6ZXIgPSBlbHQoXCJkaXZcIiwgW2QubW92ZXJdLCBcIkNvZGVNaXJyb3Itc2l6ZXJcIik7XG4gICAgICBkLnNpemVyV2lkdGggPSBudWxsO1xuICAgICAgZC5oZWlnaHRGb3JjZXIgPSBlbHQoXCJkaXZcIiwgbnVsbCwgbnVsbCwgXCJwb3NpdGlvbjogYWJzb2x1dGU7IGhlaWdodDogXCIgKyBzY3JvbGxlckdhcCArIFwicHg7IHdpZHRoOiAxcHg7XCIpO1xuICAgICAgZC5ndXR0ZXJzID0gZWx0KFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1ndXR0ZXJzXCIpO1xuICAgICAgZC5saW5lR3V0dGVyID0gbnVsbDtcbiAgICAgIGQuc2Nyb2xsZXIgPSBlbHQoXCJkaXZcIiwgW2Quc2l6ZXIsIGQuaGVpZ2h0Rm9yY2VyLCBkLmd1dHRlcnNdLCBcIkNvZGVNaXJyb3Itc2Nyb2xsXCIpO1xuICAgICAgZC5zY3JvbGxlci5zZXRBdHRyaWJ1dGUoXCJ0YWJJbmRleFwiLCBcIi0xXCIpO1xuICAgICAgZC53cmFwcGVyID0gZWx0KFwiZGl2XCIsIFtkLnNjcm9sbGJhckZpbGxlciwgZC5ndXR0ZXJGaWxsZXIsIGQuc2Nyb2xsZXJdLCBcIkNvZGVNaXJyb3JcIik7XG4gICAgICBkLndyYXBwZXIuc2V0QXR0cmlidXRlKFwidHJhbnNsYXRlXCIsIFwibm9cIik7XG4gICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDgpIHtcbiAgICAgICAgZC5ndXR0ZXJzLnN0eWxlLnpJbmRleCA9IC0xO1xuICAgICAgICBkLnNjcm9sbGVyLnN0eWxlLnBhZGRpbmdSaWdodCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoIXdlYmtpdCAmJiAhKGdlY2tvICYmIG1vYmlsZSkpIHtcbiAgICAgICAgZC5zY3JvbGxlci5kcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHBsYWNlKSB7XG4gICAgICAgIGlmIChwbGFjZS5hcHBlbmRDaGlsZCkge1xuICAgICAgICAgIHBsYWNlLmFwcGVuZENoaWxkKGQud3JhcHBlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGxhY2UoZC53cmFwcGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZC52aWV3RnJvbSA9IGQudmlld1RvID0gZG9jLmZpcnN0O1xuICAgICAgZC5yZXBvcnRlZFZpZXdGcm9tID0gZC5yZXBvcnRlZFZpZXdUbyA9IGRvYy5maXJzdDtcbiAgICAgIGQudmlldyA9IFtdO1xuICAgICAgZC5yZW5kZXJlZFZpZXcgPSBudWxsO1xuICAgICAgZC5leHRlcm5hbE1lYXN1cmVkID0gbnVsbDtcbiAgICAgIGQudmlld09mZnNldCA9IDA7XG4gICAgICBkLmxhc3RXcmFwSGVpZ2h0ID0gZC5sYXN0V3JhcFdpZHRoID0gMDtcbiAgICAgIGQudXBkYXRlTGluZU51bWJlcnMgPSBudWxsO1xuICAgICAgZC5uYXRpdmVCYXJXaWR0aCA9IGQuYmFySGVpZ2h0ID0gZC5iYXJXaWR0aCA9IDA7XG4gICAgICBkLnNjcm9sbGJhcnNDbGlwcGVkID0gZmFsc2U7XG4gICAgICBkLmxpbmVOdW1XaWR0aCA9IGQubGluZU51bUlubmVyV2lkdGggPSBkLmxpbmVOdW1DaGFycyA9IG51bGw7XG4gICAgICBkLmFsaWduV2lkZ2V0cyA9IGZhbHNlO1xuICAgICAgZC5jYWNoZWRDaGFyV2lkdGggPSBkLmNhY2hlZFRleHRIZWlnaHQgPSBkLmNhY2hlZFBhZGRpbmdIID0gbnVsbDtcbiAgICAgIGQubWF4TGluZSA9IG51bGw7XG4gICAgICBkLm1heExpbmVMZW5ndGggPSAwO1xuICAgICAgZC5tYXhMaW5lQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgZC53aGVlbERYID0gZC53aGVlbERZID0gZC53aGVlbFN0YXJ0WCA9IGQud2hlZWxTdGFydFkgPSBudWxsO1xuICAgICAgZC5zaGlmdCA9IGZhbHNlO1xuICAgICAgZC5zZWxGb3JDb250ZXh0TWVudSA9IG51bGw7XG4gICAgICBkLmFjdGl2ZVRvdWNoID0gbnVsbDtcbiAgICAgIGQuZ3V0dGVyU3BlY3MgPSBnZXRHdXR0ZXJzKG9wdGlvbnMuZ3V0dGVycywgb3B0aW9ucy5saW5lTnVtYmVycyk7XG4gICAgICByZW5kZXJHdXR0ZXJzKGQpO1xuICAgICAgaW5wdXQuaW5pdChkKTtcbiAgICB9XG4gICAgX19uYW1lKERpc3BsYXksIFwiRGlzcGxheVwiKTtcbiAgICB2YXIgd2hlZWxTYW1wbGVzID0gMCwgd2hlZWxQaXhlbHNQZXJVbml0ID0gbnVsbDtcbiAgICBpZiAoaWUpIHtcbiAgICAgIHdoZWVsUGl4ZWxzUGVyVW5pdCA9IC0wLjUzO1xuICAgIH0gZWxzZSBpZiAoZ2Vja28pIHtcbiAgICAgIHdoZWVsUGl4ZWxzUGVyVW5pdCA9IDE1O1xuICAgIH0gZWxzZSBpZiAoY2hyb21lKSB7XG4gICAgICB3aGVlbFBpeGVsc1BlclVuaXQgPSAtMC43O1xuICAgIH0gZWxzZSBpZiAoc2FmYXJpKSB7XG4gICAgICB3aGVlbFBpeGVsc1BlclVuaXQgPSAtMSAvIDM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdoZWVsRXZlbnREZWx0YShlKSB7XG4gICAgICB2YXIgZHggPSBlLndoZWVsRGVsdGFYLCBkeSA9IGUud2hlZWxEZWx0YVk7XG4gICAgICBpZiAoZHggPT0gbnVsbCAmJiBlLmRldGFpbCAmJiBlLmF4aXMgPT0gZS5IT1JJWk9OVEFMX0FYSVMpIHtcbiAgICAgICAgZHggPSBlLmRldGFpbDtcbiAgICAgIH1cbiAgICAgIGlmIChkeSA9PSBudWxsICYmIGUuZGV0YWlsICYmIGUuYXhpcyA9PSBlLlZFUlRJQ0FMX0FYSVMpIHtcbiAgICAgICAgZHkgPSBlLmRldGFpbDtcbiAgICAgIH0gZWxzZSBpZiAoZHkgPT0gbnVsbCkge1xuICAgICAgICBkeSA9IGUud2hlZWxEZWx0YTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHg6IGR4LCB5OiBkeSB9O1xuICAgIH1cbiAgICBfX25hbWUod2hlZWxFdmVudERlbHRhLCBcIndoZWVsRXZlbnREZWx0YVwiKTtcbiAgICBmdW5jdGlvbiB3aGVlbEV2ZW50UGl4ZWxzKGUpIHtcbiAgICAgIHZhciBkZWx0YSA9IHdoZWVsRXZlbnREZWx0YShlKTtcbiAgICAgIGRlbHRhLnggKj0gd2hlZWxQaXhlbHNQZXJVbml0O1xuICAgICAgZGVsdGEueSAqPSB3aGVlbFBpeGVsc1BlclVuaXQ7XG4gICAgICByZXR1cm4gZGVsdGE7XG4gICAgfVxuICAgIF9fbmFtZSh3aGVlbEV2ZW50UGl4ZWxzLCBcIndoZWVsRXZlbnRQaXhlbHNcIik7XG4gICAgZnVuY3Rpb24gb25TY3JvbGxXaGVlbChjbSwgZSkge1xuICAgICAgdmFyIGRlbHRhID0gd2hlZWxFdmVudERlbHRhKGUpLCBkeCA9IGRlbHRhLngsIGR5ID0gZGVsdGEueTtcbiAgICAgIHZhciBwaXhlbHNQZXJVbml0ID0gd2hlZWxQaXhlbHNQZXJVbml0O1xuICAgICAgaWYgKGUuZGVsdGFNb2RlID09PSAwKSB7XG4gICAgICAgIGR4ID0gZS5kZWx0YVg7XG4gICAgICAgIGR5ID0gZS5kZWx0YVk7XG4gICAgICAgIHBpeGVsc1BlclVuaXQgPSAxO1xuICAgICAgfVxuICAgICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBzY3JvbGwgPSBkaXNwbGF5LnNjcm9sbGVyO1xuICAgICAgdmFyIGNhblNjcm9sbFggPSBzY3JvbGwuc2Nyb2xsV2lkdGggPiBzY3JvbGwuY2xpZW50V2lkdGg7XG4gICAgICB2YXIgY2FuU2Nyb2xsWSA9IHNjcm9sbC5zY3JvbGxIZWlnaHQgPiBzY3JvbGwuY2xpZW50SGVpZ2h0O1xuICAgICAgaWYgKCEoZHggJiYgY2FuU2Nyb2xsWCB8fCBkeSAmJiBjYW5TY3JvbGxZKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZHkgJiYgbWFjICYmIHdlYmtpdCkge1xuICAgICAgICBvdXRlcjpcbiAgICAgICAgICBmb3IgKHZhciBjdXIgPSBlLnRhcmdldCwgdmlldyA9IGRpc3BsYXkudmlldzsgY3VyICE9IHNjcm9sbDsgY3VyID0gY3VyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCB2aWV3Lmxlbmd0aDsgaTIrKykge1xuICAgICAgICAgICAgICBpZiAodmlld1tpMl0ubm9kZSA9PSBjdXIpIHtcbiAgICAgICAgICAgICAgICBjbS5kaXNwbGF5LmN1cnJlbnRXaGVlbFRhcmdldCA9IGN1cjtcbiAgICAgICAgICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkeCAmJiAhZ2Vja28gJiYgIXByZXN0byAmJiBwaXhlbHNQZXJVbml0ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGR5ICYmIGNhblNjcm9sbFkpIHtcbiAgICAgICAgICB1cGRhdGVTY3JvbGxUb3AoY20sIE1hdGgubWF4KDAsIHNjcm9sbC5zY3JvbGxUb3AgKyBkeSAqIHBpeGVsc1BlclVuaXQpKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRTY3JvbGxMZWZ0KGNtLCBNYXRoLm1heCgwLCBzY3JvbGwuc2Nyb2xsTGVmdCArIGR4ICogcGl4ZWxzUGVyVW5pdCkpO1xuICAgICAgICBpZiAoIWR5IHx8IGR5ICYmIGNhblNjcm9sbFkpIHtcbiAgICAgICAgICBlX3ByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgICB9XG4gICAgICAgIGRpc3BsYXkud2hlZWxTdGFydFggPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZHkgJiYgcGl4ZWxzUGVyVW5pdCAhPSBudWxsKSB7XG4gICAgICAgIHZhciBwaXhlbHMgPSBkeSAqIHBpeGVsc1BlclVuaXQ7XG4gICAgICAgIHZhciB0b3AgPSBjbS5kb2Muc2Nyb2xsVG9wLCBib3QgPSB0b3AgKyBkaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0O1xuICAgICAgICBpZiAocGl4ZWxzIDwgMCkge1xuICAgICAgICAgIHRvcCA9IE1hdGgubWF4KDAsIHRvcCArIHBpeGVscyAtIDUwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBib3QgPSBNYXRoLm1pbihjbS5kb2MuaGVpZ2h0LCBib3QgKyBwaXhlbHMgKyA1MCk7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlRGlzcGxheVNpbXBsZShjbSwgeyB0b3AsIGJvdHRvbTogYm90IH0pO1xuICAgICAgfVxuICAgICAgaWYgKHdoZWVsU2FtcGxlcyA8IDIwICYmIGUuZGVsdGFNb2RlICE9PSAwKSB7XG4gICAgICAgIGlmIChkaXNwbGF5LndoZWVsU3RhcnRYID09IG51bGwpIHtcbiAgICAgICAgICBkaXNwbGF5LndoZWVsU3RhcnRYID0gc2Nyb2xsLnNjcm9sbExlZnQ7XG4gICAgICAgICAgZGlzcGxheS53aGVlbFN0YXJ0WSA9IHNjcm9sbC5zY3JvbGxUb3A7XG4gICAgICAgICAgZGlzcGxheS53aGVlbERYID0gZHg7XG4gICAgICAgICAgZGlzcGxheS53aGVlbERZID0gZHk7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChkaXNwbGF5LndoZWVsU3RhcnRYID09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1vdmVkWCA9IHNjcm9sbC5zY3JvbGxMZWZ0IC0gZGlzcGxheS53aGVlbFN0YXJ0WDtcbiAgICAgICAgICAgIHZhciBtb3ZlZFkgPSBzY3JvbGwuc2Nyb2xsVG9wIC0gZGlzcGxheS53aGVlbFN0YXJ0WTtcbiAgICAgICAgICAgIHZhciBzYW1wbGUgPSBtb3ZlZFkgJiYgZGlzcGxheS53aGVlbERZICYmIG1vdmVkWSAvIGRpc3BsYXkud2hlZWxEWSB8fCBtb3ZlZFggJiYgZGlzcGxheS53aGVlbERYICYmIG1vdmVkWCAvIGRpc3BsYXkud2hlZWxEWDtcbiAgICAgICAgICAgIGRpc3BsYXkud2hlZWxTdGFydFggPSBkaXNwbGF5LndoZWVsU3RhcnRZID0gbnVsbDtcbiAgICAgICAgICAgIGlmICghc2FtcGxlKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoZWVsUGl4ZWxzUGVyVW5pdCA9ICh3aGVlbFBpeGVsc1BlclVuaXQgKiB3aGVlbFNhbXBsZXMgKyBzYW1wbGUpIC8gKHdoZWVsU2FtcGxlcyArIDEpO1xuICAgICAgICAgICAgKyt3aGVlbFNhbXBsZXM7XG4gICAgICAgICAgfSwgMjAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkaXNwbGF5LndoZWVsRFggKz0gZHg7XG4gICAgICAgICAgZGlzcGxheS53aGVlbERZICs9IGR5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShvblNjcm9sbFdoZWVsLCBcIm9uU2Nyb2xsV2hlZWxcIik7XG4gICAgdmFyIFNlbGVjdGlvbiA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24ocmFuZ2VzLCBwcmltSW5kZXgpIHtcbiAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgdGhpcy5wcmltSW5kZXggPSBwcmltSW5kZXg7XG4gICAgfSwgXCJTZWxlY3Rpb25cIik7XG4gICAgU2VsZWN0aW9uLnByb3RvdHlwZS5wcmltYXJ5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5yYW5nZXNbdGhpcy5wcmltSW5kZXhdO1xuICAgIH07XG4gICAgU2VsZWN0aW9uLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihvdGhlcikge1xuICAgICAgaWYgKG90aGVyID09IHRoaXMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAob3RoZXIucHJpbUluZGV4ICE9IHRoaXMucHJpbUluZGV4IHx8IG90aGVyLnJhbmdlcy5sZW5ndGggIT0gdGhpcy5yYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgdmFyIGhlcmUgPSB0aGlzLnJhbmdlc1tpMl0sIHRoZXJlID0gb3RoZXIucmFuZ2VzW2kyXTtcbiAgICAgICAgaWYgKCFlcXVhbEN1cnNvclBvcyhoZXJlLmFuY2hvciwgdGhlcmUuYW5jaG9yKSB8fCAhZXF1YWxDdXJzb3JQb3MoaGVyZS5oZWFkLCB0aGVyZS5oZWFkKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBTZWxlY3Rpb24ucHJvdG90eXBlLmRlZXBDb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb3V0ID0gW107XG4gICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgIG91dFtpMl0gPSBuZXcgUmFuZ2UoY29weVBvcyh0aGlzLnJhbmdlc1tpMl0uYW5jaG9yKSwgY29weVBvcyh0aGlzLnJhbmdlc1tpMl0uaGVhZCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24ob3V0LCB0aGlzLnByaW1JbmRleCk7XG4gICAgfTtcbiAgICBTZWxlY3Rpb24ucHJvdG90eXBlLnNvbWV0aGluZ1NlbGVjdGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgIGlmICghdGhpcy5yYW5nZXNbaTJdLmVtcHR5KCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgU2VsZWN0aW9uLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uKHBvcywgZW5kKSB7XG4gICAgICBpZiAoIWVuZCkge1xuICAgICAgICBlbmQgPSBwb3M7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgIHZhciByYW5nZTIgPSB0aGlzLnJhbmdlc1tpMl07XG4gICAgICAgIGlmIChjbXAoZW5kLCByYW5nZTIuZnJvbSgpKSA+PSAwICYmIGNtcChwb3MsIHJhbmdlMi50bygpKSA8PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGkyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgICB2YXIgUmFuZ2UgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKGFuY2hvciwgaGVhZCkge1xuICAgICAgdGhpcy5hbmNob3IgPSBhbmNob3I7XG4gICAgICB0aGlzLmhlYWQgPSBoZWFkO1xuICAgIH0sIFwiUmFuZ2VcIik7XG4gICAgUmFuZ2UucHJvdG90eXBlLmZyb20gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBtaW5Qb3ModGhpcy5hbmNob3IsIHRoaXMuaGVhZCk7XG4gICAgfTtcbiAgICBSYW5nZS5wcm90b3R5cGUudG8gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBtYXhQb3ModGhpcy5hbmNob3IsIHRoaXMuaGVhZCk7XG4gICAgfTtcbiAgICBSYW5nZS5wcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmhlYWQubGluZSA9PSB0aGlzLmFuY2hvci5saW5lICYmIHRoaXMuaGVhZC5jaCA9PSB0aGlzLmFuY2hvci5jaDtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVNlbGVjdGlvbihjbSwgcmFuZ2VzLCBwcmltSW5kZXgpIHtcbiAgICAgIHZhciBtYXlUb3VjaCA9IGNtICYmIGNtLm9wdGlvbnMuc2VsZWN0aW9uc01heVRvdWNoO1xuICAgICAgdmFyIHByaW0gPSByYW5nZXNbcHJpbUluZGV4XTtcbiAgICAgIHJhbmdlcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGNtcChhLmZyb20oKSwgYi5mcm9tKCkpO1xuICAgICAgfSk7XG4gICAgICBwcmltSW5kZXggPSBpbmRleE9mKHJhbmdlcywgcHJpbSk7XG4gICAgICBmb3IgKHZhciBpMiA9IDE7IGkyIDwgcmFuZ2VzLmxlbmd0aDsgaTIrKykge1xuICAgICAgICB2YXIgY3VyID0gcmFuZ2VzW2kyXSwgcHJldiA9IHJhbmdlc1tpMiAtIDFdO1xuICAgICAgICB2YXIgZGlmZiA9IGNtcChwcmV2LnRvKCksIGN1ci5mcm9tKCkpO1xuICAgICAgICBpZiAobWF5VG91Y2ggJiYgIWN1ci5lbXB0eSgpID8gZGlmZiA+IDAgOiBkaWZmID49IDApIHtcbiAgICAgICAgICB2YXIgZnJvbSA9IG1pblBvcyhwcmV2LmZyb20oKSwgY3VyLmZyb20oKSksIHRvID0gbWF4UG9zKHByZXYudG8oKSwgY3VyLnRvKCkpO1xuICAgICAgICAgIHZhciBpbnYgPSBwcmV2LmVtcHR5KCkgPyBjdXIuZnJvbSgpID09IGN1ci5oZWFkIDogcHJldi5mcm9tKCkgPT0gcHJldi5oZWFkO1xuICAgICAgICAgIGlmIChpMiA8PSBwcmltSW5kZXgpIHtcbiAgICAgICAgICAgIC0tcHJpbUluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgICByYW5nZXMuc3BsaWNlKC0taTIsIDIsIG5ldyBSYW5nZShpbnYgPyB0byA6IGZyb20sIGludiA/IGZyb20gOiB0bykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFNlbGVjdGlvbihyYW5nZXMsIHByaW1JbmRleCk7XG4gICAgfVxuICAgIF9fbmFtZShub3JtYWxpemVTZWxlY3Rpb24sIFwibm9ybWFsaXplU2VsZWN0aW9uXCIpO1xuICAgIGZ1bmN0aW9uIHNpbXBsZVNlbGVjdGlvbihhbmNob3IsIGhlYWQpIHtcbiAgICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKFtuZXcgUmFuZ2UoYW5jaG9yLCBoZWFkIHx8IGFuY2hvcildLCAwKTtcbiAgICB9XG4gICAgX19uYW1lKHNpbXBsZVNlbGVjdGlvbiwgXCJzaW1wbGVTZWxlY3Rpb25cIik7XG4gICAgZnVuY3Rpb24gY2hhbmdlRW5kKGNoYW5nZSkge1xuICAgICAgaWYgKCFjaGFuZ2UudGV4dCkge1xuICAgICAgICByZXR1cm4gY2hhbmdlLnRvO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFBvcyhjaGFuZ2UuZnJvbS5saW5lICsgY2hhbmdlLnRleHQubGVuZ3RoIC0gMSwgbHN0KGNoYW5nZS50ZXh0KS5sZW5ndGggKyAoY2hhbmdlLnRleHQubGVuZ3RoID09IDEgPyBjaGFuZ2UuZnJvbS5jaCA6IDApKTtcbiAgICB9XG4gICAgX19uYW1lKGNoYW5nZUVuZCwgXCJjaGFuZ2VFbmRcIik7XG4gICAgZnVuY3Rpb24gYWRqdXN0Rm9yQ2hhbmdlKHBvcywgY2hhbmdlKSB7XG4gICAgICBpZiAoY21wKHBvcywgY2hhbmdlLmZyb20pIDwgMCkge1xuICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgfVxuICAgICAgaWYgKGNtcChwb3MsIGNoYW5nZS50bykgPD0gMCkge1xuICAgICAgICByZXR1cm4gY2hhbmdlRW5kKGNoYW5nZSk7XG4gICAgICB9XG4gICAgICB2YXIgbGluZSA9IHBvcy5saW5lICsgY2hhbmdlLnRleHQubGVuZ3RoIC0gKGNoYW5nZS50by5saW5lIC0gY2hhbmdlLmZyb20ubGluZSkgLSAxLCBjaCA9IHBvcy5jaDtcbiAgICAgIGlmIChwb3MubGluZSA9PSBjaGFuZ2UudG8ubGluZSkge1xuICAgICAgICBjaCArPSBjaGFuZ2VFbmQoY2hhbmdlKS5jaCAtIGNoYW5nZS50by5jaDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQb3MobGluZSwgY2gpO1xuICAgIH1cbiAgICBfX25hbWUoYWRqdXN0Rm9yQ2hhbmdlLCBcImFkanVzdEZvckNoYW5nZVwiKTtcbiAgICBmdW5jdGlvbiBjb21wdXRlU2VsQWZ0ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UpIHtcbiAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBkb2Muc2VsLnJhbmdlcy5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgdmFyIHJhbmdlMiA9IGRvYy5zZWwucmFuZ2VzW2kyXTtcbiAgICAgICAgb3V0LnB1c2gobmV3IFJhbmdlKGFkanVzdEZvckNoYW5nZShyYW5nZTIuYW5jaG9yLCBjaGFuZ2UpLCBhZGp1c3RGb3JDaGFuZ2UocmFuZ2UyLmhlYWQsIGNoYW5nZSkpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub3JtYWxpemVTZWxlY3Rpb24oZG9jLmNtLCBvdXQsIGRvYy5zZWwucHJpbUluZGV4KTtcbiAgICB9XG4gICAgX19uYW1lKGNvbXB1dGVTZWxBZnRlckNoYW5nZSwgXCJjb21wdXRlU2VsQWZ0ZXJDaGFuZ2VcIik7XG4gICAgZnVuY3Rpb24gb2Zmc2V0UG9zKHBvcywgb2xkLCBudykge1xuICAgICAgaWYgKHBvcy5saW5lID09IG9sZC5saW5lKSB7XG4gICAgICAgIHJldHVybiBQb3MobncubGluZSwgcG9zLmNoIC0gb2xkLmNoICsgbncuY2gpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFBvcyhudy5saW5lICsgKHBvcy5saW5lIC0gb2xkLmxpbmUpLCBwb3MuY2gpO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUob2Zmc2V0UG9zLCBcIm9mZnNldFBvc1wiKTtcbiAgICBmdW5jdGlvbiBjb21wdXRlUmVwbGFjZWRTZWwoZG9jLCBjaGFuZ2VzLCBoaW50KSB7XG4gICAgICB2YXIgb3V0ID0gW107XG4gICAgICB2YXIgb2xkUHJldiA9IFBvcyhkb2MuZmlyc3QsIDApLCBuZXdQcmV2ID0gb2xkUHJldjtcbiAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBjaGFuZ2VzLmxlbmd0aDsgaTIrKykge1xuICAgICAgICB2YXIgY2hhbmdlID0gY2hhbmdlc1tpMl07XG4gICAgICAgIHZhciBmcm9tID0gb2Zmc2V0UG9zKGNoYW5nZS5mcm9tLCBvbGRQcmV2LCBuZXdQcmV2KTtcbiAgICAgICAgdmFyIHRvID0gb2Zmc2V0UG9zKGNoYW5nZUVuZChjaGFuZ2UpLCBvbGRQcmV2LCBuZXdQcmV2KTtcbiAgICAgICAgb2xkUHJldiA9IGNoYW5nZS50bztcbiAgICAgICAgbmV3UHJldiA9IHRvO1xuICAgICAgICBpZiAoaGludCA9PSBcImFyb3VuZFwiKSB7XG4gICAgICAgICAgdmFyIHJhbmdlMiA9IGRvYy5zZWwucmFuZ2VzW2kyXSwgaW52ID0gY21wKHJhbmdlMi5oZWFkLCByYW5nZTIuYW5jaG9yKSA8IDA7XG4gICAgICAgICAgb3V0W2kyXSA9IG5ldyBSYW5nZShpbnYgPyB0byA6IGZyb20sIGludiA/IGZyb20gOiB0byk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0W2kyXSA9IG5ldyBSYW5nZShmcm9tLCBmcm9tKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24ob3V0LCBkb2Muc2VsLnByaW1JbmRleCk7XG4gICAgfVxuICAgIF9fbmFtZShjb21wdXRlUmVwbGFjZWRTZWwsIFwiY29tcHV0ZVJlcGxhY2VkU2VsXCIpO1xuICAgIGZ1bmN0aW9uIGxvYWRNb2RlKGNtKSB7XG4gICAgICBjbS5kb2MubW9kZSA9IGdldE1vZGUoY20ub3B0aW9ucywgY20uZG9jLm1vZGVPcHRpb24pO1xuICAgICAgcmVzZXRNb2RlU3RhdGUoY20pO1xuICAgIH1cbiAgICBfX25hbWUobG9hZE1vZGUsIFwibG9hZE1vZGVcIik7XG4gICAgZnVuY3Rpb24gcmVzZXRNb2RlU3RhdGUoY20pIHtcbiAgICAgIGNtLmRvYy5pdGVyKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgaWYgKGxpbmUuc3RhdGVBZnRlcikge1xuICAgICAgICAgIGxpbmUuc3RhdGVBZnRlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmUuc3R5bGVzKSB7XG4gICAgICAgICAgbGluZS5zdHlsZXMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNtLmRvYy5tb2RlRnJvbnRpZXIgPSBjbS5kb2MuaGlnaGxpZ2h0RnJvbnRpZXIgPSBjbS5kb2MuZmlyc3Q7XG4gICAgICBzdGFydFdvcmtlcihjbSwgMTAwKTtcbiAgICAgIGNtLnN0YXRlLm1vZGVHZW4rKztcbiAgICAgIGlmIChjbS5jdXJPcCkge1xuICAgICAgICByZWdDaGFuZ2UoY20pO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUocmVzZXRNb2RlU3RhdGUsIFwicmVzZXRNb2RlU3RhdGVcIik7XG4gICAgZnVuY3Rpb24gaXNXaG9sZUxpbmVVcGRhdGUoZG9jLCBjaGFuZ2UpIHtcbiAgICAgIHJldHVybiBjaGFuZ2UuZnJvbS5jaCA9PSAwICYmIGNoYW5nZS50by5jaCA9PSAwICYmIGxzdChjaGFuZ2UudGV4dCkgPT0gXCJcIiAmJiAoIWRvYy5jbSB8fCBkb2MuY20ub3B0aW9ucy53aG9sZUxpbmVVcGRhdGVCZWZvcmUpO1xuICAgIH1cbiAgICBfX25hbWUoaXNXaG9sZUxpbmVVcGRhdGUsIFwiaXNXaG9sZUxpbmVVcGRhdGVcIik7XG4gICAgZnVuY3Rpb24gdXBkYXRlRG9jKGRvYywgY2hhbmdlLCBtYXJrZWRTcGFucywgZXN0aW1hdGVIZWlnaHQyKSB7XG4gICAgICBmdW5jdGlvbiBzcGFuc0ZvcihuKSB7XG4gICAgICAgIHJldHVybiBtYXJrZWRTcGFucyA/IG1hcmtlZFNwYW5zW25dIDogbnVsbDtcbiAgICAgIH1cbiAgICAgIF9fbmFtZShzcGFuc0ZvciwgXCJzcGFuc0ZvclwiKTtcbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZShsaW5lLCB0ZXh0Miwgc3BhbnMpIHtcbiAgICAgICAgdXBkYXRlTGluZShsaW5lLCB0ZXh0Miwgc3BhbnMsIGVzdGltYXRlSGVpZ2h0Mik7XG4gICAgICAgIHNpZ25hbExhdGVyKGxpbmUsIFwiY2hhbmdlXCIsIGxpbmUsIGNoYW5nZSk7XG4gICAgICB9XG4gICAgICBfX25hbWUodXBkYXRlLCBcInVwZGF0ZVwiKTtcbiAgICAgIGZ1bmN0aW9uIGxpbmVzRm9yKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpMiA9IHN0YXJ0OyBpMiA8IGVuZDsgKytpMikge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBMaW5lKHRleHRbaTJdLCBzcGFuc0ZvcihpMiksIGVzdGltYXRlSGVpZ2h0MikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBfX25hbWUobGluZXNGb3IsIFwibGluZXNGb3JcIik7XG4gICAgICB2YXIgZnJvbSA9IGNoYW5nZS5mcm9tLCB0byA9IGNoYW5nZS50bywgdGV4dCA9IGNoYW5nZS50ZXh0O1xuICAgICAgdmFyIGZpcnN0TGluZSA9IGdldExpbmUoZG9jLCBmcm9tLmxpbmUpLCBsYXN0TGluZSA9IGdldExpbmUoZG9jLCB0by5saW5lKTtcbiAgICAgIHZhciBsYXN0VGV4dCA9IGxzdCh0ZXh0KSwgbGFzdFNwYW5zID0gc3BhbnNGb3IodGV4dC5sZW5ndGggLSAxKSwgbmxpbmVzID0gdG8ubGluZSAtIGZyb20ubGluZTtcbiAgICAgIGlmIChjaGFuZ2UuZnVsbCkge1xuICAgICAgICBkb2MuaW5zZXJ0KDAsIGxpbmVzRm9yKDAsIHRleHQubGVuZ3RoKSk7XG4gICAgICAgIGRvYy5yZW1vdmUodGV4dC5sZW5ndGgsIGRvYy5zaXplIC0gdGV4dC5sZW5ndGgpO1xuICAgICAgfSBlbHNlIGlmIChpc1dob2xlTGluZVVwZGF0ZShkb2MsIGNoYW5nZSkpIHtcbiAgICAgICAgdmFyIGFkZGVkID0gbGluZXNGb3IoMCwgdGV4dC5sZW5ndGggLSAxKTtcbiAgICAgICAgdXBkYXRlKGxhc3RMaW5lLCBsYXN0TGluZS50ZXh0LCBsYXN0U3BhbnMpO1xuICAgICAgICBpZiAobmxpbmVzKSB7XG4gICAgICAgICAgZG9jLnJlbW92ZShmcm9tLmxpbmUsIG5saW5lcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFkZGVkLmxlbmd0aCkge1xuICAgICAgICAgIGRvYy5pbnNlcnQoZnJvbS5saW5lLCBhZGRlZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZmlyc3RMaW5lID09IGxhc3RMaW5lKSB7XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgdXBkYXRlKGZpcnN0TGluZSwgZmlyc3RMaW5lLnRleHQuc2xpY2UoMCwgZnJvbS5jaCkgKyBsYXN0VGV4dCArIGZpcnN0TGluZS50ZXh0LnNsaWNlKHRvLmNoKSwgbGFzdFNwYW5zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgYWRkZWQkMSA9IGxpbmVzRm9yKDEsIHRleHQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgYWRkZWQkMS5wdXNoKG5ldyBMaW5lKGxhc3RUZXh0ICsgZmlyc3RMaW5lLnRleHQuc2xpY2UodG8uY2gpLCBsYXN0U3BhbnMsIGVzdGltYXRlSGVpZ2h0MikpO1xuICAgICAgICAgIHVwZGF0ZShmaXJzdExpbmUsIGZpcnN0TGluZS50ZXh0LnNsaWNlKDAsIGZyb20uY2gpICsgdGV4dFswXSwgc3BhbnNGb3IoMCkpO1xuICAgICAgICAgIGRvYy5pbnNlcnQoZnJvbS5saW5lICsgMSwgYWRkZWQkMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGV4dC5sZW5ndGggPT0gMSkge1xuICAgICAgICB1cGRhdGUoZmlyc3RMaW5lLCBmaXJzdExpbmUudGV4dC5zbGljZSgwLCBmcm9tLmNoKSArIHRleHRbMF0gKyBsYXN0TGluZS50ZXh0LnNsaWNlKHRvLmNoKSwgc3BhbnNGb3IoMCkpO1xuICAgICAgICBkb2MucmVtb3ZlKGZyb20ubGluZSArIDEsIG5saW5lcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cGRhdGUoZmlyc3RMaW5lLCBmaXJzdExpbmUudGV4dC5zbGljZSgwLCBmcm9tLmNoKSArIHRleHRbMF0sIHNwYW5zRm9yKDApKTtcbiAgICAgICAgdXBkYXRlKGxhc3RMaW5lLCBsYXN0VGV4dCArIGxhc3RMaW5lLnRleHQuc2xpY2UodG8uY2gpLCBsYXN0U3BhbnMpO1xuICAgICAgICB2YXIgYWRkZWQkMiA9IGxpbmVzRm9yKDEsIHRleHQubGVuZ3RoIC0gMSk7XG4gICAgICAgIGlmIChubGluZXMgPiAxKSB7XG4gICAgICAgICAgZG9jLnJlbW92ZShmcm9tLmxpbmUgKyAxLCBubGluZXMgLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBkb2MuaW5zZXJ0KGZyb20ubGluZSArIDEsIGFkZGVkJDIpO1xuICAgICAgfVxuICAgICAgc2lnbmFsTGF0ZXIoZG9jLCBcImNoYW5nZVwiLCBkb2MsIGNoYW5nZSk7XG4gICAgfVxuICAgIF9fbmFtZSh1cGRhdGVEb2MsIFwidXBkYXRlRG9jXCIpO1xuICAgIGZ1bmN0aW9uIGxpbmtlZERvY3MoZG9jLCBmLCBzaGFyZWRIaXN0T25seSkge1xuICAgICAgZnVuY3Rpb24gcHJvcGFnYXRlKGRvYzIsIHNraXAsIHNoYXJlZEhpc3QpIHtcbiAgICAgICAgaWYgKGRvYzIubGlua2VkKSB7XG4gICAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IGRvYzIubGlua2VkLmxlbmd0aDsgKytpMikge1xuICAgICAgICAgICAgdmFyIHJlbCA9IGRvYzIubGlua2VkW2kyXTtcbiAgICAgICAgICAgIGlmIChyZWwuZG9jID09IHNraXApIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2hhcmVkID0gc2hhcmVkSGlzdCAmJiByZWwuc2hhcmVkSGlzdDtcbiAgICAgICAgICAgIGlmIChzaGFyZWRIaXN0T25seSAmJiAhc2hhcmVkKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZihyZWwuZG9jLCBzaGFyZWQpO1xuICAgICAgICAgICAgcHJvcGFnYXRlKHJlbC5kb2MsIGRvYzIsIHNoYXJlZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBfX25hbWUocHJvcGFnYXRlLCBcInByb3BhZ2F0ZVwiKTtcbiAgICAgIHByb3BhZ2F0ZShkb2MsIG51bGwsIHRydWUpO1xuICAgIH1cbiAgICBfX25hbWUobGlua2VkRG9jcywgXCJsaW5rZWREb2NzXCIpO1xuICAgIGZ1bmN0aW9uIGF0dGFjaERvYyhjbSwgZG9jKSB7XG4gICAgICBpZiAoZG9jLmNtKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgZG9jdW1lbnQgaXMgYWxyZWFkeSBpbiB1c2UuXCIpO1xuICAgICAgfVxuICAgICAgY20uZG9jID0gZG9jO1xuICAgICAgZG9jLmNtID0gY207XG4gICAgICBlc3RpbWF0ZUxpbmVIZWlnaHRzKGNtKTtcbiAgICAgIGxvYWRNb2RlKGNtKTtcbiAgICAgIHNldERpcmVjdGlvbkNsYXNzKGNtKTtcbiAgICAgIGNtLm9wdGlvbnMuZGlyZWN0aW9uID0gZG9jLmRpcmVjdGlvbjtcbiAgICAgIGlmICghY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHtcbiAgICAgICAgZmluZE1heExpbmUoY20pO1xuICAgICAgfVxuICAgICAgY20ub3B0aW9ucy5tb2RlID0gZG9jLm1vZGVPcHRpb247XG4gICAgICByZWdDaGFuZ2UoY20pO1xuICAgIH1cbiAgICBfX25hbWUoYXR0YWNoRG9jLCBcImF0dGFjaERvY1wiKTtcbiAgICBmdW5jdGlvbiBzZXREaXJlY3Rpb25DbGFzcyhjbSkge1xuICAgICAgKGNtLmRvYy5kaXJlY3Rpb24gPT0gXCJydGxcIiA/IGFkZENsYXNzIDogcm1DbGFzcykoY20uZGlzcGxheS5saW5lRGl2LCBcIkNvZGVNaXJyb3ItcnRsXCIpO1xuICAgIH1cbiAgICBfX25hbWUoc2V0RGlyZWN0aW9uQ2xhc3MsIFwic2V0RGlyZWN0aW9uQ2xhc3NcIik7XG4gICAgZnVuY3Rpb24gZGlyZWN0aW9uQ2hhbmdlZChjbSkge1xuICAgICAgcnVuSW5PcChjbSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHNldERpcmVjdGlvbkNsYXNzKGNtKTtcbiAgICAgICAgcmVnQ2hhbmdlKGNtKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBfX25hbWUoZGlyZWN0aW9uQ2hhbmdlZCwgXCJkaXJlY3Rpb25DaGFuZ2VkXCIpO1xuICAgIGZ1bmN0aW9uIEhpc3RvcnkocHJldikge1xuICAgICAgdGhpcy5kb25lID0gW107XG4gICAgICB0aGlzLnVuZG9uZSA9IFtdO1xuICAgICAgdGhpcy51bmRvRGVwdGggPSBwcmV2ID8gcHJldi51bmRvRGVwdGggOiBJbmZpbml0eTtcbiAgICAgIHRoaXMubGFzdE1vZFRpbWUgPSB0aGlzLmxhc3RTZWxUaW1lID0gMDtcbiAgICAgIHRoaXMubGFzdE9wID0gdGhpcy5sYXN0U2VsT3AgPSBudWxsO1xuICAgICAgdGhpcy5sYXN0T3JpZ2luID0gdGhpcy5sYXN0U2VsT3JpZ2luID0gbnVsbDtcbiAgICAgIHRoaXMuZ2VuZXJhdGlvbiA9IHRoaXMubWF4R2VuZXJhdGlvbiA9IHByZXYgPyBwcmV2Lm1heEdlbmVyYXRpb24gOiAxO1xuICAgIH1cbiAgICBfX25hbWUoSGlzdG9yeSwgXCJIaXN0b3J5XCIpO1xuICAgIGZ1bmN0aW9uIGhpc3RvcnlDaGFuZ2VGcm9tQ2hhbmdlKGRvYywgY2hhbmdlKSB7XG4gICAgICB2YXIgaGlzdENoYW5nZSA9IHsgZnJvbTogY29weVBvcyhjaGFuZ2UuZnJvbSksIHRvOiBjaGFuZ2VFbmQoY2hhbmdlKSwgdGV4dDogZ2V0QmV0d2Vlbihkb2MsIGNoYW5nZS5mcm9tLCBjaGFuZ2UudG8pIH07XG4gICAgICBhdHRhY2hMb2NhbFNwYW5zKGRvYywgaGlzdENoYW5nZSwgY2hhbmdlLmZyb20ubGluZSwgY2hhbmdlLnRvLmxpbmUgKyAxKTtcbiAgICAgIGxpbmtlZERvY3MoZG9jLCBmdW5jdGlvbihkb2MyKSB7XG4gICAgICAgIHJldHVybiBhdHRhY2hMb2NhbFNwYW5zKGRvYzIsIGhpc3RDaGFuZ2UsIGNoYW5nZS5mcm9tLmxpbmUsIGNoYW5nZS50by5saW5lICsgMSk7XG4gICAgICB9LCB0cnVlKTtcbiAgICAgIHJldHVybiBoaXN0Q2hhbmdlO1xuICAgIH1cbiAgICBfX25hbWUoaGlzdG9yeUNoYW5nZUZyb21DaGFuZ2UsIFwiaGlzdG9yeUNoYW5nZUZyb21DaGFuZ2VcIik7XG4gICAgZnVuY3Rpb24gY2xlYXJTZWxlY3Rpb25FdmVudHMoYXJyYXkpIHtcbiAgICAgIHdoaWxlIChhcnJheS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGxhc3QgPSBsc3QoYXJyYXkpO1xuICAgICAgICBpZiAobGFzdC5yYW5nZXMpIHtcbiAgICAgICAgICBhcnJheS5wb3AoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoY2xlYXJTZWxlY3Rpb25FdmVudHMsIFwiY2xlYXJTZWxlY3Rpb25FdmVudHNcIik7XG4gICAgZnVuY3Rpb24gbGFzdENoYW5nZUV2ZW50KGhpc3QsIGZvcmNlKSB7XG4gICAgICBpZiAoZm9yY2UpIHtcbiAgICAgICAgY2xlYXJTZWxlY3Rpb25FdmVudHMoaGlzdC5kb25lKTtcbiAgICAgICAgcmV0dXJuIGxzdChoaXN0LmRvbmUpO1xuICAgICAgfSBlbHNlIGlmIChoaXN0LmRvbmUubGVuZ3RoICYmICFsc3QoaGlzdC5kb25lKS5yYW5nZXMpIHtcbiAgICAgICAgcmV0dXJuIGxzdChoaXN0LmRvbmUpO1xuICAgICAgfSBlbHNlIGlmIChoaXN0LmRvbmUubGVuZ3RoID4gMSAmJiAhaGlzdC5kb25lW2hpc3QuZG9uZS5sZW5ndGggLSAyXS5yYW5nZXMpIHtcbiAgICAgICAgaGlzdC5kb25lLnBvcCgpO1xuICAgICAgICByZXR1cm4gbHN0KGhpc3QuZG9uZSk7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShsYXN0Q2hhbmdlRXZlbnQsIFwibGFzdENoYW5nZUV2ZW50XCIpO1xuICAgIGZ1bmN0aW9uIGFkZENoYW5nZVRvSGlzdG9yeShkb2MsIGNoYW5nZSwgc2VsQWZ0ZXIsIG9wSWQpIHtcbiAgICAgIHZhciBoaXN0ID0gZG9jLmhpc3Rvcnk7XG4gICAgICBoaXN0LnVuZG9uZS5sZW5ndGggPSAwO1xuICAgICAgdmFyIHRpbWUgPSArbmV3IERhdGUoKSwgY3VyO1xuICAgICAgdmFyIGxhc3Q7XG4gICAgICBpZiAoKGhpc3QubGFzdE9wID09IG9wSWQgfHwgaGlzdC5sYXN0T3JpZ2luID09IGNoYW5nZS5vcmlnaW4gJiYgY2hhbmdlLm9yaWdpbiAmJiAoY2hhbmdlLm9yaWdpbi5jaGFyQXQoMCkgPT0gXCIrXCIgJiYgaGlzdC5sYXN0TW9kVGltZSA+IHRpbWUgLSAoZG9jLmNtID8gZG9jLmNtLm9wdGlvbnMuaGlzdG9yeUV2ZW50RGVsYXkgOiA1MDApIHx8IGNoYW5nZS5vcmlnaW4uY2hhckF0KDApID09IFwiKlwiKSkgJiYgKGN1ciA9IGxhc3RDaGFuZ2VFdmVudChoaXN0LCBoaXN0Lmxhc3RPcCA9PSBvcElkKSkpIHtcbiAgICAgICAgbGFzdCA9IGxzdChjdXIuY2hhbmdlcyk7XG4gICAgICAgIGlmIChjbXAoY2hhbmdlLmZyb20sIGNoYW5nZS50bykgPT0gMCAmJiBjbXAoY2hhbmdlLmZyb20sIGxhc3QudG8pID09IDApIHtcbiAgICAgICAgICBsYXN0LnRvID0gY2hhbmdlRW5kKGNoYW5nZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VyLmNoYW5nZXMucHVzaChoaXN0b3J5Q2hhbmdlRnJvbUNoYW5nZShkb2MsIGNoYW5nZSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYmVmb3JlID0gbHN0KGhpc3QuZG9uZSk7XG4gICAgICAgIGlmICghYmVmb3JlIHx8ICFiZWZvcmUucmFuZ2VzKSB7XG4gICAgICAgICAgcHVzaFNlbGVjdGlvblRvSGlzdG9yeShkb2Muc2VsLCBoaXN0LmRvbmUpO1xuICAgICAgICB9XG4gICAgICAgIGN1ciA9IHtcbiAgICAgICAgICBjaGFuZ2VzOiBbaGlzdG9yeUNoYW5nZUZyb21DaGFuZ2UoZG9jLCBjaGFuZ2UpXSxcbiAgICAgICAgICBnZW5lcmF0aW9uOiBoaXN0LmdlbmVyYXRpb25cbiAgICAgICAgfTtcbiAgICAgICAgaGlzdC5kb25lLnB1c2goY3VyKTtcbiAgICAgICAgd2hpbGUgKGhpc3QuZG9uZS5sZW5ndGggPiBoaXN0LnVuZG9EZXB0aCkge1xuICAgICAgICAgIGhpc3QuZG9uZS5zaGlmdCgpO1xuICAgICAgICAgIGlmICghaGlzdC5kb25lWzBdLnJhbmdlcykge1xuICAgICAgICAgICAgaGlzdC5kb25lLnNoaWZ0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBoaXN0LmRvbmUucHVzaChzZWxBZnRlcik7XG4gICAgICBoaXN0LmdlbmVyYXRpb24gPSArK2hpc3QubWF4R2VuZXJhdGlvbjtcbiAgICAgIGhpc3QubGFzdE1vZFRpbWUgPSBoaXN0Lmxhc3RTZWxUaW1lID0gdGltZTtcbiAgICAgIGhpc3QubGFzdE9wID0gaGlzdC5sYXN0U2VsT3AgPSBvcElkO1xuICAgICAgaGlzdC5sYXN0T3JpZ2luID0gaGlzdC5sYXN0U2VsT3JpZ2luID0gY2hhbmdlLm9yaWdpbjtcbiAgICAgIGlmICghbGFzdCkge1xuICAgICAgICBzaWduYWwoZG9jLCBcImhpc3RvcnlBZGRlZFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKGFkZENoYW5nZVRvSGlzdG9yeSwgXCJhZGRDaGFuZ2VUb0hpc3RvcnlcIik7XG4gICAgZnVuY3Rpb24gc2VsZWN0aW9uRXZlbnRDYW5CZU1lcmdlZChkb2MsIG9yaWdpbiwgcHJldiwgc2VsKSB7XG4gICAgICB2YXIgY2ggPSBvcmlnaW4uY2hhckF0KDApO1xuICAgICAgcmV0dXJuIGNoID09IFwiKlwiIHx8IGNoID09IFwiK1wiICYmIHByZXYucmFuZ2VzLmxlbmd0aCA9PSBzZWwucmFuZ2VzLmxlbmd0aCAmJiBwcmV2LnNvbWV0aGluZ1NlbGVjdGVkKCkgPT0gc2VsLnNvbWV0aGluZ1NlbGVjdGVkKCkgJiYgbmV3IERhdGUoKSAtIGRvYy5oaXN0b3J5Lmxhc3RTZWxUaW1lIDw9IChkb2MuY20gPyBkb2MuY20ub3B0aW9ucy5oaXN0b3J5RXZlbnREZWxheSA6IDUwMCk7XG4gICAgfVxuICAgIF9fbmFtZShzZWxlY3Rpb25FdmVudENhbkJlTWVyZ2VkLCBcInNlbGVjdGlvbkV2ZW50Q2FuQmVNZXJnZWRcIik7XG4gICAgZnVuY3Rpb24gYWRkU2VsZWN0aW9uVG9IaXN0b3J5KGRvYywgc2VsLCBvcElkLCBvcHRpb25zKSB7XG4gICAgICB2YXIgaGlzdCA9IGRvYy5oaXN0b3J5LCBvcmlnaW4gPSBvcHRpb25zICYmIG9wdGlvbnMub3JpZ2luO1xuICAgICAgaWYgKG9wSWQgPT0gaGlzdC5sYXN0U2VsT3AgfHwgb3JpZ2luICYmIGhpc3QubGFzdFNlbE9yaWdpbiA9PSBvcmlnaW4gJiYgKGhpc3QubGFzdE1vZFRpbWUgPT0gaGlzdC5sYXN0U2VsVGltZSAmJiBoaXN0Lmxhc3RPcmlnaW4gPT0gb3JpZ2luIHx8IHNlbGVjdGlvbkV2ZW50Q2FuQmVNZXJnZWQoZG9jLCBvcmlnaW4sIGxzdChoaXN0LmRvbmUpLCBzZWwpKSkge1xuICAgICAgICBoaXN0LmRvbmVbaGlzdC5kb25lLmxlbmd0aCAtIDFdID0gc2VsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHVzaFNlbGVjdGlvblRvSGlzdG9yeShzZWwsIGhpc3QuZG9uZSk7XG4gICAgICB9XG4gICAgICBoaXN0Lmxhc3RTZWxUaW1lID0gK25ldyBEYXRlKCk7XG4gICAgICBoaXN0Lmxhc3RTZWxPcmlnaW4gPSBvcmlnaW47XG4gICAgICBoaXN0Lmxhc3RTZWxPcCA9IG9wSWQ7XG4gICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmNsZWFyUmVkbyAhPT0gZmFsc2UpIHtcbiAgICAgICAgY2xlYXJTZWxlY3Rpb25FdmVudHMoaGlzdC51bmRvbmUpO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoYWRkU2VsZWN0aW9uVG9IaXN0b3J5LCBcImFkZFNlbGVjdGlvblRvSGlzdG9yeVwiKTtcbiAgICBmdW5jdGlvbiBwdXNoU2VsZWN0aW9uVG9IaXN0b3J5KHNlbCwgZGVzdCkge1xuICAgICAgdmFyIHRvcCA9IGxzdChkZXN0KTtcbiAgICAgIGlmICghKHRvcCAmJiB0b3AucmFuZ2VzICYmIHRvcC5lcXVhbHMoc2VsKSkpIHtcbiAgICAgICAgZGVzdC5wdXNoKHNlbCk7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShwdXNoU2VsZWN0aW9uVG9IaXN0b3J5LCBcInB1c2hTZWxlY3Rpb25Ub0hpc3RvcnlcIik7XG4gICAgZnVuY3Rpb24gYXR0YWNoTG9jYWxTcGFucyhkb2MsIGNoYW5nZSwgZnJvbSwgdG8pIHtcbiAgICAgIHZhciBleGlzdGluZyA9IGNoYW5nZVtcInNwYW5zX1wiICsgZG9jLmlkXSwgbiA9IDA7XG4gICAgICBkb2MuaXRlcihNYXRoLm1heChkb2MuZmlyc3QsIGZyb20pLCBNYXRoLm1pbihkb2MuZmlyc3QgKyBkb2Muc2l6ZSwgdG8pLCBmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgIGlmIChsaW5lLm1hcmtlZFNwYW5zKSB7XG4gICAgICAgICAgKGV4aXN0aW5nIHx8IChleGlzdGluZyA9IGNoYW5nZVtcInNwYW5zX1wiICsgZG9jLmlkXSA9IHt9KSlbbl0gPSBsaW5lLm1hcmtlZFNwYW5zO1xuICAgICAgICB9XG4gICAgICAgICsrbjtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBfX25hbWUoYXR0YWNoTG9jYWxTcGFucywgXCJhdHRhY2hMb2NhbFNwYW5zXCIpO1xuICAgIGZ1bmN0aW9uIHJlbW92ZUNsZWFyZWRTcGFucyhzcGFucykge1xuICAgICAgaWYgKCFzcGFucykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBvdXQ7XG4gICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgc3BhbnMubGVuZ3RoOyArK2kyKSB7XG4gICAgICAgIGlmIChzcGFuc1tpMl0ubWFya2VyLmV4cGxpY2l0bHlDbGVhcmVkKSB7XG4gICAgICAgICAgaWYgKCFvdXQpIHtcbiAgICAgICAgICAgIG91dCA9IHNwYW5zLnNsaWNlKDAsIGkyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAob3V0KSB7XG4gICAgICAgICAgb3V0LnB1c2goc3BhbnNbaTJdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICFvdXQgPyBzcGFucyA6IG91dC5sZW5ndGggPyBvdXQgOiBudWxsO1xuICAgIH1cbiAgICBfX25hbWUocmVtb3ZlQ2xlYXJlZFNwYW5zLCBcInJlbW92ZUNsZWFyZWRTcGFuc1wiKTtcbiAgICBmdW5jdGlvbiBnZXRPbGRTcGFucyhkb2MsIGNoYW5nZSkge1xuICAgICAgdmFyIGZvdW5kID0gY2hhbmdlW1wic3BhbnNfXCIgKyBkb2MuaWRdO1xuICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBudyA9IFtdO1xuICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IGNoYW5nZS50ZXh0Lmxlbmd0aDsgKytpMikge1xuICAgICAgICBudy5wdXNoKHJlbW92ZUNsZWFyZWRTcGFucyhmb3VuZFtpMl0pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudztcbiAgICB9XG4gICAgX19uYW1lKGdldE9sZFNwYW5zLCBcImdldE9sZFNwYW5zXCIpO1xuICAgIGZ1bmN0aW9uIG1lcmdlT2xkU3BhbnMoZG9jLCBjaGFuZ2UpIHtcbiAgICAgIHZhciBvbGQgPSBnZXRPbGRTcGFucyhkb2MsIGNoYW5nZSk7XG4gICAgICB2YXIgc3RyZXRjaGVkID0gc3RyZXRjaFNwYW5zT3ZlckNoYW5nZShkb2MsIGNoYW5nZSk7XG4gICAgICBpZiAoIW9sZCkge1xuICAgICAgICByZXR1cm4gc3RyZXRjaGVkO1xuICAgICAgfVxuICAgICAgaWYgKCFzdHJldGNoZWQpIHtcbiAgICAgICAgcmV0dXJuIG9sZDtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBvbGQubGVuZ3RoOyArK2kyKSB7XG4gICAgICAgIHZhciBvbGRDdXIgPSBvbGRbaTJdLCBzdHJldGNoQ3VyID0gc3RyZXRjaGVkW2kyXTtcbiAgICAgICAgaWYgKG9sZEN1ciAmJiBzdHJldGNoQ3VyKSB7XG4gICAgICAgICAgc3BhbnM6XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN0cmV0Y2hDdXIubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgdmFyIHNwYW4gPSBzdHJldGNoQ3VyW2pdO1xuICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IG9sZEN1ci5sZW5ndGg7ICsraykge1xuICAgICAgICAgICAgICAgIGlmIChvbGRDdXJba10ubWFya2VyID09IHNwYW4ubWFya2VyKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZSBzcGFucztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb2xkQ3VyLnB1c2goc3Bhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyZXRjaEN1cikge1xuICAgICAgICAgIG9sZFtpMl0gPSBzdHJldGNoQ3VyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2xkO1xuICAgIH1cbiAgICBfX25hbWUobWVyZ2VPbGRTcGFucywgXCJtZXJnZU9sZFNwYW5zXCIpO1xuICAgIGZ1bmN0aW9uIGNvcHlIaXN0b3J5QXJyYXkoZXZlbnRzLCBuZXdHcm91cCwgaW5zdGFudGlhdGVTZWwpIHtcbiAgICAgIHZhciBjb3B5ID0gW107XG4gICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgZXZlbnRzLmxlbmd0aDsgKytpMikge1xuICAgICAgICB2YXIgZXZlbnQgPSBldmVudHNbaTJdO1xuICAgICAgICBpZiAoZXZlbnQucmFuZ2VzKSB7XG4gICAgICAgICAgY29weS5wdXNoKGluc3RhbnRpYXRlU2VsID8gU2VsZWN0aW9uLnByb3RvdHlwZS5kZWVwQ29weS5jYWxsKGV2ZW50KSA6IGV2ZW50KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hhbmdlcyA9IGV2ZW50LmNoYW5nZXMsIG5ld0NoYW5nZXMgPSBbXTtcbiAgICAgICAgY29weS5wdXNoKHsgY2hhbmdlczogbmV3Q2hhbmdlcyB9KTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjaGFuZ2VzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgdmFyIGNoYW5nZSA9IGNoYW5nZXNbal0sIG0gPSB2b2lkIDA7XG4gICAgICAgICAgbmV3Q2hhbmdlcy5wdXNoKHsgZnJvbTogY2hhbmdlLmZyb20sIHRvOiBjaGFuZ2UudG8sIHRleHQ6IGNoYW5nZS50ZXh0IH0pO1xuICAgICAgICAgIGlmIChuZXdHcm91cCkge1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcDIgaW4gY2hhbmdlKSB7XG4gICAgICAgICAgICAgIGlmIChtID0gcHJvcDIubWF0Y2goL15zcGFuc18oXFxkKykkLykpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXhPZihuZXdHcm91cCwgTnVtYmVyKG1bMV0pKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICBsc3QobmV3Q2hhbmdlcylbcHJvcDJdID0gY2hhbmdlW3Byb3AyXTtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjaGFuZ2VbcHJvcDJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuICAgIF9fbmFtZShjb3B5SGlzdG9yeUFycmF5LCBcImNvcHlIaXN0b3J5QXJyYXlcIik7XG4gICAgZnVuY3Rpb24gZXh0ZW5kUmFuZ2UocmFuZ2UyLCBoZWFkLCBvdGhlciwgZXh0ZW5kKSB7XG4gICAgICBpZiAoZXh0ZW5kKSB7XG4gICAgICAgIHZhciBhbmNob3IgPSByYW5nZTIuYW5jaG9yO1xuICAgICAgICBpZiAob3RoZXIpIHtcbiAgICAgICAgICB2YXIgcG9zQmVmb3JlID0gY21wKGhlYWQsIGFuY2hvcikgPCAwO1xuICAgICAgICAgIGlmIChwb3NCZWZvcmUgIT0gY21wKG90aGVyLCBhbmNob3IpIDwgMCkge1xuICAgICAgICAgICAgYW5jaG9yID0gaGVhZDtcbiAgICAgICAgICAgIGhlYWQgPSBvdGhlcjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHBvc0JlZm9yZSAhPSBjbXAoaGVhZCwgb3RoZXIpIDwgMCkge1xuICAgICAgICAgICAgaGVhZCA9IG90aGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKGFuY2hvciwgaGVhZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKG90aGVyIHx8IGhlYWQsIGhlYWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoZXh0ZW5kUmFuZ2UsIFwiZXh0ZW5kUmFuZ2VcIik7XG4gICAgZnVuY3Rpb24gZXh0ZW5kU2VsZWN0aW9uKGRvYywgaGVhZCwgb3RoZXIsIG9wdGlvbnMsIGV4dGVuZCkge1xuICAgICAgaWYgKGV4dGVuZCA9PSBudWxsKSB7XG4gICAgICAgIGV4dGVuZCA9IGRvYy5jbSAmJiAoZG9jLmNtLmRpc3BsYXkuc2hpZnQgfHwgZG9jLmV4dGVuZCk7XG4gICAgICB9XG4gICAgICBzZXRTZWxlY3Rpb24oZG9jLCBuZXcgU2VsZWN0aW9uKFtleHRlbmRSYW5nZShkb2Muc2VsLnByaW1hcnkoKSwgaGVhZCwgb3RoZXIsIGV4dGVuZCldLCAwKSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIF9fbmFtZShleHRlbmRTZWxlY3Rpb24sIFwiZXh0ZW5kU2VsZWN0aW9uXCIpO1xuICAgIGZ1bmN0aW9uIGV4dGVuZFNlbGVjdGlvbnMoZG9jLCBoZWFkcywgb3B0aW9ucykge1xuICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgdmFyIGV4dGVuZCA9IGRvYy5jbSAmJiAoZG9jLmNtLmRpc3BsYXkuc2hpZnQgfHwgZG9jLmV4dGVuZCk7XG4gICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgZG9jLnNlbC5yYW5nZXMubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgIG91dFtpMl0gPSBleHRlbmRSYW5nZShkb2Muc2VsLnJhbmdlc1tpMl0sIGhlYWRzW2kyXSwgbnVsbCwgZXh0ZW5kKTtcbiAgICAgIH1cbiAgICAgIHZhciBuZXdTZWwgPSBub3JtYWxpemVTZWxlY3Rpb24oZG9jLmNtLCBvdXQsIGRvYy5zZWwucHJpbUluZGV4KTtcbiAgICAgIHNldFNlbGVjdGlvbihkb2MsIG5ld1NlbCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIF9fbmFtZShleHRlbmRTZWxlY3Rpb25zLCBcImV4dGVuZFNlbGVjdGlvbnNcIik7XG4gICAgZnVuY3Rpb24gcmVwbGFjZU9uZVNlbGVjdGlvbihkb2MsIGkyLCByYW5nZTIsIG9wdGlvbnMpIHtcbiAgICAgIHZhciByYW5nZXMgPSBkb2Muc2VsLnJhbmdlcy5zbGljZSgwKTtcbiAgICAgIHJhbmdlc1tpMl0gPSByYW5nZTI7XG4gICAgICBzZXRTZWxlY3Rpb24oZG9jLCBub3JtYWxpemVTZWxlY3Rpb24oZG9jLmNtLCByYW5nZXMsIGRvYy5zZWwucHJpbUluZGV4KSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIF9fbmFtZShyZXBsYWNlT25lU2VsZWN0aW9uLCBcInJlcGxhY2VPbmVTZWxlY3Rpb25cIik7XG4gICAgZnVuY3Rpb24gc2V0U2ltcGxlU2VsZWN0aW9uKGRvYywgYW5jaG9yLCBoZWFkLCBvcHRpb25zKSB7XG4gICAgICBzZXRTZWxlY3Rpb24oZG9jLCBzaW1wbGVTZWxlY3Rpb24oYW5jaG9yLCBoZWFkKSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIF9fbmFtZShzZXRTaW1wbGVTZWxlY3Rpb24sIFwic2V0U2ltcGxlU2VsZWN0aW9uXCIpO1xuICAgIGZ1bmN0aW9uIGZpbHRlclNlbGVjdGlvbkNoYW5nZShkb2MsIHNlbCwgb3B0aW9ucykge1xuICAgICAgdmFyIG9iaiA9IHtcbiAgICAgICAgcmFuZ2VzOiBzZWwucmFuZ2VzLFxuICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uKHJhbmdlcykge1xuICAgICAgICAgIHRoaXMucmFuZ2VzID0gW107XG4gICAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IHJhbmdlcy5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgICAgIHRoaXMucmFuZ2VzW2kyXSA9IG5ldyBSYW5nZShjbGlwUG9zKGRvYywgcmFuZ2VzW2kyXS5hbmNob3IpLCBjbGlwUG9zKGRvYywgcmFuZ2VzW2kyXS5oZWFkKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvcmlnaW46IG9wdGlvbnMgJiYgb3B0aW9ucy5vcmlnaW5cbiAgICAgIH07XG4gICAgICBzaWduYWwoZG9jLCBcImJlZm9yZVNlbGVjdGlvbkNoYW5nZVwiLCBkb2MsIG9iaik7XG4gICAgICBpZiAoZG9jLmNtKSB7XG4gICAgICAgIHNpZ25hbChkb2MuY20sIFwiYmVmb3JlU2VsZWN0aW9uQ2hhbmdlXCIsIGRvYy5jbSwgb2JqKTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmoucmFuZ2VzICE9IHNlbC5yYW5nZXMpIHtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVNlbGVjdGlvbihkb2MuY20sIG9iai5yYW5nZXMsIG9iai5yYW5nZXMubGVuZ3RoIC0gMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VsO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoZmlsdGVyU2VsZWN0aW9uQ2hhbmdlLCBcImZpbHRlclNlbGVjdGlvbkNoYW5nZVwiKTtcbiAgICBmdW5jdGlvbiBzZXRTZWxlY3Rpb25SZXBsYWNlSGlzdG9yeShkb2MsIHNlbCwgb3B0aW9ucykge1xuICAgICAgdmFyIGRvbmUgPSBkb2MuaGlzdG9yeS5kb25lLCBsYXN0ID0gbHN0KGRvbmUpO1xuICAgICAgaWYgKGxhc3QgJiYgbGFzdC5yYW5nZXMpIHtcbiAgICAgICAgZG9uZVtkb25lLmxlbmd0aCAtIDFdID0gc2VsO1xuICAgICAgICBzZXRTZWxlY3Rpb25Ob1VuZG8oZG9jLCBzZWwsIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0U2VsZWN0aW9uKGRvYywgc2VsLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKHNldFNlbGVjdGlvblJlcGxhY2VIaXN0b3J5LCBcInNldFNlbGVjdGlvblJlcGxhY2VIaXN0b3J5XCIpO1xuICAgIGZ1bmN0aW9uIHNldFNlbGVjdGlvbihkb2MsIHNlbCwgb3B0aW9ucykge1xuICAgICAgc2V0U2VsZWN0aW9uTm9VbmRvKGRvYywgc2VsLCBvcHRpb25zKTtcbiAgICAgIGFkZFNlbGVjdGlvblRvSGlzdG9yeShkb2MsIGRvYy5zZWwsIGRvYy5jbSA/IGRvYy5jbS5jdXJPcC5pZCA6IE5hTiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIF9fbmFtZShzZXRTZWxlY3Rpb24sIFwic2V0U2VsZWN0aW9uXCIpO1xuICAgIGZ1bmN0aW9uIHNldFNlbGVjdGlvbk5vVW5kbyhkb2MsIHNlbCwgb3B0aW9ucykge1xuICAgICAgaWYgKGhhc0hhbmRsZXIoZG9jLCBcImJlZm9yZVNlbGVjdGlvbkNoYW5nZVwiKSB8fCBkb2MuY20gJiYgaGFzSGFuZGxlcihkb2MuY20sIFwiYmVmb3JlU2VsZWN0aW9uQ2hhbmdlXCIpKSB7XG4gICAgICAgIHNlbCA9IGZpbHRlclNlbGVjdGlvbkNoYW5nZShkb2MsIHNlbCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICB2YXIgYmlhcyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5iaWFzIHx8IChjbXAoc2VsLnByaW1hcnkoKS5oZWFkLCBkb2Muc2VsLnByaW1hcnkoKS5oZWFkKSA8IDAgPyAtMSA6IDEpO1xuICAgICAgc2V0U2VsZWN0aW9uSW5uZXIoZG9jLCBza2lwQXRvbWljSW5TZWxlY3Rpb24oZG9jLCBzZWwsIGJpYXMsIHRydWUpKTtcbiAgICAgIGlmICghKG9wdGlvbnMgJiYgb3B0aW9ucy5zY3JvbGwgPT09IGZhbHNlKSAmJiBkb2MuY20gJiYgZG9jLmNtLmdldE9wdGlvbihcInJlYWRPbmx5XCIpICE9IFwibm9jdXJzb3JcIikge1xuICAgICAgICBlbnN1cmVDdXJzb3JWaXNpYmxlKGRvYy5jbSk7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShzZXRTZWxlY3Rpb25Ob1VuZG8sIFwic2V0U2VsZWN0aW9uTm9VbmRvXCIpO1xuICAgIGZ1bmN0aW9uIHNldFNlbGVjdGlvbklubmVyKGRvYywgc2VsKSB7XG4gICAgICBpZiAoc2VsLmVxdWFscyhkb2Muc2VsKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkb2Muc2VsID0gc2VsO1xuICAgICAgaWYgKGRvYy5jbSkge1xuICAgICAgICBkb2MuY20uY3VyT3AudXBkYXRlSW5wdXQgPSAxO1xuICAgICAgICBkb2MuY20uY3VyT3Auc2VsZWN0aW9uQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIHNpZ25hbEN1cnNvckFjdGl2aXR5KGRvYy5jbSk7XG4gICAgICB9XG4gICAgICBzaWduYWxMYXRlcihkb2MsIFwiY3Vyc29yQWN0aXZpdHlcIiwgZG9jKTtcbiAgICB9XG4gICAgX19uYW1lKHNldFNlbGVjdGlvbklubmVyLCBcInNldFNlbGVjdGlvbklubmVyXCIpO1xuICAgIGZ1bmN0aW9uIHJlQ2hlY2tTZWxlY3Rpb24oZG9jKSB7XG4gICAgICBzZXRTZWxlY3Rpb25Jbm5lcihkb2MsIHNraXBBdG9taWNJblNlbGVjdGlvbihkb2MsIGRvYy5zZWwsIG51bGwsIGZhbHNlKSk7XG4gICAgfVxuICAgIF9fbmFtZShyZUNoZWNrU2VsZWN0aW9uLCBcInJlQ2hlY2tTZWxlY3Rpb25cIik7XG4gICAgZnVuY3Rpb24gc2tpcEF0b21pY0luU2VsZWN0aW9uKGRvYywgc2VsLCBiaWFzLCBtYXlDbGVhcikge1xuICAgICAgdmFyIG91dDtcbiAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBzZWwucmFuZ2VzLmxlbmd0aDsgaTIrKykge1xuICAgICAgICB2YXIgcmFuZ2UyID0gc2VsLnJhbmdlc1tpMl07XG4gICAgICAgIHZhciBvbGQgPSBzZWwucmFuZ2VzLmxlbmd0aCA9PSBkb2Muc2VsLnJhbmdlcy5sZW5ndGggJiYgZG9jLnNlbC5yYW5nZXNbaTJdO1xuICAgICAgICB2YXIgbmV3QW5jaG9yID0gc2tpcEF0b21pYyhkb2MsIHJhbmdlMi5hbmNob3IsIG9sZCAmJiBvbGQuYW5jaG9yLCBiaWFzLCBtYXlDbGVhcik7XG4gICAgICAgIHZhciBuZXdIZWFkID0gc2tpcEF0b21pYyhkb2MsIHJhbmdlMi5oZWFkLCBvbGQgJiYgb2xkLmhlYWQsIGJpYXMsIG1heUNsZWFyKTtcbiAgICAgICAgaWYgKG91dCB8fCBuZXdBbmNob3IgIT0gcmFuZ2UyLmFuY2hvciB8fCBuZXdIZWFkICE9IHJhbmdlMi5oZWFkKSB7XG4gICAgICAgICAgaWYgKCFvdXQpIHtcbiAgICAgICAgICAgIG91dCA9IHNlbC5yYW5nZXMuc2xpY2UoMCwgaTIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXRbaTJdID0gbmV3IFJhbmdlKG5ld0FuY2hvciwgbmV3SGVhZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQgPyBub3JtYWxpemVTZWxlY3Rpb24oZG9jLmNtLCBvdXQsIHNlbC5wcmltSW5kZXgpIDogc2VsO1xuICAgIH1cbiAgICBfX25hbWUoc2tpcEF0b21pY0luU2VsZWN0aW9uLCBcInNraXBBdG9taWNJblNlbGVjdGlvblwiKTtcbiAgICBmdW5jdGlvbiBza2lwQXRvbWljSW5uZXIoZG9jLCBwb3MsIG9sZFBvcywgZGlyLCBtYXlDbGVhcikge1xuICAgICAgdmFyIGxpbmUgPSBnZXRMaW5lKGRvYywgcG9zLmxpbmUpO1xuICAgICAgaWYgKGxpbmUubWFya2VkU3BhbnMpIHtcbiAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IGxpbmUubWFya2VkU3BhbnMubGVuZ3RoOyArK2kyKSB7XG4gICAgICAgICAgdmFyIHNwID0gbGluZS5tYXJrZWRTcGFuc1tpMl0sIG0gPSBzcC5tYXJrZXI7XG4gICAgICAgICAgdmFyIHByZXZlbnRDdXJzb3JMZWZ0ID0gXCJzZWxlY3RMZWZ0XCIgaW4gbSA/ICFtLnNlbGVjdExlZnQgOiBtLmluY2x1c2l2ZUxlZnQ7XG4gICAgICAgICAgdmFyIHByZXZlbnRDdXJzb3JSaWdodCA9IFwic2VsZWN0UmlnaHRcIiBpbiBtID8gIW0uc2VsZWN0UmlnaHQgOiBtLmluY2x1c2l2ZVJpZ2h0O1xuICAgICAgICAgIGlmICgoc3AuZnJvbSA9PSBudWxsIHx8IChwcmV2ZW50Q3Vyc29yTGVmdCA/IHNwLmZyb20gPD0gcG9zLmNoIDogc3AuZnJvbSA8IHBvcy5jaCkpICYmIChzcC50byA9PSBudWxsIHx8IChwcmV2ZW50Q3Vyc29yUmlnaHQgPyBzcC50byA+PSBwb3MuY2ggOiBzcC50byA+IHBvcy5jaCkpKSB7XG4gICAgICAgICAgICBpZiAobWF5Q2xlYXIpIHtcbiAgICAgICAgICAgICAgc2lnbmFsKG0sIFwiYmVmb3JlQ3Vyc29yRW50ZXJcIik7XG4gICAgICAgICAgICAgIGlmIChtLmV4cGxpY2l0bHlDbGVhcmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFsaW5lLm1hcmtlZFNwYW5zKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLS1pMjtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFtLmF0b21pYykge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvbGRQb3MpIHtcbiAgICAgICAgICAgICAgdmFyIG5lYXIgPSBtLmZpbmQoZGlyIDwgMCA/IDEgOiAtMSksIGRpZmYgPSB2b2lkIDA7XG4gICAgICAgICAgICAgIGlmIChkaXIgPCAwID8gcHJldmVudEN1cnNvclJpZ2h0IDogcHJldmVudEN1cnNvckxlZnQpIHtcbiAgICAgICAgICAgICAgICBuZWFyID0gbW92ZVBvcyhkb2MsIG5lYXIsIC1kaXIsIG5lYXIgJiYgbmVhci5saW5lID09IHBvcy5saW5lID8gbGluZSA6IG51bGwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChuZWFyICYmIG5lYXIubGluZSA9PSBwb3MubGluZSAmJiAoZGlmZiA9IGNtcChuZWFyLCBvbGRQb3MpKSAmJiAoZGlyIDwgMCA/IGRpZmYgPCAwIDogZGlmZiA+IDApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNraXBBdG9taWNJbm5lcihkb2MsIG5lYXIsIHBvcywgZGlyLCBtYXlDbGVhcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmYXIgPSBtLmZpbmQoZGlyIDwgMCA/IC0xIDogMSk7XG4gICAgICAgICAgICBpZiAoZGlyIDwgMCA/IHByZXZlbnRDdXJzb3JMZWZ0IDogcHJldmVudEN1cnNvclJpZ2h0KSB7XG4gICAgICAgICAgICAgIGZhciA9IG1vdmVQb3MoZG9jLCBmYXIsIGRpciwgZmFyLmxpbmUgPT0gcG9zLmxpbmUgPyBsaW5lIDogbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFyID8gc2tpcEF0b21pY0lubmVyKGRvYywgZmFyLCBwb3MsIGRpciwgbWF5Q2xlYXIpIDogbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIF9fbmFtZShza2lwQXRvbWljSW5uZXIsIFwic2tpcEF0b21pY0lubmVyXCIpO1xuICAgIGZ1bmN0aW9uIHNraXBBdG9taWMoZG9jLCBwb3MsIG9sZFBvcywgYmlhcywgbWF5Q2xlYXIpIHtcbiAgICAgIHZhciBkaXIgPSBiaWFzIHx8IDE7XG4gICAgICB2YXIgZm91bmQgPSBza2lwQXRvbWljSW5uZXIoZG9jLCBwb3MsIG9sZFBvcywgZGlyLCBtYXlDbGVhcikgfHwgIW1heUNsZWFyICYmIHNraXBBdG9taWNJbm5lcihkb2MsIHBvcywgb2xkUG9zLCBkaXIsIHRydWUpIHx8IHNraXBBdG9taWNJbm5lcihkb2MsIHBvcywgb2xkUG9zLCAtZGlyLCBtYXlDbGVhcikgfHwgIW1heUNsZWFyICYmIHNraXBBdG9taWNJbm5lcihkb2MsIHBvcywgb2xkUG9zLCAtZGlyLCB0cnVlKTtcbiAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgZG9jLmNhbnRFZGl0ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIFBvcyhkb2MuZmlyc3QsIDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgICBfX25hbWUoc2tpcEF0b21pYywgXCJza2lwQXRvbWljXCIpO1xuICAgIGZ1bmN0aW9uIG1vdmVQb3MoZG9jLCBwb3MsIGRpciwgbGluZSkge1xuICAgICAgaWYgKGRpciA8IDAgJiYgcG9zLmNoID09IDApIHtcbiAgICAgICAgaWYgKHBvcy5saW5lID4gZG9jLmZpcnN0KSB7XG4gICAgICAgICAgcmV0dXJuIGNsaXBQb3MoZG9jLCBQb3MocG9zLmxpbmUgLSAxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGlyID4gMCAmJiBwb3MuY2ggPT0gKGxpbmUgfHwgZ2V0TGluZShkb2MsIHBvcy5saW5lKSkudGV4dC5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHBvcy5saW5lIDwgZG9jLmZpcnN0ICsgZG9jLnNpemUgLSAxKSB7XG4gICAgICAgICAgcmV0dXJuIFBvcyhwb3MubGluZSArIDEsIDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IFBvcyhwb3MubGluZSwgcG9zLmNoICsgZGlyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKG1vdmVQb3MsIFwibW92ZVBvc1wiKTtcbiAgICBmdW5jdGlvbiBzZWxlY3RBbGwoY20pIHtcbiAgICAgIGNtLnNldFNlbGVjdGlvbihQb3MoY20uZmlyc3RMaW5lKCksIDApLCBQb3MoY20ubGFzdExpbmUoKSksIHNlbF9kb250U2Nyb2xsKTtcbiAgICB9XG4gICAgX19uYW1lKHNlbGVjdEFsbCwgXCJzZWxlY3RBbGxcIik7XG4gICAgZnVuY3Rpb24gZmlsdGVyQ2hhbmdlKGRvYywgY2hhbmdlLCB1cGRhdGUpIHtcbiAgICAgIHZhciBvYmogPSB7XG4gICAgICAgIGNhbmNlbGVkOiBmYWxzZSxcbiAgICAgICAgZnJvbTogY2hhbmdlLmZyb20sXG4gICAgICAgIHRvOiBjaGFuZ2UudG8sXG4gICAgICAgIHRleHQ6IGNoYW5nZS50ZXh0LFxuICAgICAgICBvcmlnaW46IGNoYW5nZS5vcmlnaW4sXG4gICAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIG9iai5jYW5jZWxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgIG9iai51cGRhdGUgPSBmdW5jdGlvbihmcm9tLCB0bywgdGV4dCwgb3JpZ2luKSB7XG4gICAgICAgICAgaWYgKGZyb20pIHtcbiAgICAgICAgICAgIG9iai5mcm9tID0gY2xpcFBvcyhkb2MsIGZyb20pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodG8pIHtcbiAgICAgICAgICAgIG9iai50byA9IGNsaXBQb3MoZG9jLCB0byk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICBvYmoudGV4dCA9IHRleHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcmlnaW4gIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgb2JqLm9yaWdpbiA9IG9yaWdpbjtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBzaWduYWwoZG9jLCBcImJlZm9yZUNoYW5nZVwiLCBkb2MsIG9iaik7XG4gICAgICBpZiAoZG9jLmNtKSB7XG4gICAgICAgIHNpZ25hbChkb2MuY20sIFwiYmVmb3JlQ2hhbmdlXCIsIGRvYy5jbSwgb2JqKTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmouY2FuY2VsZWQpIHtcbiAgICAgICAgaWYgKGRvYy5jbSkge1xuICAgICAgICAgIGRvYy5jbS5jdXJPcC51cGRhdGVJbnB1dCA9IDI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBmcm9tOiBvYmouZnJvbSwgdG86IG9iai50bywgdGV4dDogb2JqLnRleHQsIG9yaWdpbjogb2JqLm9yaWdpbiB9O1xuICAgIH1cbiAgICBfX25hbWUoZmlsdGVyQ2hhbmdlLCBcImZpbHRlckNoYW5nZVwiKTtcbiAgICBmdW5jdGlvbiBtYWtlQ2hhbmdlKGRvYywgY2hhbmdlLCBpZ25vcmVSZWFkT25seSkge1xuICAgICAgaWYgKGRvYy5jbSkge1xuICAgICAgICBpZiAoIWRvYy5jbS5jdXJPcCkge1xuICAgICAgICAgIHJldHVybiBvcGVyYXRpb24oZG9jLmNtLCBtYWtlQ2hhbmdlKShkb2MsIGNoYW5nZSwgaWdub3JlUmVhZE9ubHkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb2MuY20uc3RhdGUuc3VwcHJlc3NFZGl0cykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGhhc0hhbmRsZXIoZG9jLCBcImJlZm9yZUNoYW5nZVwiKSB8fCBkb2MuY20gJiYgaGFzSGFuZGxlcihkb2MuY20sIFwiYmVmb3JlQ2hhbmdlXCIpKSB7XG4gICAgICAgIGNoYW5nZSA9IGZpbHRlckNoYW5nZShkb2MsIGNoYW5nZSwgdHJ1ZSk7XG4gICAgICAgIGlmICghY2hhbmdlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgc3BsaXQgPSBzYXdSZWFkT25seVNwYW5zICYmICFpZ25vcmVSZWFkT25seSAmJiByZW1vdmVSZWFkT25seVJhbmdlcyhkb2MsIGNoYW5nZS5mcm9tLCBjaGFuZ2UudG8pO1xuICAgICAgaWYgKHNwbGl0KSB7XG4gICAgICAgIGZvciAodmFyIGkyID0gc3BsaXQubGVuZ3RoIC0gMTsgaTIgPj0gMDsgLS1pMikge1xuICAgICAgICAgIG1ha2VDaGFuZ2VJbm5lcihkb2MsIHsgZnJvbTogc3BsaXRbaTJdLmZyb20sIHRvOiBzcGxpdFtpMl0udG8sIHRleHQ6IGkyID8gW1wiXCJdIDogY2hhbmdlLnRleHQsIG9yaWdpbjogY2hhbmdlLm9yaWdpbiB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFrZUNoYW5nZUlubmVyKGRvYywgY2hhbmdlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKG1ha2VDaGFuZ2UsIFwibWFrZUNoYW5nZVwiKTtcbiAgICBmdW5jdGlvbiBtYWtlQ2hhbmdlSW5uZXIoZG9jLCBjaGFuZ2UpIHtcbiAgICAgIGlmIChjaGFuZ2UudGV4dC5sZW5ndGggPT0gMSAmJiBjaGFuZ2UudGV4dFswXSA9PSBcIlwiICYmIGNtcChjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvKSA9PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBzZWxBZnRlciA9IGNvbXB1dGVTZWxBZnRlckNoYW5nZShkb2MsIGNoYW5nZSk7XG4gICAgICBhZGRDaGFuZ2VUb0hpc3RvcnkoZG9jLCBjaGFuZ2UsIHNlbEFmdGVyLCBkb2MuY20gPyBkb2MuY20uY3VyT3AuaWQgOiBOYU4pO1xuICAgICAgbWFrZUNoYW5nZVNpbmdsZURvYyhkb2MsIGNoYW5nZSwgc2VsQWZ0ZXIsIHN0cmV0Y2hTcGFuc092ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UpKTtcbiAgICAgIHZhciByZWJhc2VkID0gW107XG4gICAgICBsaW5rZWREb2NzKGRvYywgZnVuY3Rpb24oZG9jMiwgc2hhcmVkSGlzdCkge1xuICAgICAgICBpZiAoIXNoYXJlZEhpc3QgJiYgaW5kZXhPZihyZWJhc2VkLCBkb2MyLmhpc3RvcnkpID09IC0xKSB7XG4gICAgICAgICAgcmViYXNlSGlzdChkb2MyLmhpc3RvcnksIGNoYW5nZSk7XG4gICAgICAgICAgcmViYXNlZC5wdXNoKGRvYzIuaGlzdG9yeSk7XG4gICAgICAgIH1cbiAgICAgICAgbWFrZUNoYW5nZVNpbmdsZURvYyhkb2MyLCBjaGFuZ2UsIG51bGwsIHN0cmV0Y2hTcGFuc092ZXJDaGFuZ2UoZG9jMiwgY2hhbmdlKSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgX19uYW1lKG1ha2VDaGFuZ2VJbm5lciwgXCJtYWtlQ2hhbmdlSW5uZXJcIik7XG4gICAgZnVuY3Rpb24gbWFrZUNoYW5nZUZyb21IaXN0b3J5KGRvYywgdHlwZSwgYWxsb3dTZWxlY3Rpb25Pbmx5KSB7XG4gICAgICB2YXIgc3VwcHJlc3MgPSBkb2MuY20gJiYgZG9jLmNtLnN0YXRlLnN1cHByZXNzRWRpdHM7XG4gICAgICBpZiAoc3VwcHJlc3MgJiYgIWFsbG93U2VsZWN0aW9uT25seSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaGlzdCA9IGRvYy5oaXN0b3J5LCBldmVudCwgc2VsQWZ0ZXIgPSBkb2Muc2VsO1xuICAgICAgdmFyIHNvdXJjZSA9IHR5cGUgPT0gXCJ1bmRvXCIgPyBoaXN0LmRvbmUgOiBoaXN0LnVuZG9uZSwgZGVzdCA9IHR5cGUgPT0gXCJ1bmRvXCIgPyBoaXN0LnVuZG9uZSA6IGhpc3QuZG9uZTtcbiAgICAgIHZhciBpMiA9IDA7XG4gICAgICBmb3IgKDsgaTIgPCBzb3VyY2UubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgIGV2ZW50ID0gc291cmNlW2kyXTtcbiAgICAgICAgaWYgKGFsbG93U2VsZWN0aW9uT25seSA/IGV2ZW50LnJhbmdlcyAmJiAhZXZlbnQuZXF1YWxzKGRvYy5zZWwpIDogIWV2ZW50LnJhbmdlcykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaTIgPT0gc291cmNlLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBoaXN0Lmxhc3RPcmlnaW4gPSBoaXN0Lmxhc3RTZWxPcmlnaW4gPSBudWxsO1xuICAgICAgZm9yICg7IDsgKSB7XG4gICAgICAgIGV2ZW50ID0gc291cmNlLnBvcCgpO1xuICAgICAgICBpZiAoZXZlbnQucmFuZ2VzKSB7XG4gICAgICAgICAgcHVzaFNlbGVjdGlvblRvSGlzdG9yeShldmVudCwgZGVzdCk7XG4gICAgICAgICAgaWYgKGFsbG93U2VsZWN0aW9uT25seSAmJiAhZXZlbnQuZXF1YWxzKGRvYy5zZWwpKSB7XG4gICAgICAgICAgICBzZXRTZWxlY3Rpb24oZG9jLCBldmVudCwgeyBjbGVhclJlZG86IGZhbHNlIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxBZnRlciA9IGV2ZW50O1xuICAgICAgICB9IGVsc2UgaWYgKHN1cHByZXNzKSB7XG4gICAgICAgICAgc291cmNlLnB1c2goZXZlbnQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGFudGlDaGFuZ2VzID0gW107XG4gICAgICBwdXNoU2VsZWN0aW9uVG9IaXN0b3J5KHNlbEFmdGVyLCBkZXN0KTtcbiAgICAgIGRlc3QucHVzaCh7IGNoYW5nZXM6IGFudGlDaGFuZ2VzLCBnZW5lcmF0aW9uOiBoaXN0LmdlbmVyYXRpb24gfSk7XG4gICAgICBoaXN0LmdlbmVyYXRpb24gPSBldmVudC5nZW5lcmF0aW9uIHx8ICsraGlzdC5tYXhHZW5lcmF0aW9uO1xuICAgICAgdmFyIGZpbHRlciA9IGhhc0hhbmRsZXIoZG9jLCBcImJlZm9yZUNoYW5nZVwiKSB8fCBkb2MuY20gJiYgaGFzSGFuZGxlcihkb2MuY20sIFwiYmVmb3JlQ2hhbmdlXCIpO1xuICAgICAgdmFyIGxvb3AgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKGkzKSB7XG4gICAgICAgIHZhciBjaGFuZ2UgPSBldmVudC5jaGFuZ2VzW2kzXTtcbiAgICAgICAgY2hhbmdlLm9yaWdpbiA9IHR5cGU7XG4gICAgICAgIGlmIChmaWx0ZXIgJiYgIWZpbHRlckNoYW5nZShkb2MsIGNoYW5nZSwgZmFsc2UpKSB7XG4gICAgICAgICAgc291cmNlLmxlbmd0aCA9IDA7XG4gICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICAgIGFudGlDaGFuZ2VzLnB1c2goaGlzdG9yeUNoYW5nZUZyb21DaGFuZ2UoZG9jLCBjaGFuZ2UpKTtcbiAgICAgICAgdmFyIGFmdGVyID0gaTMgPyBjb21wdXRlU2VsQWZ0ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UpIDogbHN0KHNvdXJjZSk7XG4gICAgICAgIG1ha2VDaGFuZ2VTaW5nbGVEb2MoZG9jLCBjaGFuZ2UsIGFmdGVyLCBtZXJnZU9sZFNwYW5zKGRvYywgY2hhbmdlKSk7XG4gICAgICAgIGlmICghaTMgJiYgZG9jLmNtKSB7XG4gICAgICAgICAgZG9jLmNtLnNjcm9sbEludG9WaWV3KHsgZnJvbTogY2hhbmdlLmZyb20sIHRvOiBjaGFuZ2VFbmQoY2hhbmdlKSB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmViYXNlZCA9IFtdO1xuICAgICAgICBsaW5rZWREb2NzKGRvYywgZnVuY3Rpb24oZG9jMiwgc2hhcmVkSGlzdCkge1xuICAgICAgICAgIGlmICghc2hhcmVkSGlzdCAmJiBpbmRleE9mKHJlYmFzZWQsIGRvYzIuaGlzdG9yeSkgPT0gLTEpIHtcbiAgICAgICAgICAgIHJlYmFzZUhpc3QoZG9jMi5oaXN0b3J5LCBjaGFuZ2UpO1xuICAgICAgICAgICAgcmViYXNlZC5wdXNoKGRvYzIuaGlzdG9yeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1ha2VDaGFuZ2VTaW5nbGVEb2MoZG9jMiwgY2hhbmdlLCBudWxsLCBtZXJnZU9sZFNwYW5zKGRvYzIsIGNoYW5nZSkpO1xuICAgICAgICB9KTtcbiAgICAgIH0sIFwibG9vcFwiKTtcbiAgICAgIGZvciAodmFyIGkkMTIgPSBldmVudC5jaGFuZ2VzLmxlbmd0aCAtIDE7IGkkMTIgPj0gMDsgLS1pJDEyKSB7XG4gICAgICAgIHZhciByZXR1cm5lZCA9IGxvb3AoaSQxMik7XG4gICAgICAgIGlmIChyZXR1cm5lZClcbiAgICAgICAgICByZXR1cm4gcmV0dXJuZWQudjtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKG1ha2VDaGFuZ2VGcm9tSGlzdG9yeSwgXCJtYWtlQ2hhbmdlRnJvbUhpc3RvcnlcIik7XG4gICAgZnVuY3Rpb24gc2hpZnREb2MoZG9jLCBkaXN0YW5jZSkge1xuICAgICAgaWYgKGRpc3RhbmNlID09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZG9jLmZpcnN0ICs9IGRpc3RhbmNlO1xuICAgICAgZG9jLnNlbCA9IG5ldyBTZWxlY3Rpb24obWFwKGRvYy5zZWwucmFuZ2VzLCBmdW5jdGlvbihyYW5nZTIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShQb3MocmFuZ2UyLmFuY2hvci5saW5lICsgZGlzdGFuY2UsIHJhbmdlMi5hbmNob3IuY2gpLCBQb3MocmFuZ2UyLmhlYWQubGluZSArIGRpc3RhbmNlLCByYW5nZTIuaGVhZC5jaCkpO1xuICAgICAgfSksIGRvYy5zZWwucHJpbUluZGV4KTtcbiAgICAgIGlmIChkb2MuY20pIHtcbiAgICAgICAgcmVnQ2hhbmdlKGRvYy5jbSwgZG9jLmZpcnN0LCBkb2MuZmlyc3QgLSBkaXN0YW5jZSwgZGlzdGFuY2UpO1xuICAgICAgICBmb3IgKHZhciBkID0gZG9jLmNtLmRpc3BsYXksIGwgPSBkLnZpZXdGcm9tOyBsIDwgZC52aWV3VG87IGwrKykge1xuICAgICAgICAgIHJlZ0xpbmVDaGFuZ2UoZG9jLmNtLCBsLCBcImd1dHRlclwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoc2hpZnREb2MsIFwic2hpZnREb2NcIik7XG4gICAgZnVuY3Rpb24gbWFrZUNoYW5nZVNpbmdsZURvYyhkb2MsIGNoYW5nZSwgc2VsQWZ0ZXIsIHNwYW5zKSB7XG4gICAgICBpZiAoZG9jLmNtICYmICFkb2MuY20uY3VyT3ApIHtcbiAgICAgICAgcmV0dXJuIG9wZXJhdGlvbihkb2MuY20sIG1ha2VDaGFuZ2VTaW5nbGVEb2MpKGRvYywgY2hhbmdlLCBzZWxBZnRlciwgc3BhbnMpO1xuICAgICAgfVxuICAgICAgaWYgKGNoYW5nZS50by5saW5lIDwgZG9jLmZpcnN0KSB7XG4gICAgICAgIHNoaWZ0RG9jKGRvYywgY2hhbmdlLnRleHQubGVuZ3RoIC0gMSAtIChjaGFuZ2UudG8ubGluZSAtIGNoYW5nZS5mcm9tLmxpbmUpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGNoYW5nZS5mcm9tLmxpbmUgPiBkb2MubGFzdExpbmUoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoY2hhbmdlLmZyb20ubGluZSA8IGRvYy5maXJzdCkge1xuICAgICAgICB2YXIgc2hpZnQgPSBjaGFuZ2UudGV4dC5sZW5ndGggLSAxIC0gKGRvYy5maXJzdCAtIGNoYW5nZS5mcm9tLmxpbmUpO1xuICAgICAgICBzaGlmdERvYyhkb2MsIHNoaWZ0KTtcbiAgICAgICAgY2hhbmdlID0ge1xuICAgICAgICAgIGZyb206IFBvcyhkb2MuZmlyc3QsIDApLFxuICAgICAgICAgIHRvOiBQb3MoY2hhbmdlLnRvLmxpbmUgKyBzaGlmdCwgY2hhbmdlLnRvLmNoKSxcbiAgICAgICAgICB0ZXh0OiBbbHN0KGNoYW5nZS50ZXh0KV0sXG4gICAgICAgICAgb3JpZ2luOiBjaGFuZ2Uub3JpZ2luXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB2YXIgbGFzdCA9IGRvYy5sYXN0TGluZSgpO1xuICAgICAgaWYgKGNoYW5nZS50by5saW5lID4gbGFzdCkge1xuICAgICAgICBjaGFuZ2UgPSB7XG4gICAgICAgICAgZnJvbTogY2hhbmdlLmZyb20sXG4gICAgICAgICAgdG86IFBvcyhsYXN0LCBnZXRMaW5lKGRvYywgbGFzdCkudGV4dC5sZW5ndGgpLFxuICAgICAgICAgIHRleHQ6IFtjaGFuZ2UudGV4dFswXV0sXG4gICAgICAgICAgb3JpZ2luOiBjaGFuZ2Uub3JpZ2luXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjaGFuZ2UucmVtb3ZlZCA9IGdldEJldHdlZW4oZG9jLCBjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvKTtcbiAgICAgIGlmICghc2VsQWZ0ZXIpIHtcbiAgICAgICAgc2VsQWZ0ZXIgPSBjb21wdXRlU2VsQWZ0ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UpO1xuICAgICAgfVxuICAgICAgaWYgKGRvYy5jbSkge1xuICAgICAgICBtYWtlQ2hhbmdlU2luZ2xlRG9jSW5FZGl0b3IoZG9jLmNtLCBjaGFuZ2UsIHNwYW5zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVwZGF0ZURvYyhkb2MsIGNoYW5nZSwgc3BhbnMpO1xuICAgICAgfVxuICAgICAgc2V0U2VsZWN0aW9uTm9VbmRvKGRvYywgc2VsQWZ0ZXIsIHNlbF9kb250U2Nyb2xsKTtcbiAgICAgIGlmIChkb2MuY2FudEVkaXQgJiYgc2tpcEF0b21pYyhkb2MsIFBvcyhkb2MuZmlyc3RMaW5lKCksIDApKSkge1xuICAgICAgICBkb2MuY2FudEVkaXQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKG1ha2VDaGFuZ2VTaW5nbGVEb2MsIFwibWFrZUNoYW5nZVNpbmdsZURvY1wiKTtcbiAgICBmdW5jdGlvbiBtYWtlQ2hhbmdlU2luZ2xlRG9jSW5FZGl0b3IoY20sIGNoYW5nZSwgc3BhbnMpIHtcbiAgICAgIHZhciBkb2MgPSBjbS5kb2MsIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBmcm9tID0gY2hhbmdlLmZyb20sIHRvID0gY2hhbmdlLnRvO1xuICAgICAgdmFyIHJlY29tcHV0ZU1heExlbmd0aCA9IGZhbHNlLCBjaGVja1dpZHRoU3RhcnQgPSBmcm9tLmxpbmU7XG4gICAgICBpZiAoIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7XG4gICAgICAgIGNoZWNrV2lkdGhTdGFydCA9IGxpbmVObyh2aXN1YWxMaW5lKGdldExpbmUoZG9jLCBmcm9tLmxpbmUpKSk7XG4gICAgICAgIGRvYy5pdGVyKGNoZWNrV2lkdGhTdGFydCwgdG8ubGluZSArIDEsIGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICBpZiAobGluZSA9PSBkaXNwbGF5Lm1heExpbmUpIHtcbiAgICAgICAgICAgIHJlY29tcHV0ZU1heExlbmd0aCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGRvYy5zZWwuY29udGFpbnMoY2hhbmdlLmZyb20sIGNoYW5nZS50bykgPiAtMSkge1xuICAgICAgICBzaWduYWxDdXJzb3JBY3Rpdml0eShjbSk7XG4gICAgICB9XG4gICAgICB1cGRhdGVEb2MoZG9jLCBjaGFuZ2UsIHNwYW5zLCBlc3RpbWF0ZUhlaWdodChjbSkpO1xuICAgICAgaWYgKCFjbS5vcHRpb25zLmxpbmVXcmFwcGluZykge1xuICAgICAgICBkb2MuaXRlcihjaGVja1dpZHRoU3RhcnQsIGZyb20ubGluZSArIGNoYW5nZS50ZXh0Lmxlbmd0aCwgZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgIHZhciBsZW4gPSBsaW5lTGVuZ3RoKGxpbmUpO1xuICAgICAgICAgIGlmIChsZW4gPiBkaXNwbGF5Lm1heExpbmVMZW5ndGgpIHtcbiAgICAgICAgICAgIGRpc3BsYXkubWF4TGluZSA9IGxpbmU7XG4gICAgICAgICAgICBkaXNwbGF5Lm1heExpbmVMZW5ndGggPSBsZW47XG4gICAgICAgICAgICBkaXNwbGF5Lm1heExpbmVDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlY29tcHV0ZU1heExlbmd0aCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZWNvbXB1dGVNYXhMZW5ndGgpIHtcbiAgICAgICAgICBjbS5jdXJPcC51cGRhdGVNYXhMaW5lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0cmVhdEZyb250aWVyKGRvYywgZnJvbS5saW5lKTtcbiAgICAgIHN0YXJ0V29ya2VyKGNtLCA0MDApO1xuICAgICAgdmFyIGxlbmRpZmYgPSBjaGFuZ2UudGV4dC5sZW5ndGggLSAodG8ubGluZSAtIGZyb20ubGluZSkgLSAxO1xuICAgICAgaWYgKGNoYW5nZS5mdWxsKSB7XG4gICAgICAgIHJlZ0NoYW5nZShjbSk7XG4gICAgICB9IGVsc2UgaWYgKGZyb20ubGluZSA9PSB0by5saW5lICYmIGNoYW5nZS50ZXh0Lmxlbmd0aCA9PSAxICYmICFpc1dob2xlTGluZVVwZGF0ZShjbS5kb2MsIGNoYW5nZSkpIHtcbiAgICAgICAgcmVnTGluZUNoYW5nZShjbSwgZnJvbS5saW5lLCBcInRleHRcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWdDaGFuZ2UoY20sIGZyb20ubGluZSwgdG8ubGluZSArIDEsIGxlbmRpZmYpO1xuICAgICAgfVxuICAgICAgdmFyIGNoYW5nZXNIYW5kbGVyID0gaGFzSGFuZGxlcihjbSwgXCJjaGFuZ2VzXCIpLCBjaGFuZ2VIYW5kbGVyID0gaGFzSGFuZGxlcihjbSwgXCJjaGFuZ2VcIik7XG4gICAgICBpZiAoY2hhbmdlSGFuZGxlciB8fCBjaGFuZ2VzSGFuZGxlcikge1xuICAgICAgICB2YXIgb2JqID0ge1xuICAgICAgICAgIGZyb20sXG4gICAgICAgICAgdG8sXG4gICAgICAgICAgdGV4dDogY2hhbmdlLnRleHQsXG4gICAgICAgICAgcmVtb3ZlZDogY2hhbmdlLnJlbW92ZWQsXG4gICAgICAgICAgb3JpZ2luOiBjaGFuZ2Uub3JpZ2luXG4gICAgICAgIH07XG4gICAgICAgIGlmIChjaGFuZ2VIYW5kbGVyKSB7XG4gICAgICAgICAgc2lnbmFsTGF0ZXIoY20sIFwiY2hhbmdlXCIsIGNtLCBvYmopO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzSGFuZGxlcikge1xuICAgICAgICAgIChjbS5jdXJPcC5jaGFuZ2VPYmpzIHx8IChjbS5jdXJPcC5jaGFuZ2VPYmpzID0gW10pKS5wdXNoKG9iaik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNtLmRpc3BsYXkuc2VsRm9yQ29udGV4dE1lbnUgPSBudWxsO1xuICAgIH1cbiAgICBfX25hbWUobWFrZUNoYW5nZVNpbmdsZURvY0luRWRpdG9yLCBcIm1ha2VDaGFuZ2VTaW5nbGVEb2NJbkVkaXRvclwiKTtcbiAgICBmdW5jdGlvbiByZXBsYWNlUmFuZ2UoZG9jLCBjb2RlLCBmcm9tLCB0bywgb3JpZ2luKSB7XG4gICAgICB2YXIgYXNzaWduO1xuICAgICAgaWYgKCF0bykge1xuICAgICAgICB0byA9IGZyb207XG4gICAgICB9XG4gICAgICBpZiAoY21wKHRvLCBmcm9tKSA8IDApIHtcbiAgICAgICAgYXNzaWduID0gW3RvLCBmcm9tXSwgZnJvbSA9IGFzc2lnblswXSwgdG8gPSBhc3NpZ25bMV07XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGNvZGUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb2RlID0gZG9jLnNwbGl0TGluZXMoY29kZSk7XG4gICAgICB9XG4gICAgICBtYWtlQ2hhbmdlKGRvYywgeyBmcm9tLCB0bywgdGV4dDogY29kZSwgb3JpZ2luIH0pO1xuICAgIH1cbiAgICBfX25hbWUocmVwbGFjZVJhbmdlLCBcInJlcGxhY2VSYW5nZVwiKTtcbiAgICBmdW5jdGlvbiByZWJhc2VIaXN0U2VsU2luZ2xlKHBvcywgZnJvbSwgdG8sIGRpZmYpIHtcbiAgICAgIGlmICh0byA8IHBvcy5saW5lKSB7XG4gICAgICAgIHBvcy5saW5lICs9IGRpZmY7XG4gICAgICB9IGVsc2UgaWYgKGZyb20gPCBwb3MubGluZSkge1xuICAgICAgICBwb3MubGluZSA9IGZyb207XG4gICAgICAgIHBvcy5jaCA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShyZWJhc2VIaXN0U2VsU2luZ2xlLCBcInJlYmFzZUhpc3RTZWxTaW5nbGVcIik7XG4gICAgZnVuY3Rpb24gcmViYXNlSGlzdEFycmF5KGFycmF5LCBmcm9tLCB0bywgZGlmZikge1xuICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IGFycmF5Lmxlbmd0aDsgKytpMikge1xuICAgICAgICB2YXIgc3ViID0gYXJyYXlbaTJdLCBvayA9IHRydWU7XG4gICAgICAgIGlmIChzdWIucmFuZ2VzKSB7XG4gICAgICAgICAgaWYgKCFzdWIuY29waWVkKSB7XG4gICAgICAgICAgICBzdWIgPSBhcnJheVtpMl0gPSBzdWIuZGVlcENvcHkoKTtcbiAgICAgICAgICAgIHN1Yi5jb3BpZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN1Yi5yYW5nZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHJlYmFzZUhpc3RTZWxTaW5nbGUoc3ViLnJhbmdlc1tqXS5hbmNob3IsIGZyb20sIHRvLCBkaWZmKTtcbiAgICAgICAgICAgIHJlYmFzZUhpc3RTZWxTaW5nbGUoc3ViLnJhbmdlc1tqXS5oZWFkLCBmcm9tLCB0bywgZGlmZik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGokMSA9IDA7IGokMSA8IHN1Yi5jaGFuZ2VzLmxlbmd0aDsgKytqJDEpIHtcbiAgICAgICAgICB2YXIgY3VyID0gc3ViLmNoYW5nZXNbaiQxXTtcbiAgICAgICAgICBpZiAodG8gPCBjdXIuZnJvbS5saW5lKSB7XG4gICAgICAgICAgICBjdXIuZnJvbSA9IFBvcyhjdXIuZnJvbS5saW5lICsgZGlmZiwgY3VyLmZyb20uY2gpO1xuICAgICAgICAgICAgY3VyLnRvID0gUG9zKGN1ci50by5saW5lICsgZGlmZiwgY3VyLnRvLmNoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGZyb20gPD0gY3VyLnRvLmxpbmUpIHtcbiAgICAgICAgICAgIG9rID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvaykge1xuICAgICAgICAgIGFycmF5LnNwbGljZSgwLCBpMiArIDEpO1xuICAgICAgICAgIGkyID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUocmViYXNlSGlzdEFycmF5LCBcInJlYmFzZUhpc3RBcnJheVwiKTtcbiAgICBmdW5jdGlvbiByZWJhc2VIaXN0KGhpc3QsIGNoYW5nZSkge1xuICAgICAgdmFyIGZyb20gPSBjaGFuZ2UuZnJvbS5saW5lLCB0byA9IGNoYW5nZS50by5saW5lLCBkaWZmID0gY2hhbmdlLnRleHQubGVuZ3RoIC0gKHRvIC0gZnJvbSkgLSAxO1xuICAgICAgcmViYXNlSGlzdEFycmF5KGhpc3QuZG9uZSwgZnJvbSwgdG8sIGRpZmYpO1xuICAgICAgcmViYXNlSGlzdEFycmF5KGhpc3QudW5kb25lLCBmcm9tLCB0bywgZGlmZik7XG4gICAgfVxuICAgIF9fbmFtZShyZWJhc2VIaXN0LCBcInJlYmFzZUhpc3RcIik7XG4gICAgZnVuY3Rpb24gY2hhbmdlTGluZShkb2MsIGhhbmRsZSwgY2hhbmdlVHlwZSwgb3ApIHtcbiAgICAgIHZhciBubyA9IGhhbmRsZSwgbGluZSA9IGhhbmRsZTtcbiAgICAgIGlmICh0eXBlb2YgaGFuZGxlID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgbGluZSA9IGdldExpbmUoZG9jLCBjbGlwTGluZShkb2MsIGhhbmRsZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm8gPSBsaW5lTm8oaGFuZGxlKTtcbiAgICAgIH1cbiAgICAgIGlmIChubyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKG9wKGxpbmUsIG5vKSAmJiBkb2MuY20pIHtcbiAgICAgICAgcmVnTGluZUNoYW5nZShkb2MuY20sIG5vLCBjaGFuZ2VUeXBlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaW5lO1xuICAgIH1cbiAgICBfX25hbWUoY2hhbmdlTGluZSwgXCJjaGFuZ2VMaW5lXCIpO1xuICAgIGZ1bmN0aW9uIExlYWZDaHVuayhsaW5lcykge1xuICAgICAgdGhpcy5saW5lcyA9IGxpbmVzO1xuICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgdmFyIGhlaWdodCA9IDA7XG4gICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgbGluZXMubGVuZ3RoOyArK2kyKSB7XG4gICAgICAgIGxpbmVzW2kyXS5wYXJlbnQgPSB0aGlzO1xuICAgICAgICBoZWlnaHQgKz0gbGluZXNbaTJdLmhlaWdodDtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cbiAgICBfX25hbWUoTGVhZkNodW5rLCBcIkxlYWZDaHVua1wiKTtcbiAgICBMZWFmQ2h1bmsucHJvdG90eXBlID0ge1xuICAgICAgY2h1bmtTaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGluZXMubGVuZ3RoO1xuICAgICAgfSxcbiAgICAgIHJlbW92ZUlubmVyOiBmdW5jdGlvbihhdCwgbikge1xuICAgICAgICBmb3IgKHZhciBpMiA9IGF0LCBlID0gYXQgKyBuOyBpMiA8IGU7ICsraTIpIHtcbiAgICAgICAgICB2YXIgbGluZSA9IHRoaXMubGluZXNbaTJdO1xuICAgICAgICAgIHRoaXMuaGVpZ2h0IC09IGxpbmUuaGVpZ2h0O1xuICAgICAgICAgIGNsZWFuVXBMaW5lKGxpbmUpO1xuICAgICAgICAgIHNpZ25hbExhdGVyKGxpbmUsIFwiZGVsZXRlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGluZXMuc3BsaWNlKGF0LCBuKTtcbiAgICAgIH0sXG4gICAgICBjb2xsYXBzZTogZnVuY3Rpb24obGluZXMpIHtcbiAgICAgICAgbGluZXMucHVzaC5hcHBseShsaW5lcywgdGhpcy5saW5lcyk7XG4gICAgICB9LFxuICAgICAgaW5zZXJ0SW5uZXI6IGZ1bmN0aW9uKGF0LCBsaW5lcywgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuaGVpZ2h0ICs9IGhlaWdodDtcbiAgICAgICAgdGhpcy5saW5lcyA9IHRoaXMubGluZXMuc2xpY2UoMCwgYXQpLmNvbmNhdChsaW5lcykuY29uY2F0KHRoaXMubGluZXMuc2xpY2UoYXQpKTtcbiAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IGxpbmVzLmxlbmd0aDsgKytpMikge1xuICAgICAgICAgIGxpbmVzW2kyXS5wYXJlbnQgPSB0aGlzO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaXRlck46IGZ1bmN0aW9uKGF0LCBuLCBvcCkge1xuICAgICAgICBmb3IgKHZhciBlID0gYXQgKyBuOyBhdCA8IGU7ICsrYXQpIHtcbiAgICAgICAgICBpZiAob3AodGhpcy5saW5lc1thdF0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIEJyYW5jaENodW5rKGNoaWxkcmVuKSB7XG4gICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICB2YXIgc2l6ZSA9IDAsIGhlaWdodCA9IDA7XG4gICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kyKSB7XG4gICAgICAgIHZhciBjaCA9IGNoaWxkcmVuW2kyXTtcbiAgICAgICAgc2l6ZSArPSBjaC5jaHVua1NpemUoKTtcbiAgICAgICAgaGVpZ2h0ICs9IGNoLmhlaWdodDtcbiAgICAgICAgY2gucGFyZW50ID0gdGhpcztcbiAgICAgIH1cbiAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICB9XG4gICAgX19uYW1lKEJyYW5jaENodW5rLCBcIkJyYW5jaENodW5rXCIpO1xuICAgIEJyYW5jaENodW5rLnByb3RvdHlwZSA9IHtcbiAgICAgIGNodW5rU2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemU7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlSW5uZXI6IGZ1bmN0aW9uKGF0LCBuKSB7XG4gICAgICAgIHRoaXMuc2l6ZSAtPSBuO1xuICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7ICsraTIpIHtcbiAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2kyXSwgc3ogPSBjaGlsZC5jaHVua1NpemUoKTtcbiAgICAgICAgICBpZiAoYXQgPCBzeikge1xuICAgICAgICAgICAgdmFyIHJtID0gTWF0aC5taW4obiwgc3ogLSBhdCksIG9sZEhlaWdodCA9IGNoaWxkLmhlaWdodDtcbiAgICAgICAgICAgIGNoaWxkLnJlbW92ZUlubmVyKGF0LCBybSk7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCAtPSBvbGRIZWlnaHQgLSBjaGlsZC5oZWlnaHQ7XG4gICAgICAgICAgICBpZiAoc3ogPT0gcm0pIHtcbiAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoaTItLSwgMSk7XG4gICAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKG4gLT0gcm0pID09IDApIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdCA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF0IC09IHN6O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zaXplIC0gbiA8IDI1ICYmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDEgfHwgISh0aGlzLmNoaWxkcmVuWzBdIGluc3RhbmNlb2YgTGVhZkNodW5rKSkpIHtcbiAgICAgICAgICB2YXIgbGluZXMgPSBbXTtcbiAgICAgICAgICB0aGlzLmNvbGxhcHNlKGxpbmVzKTtcbiAgICAgICAgICB0aGlzLmNoaWxkcmVuID0gW25ldyBMZWFmQ2h1bmsobGluZXMpXTtcbiAgICAgICAgICB0aGlzLmNoaWxkcmVuWzBdLnBhcmVudCA9IHRoaXM7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjb2xsYXBzZTogZnVuY3Rpb24obGluZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyArK2kyKSB7XG4gICAgICAgICAgdGhpcy5jaGlsZHJlbltpMl0uY29sbGFwc2UobGluZXMpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaW5zZXJ0SW5uZXI6IGZ1bmN0aW9uKGF0LCBsaW5lcywgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuc2l6ZSArPSBsaW5lcy5sZW5ndGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ICs9IGhlaWdodDtcbiAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyArK2kyKSB7XG4gICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpMl0sIHN6ID0gY2hpbGQuY2h1bmtTaXplKCk7XG4gICAgICAgICAgaWYgKGF0IDw9IHN6KSB7XG4gICAgICAgICAgICBjaGlsZC5pbnNlcnRJbm5lcihhdCwgbGluZXMsIGhlaWdodCk7XG4gICAgICAgICAgICBpZiAoY2hpbGQubGluZXMgJiYgY2hpbGQubGluZXMubGVuZ3RoID4gNTApIHtcbiAgICAgICAgICAgICAgdmFyIHJlbWFpbmluZyA9IGNoaWxkLmxpbmVzLmxlbmd0aCAlIDI1ICsgMjU7XG4gICAgICAgICAgICAgIGZvciAodmFyIHBvcyA9IHJlbWFpbmluZzsgcG9zIDwgY2hpbGQubGluZXMubGVuZ3RoOyApIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVhZiA9IG5ldyBMZWFmQ2h1bmsoY2hpbGQubGluZXMuc2xpY2UocG9zLCBwb3MgKz0gMjUpKTtcbiAgICAgICAgICAgICAgICBjaGlsZC5oZWlnaHQgLT0gbGVhZi5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoKytpMiwgMCwgbGVhZik7XG4gICAgICAgICAgICAgICAgbGVhZi5wYXJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNoaWxkLmxpbmVzID0gY2hpbGQubGluZXMuc2xpY2UoMCwgcmVtYWluaW5nKTtcbiAgICAgICAgICAgICAgdGhpcy5tYXliZVNwaWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYXQgLT0gc3o7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBtYXliZVNwaWxsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoIDw9IDEwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICB2YXIgc3BpbGxlZCA9IG1lLmNoaWxkcmVuLnNwbGljZShtZS5jaGlsZHJlbi5sZW5ndGggLSA1LCA1KTtcbiAgICAgICAgICB2YXIgc2libGluZyA9IG5ldyBCcmFuY2hDaHVuayhzcGlsbGVkKTtcbiAgICAgICAgICBpZiAoIW1lLnBhcmVudCkge1xuICAgICAgICAgICAgdmFyIGNvcHkgPSBuZXcgQnJhbmNoQ2h1bmsobWUuY2hpbGRyZW4pO1xuICAgICAgICAgICAgY29weS5wYXJlbnQgPSBtZTtcbiAgICAgICAgICAgIG1lLmNoaWxkcmVuID0gW2NvcHksIHNpYmxpbmddO1xuICAgICAgICAgICAgbWUgPSBjb3B5O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5zaXplIC09IHNpYmxpbmcuc2l6ZTtcbiAgICAgICAgICAgIG1lLmhlaWdodCAtPSBzaWJsaW5nLmhlaWdodDtcbiAgICAgICAgICAgIHZhciBteUluZGV4ID0gaW5kZXhPZihtZS5wYXJlbnQuY2hpbGRyZW4sIG1lKTtcbiAgICAgICAgICAgIG1lLnBhcmVudC5jaGlsZHJlbi5zcGxpY2UobXlJbmRleCArIDEsIDAsIHNpYmxpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzaWJsaW5nLnBhcmVudCA9IG1lLnBhcmVudDtcbiAgICAgICAgfSB3aGlsZSAobWUuY2hpbGRyZW4ubGVuZ3RoID4gMTApO1xuICAgICAgICBtZS5wYXJlbnQubWF5YmVTcGlsbCgpO1xuICAgICAgfSxcbiAgICAgIGl0ZXJOOiBmdW5jdGlvbihhdCwgbiwgb3ApIHtcbiAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyArK2kyKSB7XG4gICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpMl0sIHN6ID0gY2hpbGQuY2h1bmtTaXplKCk7XG4gICAgICAgICAgaWYgKGF0IDwgc3opIHtcbiAgICAgICAgICAgIHZhciB1c2VkID0gTWF0aC5taW4obiwgc3ogLSBhdCk7XG4gICAgICAgICAgICBpZiAoY2hpbGQuaXRlck4oYXQsIHVzZWQsIG9wKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgobiAtPSB1c2VkKSA9PSAwKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXQgPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdCAtPSBzejtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBMaW5lV2lkZ2V0ID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbihkb2MsIG5vZGUsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGZvciAodmFyIG9wdCBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkob3B0KSkge1xuICAgICAgICAgICAgdGhpc1tvcHRdID0gb3B0aW9uc1tvcHRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgIH0sIFwiTGluZVdpZGdldFwiKTtcbiAgICBMaW5lV2lkZ2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNtID0gdGhpcy5kb2MuY20sIHdzID0gdGhpcy5saW5lLndpZGdldHMsIGxpbmUgPSB0aGlzLmxpbmUsIG5vID0gbGluZU5vKGxpbmUpO1xuICAgICAgaWYgKG5vID09IG51bGwgfHwgIXdzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCB3cy5sZW5ndGg7ICsraTIpIHtcbiAgICAgICAgaWYgKHdzW2kyXSA9PSB0aGlzKSB7XG4gICAgICAgICAgd3Muc3BsaWNlKGkyLS0sIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXdzLmxlbmd0aCkge1xuICAgICAgICBsaW5lLndpZGdldHMgPSBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIGhlaWdodCA9IHdpZGdldEhlaWdodCh0aGlzKTtcbiAgICAgIHVwZGF0ZUxpbmVIZWlnaHQobGluZSwgTWF0aC5tYXgoMCwgbGluZS5oZWlnaHQgLSBoZWlnaHQpKTtcbiAgICAgIGlmIChjbSkge1xuICAgICAgICBydW5Jbk9wKGNtLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBhZGp1c3RTY3JvbGxXaGVuQWJvdmVWaXNpYmxlKGNtLCBsaW5lLCAtaGVpZ2h0KTtcbiAgICAgICAgICByZWdMaW5lQ2hhbmdlKGNtLCBubywgXCJ3aWRnZXRcIik7XG4gICAgICAgIH0pO1xuICAgICAgICBzaWduYWxMYXRlcihjbSwgXCJsaW5lV2lkZ2V0Q2xlYXJlZFwiLCBjbSwgdGhpcywgbm8pO1xuICAgICAgfVxuICAgIH07XG4gICAgTGluZVdpZGdldC5wcm90b3R5cGUuY2hhbmdlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRoaXMkMSQxID0gdGhpcztcbiAgICAgIHZhciBvbGRIID0gdGhpcy5oZWlnaHQsIGNtID0gdGhpcy5kb2MuY20sIGxpbmUgPSB0aGlzLmxpbmU7XG4gICAgICB0aGlzLmhlaWdodCA9IG51bGw7XG4gICAgICB2YXIgZGlmZiA9IHdpZGdldEhlaWdodCh0aGlzKSAtIG9sZEg7XG4gICAgICBpZiAoIWRpZmYpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFsaW5lSXNIaWRkZW4odGhpcy5kb2MsIGxpbmUpKSB7XG4gICAgICAgIHVwZGF0ZUxpbmVIZWlnaHQobGluZSwgbGluZS5oZWlnaHQgKyBkaWZmKTtcbiAgICAgIH1cbiAgICAgIGlmIChjbSkge1xuICAgICAgICBydW5Jbk9wKGNtLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBjbS5jdXJPcC5mb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgYWRqdXN0U2Nyb2xsV2hlbkFib3ZlVmlzaWJsZShjbSwgbGluZSwgZGlmZik7XG4gICAgICAgICAgc2lnbmFsTGF0ZXIoY20sIFwibGluZVdpZGdldENoYW5nZWRcIiwgY20sIHRoaXMkMSQxLCBsaW5lTm8obGluZSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGV2ZW50TWl4aW4oTGluZVdpZGdldCk7XG4gICAgZnVuY3Rpb24gYWRqdXN0U2Nyb2xsV2hlbkFib3ZlVmlzaWJsZShjbSwgbGluZSwgZGlmZikge1xuICAgICAgaWYgKGhlaWdodEF0TGluZShsaW5lKSA8IChjbS5jdXJPcCAmJiBjbS5jdXJPcC5zY3JvbGxUb3AgfHwgY20uZG9jLnNjcm9sbFRvcCkpIHtcbiAgICAgICAgYWRkVG9TY3JvbGxUb3AoY20sIGRpZmYpO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoYWRqdXN0U2Nyb2xsV2hlbkFib3ZlVmlzaWJsZSwgXCJhZGp1c3RTY3JvbGxXaGVuQWJvdmVWaXNpYmxlXCIpO1xuICAgIGZ1bmN0aW9uIGFkZExpbmVXaWRnZXQoZG9jLCBoYW5kbGUsIG5vZGUsIG9wdGlvbnMpIHtcbiAgICAgIHZhciB3aWRnZXQgPSBuZXcgTGluZVdpZGdldChkb2MsIG5vZGUsIG9wdGlvbnMpO1xuICAgICAgdmFyIGNtID0gZG9jLmNtO1xuICAgICAgaWYgKGNtICYmIHdpZGdldC5ub0hTY3JvbGwpIHtcbiAgICAgICAgY20uZGlzcGxheS5hbGlnbldpZGdldHMgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY2hhbmdlTGluZShkb2MsIGhhbmRsZSwgXCJ3aWRnZXRcIiwgZnVuY3Rpb24obGluZSkge1xuICAgICAgICB2YXIgd2lkZ2V0cyA9IGxpbmUud2lkZ2V0cyB8fCAobGluZS53aWRnZXRzID0gW10pO1xuICAgICAgICBpZiAod2lkZ2V0Lmluc2VydEF0ID09IG51bGwpIHtcbiAgICAgICAgICB3aWRnZXRzLnB1c2god2lkZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aWRnZXRzLnNwbGljZShNYXRoLm1pbih3aWRnZXRzLmxlbmd0aCwgTWF0aC5tYXgoMCwgd2lkZ2V0Lmluc2VydEF0KSksIDAsIHdpZGdldCk7XG4gICAgICAgIH1cbiAgICAgICAgd2lkZ2V0LmxpbmUgPSBsaW5lO1xuICAgICAgICBpZiAoY20gJiYgIWxpbmVJc0hpZGRlbihkb2MsIGxpbmUpKSB7XG4gICAgICAgICAgdmFyIGFib3ZlVmlzaWJsZSA9IGhlaWdodEF0TGluZShsaW5lKSA8IGRvYy5zY3JvbGxUb3A7XG4gICAgICAgICAgdXBkYXRlTGluZUhlaWdodChsaW5lLCBsaW5lLmhlaWdodCArIHdpZGdldEhlaWdodCh3aWRnZXQpKTtcbiAgICAgICAgICBpZiAoYWJvdmVWaXNpYmxlKSB7XG4gICAgICAgICAgICBhZGRUb1Njcm9sbFRvcChjbSwgd2lkZ2V0LmhlaWdodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNtLmN1ck9wLmZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGNtKSB7XG4gICAgICAgIHNpZ25hbExhdGVyKGNtLCBcImxpbmVXaWRnZXRBZGRlZFwiLCBjbSwgd2lkZ2V0LCB0eXBlb2YgaGFuZGxlID09IFwibnVtYmVyXCIgPyBoYW5kbGUgOiBsaW5lTm8oaGFuZGxlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2lkZ2V0O1xuICAgIH1cbiAgICBfX25hbWUoYWRkTGluZVdpZGdldCwgXCJhZGRMaW5lV2lkZ2V0XCIpO1xuICAgIHZhciBuZXh0TWFya2VySWQgPSAwO1xuICAgIHZhciBUZXh0TWFya2VyID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbihkb2MsIHR5cGUpIHtcbiAgICAgIHRoaXMubGluZXMgPSBbXTtcbiAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAgIHRoaXMuaWQgPSArK25leHRNYXJrZXJJZDtcbiAgICB9LCBcIlRleHRNYXJrZXJcIik7XG4gICAgVGV4dE1hcmtlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmV4cGxpY2l0bHlDbGVhcmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBjbSA9IHRoaXMuZG9jLmNtLCB3aXRoT3AgPSBjbSAmJiAhY20uY3VyT3A7XG4gICAgICBpZiAod2l0aE9wKSB7XG4gICAgICAgIHN0YXJ0T3BlcmF0aW9uKGNtKTtcbiAgICAgIH1cbiAgICAgIGlmIChoYXNIYW5kbGVyKHRoaXMsIFwiY2xlYXJcIikpIHtcbiAgICAgICAgdmFyIGZvdW5kID0gdGhpcy5maW5kKCk7XG4gICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgIHNpZ25hbExhdGVyKHRoaXMsIFwiY2xlYXJcIiwgZm91bmQuZnJvbSwgZm91bmQudG8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgbWluID0gbnVsbCwgbWF4ID0gbnVsbDtcbiAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCB0aGlzLmxpbmVzLmxlbmd0aDsgKytpMikge1xuICAgICAgICB2YXIgbGluZSA9IHRoaXMubGluZXNbaTJdO1xuICAgICAgICB2YXIgc3BhbiA9IGdldE1hcmtlZFNwYW5Gb3IobGluZS5tYXJrZWRTcGFucywgdGhpcyk7XG4gICAgICAgIGlmIChjbSAmJiAhdGhpcy5jb2xsYXBzZWQpIHtcbiAgICAgICAgICByZWdMaW5lQ2hhbmdlKGNtLCBsaW5lTm8obGluZSksIFwidGV4dFwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChjbSkge1xuICAgICAgICAgIGlmIChzcGFuLnRvICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1heCA9IGxpbmVObyhsaW5lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNwYW4uZnJvbSAhPSBudWxsKSB7XG4gICAgICAgICAgICBtaW4gPSBsaW5lTm8obGluZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxpbmUubWFya2VkU3BhbnMgPSByZW1vdmVNYXJrZWRTcGFuKGxpbmUubWFya2VkU3BhbnMsIHNwYW4pO1xuICAgICAgICBpZiAoc3Bhbi5mcm9tID09IG51bGwgJiYgdGhpcy5jb2xsYXBzZWQgJiYgIWxpbmVJc0hpZGRlbih0aGlzLmRvYywgbGluZSkgJiYgY20pIHtcbiAgICAgICAgICB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIHRleHRIZWlnaHQoY20uZGlzcGxheSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY20gJiYgdGhpcy5jb2xsYXBzZWQgJiYgIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7XG4gICAgICAgIGZvciAodmFyIGkkMTIgPSAwOyBpJDEyIDwgdGhpcy5saW5lcy5sZW5ndGg7ICsraSQxMikge1xuICAgICAgICAgIHZhciB2aXN1YWwgPSB2aXN1YWxMaW5lKHRoaXMubGluZXNbaSQxMl0pLCBsZW4gPSBsaW5lTGVuZ3RoKHZpc3VhbCk7XG4gICAgICAgICAgaWYgKGxlbiA+IGNtLmRpc3BsYXkubWF4TGluZUxlbmd0aCkge1xuICAgICAgICAgICAgY20uZGlzcGxheS5tYXhMaW5lID0gdmlzdWFsO1xuICAgICAgICAgICAgY20uZGlzcGxheS5tYXhMaW5lTGVuZ3RoID0gbGVuO1xuICAgICAgICAgICAgY20uZGlzcGxheS5tYXhMaW5lQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWluICE9IG51bGwgJiYgY20gJiYgdGhpcy5jb2xsYXBzZWQpIHtcbiAgICAgICAgcmVnQ2hhbmdlKGNtLCBtaW4sIG1heCArIDEpO1xuICAgICAgfVxuICAgICAgdGhpcy5saW5lcy5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5leHBsaWNpdGx5Q2xlYXJlZCA9IHRydWU7XG4gICAgICBpZiAodGhpcy5hdG9taWMgJiYgdGhpcy5kb2MuY2FudEVkaXQpIHtcbiAgICAgICAgdGhpcy5kb2MuY2FudEVkaXQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGNtKSB7XG4gICAgICAgICAgcmVDaGVja1NlbGVjdGlvbihjbS5kb2MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY20pIHtcbiAgICAgICAgc2lnbmFsTGF0ZXIoY20sIFwibWFya2VyQ2xlYXJlZFwiLCBjbSwgdGhpcywgbWluLCBtYXgpO1xuICAgICAgfVxuICAgICAgaWYgKHdpdGhPcCkge1xuICAgICAgICBlbmRPcGVyYXRpb24oY20pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgIHRoaXMucGFyZW50LmNsZWFyKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBUZXh0TWFya2VyLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24oc2lkZSwgbGluZU9iaikge1xuICAgICAgaWYgKHNpZGUgPT0gbnVsbCAmJiB0aGlzLnR5cGUgPT0gXCJib29rbWFya1wiKSB7XG4gICAgICAgIHNpZGUgPSAxO1xuICAgICAgfVxuICAgICAgdmFyIGZyb20sIHRvO1xuICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IHRoaXMubGluZXMubGVuZ3RoOyArK2kyKSB7XG4gICAgICAgIHZhciBsaW5lID0gdGhpcy5saW5lc1tpMl07XG4gICAgICAgIHZhciBzcGFuID0gZ2V0TWFya2VkU3BhbkZvcihsaW5lLm1hcmtlZFNwYW5zLCB0aGlzKTtcbiAgICAgICAgaWYgKHNwYW4uZnJvbSAhPSBudWxsKSB7XG4gICAgICAgICAgZnJvbSA9IFBvcyhsaW5lT2JqID8gbGluZSA6IGxpbmVObyhsaW5lKSwgc3Bhbi5mcm9tKTtcbiAgICAgICAgICBpZiAoc2lkZSA9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZyb207XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzcGFuLnRvICE9IG51bGwpIHtcbiAgICAgICAgICB0byA9IFBvcyhsaW5lT2JqID8gbGluZSA6IGxpbmVObyhsaW5lKSwgc3Bhbi50byk7XG4gICAgICAgICAgaWYgKHNpZGUgPT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRvO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb20gJiYgeyBmcm9tLCB0byB9O1xuICAgIH07XG4gICAgVGV4dE1hcmtlci5wcm90b3R5cGUuY2hhbmdlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRoaXMkMSQxID0gdGhpcztcbiAgICAgIHZhciBwb3MgPSB0aGlzLmZpbmQoLTEsIHRydWUpLCB3aWRnZXQgPSB0aGlzLCBjbSA9IHRoaXMuZG9jLmNtO1xuICAgICAgaWYgKCFwb3MgfHwgIWNtKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJ1bkluT3AoY20sIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbGluZSA9IHBvcy5saW5lLCBsaW5lTiA9IGxpbmVObyhwb3MubGluZSk7XG4gICAgICAgIHZhciB2aWV3ID0gZmluZFZpZXdGb3JMaW5lKGNtLCBsaW5lTik7XG4gICAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgICAgY2xlYXJMaW5lTWVhc3VyZW1lbnRDYWNoZUZvcih2aWV3KTtcbiAgICAgICAgICBjbS5jdXJPcC5zZWxlY3Rpb25DaGFuZ2VkID0gY20uY3VyT3AuZm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNtLmN1ck9wLnVwZGF0ZU1heExpbmUgPSB0cnVlO1xuICAgICAgICBpZiAoIWxpbmVJc0hpZGRlbih3aWRnZXQuZG9jLCBsaW5lKSAmJiB3aWRnZXQuaGVpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgb2xkSGVpZ2h0ID0gd2lkZ2V0LmhlaWdodDtcbiAgICAgICAgICB3aWRnZXQuaGVpZ2h0ID0gbnVsbDtcbiAgICAgICAgICB2YXIgZEhlaWdodCA9IHdpZGdldEhlaWdodCh3aWRnZXQpIC0gb2xkSGVpZ2h0O1xuICAgICAgICAgIGlmIChkSGVpZ2h0KSB7XG4gICAgICAgICAgICB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIGxpbmUuaGVpZ2h0ICsgZEhlaWdodCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNpZ25hbExhdGVyKGNtLCBcIm1hcmtlckNoYW5nZWRcIiwgY20sIHRoaXMkMSQxKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgVGV4dE1hcmtlci5wcm90b3R5cGUuYXR0YWNoTGluZSA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIGlmICghdGhpcy5saW5lcy5sZW5ndGggJiYgdGhpcy5kb2MuY20pIHtcbiAgICAgICAgdmFyIG9wID0gdGhpcy5kb2MuY20uY3VyT3A7XG4gICAgICAgIGlmICghb3AubWF5YmVIaWRkZW5NYXJrZXJzIHx8IGluZGV4T2Yob3AubWF5YmVIaWRkZW5NYXJrZXJzLCB0aGlzKSA9PSAtMSkge1xuICAgICAgICAgIChvcC5tYXliZVVuaGlkZGVuTWFya2VycyB8fCAob3AubWF5YmVVbmhpZGRlbk1hcmtlcnMgPSBbXSkpLnB1c2godGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubGluZXMucHVzaChsaW5lKTtcbiAgICB9O1xuICAgIFRleHRNYXJrZXIucHJvdG90eXBlLmRldGFjaExpbmUgPSBmdW5jdGlvbihsaW5lKSB7XG4gICAgICB0aGlzLmxpbmVzLnNwbGljZShpbmRleE9mKHRoaXMubGluZXMsIGxpbmUpLCAxKTtcbiAgICAgIGlmICghdGhpcy5saW5lcy5sZW5ndGggJiYgdGhpcy5kb2MuY20pIHtcbiAgICAgICAgdmFyIG9wID0gdGhpcy5kb2MuY20uY3VyT3A7XG4gICAgICAgIChvcC5tYXliZUhpZGRlbk1hcmtlcnMgfHwgKG9wLm1heWJlSGlkZGVuTWFya2VycyA9IFtdKSkucHVzaCh0aGlzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGV2ZW50TWl4aW4oVGV4dE1hcmtlcik7XG4gICAgZnVuY3Rpb24gbWFya1RleHQoZG9jLCBmcm9tLCB0bywgb3B0aW9ucywgdHlwZSkge1xuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zaGFyZWQpIHtcbiAgICAgICAgcmV0dXJuIG1hcmtUZXh0U2hhcmVkKGRvYywgZnJvbSwgdG8sIG9wdGlvbnMsIHR5cGUpO1xuICAgICAgfVxuICAgICAgaWYgKGRvYy5jbSAmJiAhZG9jLmNtLmN1ck9wKSB7XG4gICAgICAgIHJldHVybiBvcGVyYXRpb24oZG9jLmNtLCBtYXJrVGV4dCkoZG9jLCBmcm9tLCB0bywgb3B0aW9ucywgdHlwZSk7XG4gICAgICB9XG4gICAgICB2YXIgbWFya2VyID0gbmV3IFRleHRNYXJrZXIoZG9jLCB0eXBlKSwgZGlmZiA9IGNtcChmcm9tLCB0byk7XG4gICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBjb3B5T2JqKG9wdGlvbnMsIG1hcmtlciwgZmFsc2UpO1xuICAgICAgfVxuICAgICAgaWYgKGRpZmYgPiAwIHx8IGRpZmYgPT0gMCAmJiBtYXJrZXIuY2xlYXJXaGVuRW1wdHkgIT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBtYXJrZXI7XG4gICAgICB9XG4gICAgICBpZiAobWFya2VyLnJlcGxhY2VkV2l0aCkge1xuICAgICAgICBtYXJrZXIuY29sbGFwc2VkID0gdHJ1ZTtcbiAgICAgICAgbWFya2VyLndpZGdldE5vZGUgPSBlbHRQKFwic3BhblwiLCBbbWFya2VyLnJlcGxhY2VkV2l0aF0sIFwiQ29kZU1pcnJvci13aWRnZXRcIik7XG4gICAgICAgIGlmICghb3B0aW9ucy5oYW5kbGVNb3VzZUV2ZW50cykge1xuICAgICAgICAgIG1hcmtlci53aWRnZXROb2RlLnNldEF0dHJpYnV0ZShcImNtLWlnbm9yZS1ldmVudHNcIiwgXCJ0cnVlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmluc2VydExlZnQpIHtcbiAgICAgICAgICBtYXJrZXIud2lkZ2V0Tm9kZS5pbnNlcnRMZWZ0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1hcmtlci5jb2xsYXBzZWQpIHtcbiAgICAgICAgaWYgKGNvbmZsaWN0aW5nQ29sbGFwc2VkUmFuZ2UoZG9jLCBmcm9tLmxpbmUsIGZyb20sIHRvLCBtYXJrZXIpIHx8IGZyb20ubGluZSAhPSB0by5saW5lICYmIGNvbmZsaWN0aW5nQ29sbGFwc2VkUmFuZ2UoZG9jLCB0by5saW5lLCBmcm9tLCB0bywgbWFya2VyKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluc2VydGluZyBjb2xsYXBzZWQgbWFya2VyIHBhcnRpYWxseSBvdmVybGFwcGluZyBhbiBleGlzdGluZyBvbmVcIik7XG4gICAgICAgIH1cbiAgICAgICAgc2VlQ29sbGFwc2VkU3BhbnMoKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXJrZXIuYWRkVG9IaXN0b3J5KSB7XG4gICAgICAgIGFkZENoYW5nZVRvSGlzdG9yeShkb2MsIHsgZnJvbSwgdG8sIG9yaWdpbjogXCJtYXJrVGV4dFwiIH0sIGRvYy5zZWwsIE5hTik7XG4gICAgICB9XG4gICAgICB2YXIgY3VyTGluZSA9IGZyb20ubGluZSwgY20gPSBkb2MuY20sIHVwZGF0ZU1heExpbmU7XG4gICAgICBkb2MuaXRlcihjdXJMaW5lLCB0by5saW5lICsgMSwgZnVuY3Rpb24obGluZSkge1xuICAgICAgICBpZiAoY20gJiYgbWFya2VyLmNvbGxhcHNlZCAmJiAhY20ub3B0aW9ucy5saW5lV3JhcHBpbmcgJiYgdmlzdWFsTGluZShsaW5lKSA9PSBjbS5kaXNwbGF5Lm1heExpbmUpIHtcbiAgICAgICAgICB1cGRhdGVNYXhMaW5lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFya2VyLmNvbGxhcHNlZCAmJiBjdXJMaW5lICE9IGZyb20ubGluZSkge1xuICAgICAgICAgIHVwZGF0ZUxpbmVIZWlnaHQobGluZSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkTWFya2VkU3BhbihsaW5lLCBuZXcgTWFya2VkU3BhbihtYXJrZXIsIGN1ckxpbmUgPT0gZnJvbS5saW5lID8gZnJvbS5jaCA6IG51bGwsIGN1ckxpbmUgPT0gdG8ubGluZSA/IHRvLmNoIDogbnVsbCksIGRvYy5jbSAmJiBkb2MuY20uY3VyT3ApO1xuICAgICAgICArK2N1ckxpbmU7XG4gICAgICB9KTtcbiAgICAgIGlmIChtYXJrZXIuY29sbGFwc2VkKSB7XG4gICAgICAgIGRvYy5pdGVyKGZyb20ubGluZSwgdG8ubGluZSArIDEsIGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICBpZiAobGluZUlzSGlkZGVuKGRvYywgbGluZSkpIHtcbiAgICAgICAgICAgIHVwZGF0ZUxpbmVIZWlnaHQobGluZSwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXJrZXIuY2xlYXJPbkVudGVyKSB7XG4gICAgICAgIG9uKG1hcmtlciwgXCJiZWZvcmVDdXJzb3JFbnRlclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gbWFya2VyLmNsZWFyKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKG1hcmtlci5yZWFkT25seSkge1xuICAgICAgICBzZWVSZWFkT25seVNwYW5zKCk7XG4gICAgICAgIGlmIChkb2MuaGlzdG9yeS5kb25lLmxlbmd0aCB8fCBkb2MuaGlzdG9yeS51bmRvbmUubGVuZ3RoKSB7XG4gICAgICAgICAgZG9jLmNsZWFySGlzdG9yeSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWFya2VyLmNvbGxhcHNlZCkge1xuICAgICAgICBtYXJrZXIuaWQgPSArK25leHRNYXJrZXJJZDtcbiAgICAgICAgbWFya2VyLmF0b21pYyA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoY20pIHtcbiAgICAgICAgaWYgKHVwZGF0ZU1heExpbmUpIHtcbiAgICAgICAgICBjbS5jdXJPcC51cGRhdGVNYXhMaW5lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFya2VyLmNvbGxhcHNlZCkge1xuICAgICAgICAgIHJlZ0NoYW5nZShjbSwgZnJvbS5saW5lLCB0by5saW5lICsgMSk7XG4gICAgICAgIH0gZWxzZSBpZiAobWFya2VyLmNsYXNzTmFtZSB8fCBtYXJrZXIuc3RhcnRTdHlsZSB8fCBtYXJrZXIuZW5kU3R5bGUgfHwgbWFya2VyLmNzcyB8fCBtYXJrZXIuYXR0cmlidXRlcyB8fCBtYXJrZXIudGl0bGUpIHtcbiAgICAgICAgICBmb3IgKHZhciBpMiA9IGZyb20ubGluZTsgaTIgPD0gdG8ubGluZTsgaTIrKykge1xuICAgICAgICAgICAgcmVnTGluZUNoYW5nZShjbSwgaTIsIFwidGV4dFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmtlci5hdG9taWMpIHtcbiAgICAgICAgICByZUNoZWNrU2VsZWN0aW9uKGNtLmRvYyk7XG4gICAgICAgIH1cbiAgICAgICAgc2lnbmFsTGF0ZXIoY20sIFwibWFya2VyQWRkZWRcIiwgY20sIG1hcmtlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFya2VyO1xuICAgIH1cbiAgICBfX25hbWUobWFya1RleHQsIFwibWFya1RleHRcIik7XG4gICAgdmFyIFNoYXJlZFRleHRNYXJrZXIgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKG1hcmtlcnMsIHByaW1hcnkpIHtcbiAgICAgIHRoaXMubWFya2VycyA9IG1hcmtlcnM7XG4gICAgICB0aGlzLnByaW1hcnkgPSBwcmltYXJ5O1xuICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IG1hcmtlcnMubGVuZ3RoOyArK2kyKSB7XG4gICAgICAgIG1hcmtlcnNbaTJdLnBhcmVudCA9IHRoaXM7XG4gICAgICB9XG4gICAgfSwgXCJTaGFyZWRUZXh0TWFya2VyXCIpO1xuICAgIFNoYXJlZFRleHRNYXJrZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5leHBsaWNpdGx5Q2xlYXJlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmV4cGxpY2l0bHlDbGVhcmVkID0gdHJ1ZTtcbiAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCB0aGlzLm1hcmtlcnMubGVuZ3RoOyArK2kyKSB7XG4gICAgICAgIHRoaXMubWFya2Vyc1tpMl0uY2xlYXIoKTtcbiAgICAgIH1cbiAgICAgIHNpZ25hbExhdGVyKHRoaXMsIFwiY2xlYXJcIik7XG4gICAgfTtcbiAgICBTaGFyZWRUZXh0TWFya2VyLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24oc2lkZSwgbGluZU9iaikge1xuICAgICAgcmV0dXJuIHRoaXMucHJpbWFyeS5maW5kKHNpZGUsIGxpbmVPYmopO1xuICAgIH07XG4gICAgZXZlbnRNaXhpbihTaGFyZWRUZXh0TWFya2VyKTtcbiAgICBmdW5jdGlvbiBtYXJrVGV4dFNoYXJlZChkb2MsIGZyb20sIHRvLCBvcHRpb25zLCB0eXBlKSB7XG4gICAgICBvcHRpb25zID0gY29weU9iaihvcHRpb25zKTtcbiAgICAgIG9wdGlvbnMuc2hhcmVkID0gZmFsc2U7XG4gICAgICB2YXIgbWFya2VycyA9IFttYXJrVGV4dChkb2MsIGZyb20sIHRvLCBvcHRpb25zLCB0eXBlKV0sIHByaW1hcnkgPSBtYXJrZXJzWzBdO1xuICAgICAgdmFyIHdpZGdldCA9IG9wdGlvbnMud2lkZ2V0Tm9kZTtcbiAgICAgIGxpbmtlZERvY3MoZG9jLCBmdW5jdGlvbihkb2MyKSB7XG4gICAgICAgIGlmICh3aWRnZXQpIHtcbiAgICAgICAgICBvcHRpb25zLndpZGdldE5vZGUgPSB3aWRnZXQuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIG1hcmtlcnMucHVzaChtYXJrVGV4dChkb2MyLCBjbGlwUG9zKGRvYzIsIGZyb20pLCBjbGlwUG9zKGRvYzIsIHRvKSwgb3B0aW9ucywgdHlwZSkpO1xuICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgZG9jMi5saW5rZWQubGVuZ3RoOyArK2kyKSB7XG4gICAgICAgICAgaWYgKGRvYzIubGlua2VkW2kyXS5pc1BhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcmltYXJ5ID0gbHN0KG1hcmtlcnMpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IFNoYXJlZFRleHRNYXJrZXIobWFya2VycywgcHJpbWFyeSk7XG4gICAgfVxuICAgIF9fbmFtZShtYXJrVGV4dFNoYXJlZCwgXCJtYXJrVGV4dFNoYXJlZFwiKTtcbiAgICBmdW5jdGlvbiBmaW5kU2hhcmVkTWFya2Vycyhkb2MpIHtcbiAgICAgIHJldHVybiBkb2MuZmluZE1hcmtzKFBvcyhkb2MuZmlyc3QsIDApLCBkb2MuY2xpcFBvcyhQb3MoZG9jLmxhc3RMaW5lKCkpKSwgZnVuY3Rpb24obSkge1xuICAgICAgICByZXR1cm4gbS5wYXJlbnQ7XG4gICAgICB9KTtcbiAgICB9XG4gICAgX19uYW1lKGZpbmRTaGFyZWRNYXJrZXJzLCBcImZpbmRTaGFyZWRNYXJrZXJzXCIpO1xuICAgIGZ1bmN0aW9uIGNvcHlTaGFyZWRNYXJrZXJzKGRvYywgbWFya2Vycykge1xuICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IG1hcmtlcnMubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgIHZhciBtYXJrZXIgPSBtYXJrZXJzW2kyXSwgcG9zID0gbWFya2VyLmZpbmQoKTtcbiAgICAgICAgdmFyIG1Gcm9tID0gZG9jLmNsaXBQb3MocG9zLmZyb20pLCBtVG8gPSBkb2MuY2xpcFBvcyhwb3MudG8pO1xuICAgICAgICBpZiAoY21wKG1Gcm9tLCBtVG8pKSB7XG4gICAgICAgICAgdmFyIHN1Yk1hcmsgPSBtYXJrVGV4dChkb2MsIG1Gcm9tLCBtVG8sIG1hcmtlci5wcmltYXJ5LCBtYXJrZXIucHJpbWFyeS50eXBlKTtcbiAgICAgICAgICBtYXJrZXIubWFya2Vycy5wdXNoKHN1Yk1hcmspO1xuICAgICAgICAgIHN1Yk1hcmsucGFyZW50ID0gbWFya2VyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShjb3B5U2hhcmVkTWFya2VycywgXCJjb3B5U2hhcmVkTWFya2Vyc1wiKTtcbiAgICBmdW5jdGlvbiBkZXRhY2hTaGFyZWRNYXJrZXJzKG1hcmtlcnMpIHtcbiAgICAgIHZhciBsb29wID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbihpMykge1xuICAgICAgICB2YXIgbWFya2VyID0gbWFya2Vyc1tpM10sIGxpbmtlZCA9IFttYXJrZXIucHJpbWFyeS5kb2NdO1xuICAgICAgICBsaW5rZWREb2NzKG1hcmtlci5wcmltYXJ5LmRvYywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgIHJldHVybiBsaW5rZWQucHVzaChkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWFya2VyLm1hcmtlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgc3ViTWFya2VyID0gbWFya2VyLm1hcmtlcnNbal07XG4gICAgICAgICAgaWYgKGluZGV4T2YobGlua2VkLCBzdWJNYXJrZXIuZG9jKSA9PSAtMSkge1xuICAgICAgICAgICAgc3ViTWFya2VyLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICBtYXJrZXIubWFya2Vycy5zcGxpY2Uoai0tLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIFwibG9vcFwiKTtcbiAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBtYXJrZXJzLmxlbmd0aDsgaTIrKylcbiAgICAgICAgbG9vcChpMik7XG4gICAgfVxuICAgIF9fbmFtZShkZXRhY2hTaGFyZWRNYXJrZXJzLCBcImRldGFjaFNoYXJlZE1hcmtlcnNcIik7XG4gICAgdmFyIG5leHREb2NJZCA9IDA7XG4gICAgdmFyIERvYyA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24odGV4dCwgbW9kZSwgZmlyc3RMaW5lLCBsaW5lU2VwLCBkaXJlY3Rpb24pIHtcbiAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEb2MpKSB7XG4gICAgICAgIHJldHVybiBuZXcgRG9jKHRleHQsIG1vZGUsIGZpcnN0TGluZSwgbGluZVNlcCwgZGlyZWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIGlmIChmaXJzdExpbmUgPT0gbnVsbCkge1xuICAgICAgICBmaXJzdExpbmUgPSAwO1xuICAgICAgfVxuICAgICAgQnJhbmNoQ2h1bmsuY2FsbCh0aGlzLCBbbmV3IExlYWZDaHVuayhbbmV3IExpbmUoXCJcIiwgbnVsbCldKV0pO1xuICAgICAgdGhpcy5maXJzdCA9IGZpcnN0TGluZTtcbiAgICAgIHRoaXMuc2Nyb2xsVG9wID0gdGhpcy5zY3JvbGxMZWZ0ID0gMDtcbiAgICAgIHRoaXMuY2FudEVkaXQgPSBmYWxzZTtcbiAgICAgIHRoaXMuY2xlYW5HZW5lcmF0aW9uID0gMTtcbiAgICAgIHRoaXMubW9kZUZyb250aWVyID0gdGhpcy5oaWdobGlnaHRGcm9udGllciA9IGZpcnN0TGluZTtcbiAgICAgIHZhciBzdGFydCA9IFBvcyhmaXJzdExpbmUsIDApO1xuICAgICAgdGhpcy5zZWwgPSBzaW1wbGVTZWxlY3Rpb24oc3RhcnQpO1xuICAgICAgdGhpcy5oaXN0b3J5ID0gbmV3IEhpc3RvcnkobnVsbCk7XG4gICAgICB0aGlzLmlkID0gKytuZXh0RG9jSWQ7XG4gICAgICB0aGlzLm1vZGVPcHRpb24gPSBtb2RlO1xuICAgICAgdGhpcy5saW5lU2VwID0gbGluZVNlcDtcbiAgICAgIHRoaXMuZGlyZWN0aW9uID0gZGlyZWN0aW9uID09IFwicnRsXCIgPyBcInJ0bFwiIDogXCJsdHJcIjtcbiAgICAgIHRoaXMuZXh0ZW5kID0gZmFsc2U7XG4gICAgICBpZiAodHlwZW9mIHRleHQgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0ZXh0ID0gdGhpcy5zcGxpdExpbmVzKHRleHQpO1xuICAgICAgfVxuICAgICAgdXBkYXRlRG9jKHRoaXMsIHsgZnJvbTogc3RhcnQsIHRvOiBzdGFydCwgdGV4dCB9KTtcbiAgICAgIHNldFNlbGVjdGlvbih0aGlzLCBzaW1wbGVTZWxlY3Rpb24oc3RhcnQpLCBzZWxfZG9udFNjcm9sbCk7XG4gICAgfSwgXCJEb2NcIik7XG4gICAgRG9jLnByb3RvdHlwZSA9IGNyZWF0ZU9iaihCcmFuY2hDaHVuay5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiBEb2MsXG4gICAgICBpdGVyOiBmdW5jdGlvbihmcm9tLCB0bywgb3ApIHtcbiAgICAgICAgaWYgKG9wKSB7XG4gICAgICAgICAgdGhpcy5pdGVyTihmcm9tIC0gdGhpcy5maXJzdCwgdG8gLSBmcm9tLCBvcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5pdGVyTih0aGlzLmZpcnN0LCB0aGlzLmZpcnN0ICsgdGhpcy5zaXplLCBmcm9tKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGluc2VydDogZnVuY3Rpb24oYXQsIGxpbmVzKSB7XG4gICAgICAgIHZhciBoZWlnaHQgPSAwO1xuICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgbGluZXMubGVuZ3RoOyArK2kyKSB7XG4gICAgICAgICAgaGVpZ2h0ICs9IGxpbmVzW2kyXS5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnNlcnRJbm5lcihhdCAtIHRoaXMuZmlyc3QsIGxpbmVzLCBoZWlnaHQpO1xuICAgICAgfSxcbiAgICAgIHJlbW92ZTogZnVuY3Rpb24oYXQsIG4pIHtcbiAgICAgICAgdGhpcy5yZW1vdmVJbm5lcihhdCAtIHRoaXMuZmlyc3QsIG4pO1xuICAgICAgfSxcbiAgICAgIGdldFZhbHVlOiBmdW5jdGlvbihsaW5lU2VwKSB7XG4gICAgICAgIHZhciBsaW5lcyA9IGdldExpbmVzKHRoaXMsIHRoaXMuZmlyc3QsIHRoaXMuZmlyc3QgKyB0aGlzLnNpemUpO1xuICAgICAgICBpZiAobGluZVNlcCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gbGluZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmVzLmpvaW4obGluZVNlcCB8fCB0aGlzLmxpbmVTZXBhcmF0b3IoKSk7XG4gICAgICB9LFxuICAgICAgc2V0VmFsdWU6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGNvZGUpIHtcbiAgICAgICAgdmFyIHRvcCA9IFBvcyh0aGlzLmZpcnN0LCAwKSwgbGFzdCA9IHRoaXMuZmlyc3QgKyB0aGlzLnNpemUgLSAxO1xuICAgICAgICBtYWtlQ2hhbmdlKHRoaXMsIHtcbiAgICAgICAgICBmcm9tOiB0b3AsXG4gICAgICAgICAgdG86IFBvcyhsYXN0LCBnZXRMaW5lKHRoaXMsIGxhc3QpLnRleHQubGVuZ3RoKSxcbiAgICAgICAgICB0ZXh0OiB0aGlzLnNwbGl0TGluZXMoY29kZSksXG4gICAgICAgICAgb3JpZ2luOiBcInNldFZhbHVlXCIsXG4gICAgICAgICAgZnVsbDogdHJ1ZVxuICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgaWYgKHRoaXMuY20pIHtcbiAgICAgICAgICBzY3JvbGxUb0Nvb3Jkcyh0aGlzLmNtLCAwLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRTZWxlY3Rpb24odGhpcywgc2ltcGxlU2VsZWN0aW9uKHRvcCksIHNlbF9kb250U2Nyb2xsKTtcbiAgICAgIH0pLFxuICAgICAgcmVwbGFjZVJhbmdlOiBmdW5jdGlvbihjb2RlLCBmcm9tLCB0bywgb3JpZ2luKSB7XG4gICAgICAgIGZyb20gPSBjbGlwUG9zKHRoaXMsIGZyb20pO1xuICAgICAgICB0byA9IHRvID8gY2xpcFBvcyh0aGlzLCB0bykgOiBmcm9tO1xuICAgICAgICByZXBsYWNlUmFuZ2UodGhpcywgY29kZSwgZnJvbSwgdG8sIG9yaWdpbik7XG4gICAgICB9LFxuICAgICAgZ2V0UmFuZ2U6IGZ1bmN0aW9uKGZyb20sIHRvLCBsaW5lU2VwKSB7XG4gICAgICAgIHZhciBsaW5lcyA9IGdldEJldHdlZW4odGhpcywgY2xpcFBvcyh0aGlzLCBmcm9tKSwgY2xpcFBvcyh0aGlzLCB0bykpO1xuICAgICAgICBpZiAobGluZVNlcCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gbGluZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmVTZXAgPT09IFwiXCIpIHtcbiAgICAgICAgICByZXR1cm4gbGluZXMuam9pbihcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGluZXMuam9pbihsaW5lU2VwIHx8IHRoaXMubGluZVNlcGFyYXRvcigpKTtcbiAgICAgIH0sXG4gICAgICBnZXRMaW5lOiBmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgIHZhciBsID0gdGhpcy5nZXRMaW5lSGFuZGxlKGxpbmUpO1xuICAgICAgICByZXR1cm4gbCAmJiBsLnRleHQ7XG4gICAgICB9LFxuICAgICAgZ2V0TGluZUhhbmRsZTogZnVuY3Rpb24obGluZSkge1xuICAgICAgICBpZiAoaXNMaW5lKHRoaXMsIGxpbmUpKSB7XG4gICAgICAgICAgcmV0dXJuIGdldExpbmUodGhpcywgbGluZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBnZXRMaW5lTnVtYmVyOiBmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgIHJldHVybiBsaW5lTm8obGluZSk7XG4gICAgICB9LFxuICAgICAgZ2V0TGluZUhhbmRsZVZpc3VhbFN0YXJ0OiBmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbGluZSA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgbGluZSA9IGdldExpbmUodGhpcywgbGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZpc3VhbExpbmUobGluZSk7XG4gICAgICB9LFxuICAgICAgbGluZUNvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZTtcbiAgICAgIH0sXG4gICAgICBmaXJzdExpbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maXJzdDtcbiAgICAgIH0sXG4gICAgICBsYXN0TGluZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpcnN0ICsgdGhpcy5zaXplIC0gMTtcbiAgICAgIH0sXG4gICAgICBjbGlwUG9zOiBmdW5jdGlvbihwb3MpIHtcbiAgICAgICAgcmV0dXJuIGNsaXBQb3ModGhpcywgcG9zKTtcbiAgICAgIH0sXG4gICAgICBnZXRDdXJzb3I6IGZ1bmN0aW9uKHN0YXJ0KSB7XG4gICAgICAgIHZhciByYW5nZTIgPSB0aGlzLnNlbC5wcmltYXJ5KCksIHBvcztcbiAgICAgICAgaWYgKHN0YXJ0ID09IG51bGwgfHwgc3RhcnQgPT0gXCJoZWFkXCIpIHtcbiAgICAgICAgICBwb3MgPSByYW5nZTIuaGVhZDtcbiAgICAgICAgfSBlbHNlIGlmIChzdGFydCA9PSBcImFuY2hvclwiKSB7XG4gICAgICAgICAgcG9zID0gcmFuZ2UyLmFuY2hvcjtcbiAgICAgICAgfSBlbHNlIGlmIChzdGFydCA9PSBcImVuZFwiIHx8IHN0YXJ0ID09IFwidG9cIiB8fCBzdGFydCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBwb3MgPSByYW5nZTIudG8oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwb3MgPSByYW5nZTIuZnJvbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgICB9LFxuICAgICAgbGlzdFNlbGVjdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWwucmFuZ2VzO1xuICAgICAgfSxcbiAgICAgIHNvbWV0aGluZ1NlbGVjdGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsLnNvbWV0aGluZ1NlbGVjdGVkKCk7XG4gICAgICB9LFxuICAgICAgc2V0Q3Vyc29yOiBkb2NNZXRob2RPcChmdW5jdGlvbihsaW5lLCBjaCwgb3B0aW9ucykge1xuICAgICAgICBzZXRTaW1wbGVTZWxlY3Rpb24odGhpcywgY2xpcFBvcyh0aGlzLCB0eXBlb2YgbGluZSA9PSBcIm51bWJlclwiID8gUG9zKGxpbmUsIGNoIHx8IDApIDogbGluZSksIG51bGwsIG9wdGlvbnMpO1xuICAgICAgfSksXG4gICAgICBzZXRTZWxlY3Rpb246IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGFuY2hvciwgaGVhZCwgb3B0aW9ucykge1xuICAgICAgICBzZXRTaW1wbGVTZWxlY3Rpb24odGhpcywgY2xpcFBvcyh0aGlzLCBhbmNob3IpLCBjbGlwUG9zKHRoaXMsIGhlYWQgfHwgYW5jaG9yKSwgb3B0aW9ucyk7XG4gICAgICB9KSxcbiAgICAgIGV4dGVuZFNlbGVjdGlvbjogZG9jTWV0aG9kT3AoZnVuY3Rpb24oaGVhZCwgb3RoZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgZXh0ZW5kU2VsZWN0aW9uKHRoaXMsIGNsaXBQb3ModGhpcywgaGVhZCksIG90aGVyICYmIGNsaXBQb3ModGhpcywgb3RoZXIpLCBvcHRpb25zKTtcbiAgICAgIH0pLFxuICAgICAgZXh0ZW5kU2VsZWN0aW9uczogZG9jTWV0aG9kT3AoZnVuY3Rpb24oaGVhZHMsIG9wdGlvbnMpIHtcbiAgICAgICAgZXh0ZW5kU2VsZWN0aW9ucyh0aGlzLCBjbGlwUG9zQXJyYXkodGhpcywgaGVhZHMpLCBvcHRpb25zKTtcbiAgICAgIH0pLFxuICAgICAgZXh0ZW5kU2VsZWN0aW9uc0J5OiBkb2NNZXRob2RPcChmdW5jdGlvbihmLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBoZWFkcyA9IG1hcCh0aGlzLnNlbC5yYW5nZXMsIGYpO1xuICAgICAgICBleHRlbmRTZWxlY3Rpb25zKHRoaXMsIGNsaXBQb3NBcnJheSh0aGlzLCBoZWFkcyksIG9wdGlvbnMpO1xuICAgICAgfSksXG4gICAgICBzZXRTZWxlY3Rpb25zOiBkb2NNZXRob2RPcChmdW5jdGlvbihyYW5nZXMsIHByaW1hcnksIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFyYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IHJhbmdlcy5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgICBvdXRbaTJdID0gbmV3IFJhbmdlKGNsaXBQb3ModGhpcywgcmFuZ2VzW2kyXS5hbmNob3IpLCBjbGlwUG9zKHRoaXMsIHJhbmdlc1tpMl0uaGVhZCB8fCByYW5nZXNbaTJdLmFuY2hvcikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmltYXJ5ID09IG51bGwpIHtcbiAgICAgICAgICBwcmltYXJ5ID0gTWF0aC5taW4ocmFuZ2VzLmxlbmd0aCAtIDEsIHRoaXMuc2VsLnByaW1JbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0U2VsZWN0aW9uKHRoaXMsIG5vcm1hbGl6ZVNlbGVjdGlvbih0aGlzLmNtLCBvdXQsIHByaW1hcnkpLCBvcHRpb25zKTtcbiAgICAgIH0pLFxuICAgICAgYWRkU2VsZWN0aW9uOiBkb2NNZXRob2RPcChmdW5jdGlvbihhbmNob3IsIGhlYWQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJhbmdlcyA9IHRoaXMuc2VsLnJhbmdlcy5zbGljZSgwKTtcbiAgICAgICAgcmFuZ2VzLnB1c2gobmV3IFJhbmdlKGNsaXBQb3ModGhpcywgYW5jaG9yKSwgY2xpcFBvcyh0aGlzLCBoZWFkIHx8IGFuY2hvcikpKTtcbiAgICAgICAgc2V0U2VsZWN0aW9uKHRoaXMsIG5vcm1hbGl6ZVNlbGVjdGlvbih0aGlzLmNtLCByYW5nZXMsIHJhbmdlcy5sZW5ndGggLSAxKSwgb3B0aW9ucyk7XG4gICAgICB9KSxcbiAgICAgIGdldFNlbGVjdGlvbjogZnVuY3Rpb24obGluZVNlcCkge1xuICAgICAgICB2YXIgcmFuZ2VzID0gdGhpcy5zZWwucmFuZ2VzLCBsaW5lcztcbiAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IHJhbmdlcy5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgICB2YXIgc2VsID0gZ2V0QmV0d2Vlbih0aGlzLCByYW5nZXNbaTJdLmZyb20oKSwgcmFuZ2VzW2kyXS50bygpKTtcbiAgICAgICAgICBsaW5lcyA9IGxpbmVzID8gbGluZXMuY29uY2F0KHNlbCkgOiBzZWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmVTZXAgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIGxpbmVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBsaW5lcy5qb2luKGxpbmVTZXAgfHwgdGhpcy5saW5lU2VwYXJhdG9yKCkpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZ2V0U2VsZWN0aW9uczogZnVuY3Rpb24obGluZVNlcCkge1xuICAgICAgICB2YXIgcGFydHMgPSBbXSwgcmFuZ2VzID0gdGhpcy5zZWwucmFuZ2VzO1xuICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgcmFuZ2VzLmxlbmd0aDsgaTIrKykge1xuICAgICAgICAgIHZhciBzZWwgPSBnZXRCZXR3ZWVuKHRoaXMsIHJhbmdlc1tpMl0uZnJvbSgpLCByYW5nZXNbaTJdLnRvKCkpO1xuICAgICAgICAgIGlmIChsaW5lU2VwICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgc2VsID0gc2VsLmpvaW4obGluZVNlcCB8fCB0aGlzLmxpbmVTZXBhcmF0b3IoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcnRzW2kyXSA9IHNlbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFydHM7XG4gICAgICB9LFxuICAgICAgcmVwbGFjZVNlbGVjdGlvbjogZnVuY3Rpb24oY29kZSwgY29sbGFwc2UsIG9yaWdpbikge1xuICAgICAgICB2YXIgZHVwID0gW107XG4gICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCB0aGlzLnNlbC5yYW5nZXMubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgICAgZHVwW2kyXSA9IGNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXBsYWNlU2VsZWN0aW9ucyhkdXAsIGNvbGxhcHNlLCBvcmlnaW4gfHwgXCIraW5wdXRcIik7XG4gICAgICB9LFxuICAgICAgcmVwbGFjZVNlbGVjdGlvbnM6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGNvZGUsIGNvbGxhcHNlLCBvcmlnaW4pIHtcbiAgICAgICAgdmFyIGNoYW5nZXMgPSBbXSwgc2VsID0gdGhpcy5zZWw7XG4gICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBzZWwucmFuZ2VzLmxlbmd0aDsgaTIrKykge1xuICAgICAgICAgIHZhciByYW5nZTIgPSBzZWwucmFuZ2VzW2kyXTtcbiAgICAgICAgICBjaGFuZ2VzW2kyXSA9IHsgZnJvbTogcmFuZ2UyLmZyb20oKSwgdG86IHJhbmdlMi50bygpLCB0ZXh0OiB0aGlzLnNwbGl0TGluZXMoY29kZVtpMl0pLCBvcmlnaW4gfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3U2VsID0gY29sbGFwc2UgJiYgY29sbGFwc2UgIT0gXCJlbmRcIiAmJiBjb21wdXRlUmVwbGFjZWRTZWwodGhpcywgY2hhbmdlcywgY29sbGFwc2UpO1xuICAgICAgICBmb3IgKHZhciBpJDEyID0gY2hhbmdlcy5sZW5ndGggLSAxOyBpJDEyID49IDA7IGkkMTItLSkge1xuICAgICAgICAgIG1ha2VDaGFuZ2UodGhpcywgY2hhbmdlc1tpJDEyXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld1NlbCkge1xuICAgICAgICAgIHNldFNlbGVjdGlvblJlcGxhY2VIaXN0b3J5KHRoaXMsIG5ld1NlbCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5jbSkge1xuICAgICAgICAgIGVuc3VyZUN1cnNvclZpc2libGUodGhpcy5jbSk7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgdW5kbzogZG9jTWV0aG9kT3AoZnVuY3Rpb24oKSB7XG4gICAgICAgIG1ha2VDaGFuZ2VGcm9tSGlzdG9yeSh0aGlzLCBcInVuZG9cIik7XG4gICAgICB9KSxcbiAgICAgIHJlZG86IGRvY01ldGhvZE9wKGZ1bmN0aW9uKCkge1xuICAgICAgICBtYWtlQ2hhbmdlRnJvbUhpc3RvcnkodGhpcywgXCJyZWRvXCIpO1xuICAgICAgfSksXG4gICAgICB1bmRvU2VsZWN0aW9uOiBkb2NNZXRob2RPcChmdW5jdGlvbigpIHtcbiAgICAgICAgbWFrZUNoYW5nZUZyb21IaXN0b3J5KHRoaXMsIFwidW5kb1wiLCB0cnVlKTtcbiAgICAgIH0pLFxuICAgICAgcmVkb1NlbGVjdGlvbjogZG9jTWV0aG9kT3AoZnVuY3Rpb24oKSB7XG4gICAgICAgIG1ha2VDaGFuZ2VGcm9tSGlzdG9yeSh0aGlzLCBcInJlZG9cIiwgdHJ1ZSk7XG4gICAgICB9KSxcbiAgICAgIHNldEV4dGVuZGluZzogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMuZXh0ZW5kID0gdmFsO1xuICAgICAgfSxcbiAgICAgIGdldEV4dGVuZGluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dGVuZDtcbiAgICAgIH0sXG4gICAgICBoaXN0b3J5U2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoaXN0ID0gdGhpcy5oaXN0b3J5LCBkb25lID0gMCwgdW5kb25lID0gMDtcbiAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IGhpc3QuZG9uZS5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgICBpZiAoIWhpc3QuZG9uZVtpMl0ucmFuZ2VzKSB7XG4gICAgICAgICAgICArK2RvbmU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkkMTIgPSAwOyBpJDEyIDwgaGlzdC51bmRvbmUubGVuZ3RoOyBpJDEyKyspIHtcbiAgICAgICAgICBpZiAoIWhpc3QudW5kb25lW2kkMTJdLnJhbmdlcykge1xuICAgICAgICAgICAgKyt1bmRvbmU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHVuZG86IGRvbmUsIHJlZG86IHVuZG9uZSB9O1xuICAgICAgfSxcbiAgICAgIGNsZWFySGlzdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0aGlzJDEkMSA9IHRoaXM7XG4gICAgICAgIHRoaXMuaGlzdG9yeSA9IG5ldyBIaXN0b3J5KHRoaXMuaGlzdG9yeSk7XG4gICAgICAgIGxpbmtlZERvY3ModGhpcywgZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgICAgcmV0dXJuIGRvYy5oaXN0b3J5ID0gdGhpcyQxJDEuaGlzdG9yeTtcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICB9LFxuICAgICAgbWFya0NsZWFuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jbGVhbkdlbmVyYXRpb24gPSB0aGlzLmNoYW5nZUdlbmVyYXRpb24odHJ1ZSk7XG4gICAgICB9LFxuICAgICAgY2hhbmdlR2VuZXJhdGlvbjogZnVuY3Rpb24oZm9yY2VTcGxpdCkge1xuICAgICAgICBpZiAoZm9yY2VTcGxpdCkge1xuICAgICAgICAgIHRoaXMuaGlzdG9yeS5sYXN0T3AgPSB0aGlzLmhpc3RvcnkubGFzdFNlbE9wID0gdGhpcy5oaXN0b3J5Lmxhc3RPcmlnaW4gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmhpc3RvcnkuZ2VuZXJhdGlvbjtcbiAgICAgIH0sXG4gICAgICBpc0NsZWFuOiBmdW5jdGlvbihnZW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGlzdG9yeS5nZW5lcmF0aW9uID09IChnZW4gfHwgdGhpcy5jbGVhbkdlbmVyYXRpb24pO1xuICAgICAgfSxcbiAgICAgIGdldEhpc3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRvbmU6IGNvcHlIaXN0b3J5QXJyYXkodGhpcy5oaXN0b3J5LmRvbmUpLFxuICAgICAgICAgIHVuZG9uZTogY29weUhpc3RvcnlBcnJheSh0aGlzLmhpc3RvcnkudW5kb25lKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHNldEhpc3Rvcnk6IGZ1bmN0aW9uKGhpc3REYXRhKSB7XG4gICAgICAgIHZhciBoaXN0ID0gdGhpcy5oaXN0b3J5ID0gbmV3IEhpc3RvcnkodGhpcy5oaXN0b3J5KTtcbiAgICAgICAgaGlzdC5kb25lID0gY29weUhpc3RvcnlBcnJheShoaXN0RGF0YS5kb25lLnNsaWNlKDApLCBudWxsLCB0cnVlKTtcbiAgICAgICAgaGlzdC51bmRvbmUgPSBjb3B5SGlzdG9yeUFycmF5KGhpc3REYXRhLnVuZG9uZS5zbGljZSgwKSwgbnVsbCwgdHJ1ZSk7XG4gICAgICB9LFxuICAgICAgc2V0R3V0dGVyTWFya2VyOiBkb2NNZXRob2RPcChmdW5jdGlvbihsaW5lLCBndXR0ZXJJRCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGNoYW5nZUxpbmUodGhpcywgbGluZSwgXCJndXR0ZXJcIiwgZnVuY3Rpb24obGluZTIpIHtcbiAgICAgICAgICB2YXIgbWFya2VycyA9IGxpbmUyLmd1dHRlck1hcmtlcnMgfHwgKGxpbmUyLmd1dHRlck1hcmtlcnMgPSB7fSk7XG4gICAgICAgICAgbWFya2Vyc1tndXR0ZXJJRF0gPSB2YWx1ZTtcbiAgICAgICAgICBpZiAoIXZhbHVlICYmIGlzRW1wdHkobWFya2VycykpIHtcbiAgICAgICAgICAgIGxpbmUyLmd1dHRlck1hcmtlcnMgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9KSxcbiAgICAgIGNsZWFyR3V0dGVyOiBkb2NNZXRob2RPcChmdW5jdGlvbihndXR0ZXJJRCkge1xuICAgICAgICB2YXIgdGhpcyQxJDEgPSB0aGlzO1xuICAgICAgICB0aGlzLml0ZXIoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgIGlmIChsaW5lLmd1dHRlck1hcmtlcnMgJiYgbGluZS5ndXR0ZXJNYXJrZXJzW2d1dHRlcklEXSkge1xuICAgICAgICAgICAgY2hhbmdlTGluZSh0aGlzJDEkMSwgbGluZSwgXCJndXR0ZXJcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGxpbmUuZ3V0dGVyTWFya2Vyc1tndXR0ZXJJRF0gPSBudWxsO1xuICAgICAgICAgICAgICBpZiAoaXNFbXB0eShsaW5lLmd1dHRlck1hcmtlcnMpKSB7XG4gICAgICAgICAgICAgICAgbGluZS5ndXR0ZXJNYXJrZXJzID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KSxcbiAgICAgIGxpbmVJbmZvOiBmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgIHZhciBuO1xuICAgICAgICBpZiAodHlwZW9mIGxpbmUgPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIGlmICghaXNMaW5lKHRoaXMsIGxpbmUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgbiA9IGxpbmU7XG4gICAgICAgICAgbGluZSA9IGdldExpbmUodGhpcywgbGluZSk7XG4gICAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbiA9IGxpbmVObyhsaW5lKTtcbiAgICAgICAgICBpZiAobiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsaW5lOiBuLFxuICAgICAgICAgIGhhbmRsZTogbGluZSxcbiAgICAgICAgICB0ZXh0OiBsaW5lLnRleHQsXG4gICAgICAgICAgZ3V0dGVyTWFya2VyczogbGluZS5ndXR0ZXJNYXJrZXJzLFxuICAgICAgICAgIHRleHRDbGFzczogbGluZS50ZXh0Q2xhc3MsXG4gICAgICAgICAgYmdDbGFzczogbGluZS5iZ0NsYXNzLFxuICAgICAgICAgIHdyYXBDbGFzczogbGluZS53cmFwQ2xhc3MsXG4gICAgICAgICAgd2lkZ2V0czogbGluZS53aWRnZXRzXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgYWRkTGluZUNsYXNzOiBkb2NNZXRob2RPcChmdW5jdGlvbihoYW5kbGUsIHdoZXJlLCBjbHMpIHtcbiAgICAgICAgcmV0dXJuIGNoYW5nZUxpbmUodGhpcywgaGFuZGxlLCB3aGVyZSA9PSBcImd1dHRlclwiID8gXCJndXR0ZXJcIiA6IFwiY2xhc3NcIiwgZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgIHZhciBwcm9wMiA9IHdoZXJlID09IFwidGV4dFwiID8gXCJ0ZXh0Q2xhc3NcIiA6IHdoZXJlID09IFwiYmFja2dyb3VuZFwiID8gXCJiZ0NsYXNzXCIgOiB3aGVyZSA9PSBcImd1dHRlclwiID8gXCJndXR0ZXJDbGFzc1wiIDogXCJ3cmFwQ2xhc3NcIjtcbiAgICAgICAgICBpZiAoIWxpbmVbcHJvcDJdKSB7XG4gICAgICAgICAgICBsaW5lW3Byb3AyXSA9IGNscztcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzVGVzdChjbHMpLnRlc3QobGluZVtwcm9wMl0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpbmVbcHJvcDJdICs9IFwiIFwiICsgY2xzO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9KSxcbiAgICAgIHJlbW92ZUxpbmVDbGFzczogZG9jTWV0aG9kT3AoZnVuY3Rpb24oaGFuZGxlLCB3aGVyZSwgY2xzKSB7XG4gICAgICAgIHJldHVybiBjaGFuZ2VMaW5lKHRoaXMsIGhhbmRsZSwgd2hlcmUgPT0gXCJndXR0ZXJcIiA/IFwiZ3V0dGVyXCIgOiBcImNsYXNzXCIsIGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICB2YXIgcHJvcDIgPSB3aGVyZSA9PSBcInRleHRcIiA/IFwidGV4dENsYXNzXCIgOiB3aGVyZSA9PSBcImJhY2tncm91bmRcIiA/IFwiYmdDbGFzc1wiIDogd2hlcmUgPT0gXCJndXR0ZXJcIiA/IFwiZ3V0dGVyQ2xhc3NcIiA6IFwid3JhcENsYXNzXCI7XG4gICAgICAgICAgdmFyIGN1ciA9IGxpbmVbcHJvcDJdO1xuICAgICAgICAgIGlmICghY3VyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgbGluZVtwcm9wMl0gPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZm91bmQgPSBjdXIubWF0Y2goY2xhc3NUZXN0KGNscykpO1xuICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZW5kID0gZm91bmQuaW5kZXggKyBmb3VuZFswXS5sZW5ndGg7XG4gICAgICAgICAgICBsaW5lW3Byb3AyXSA9IGN1ci5zbGljZSgwLCBmb3VuZC5pbmRleCkgKyAoIWZvdW5kLmluZGV4IHx8IGVuZCA9PSBjdXIubGVuZ3RoID8gXCJcIiA6IFwiIFwiKSArIGN1ci5zbGljZShlbmQpIHx8IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgIH0pLFxuICAgICAgYWRkTGluZVdpZGdldDogZG9jTWV0aG9kT3AoZnVuY3Rpb24oaGFuZGxlLCBub2RlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBhZGRMaW5lV2lkZ2V0KHRoaXMsIGhhbmRsZSwgbm9kZSwgb3B0aW9ucyk7XG4gICAgICB9KSxcbiAgICAgIHJlbW92ZUxpbmVXaWRnZXQ6IGZ1bmN0aW9uKHdpZGdldCkge1xuICAgICAgICB3aWRnZXQuY2xlYXIoKTtcbiAgICAgIH0sXG4gICAgICBtYXJrVGV4dDogZnVuY3Rpb24oZnJvbSwgdG8sIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG1hcmtUZXh0KHRoaXMsIGNsaXBQb3ModGhpcywgZnJvbSksIGNsaXBQb3ModGhpcywgdG8pLCBvcHRpb25zLCBvcHRpb25zICYmIG9wdGlvbnMudHlwZSB8fCBcInJhbmdlXCIpO1xuICAgICAgfSxcbiAgICAgIHNldEJvb2ttYXJrOiBmdW5jdGlvbihwb3MsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlYWxPcHRzID0ge1xuICAgICAgICAgIHJlcGxhY2VkV2l0aDogb3B0aW9ucyAmJiAob3B0aW9ucy5ub2RlVHlwZSA9PSBudWxsID8gb3B0aW9ucy53aWRnZXQgOiBvcHRpb25zKSxcbiAgICAgICAgICBpbnNlcnRMZWZ0OiBvcHRpb25zICYmIG9wdGlvbnMuaW5zZXJ0TGVmdCxcbiAgICAgICAgICBjbGVhcldoZW5FbXB0eTogZmFsc2UsXG4gICAgICAgICAgc2hhcmVkOiBvcHRpb25zICYmIG9wdGlvbnMuc2hhcmVkLFxuICAgICAgICAgIGhhbmRsZU1vdXNlRXZlbnRzOiBvcHRpb25zICYmIG9wdGlvbnMuaGFuZGxlTW91c2VFdmVudHNcbiAgICAgICAgfTtcbiAgICAgICAgcG9zID0gY2xpcFBvcyh0aGlzLCBwb3MpO1xuICAgICAgICByZXR1cm4gbWFya1RleHQodGhpcywgcG9zLCBwb3MsIHJlYWxPcHRzLCBcImJvb2ttYXJrXCIpO1xuICAgICAgfSxcbiAgICAgIGZpbmRNYXJrc0F0OiBmdW5jdGlvbihwb3MpIHtcbiAgICAgICAgcG9zID0gY2xpcFBvcyh0aGlzLCBwb3MpO1xuICAgICAgICB2YXIgbWFya2VycyA9IFtdLCBzcGFucyA9IGdldExpbmUodGhpcywgcG9zLmxpbmUpLm1hcmtlZFNwYW5zO1xuICAgICAgICBpZiAoc3BhbnMpIHtcbiAgICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgc3BhbnMubGVuZ3RoOyArK2kyKSB7XG4gICAgICAgICAgICB2YXIgc3BhbiA9IHNwYW5zW2kyXTtcbiAgICAgICAgICAgIGlmICgoc3Bhbi5mcm9tID09IG51bGwgfHwgc3Bhbi5mcm9tIDw9IHBvcy5jaCkgJiYgKHNwYW4udG8gPT0gbnVsbCB8fCBzcGFuLnRvID49IHBvcy5jaCkpIHtcbiAgICAgICAgICAgICAgbWFya2Vycy5wdXNoKHNwYW4ubWFya2VyLnBhcmVudCB8fCBzcGFuLm1hcmtlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXJrZXJzO1xuICAgICAgfSxcbiAgICAgIGZpbmRNYXJrczogZnVuY3Rpb24oZnJvbSwgdG8sIGZpbHRlcikge1xuICAgICAgICBmcm9tID0gY2xpcFBvcyh0aGlzLCBmcm9tKTtcbiAgICAgICAgdG8gPSBjbGlwUG9zKHRoaXMsIHRvKTtcbiAgICAgICAgdmFyIGZvdW5kID0gW10sIGxpbmVObzIgPSBmcm9tLmxpbmU7XG4gICAgICAgIHRoaXMuaXRlcihmcm9tLmxpbmUsIHRvLmxpbmUgKyAxLCBmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgdmFyIHNwYW5zID0gbGluZS5tYXJrZWRTcGFucztcbiAgICAgICAgICBpZiAoc3BhbnMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBzcGFucy5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgICAgICAgdmFyIHNwYW4gPSBzcGFuc1tpMl07XG4gICAgICAgICAgICAgIGlmICghKHNwYW4udG8gIT0gbnVsbCAmJiBsaW5lTm8yID09IGZyb20ubGluZSAmJiBmcm9tLmNoID49IHNwYW4udG8gfHwgc3Bhbi5mcm9tID09IG51bGwgJiYgbGluZU5vMiAhPSBmcm9tLmxpbmUgfHwgc3Bhbi5mcm9tICE9IG51bGwgJiYgbGluZU5vMiA9PSB0by5saW5lICYmIHNwYW4uZnJvbSA+PSB0by5jaCkgJiYgKCFmaWx0ZXIgfHwgZmlsdGVyKHNwYW4ubWFya2VyKSkpIHtcbiAgICAgICAgICAgICAgICBmb3VuZC5wdXNoKHNwYW4ubWFya2VyLnBhcmVudCB8fCBzcGFuLm1hcmtlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgKytsaW5lTm8yO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgfSxcbiAgICAgIGdldEFsbE1hcmtzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1hcmtlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5pdGVyKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICB2YXIgc3BzID0gbGluZS5tYXJrZWRTcGFucztcbiAgICAgICAgICBpZiAoc3BzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgc3BzLmxlbmd0aDsgKytpMikge1xuICAgICAgICAgICAgICBpZiAoc3BzW2kyXS5mcm9tICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXJzLnB1c2goc3BzW2kyXS5tYXJrZXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1hcmtlcnM7XG4gICAgICB9LFxuICAgICAgcG9zRnJvbUluZGV4OiBmdW5jdGlvbihvZmYyKSB7XG4gICAgICAgIHZhciBjaCwgbGluZU5vMiA9IHRoaXMuZmlyc3QsIHNlcFNpemUgPSB0aGlzLmxpbmVTZXBhcmF0b3IoKS5sZW5ndGg7XG4gICAgICAgIHRoaXMuaXRlcihmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgdmFyIHN6ID0gbGluZS50ZXh0Lmxlbmd0aCArIHNlcFNpemU7XG4gICAgICAgICAgaWYgKHN6ID4gb2ZmMikge1xuICAgICAgICAgICAgY2ggPSBvZmYyO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9mZjIgLT0gc3o7XG4gICAgICAgICAgKytsaW5lTm8yO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNsaXBQb3ModGhpcywgUG9zKGxpbmVObzIsIGNoKSk7XG4gICAgICB9LFxuICAgICAgaW5kZXhGcm9tUG9zOiBmdW5jdGlvbihjb29yZHMpIHtcbiAgICAgICAgY29vcmRzID0gY2xpcFBvcyh0aGlzLCBjb29yZHMpO1xuICAgICAgICB2YXIgaW5kZXggPSBjb29yZHMuY2g7XG4gICAgICAgIGlmIChjb29yZHMubGluZSA8IHRoaXMuZmlyc3QgfHwgY29vcmRzLmNoIDwgMCkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZXBTaXplID0gdGhpcy5saW5lU2VwYXJhdG9yKCkubGVuZ3RoO1xuICAgICAgICB0aGlzLml0ZXIodGhpcy5maXJzdCwgY29vcmRzLmxpbmUsIGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICBpbmRleCArPSBsaW5lLnRleHQubGVuZ3RoICsgc2VwU2l6ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH0sXG4gICAgICBjb3B5OiBmdW5jdGlvbihjb3B5SGlzdG9yeSkge1xuICAgICAgICB2YXIgZG9jID0gbmV3IERvYyhnZXRMaW5lcyh0aGlzLCB0aGlzLmZpcnN0LCB0aGlzLmZpcnN0ICsgdGhpcy5zaXplKSwgdGhpcy5tb2RlT3B0aW9uLCB0aGlzLmZpcnN0LCB0aGlzLmxpbmVTZXAsIHRoaXMuZGlyZWN0aW9uKTtcbiAgICAgICAgZG9jLnNjcm9sbFRvcCA9IHRoaXMuc2Nyb2xsVG9wO1xuICAgICAgICBkb2Muc2Nyb2xsTGVmdCA9IHRoaXMuc2Nyb2xsTGVmdDtcbiAgICAgICAgZG9jLnNlbCA9IHRoaXMuc2VsO1xuICAgICAgICBkb2MuZXh0ZW5kID0gZmFsc2U7XG4gICAgICAgIGlmIChjb3B5SGlzdG9yeSkge1xuICAgICAgICAgIGRvYy5oaXN0b3J5LnVuZG9EZXB0aCA9IHRoaXMuaGlzdG9yeS51bmRvRGVwdGg7XG4gICAgICAgICAgZG9jLnNldEhpc3RvcnkodGhpcy5nZXRIaXN0b3J5KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb2M7XG4gICAgICB9LFxuICAgICAgbGlua2VkRG9jOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZnJvbSA9IHRoaXMuZmlyc3QsIHRvID0gdGhpcy5maXJzdCArIHRoaXMuc2l6ZTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZnJvbSAhPSBudWxsICYmIG9wdGlvbnMuZnJvbSA+IGZyb20pIHtcbiAgICAgICAgICBmcm9tID0gb3B0aW9ucy5mcm9tO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnRvICE9IG51bGwgJiYgb3B0aW9ucy50byA8IHRvKSB7XG4gICAgICAgICAgdG8gPSBvcHRpb25zLnRvO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb3B5ID0gbmV3IERvYyhnZXRMaW5lcyh0aGlzLCBmcm9tLCB0byksIG9wdGlvbnMubW9kZSB8fCB0aGlzLm1vZGVPcHRpb24sIGZyb20sIHRoaXMubGluZVNlcCwgdGhpcy5kaXJlY3Rpb24pO1xuICAgICAgICBpZiAob3B0aW9ucy5zaGFyZWRIaXN0KSB7XG4gICAgICAgICAgY29weS5oaXN0b3J5ID0gdGhpcy5oaXN0b3J5O1xuICAgICAgICB9XG4gICAgICAgICh0aGlzLmxpbmtlZCB8fCAodGhpcy5saW5rZWQgPSBbXSkpLnB1c2goeyBkb2M6IGNvcHksIHNoYXJlZEhpc3Q6IG9wdGlvbnMuc2hhcmVkSGlzdCB9KTtcbiAgICAgICAgY29weS5saW5rZWQgPSBbeyBkb2M6IHRoaXMsIGlzUGFyZW50OiB0cnVlLCBzaGFyZWRIaXN0OiBvcHRpb25zLnNoYXJlZEhpc3QgfV07XG4gICAgICAgIGNvcHlTaGFyZWRNYXJrZXJzKGNvcHksIGZpbmRTaGFyZWRNYXJrZXJzKHRoaXMpKTtcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgICB9LFxuICAgICAgdW5saW5rRG9jOiBmdW5jdGlvbihvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBDb2RlTWlycm9yMikge1xuICAgICAgICAgIG90aGVyID0gb3RoZXIuZG9jO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxpbmtlZCkge1xuICAgICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCB0aGlzLmxpbmtlZC5sZW5ndGg7ICsraTIpIHtcbiAgICAgICAgICAgIHZhciBsaW5rID0gdGhpcy5saW5rZWRbaTJdO1xuICAgICAgICAgICAgaWYgKGxpbmsuZG9jICE9IG90aGVyKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5saW5rZWQuc3BsaWNlKGkyLCAxKTtcbiAgICAgICAgICAgIG90aGVyLnVubGlua0RvYyh0aGlzKTtcbiAgICAgICAgICAgIGRldGFjaFNoYXJlZE1hcmtlcnMoZmluZFNoYXJlZE1hcmtlcnModGhpcykpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlci5oaXN0b3J5ID09IHRoaXMuaGlzdG9yeSkge1xuICAgICAgICAgIHZhciBzcGxpdElkcyA9IFtvdGhlci5pZF07XG4gICAgICAgICAgbGlua2VkRG9jcyhvdGhlciwgZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgICAgICByZXR1cm4gc3BsaXRJZHMucHVzaChkb2MuaWQpO1xuICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgIG90aGVyLmhpc3RvcnkgPSBuZXcgSGlzdG9yeShudWxsKTtcbiAgICAgICAgICBvdGhlci5oaXN0b3J5LmRvbmUgPSBjb3B5SGlzdG9yeUFycmF5KHRoaXMuaGlzdG9yeS5kb25lLCBzcGxpdElkcyk7XG4gICAgICAgICAgb3RoZXIuaGlzdG9yeS51bmRvbmUgPSBjb3B5SGlzdG9yeUFycmF5KHRoaXMuaGlzdG9yeS51bmRvbmUsIHNwbGl0SWRzKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGl0ZXJMaW5rZWREb2NzOiBmdW5jdGlvbihmKSB7XG4gICAgICAgIGxpbmtlZERvY3ModGhpcywgZik7XG4gICAgICB9LFxuICAgICAgZ2V0TW9kZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGU7XG4gICAgICB9LFxuICAgICAgZ2V0RWRpdG9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY207XG4gICAgICB9LFxuICAgICAgc3BsaXRMaW5lczogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgIGlmICh0aGlzLmxpbmVTZXApIHtcbiAgICAgICAgICByZXR1cm4gc3RyLnNwbGl0KHRoaXMubGluZVNlcCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwbGl0TGluZXNBdXRvKHN0cik7XG4gICAgICB9LFxuICAgICAgbGluZVNlcGFyYXRvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmVTZXAgfHwgXCJcXG5cIjtcbiAgICAgIH0sXG4gICAgICBzZXREaXJlY3Rpb246IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGRpcikge1xuICAgICAgICBpZiAoZGlyICE9IFwicnRsXCIpIHtcbiAgICAgICAgICBkaXIgPSBcImx0clwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXIgPT0gdGhpcy5kaXJlY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBkaXI7XG4gICAgICAgIHRoaXMuaXRlcihmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgcmV0dXJuIGxpbmUub3JkZXIgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuY20pIHtcbiAgICAgICAgICBkaXJlY3Rpb25DaGFuZ2VkKHRoaXMuY20pO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pO1xuICAgIERvYy5wcm90b3R5cGUuZWFjaExpbmUgPSBEb2MucHJvdG90eXBlLml0ZXI7XG4gICAgdmFyIGxhc3REcm9wID0gMDtcbiAgICBmdW5jdGlvbiBvbkRyb3AoZSkge1xuICAgICAgdmFyIGNtID0gdGhpcztcbiAgICAgIGNsZWFyRHJhZ0N1cnNvcihjbSk7XG4gICAgICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUpIHx8IGV2ZW50SW5XaWRnZXQoY20uZGlzcGxheSwgZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZV9wcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgIGlmIChpZSkge1xuICAgICAgICBsYXN0RHJvcCA9ICtuZXcgRGF0ZSgpO1xuICAgICAgfVxuICAgICAgdmFyIHBvcyA9IHBvc0Zyb21Nb3VzZShjbSwgZSwgdHJ1ZSksIGZpbGVzID0gZS5kYXRhVHJhbnNmZXIuZmlsZXM7XG4gICAgICBpZiAoIXBvcyB8fCBjbS5pc1JlYWRPbmx5KCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGZpbGVzICYmIGZpbGVzLmxlbmd0aCAmJiB3aW5kb3cuRmlsZVJlYWRlciAmJiB3aW5kb3cuRmlsZSkge1xuICAgICAgICB2YXIgbiA9IGZpbGVzLmxlbmd0aCwgdGV4dCA9IEFycmF5KG4pLCByZWFkID0gMDtcbiAgICAgICAgdmFyIG1hcmtBc1JlYWRBbmRQYXN0ZUlmQWxsRmlsZXNBcmVSZWFkID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoKytyZWFkID09IG4pIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbihjbSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHBvcyA9IGNsaXBQb3MoY20uZG9jLCBwb3MpO1xuICAgICAgICAgICAgICB2YXIgY2hhbmdlID0ge1xuICAgICAgICAgICAgICAgIGZyb206IHBvcyxcbiAgICAgICAgICAgICAgICB0bzogcG9zLFxuICAgICAgICAgICAgICAgIHRleHQ6IGNtLmRvYy5zcGxpdExpbmVzKHRleHQuZmlsdGVyKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0ICE9IG51bGw7XG4gICAgICAgICAgICAgICAgfSkuam9pbihjbS5kb2MubGluZVNlcGFyYXRvcigpKSksXG4gICAgICAgICAgICAgICAgb3JpZ2luOiBcInBhc3RlXCJcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgbWFrZUNoYW5nZShjbS5kb2MsIGNoYW5nZSk7XG4gICAgICAgICAgICAgIHNldFNlbGVjdGlvblJlcGxhY2VIaXN0b3J5KGNtLmRvYywgc2ltcGxlU2VsZWN0aW9uKGNsaXBQb3MoY20uZG9jLCBwb3MpLCBjbGlwUG9zKGNtLmRvYywgY2hhbmdlRW5kKGNoYW5nZSkpKSk7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgXCJtYXJrQXNSZWFkQW5kUGFzdGVJZkFsbEZpbGVzQXJlUmVhZFwiKTtcbiAgICAgICAgdmFyIHJlYWRUZXh0RnJvbUZpbGUgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKGZpbGUsIGkzKSB7XG4gICAgICAgICAgaWYgKGNtLm9wdGlvbnMuYWxsb3dEcm9wRmlsZVR5cGVzICYmIGluZGV4T2YoY20ub3B0aW9ucy5hbGxvd0Ryb3BGaWxlVHlwZXMsIGZpbGUudHlwZSkgPT0gLTEpIHtcbiAgICAgICAgICAgIG1hcmtBc1JlYWRBbmRQYXN0ZUlmQWxsRmlsZXNBcmVSZWFkKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFya0FzUmVhZEFuZFBhc3RlSWZBbGxGaWxlc0FyZVJlYWQoKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVhZGVyLnJlc3VsdDtcbiAgICAgICAgICAgIGlmICgvW1xceDAwLVxceDA4XFx4MGUtXFx4MWZdezJ9Ly50ZXN0KGNvbnRlbnQpKSB7XG4gICAgICAgICAgICAgIG1hcmtBc1JlYWRBbmRQYXN0ZUlmQWxsRmlsZXNBcmVSZWFkKCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRleHRbaTNdID0gY29udGVudDtcbiAgICAgICAgICAgIG1hcmtBc1JlYWRBbmRQYXN0ZUlmQWxsRmlsZXNBcmVSZWFkKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZWFkZXIucmVhZEFzVGV4dChmaWxlKTtcbiAgICAgICAgfSwgXCJyZWFkVGV4dEZyb21GaWxlXCIpO1xuICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgZmlsZXMubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgICAgcmVhZFRleHRGcm9tRmlsZShmaWxlc1tpMl0sIGkyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNtLnN0YXRlLmRyYWdnaW5nVGV4dCAmJiBjbS5kb2Muc2VsLmNvbnRhaW5zKHBvcykgPiAtMSkge1xuICAgICAgICAgIGNtLnN0YXRlLmRyYWdnaW5nVGV4dChlKTtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGNtLmRpc3BsYXkuaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICB9LCAyMCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIHRleHQkMSA9IGUuZGF0YVRyYW5zZmVyLmdldERhdGEoXCJUZXh0XCIpO1xuICAgICAgICAgIGlmICh0ZXh0JDEpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZDtcbiAgICAgICAgICAgIGlmIChjbS5zdGF0ZS5kcmFnZ2luZ1RleHQgJiYgIWNtLnN0YXRlLmRyYWdnaW5nVGV4dC5jb3B5KSB7XG4gICAgICAgICAgICAgIHNlbGVjdGVkID0gY20ubGlzdFNlbGVjdGlvbnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldFNlbGVjdGlvbk5vVW5kbyhjbS5kb2MsIHNpbXBsZVNlbGVjdGlvbihwb3MsIHBvcykpO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkkMTIgPSAwOyBpJDEyIDwgc2VsZWN0ZWQubGVuZ3RoOyArK2kkMTIpIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlUmFuZ2UoY20uZG9jLCBcIlwiLCBzZWxlY3RlZFtpJDEyXS5hbmNob3IsIHNlbGVjdGVkW2kkMTJdLmhlYWQsIFwiZHJhZ1wiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY20ucmVwbGFjZVNlbGVjdGlvbih0ZXh0JDEsIFwiYXJvdW5kXCIsIFwicGFzdGVcIik7XG4gICAgICAgICAgICBjbS5kaXNwbGF5LmlucHV0LmZvY3VzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlJDEpIHtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUob25Ecm9wLCBcIm9uRHJvcFwiKTtcbiAgICBmdW5jdGlvbiBvbkRyYWdTdGFydChjbSwgZSkge1xuICAgICAgaWYgKGllICYmICghY20uc3RhdGUuZHJhZ2dpbmdUZXh0IHx8ICtuZXcgRGF0ZSgpIC0gbGFzdERyb3AgPCAxMDApKSB7XG4gICAgICAgIGVfc3RvcChlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHNpZ25hbERPTUV2ZW50KGNtLCBlKSB8fCBldmVudEluV2lkZ2V0KGNtLmRpc3BsYXksIGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGUuZGF0YVRyYW5zZmVyLnNldERhdGEoXCJUZXh0XCIsIGNtLmdldFNlbGVjdGlvbigpKTtcbiAgICAgIGUuZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQgPSBcImNvcHlNb3ZlXCI7XG4gICAgICBpZiAoZS5kYXRhVHJhbnNmZXIuc2V0RHJhZ0ltYWdlICYmICFzYWZhcmkpIHtcbiAgICAgICAgdmFyIGltZyA9IGVsdChcImltZ1wiLCBudWxsLCBudWxsLCBcInBvc2l0aW9uOiBmaXhlZDsgbGVmdDogMDsgdG9wOiAwO1wiKTtcbiAgICAgICAgaW1nLnNyYyA9IFwiZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFBQUFBQ0g1QkFFS0FBRUFMQUFBQUFBQkFBRUFBQUlDVEFFQU93PT1cIjtcbiAgICAgICAgaWYgKHByZXN0bykge1xuICAgICAgICAgIGltZy53aWR0aCA9IGltZy5oZWlnaHQgPSAxO1xuICAgICAgICAgIGNtLmRpc3BsYXkud3JhcHBlci5hcHBlbmRDaGlsZChpbWcpO1xuICAgICAgICAgIGltZy5fdG9wID0gaW1nLm9mZnNldFRvcDtcbiAgICAgICAgfVxuICAgICAgICBlLmRhdGFUcmFuc2Zlci5zZXREcmFnSW1hZ2UoaW1nLCAwLCAwKTtcbiAgICAgICAgaWYgKHByZXN0bykge1xuICAgICAgICAgIGltZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGltZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKG9uRHJhZ1N0YXJ0LCBcIm9uRHJhZ1N0YXJ0XCIpO1xuICAgIGZ1bmN0aW9uIG9uRHJhZ092ZXIoY20sIGUpIHtcbiAgICAgIHZhciBwb3MgPSBwb3NGcm9tTW91c2UoY20sIGUpO1xuICAgICAgaWYgKCFwb3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICBkcmF3U2VsZWN0aW9uQ3Vyc29yKGNtLCBwb3MsIGZyYWcpO1xuICAgICAgaWYgKCFjbS5kaXNwbGF5LmRyYWdDdXJzb3IpIHtcbiAgICAgICAgY20uZGlzcGxheS5kcmFnQ3Vyc29yID0gZWx0KFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1jdXJzb3JzIENvZGVNaXJyb3ItZHJhZ2N1cnNvcnNcIik7XG4gICAgICAgIGNtLmRpc3BsYXkubGluZVNwYWNlLmluc2VydEJlZm9yZShjbS5kaXNwbGF5LmRyYWdDdXJzb3IsIGNtLmRpc3BsYXkuY3Vyc29yRGl2KTtcbiAgICAgIH1cbiAgICAgIHJlbW92ZUNoaWxkcmVuQW5kQWRkKGNtLmRpc3BsYXkuZHJhZ0N1cnNvciwgZnJhZyk7XG4gICAgfVxuICAgIF9fbmFtZShvbkRyYWdPdmVyLCBcIm9uRHJhZ092ZXJcIik7XG4gICAgZnVuY3Rpb24gY2xlYXJEcmFnQ3Vyc29yKGNtKSB7XG4gICAgICBpZiAoY20uZGlzcGxheS5kcmFnQ3Vyc29yKSB7XG4gICAgICAgIGNtLmRpc3BsYXkubGluZVNwYWNlLnJlbW92ZUNoaWxkKGNtLmRpc3BsYXkuZHJhZ0N1cnNvcik7XG4gICAgICAgIGNtLmRpc3BsYXkuZHJhZ0N1cnNvciA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShjbGVhckRyYWdDdXJzb3IsIFwiY2xlYXJEcmFnQ3Vyc29yXCIpO1xuICAgIGZ1bmN0aW9uIGZvckVhY2hDb2RlTWlycm9yKGYpIHtcbiAgICAgIGlmICghZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgYnlDbGFzcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJDb2RlTWlycm9yXCIpLCBlZGl0b3JzID0gW107XG4gICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgYnlDbGFzcy5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgdmFyIGNtID0gYnlDbGFzc1tpMl0uQ29kZU1pcnJvcjtcbiAgICAgICAgaWYgKGNtKSB7XG4gICAgICAgICAgZWRpdG9ycy5wdXNoKGNtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGVkaXRvcnMubGVuZ3RoKSB7XG4gICAgICAgIGVkaXRvcnNbMF0ub3BlcmF0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGZvciAodmFyIGkzID0gMDsgaTMgPCBlZGl0b3JzLmxlbmd0aDsgaTMrKykge1xuICAgICAgICAgICAgZihlZGl0b3JzW2kzXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKGZvckVhY2hDb2RlTWlycm9yLCBcImZvckVhY2hDb2RlTWlycm9yXCIpO1xuICAgIHZhciBnbG9iYWxzUmVnaXN0ZXJlZCA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIGVuc3VyZUdsb2JhbEhhbmRsZXJzKCkge1xuICAgICAgaWYgKGdsb2JhbHNSZWdpc3RlcmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlZ2lzdGVyR2xvYmFsSGFuZGxlcnMoKTtcbiAgICAgIGdsb2JhbHNSZWdpc3RlcmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgX19uYW1lKGVuc3VyZUdsb2JhbEhhbmRsZXJzLCBcImVuc3VyZUdsb2JhbEhhbmRsZXJzXCIpO1xuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyR2xvYmFsSGFuZGxlcnMoKSB7XG4gICAgICB2YXIgcmVzaXplVGltZXI7XG4gICAgICBvbih3aW5kb3csIFwicmVzaXplXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAocmVzaXplVGltZXIgPT0gbnVsbCkge1xuICAgICAgICAgIHJlc2l6ZVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJlc2l6ZVRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIGZvckVhY2hDb2RlTWlycm9yKG9uUmVzaXplKTtcbiAgICAgICAgICB9LCAxMDApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG9uKHdpbmRvdywgXCJibHVyXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZm9yRWFjaENvZGVNaXJyb3Iob25CbHVyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBfX25hbWUocmVnaXN0ZXJHbG9iYWxIYW5kbGVycywgXCJyZWdpc3Rlckdsb2JhbEhhbmRsZXJzXCIpO1xuICAgIGZ1bmN0aW9uIG9uUmVzaXplKGNtKSB7XG4gICAgICB2YXIgZCA9IGNtLmRpc3BsYXk7XG4gICAgICBkLmNhY2hlZENoYXJXaWR0aCA9IGQuY2FjaGVkVGV4dEhlaWdodCA9IGQuY2FjaGVkUGFkZGluZ0ggPSBudWxsO1xuICAgICAgZC5zY3JvbGxiYXJzQ2xpcHBlZCA9IGZhbHNlO1xuICAgICAgY20uc2V0U2l6ZSgpO1xuICAgIH1cbiAgICBfX25hbWUob25SZXNpemUsIFwib25SZXNpemVcIik7XG4gICAgdmFyIGtleU5hbWVzID0ge1xuICAgICAgMzogXCJQYXVzZVwiLFxuICAgICAgODogXCJCYWNrc3BhY2VcIixcbiAgICAgIDk6IFwiVGFiXCIsXG4gICAgICAxMzogXCJFbnRlclwiLFxuICAgICAgMTY6IFwiU2hpZnRcIixcbiAgICAgIDE3OiBcIkN0cmxcIixcbiAgICAgIDE4OiBcIkFsdFwiLFxuICAgICAgMTk6IFwiUGF1c2VcIixcbiAgICAgIDIwOiBcIkNhcHNMb2NrXCIsXG4gICAgICAyNzogXCJFc2NcIixcbiAgICAgIDMyOiBcIlNwYWNlXCIsXG4gICAgICAzMzogXCJQYWdlVXBcIixcbiAgICAgIDM0OiBcIlBhZ2VEb3duXCIsXG4gICAgICAzNTogXCJFbmRcIixcbiAgICAgIDM2OiBcIkhvbWVcIixcbiAgICAgIDM3OiBcIkxlZnRcIixcbiAgICAgIDM4OiBcIlVwXCIsXG4gICAgICAzOTogXCJSaWdodFwiLFxuICAgICAgNDA6IFwiRG93blwiLFxuICAgICAgNDQ6IFwiUHJpbnRTY3JuXCIsXG4gICAgICA0NTogXCJJbnNlcnRcIixcbiAgICAgIDQ2OiBcIkRlbGV0ZVwiLFxuICAgICAgNTk6IFwiO1wiLFxuICAgICAgNjE6IFwiPVwiLFxuICAgICAgOTE6IFwiTW9kXCIsXG4gICAgICA5MjogXCJNb2RcIixcbiAgICAgIDkzOiBcIk1vZFwiLFxuICAgICAgMTA2OiBcIipcIixcbiAgICAgIDEwNzogXCI9XCIsXG4gICAgICAxMDk6IFwiLVwiLFxuICAgICAgMTEwOiBcIi5cIixcbiAgICAgIDExMTogXCIvXCIsXG4gICAgICAxNDU6IFwiU2Nyb2xsTG9ja1wiLFxuICAgICAgMTczOiBcIi1cIixcbiAgICAgIDE4NjogXCI7XCIsXG4gICAgICAxODc6IFwiPVwiLFxuICAgICAgMTg4OiBcIixcIixcbiAgICAgIDE4OTogXCItXCIsXG4gICAgICAxOTA6IFwiLlwiLFxuICAgICAgMTkxOiBcIi9cIixcbiAgICAgIDE5MjogXCJgXCIsXG4gICAgICAyMTk6IFwiW1wiLFxuICAgICAgMjIwOiBcIlxcXFxcIixcbiAgICAgIDIyMTogXCJdXCIsXG4gICAgICAyMjI6IFwiJ1wiLFxuICAgICAgMjI0OiBcIk1vZFwiLFxuICAgICAgNjMyMzI6IFwiVXBcIixcbiAgICAgIDYzMjMzOiBcIkRvd25cIixcbiAgICAgIDYzMjM0OiBcIkxlZnRcIixcbiAgICAgIDYzMjM1OiBcIlJpZ2h0XCIsXG4gICAgICA2MzI3MjogXCJEZWxldGVcIixcbiAgICAgIDYzMjczOiBcIkhvbWVcIixcbiAgICAgIDYzMjc1OiBcIkVuZFwiLFxuICAgICAgNjMyNzY6IFwiUGFnZVVwXCIsXG4gICAgICA2MzI3NzogXCJQYWdlRG93blwiLFxuICAgICAgNjMzMDI6IFwiSW5zZXJ0XCJcbiAgICB9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAga2V5TmFtZXNbaSArIDQ4XSA9IGtleU5hbWVzW2kgKyA5Nl0gPSBTdHJpbmcoaSk7XG4gICAgfVxuICAgIGZvciAodmFyIGkkMSA9IDY1OyBpJDEgPD0gOTA7IGkkMSsrKSB7XG4gICAgICBrZXlOYW1lc1tpJDFdID0gU3RyaW5nLmZyb21DaGFyQ29kZShpJDEpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpJDIgPSAxOyBpJDIgPD0gMTI7IGkkMisrKSB7XG4gICAgICBrZXlOYW1lc1tpJDIgKyAxMTFdID0ga2V5TmFtZXNbaSQyICsgNjMyMzVdID0gXCJGXCIgKyBpJDI7XG4gICAgfVxuICAgIHZhciBrZXlNYXAgPSB7fTtcbiAgICBrZXlNYXAuYmFzaWMgPSB7XG4gICAgICBcIkxlZnRcIjogXCJnb0NoYXJMZWZ0XCIsXG4gICAgICBcIlJpZ2h0XCI6IFwiZ29DaGFyUmlnaHRcIixcbiAgICAgIFwiVXBcIjogXCJnb0xpbmVVcFwiLFxuICAgICAgXCJEb3duXCI6IFwiZ29MaW5lRG93blwiLFxuICAgICAgXCJFbmRcIjogXCJnb0xpbmVFbmRcIixcbiAgICAgIFwiSG9tZVwiOiBcImdvTGluZVN0YXJ0U21hcnRcIixcbiAgICAgIFwiUGFnZVVwXCI6IFwiZ29QYWdlVXBcIixcbiAgICAgIFwiUGFnZURvd25cIjogXCJnb1BhZ2VEb3duXCIsXG4gICAgICBcIkRlbGV0ZVwiOiBcImRlbENoYXJBZnRlclwiLFxuICAgICAgXCJCYWNrc3BhY2VcIjogXCJkZWxDaGFyQmVmb3JlXCIsXG4gICAgICBcIlNoaWZ0LUJhY2tzcGFjZVwiOiBcImRlbENoYXJCZWZvcmVcIixcbiAgICAgIFwiVGFiXCI6IFwiZGVmYXVsdFRhYlwiLFxuICAgICAgXCJTaGlmdC1UYWJcIjogXCJpbmRlbnRBdXRvXCIsXG4gICAgICBcIkVudGVyXCI6IFwibmV3bGluZUFuZEluZGVudFwiLFxuICAgICAgXCJJbnNlcnRcIjogXCJ0b2dnbGVPdmVyd3JpdGVcIixcbiAgICAgIFwiRXNjXCI6IFwic2luZ2xlU2VsZWN0aW9uXCJcbiAgICB9O1xuICAgIGtleU1hcC5wY0RlZmF1bHQgPSB7XG4gICAgICBcIkN0cmwtQVwiOiBcInNlbGVjdEFsbFwiLFxuICAgICAgXCJDdHJsLURcIjogXCJkZWxldGVMaW5lXCIsXG4gICAgICBcIkN0cmwtWlwiOiBcInVuZG9cIixcbiAgICAgIFwiU2hpZnQtQ3RybC1aXCI6IFwicmVkb1wiLFxuICAgICAgXCJDdHJsLVlcIjogXCJyZWRvXCIsXG4gICAgICBcIkN0cmwtSG9tZVwiOiBcImdvRG9jU3RhcnRcIixcbiAgICAgIFwiQ3RybC1FbmRcIjogXCJnb0RvY0VuZFwiLFxuICAgICAgXCJDdHJsLVVwXCI6IFwiZ29MaW5lVXBcIixcbiAgICAgIFwiQ3RybC1Eb3duXCI6IFwiZ29MaW5lRG93blwiLFxuICAgICAgXCJDdHJsLUxlZnRcIjogXCJnb0dyb3VwTGVmdFwiLFxuICAgICAgXCJDdHJsLVJpZ2h0XCI6IFwiZ29Hcm91cFJpZ2h0XCIsXG4gICAgICBcIkFsdC1MZWZ0XCI6IFwiZ29MaW5lU3RhcnRcIixcbiAgICAgIFwiQWx0LVJpZ2h0XCI6IFwiZ29MaW5lRW5kXCIsXG4gICAgICBcIkN0cmwtQmFja3NwYWNlXCI6IFwiZGVsR3JvdXBCZWZvcmVcIixcbiAgICAgIFwiQ3RybC1EZWxldGVcIjogXCJkZWxHcm91cEFmdGVyXCIsXG4gICAgICBcIkN0cmwtU1wiOiBcInNhdmVcIixcbiAgICAgIFwiQ3RybC1GXCI6IFwiZmluZFwiLFxuICAgICAgXCJDdHJsLUdcIjogXCJmaW5kTmV4dFwiLFxuICAgICAgXCJTaGlmdC1DdHJsLUdcIjogXCJmaW5kUHJldlwiLFxuICAgICAgXCJTaGlmdC1DdHJsLUZcIjogXCJyZXBsYWNlXCIsXG4gICAgICBcIlNoaWZ0LUN0cmwtUlwiOiBcInJlcGxhY2VBbGxcIixcbiAgICAgIFwiQ3RybC1bXCI6IFwiaW5kZW50TGVzc1wiLFxuICAgICAgXCJDdHJsLV1cIjogXCJpbmRlbnRNb3JlXCIsXG4gICAgICBcIkN0cmwtVVwiOiBcInVuZG9TZWxlY3Rpb25cIixcbiAgICAgIFwiU2hpZnQtQ3RybC1VXCI6IFwicmVkb1NlbGVjdGlvblwiLFxuICAgICAgXCJBbHQtVVwiOiBcInJlZG9TZWxlY3Rpb25cIixcbiAgICAgIFwiZmFsbHRocm91Z2hcIjogXCJiYXNpY1wiXG4gICAgfTtcbiAgICBrZXlNYXAuZW1hY3N5ID0ge1xuICAgICAgXCJDdHJsLUZcIjogXCJnb0NoYXJSaWdodFwiLFxuICAgICAgXCJDdHJsLUJcIjogXCJnb0NoYXJMZWZ0XCIsXG4gICAgICBcIkN0cmwtUFwiOiBcImdvTGluZVVwXCIsXG4gICAgICBcIkN0cmwtTlwiOiBcImdvTGluZURvd25cIixcbiAgICAgIFwiQ3RybC1BXCI6IFwiZ29MaW5lU3RhcnRcIixcbiAgICAgIFwiQ3RybC1FXCI6IFwiZ29MaW5lRW5kXCIsXG4gICAgICBcIkN0cmwtVlwiOiBcImdvUGFnZURvd25cIixcbiAgICAgIFwiU2hpZnQtQ3RybC1WXCI6IFwiZ29QYWdlVXBcIixcbiAgICAgIFwiQ3RybC1EXCI6IFwiZGVsQ2hhckFmdGVyXCIsXG4gICAgICBcIkN0cmwtSFwiOiBcImRlbENoYXJCZWZvcmVcIixcbiAgICAgIFwiQWx0LUJhY2tzcGFjZVwiOiBcImRlbFdvcmRCZWZvcmVcIixcbiAgICAgIFwiQ3RybC1LXCI6IFwia2lsbExpbmVcIixcbiAgICAgIFwiQ3RybC1UXCI6IFwidHJhbnNwb3NlQ2hhcnNcIixcbiAgICAgIFwiQ3RybC1PXCI6IFwib3BlbkxpbmVcIlxuICAgIH07XG4gICAga2V5TWFwLm1hY0RlZmF1bHQgPSB7XG4gICAgICBcIkNtZC1BXCI6IFwic2VsZWN0QWxsXCIsXG4gICAgICBcIkNtZC1EXCI6IFwiZGVsZXRlTGluZVwiLFxuICAgICAgXCJDbWQtWlwiOiBcInVuZG9cIixcbiAgICAgIFwiU2hpZnQtQ21kLVpcIjogXCJyZWRvXCIsXG4gICAgICBcIkNtZC1ZXCI6IFwicmVkb1wiLFxuICAgICAgXCJDbWQtSG9tZVwiOiBcImdvRG9jU3RhcnRcIixcbiAgICAgIFwiQ21kLVVwXCI6IFwiZ29Eb2NTdGFydFwiLFxuICAgICAgXCJDbWQtRW5kXCI6IFwiZ29Eb2NFbmRcIixcbiAgICAgIFwiQ21kLURvd25cIjogXCJnb0RvY0VuZFwiLFxuICAgICAgXCJBbHQtTGVmdFwiOiBcImdvR3JvdXBMZWZ0XCIsXG4gICAgICBcIkFsdC1SaWdodFwiOiBcImdvR3JvdXBSaWdodFwiLFxuICAgICAgXCJDbWQtTGVmdFwiOiBcImdvTGluZUxlZnRcIixcbiAgICAgIFwiQ21kLVJpZ2h0XCI6IFwiZ29MaW5lUmlnaHRcIixcbiAgICAgIFwiQWx0LUJhY2tzcGFjZVwiOiBcImRlbEdyb3VwQmVmb3JlXCIsXG4gICAgICBcIkN0cmwtQWx0LUJhY2tzcGFjZVwiOiBcImRlbEdyb3VwQWZ0ZXJcIixcbiAgICAgIFwiQWx0LURlbGV0ZVwiOiBcImRlbEdyb3VwQWZ0ZXJcIixcbiAgICAgIFwiQ21kLVNcIjogXCJzYXZlXCIsXG4gICAgICBcIkNtZC1GXCI6IFwiZmluZFwiLFxuICAgICAgXCJDbWQtR1wiOiBcImZpbmROZXh0XCIsXG4gICAgICBcIlNoaWZ0LUNtZC1HXCI6IFwiZmluZFByZXZcIixcbiAgICAgIFwiQ21kLUFsdC1GXCI6IFwicmVwbGFjZVwiLFxuICAgICAgXCJTaGlmdC1DbWQtQWx0LUZcIjogXCJyZXBsYWNlQWxsXCIsXG4gICAgICBcIkNtZC1bXCI6IFwiaW5kZW50TGVzc1wiLFxuICAgICAgXCJDbWQtXVwiOiBcImluZGVudE1vcmVcIixcbiAgICAgIFwiQ21kLUJhY2tzcGFjZVwiOiBcImRlbFdyYXBwZWRMaW5lTGVmdFwiLFxuICAgICAgXCJDbWQtRGVsZXRlXCI6IFwiZGVsV3JhcHBlZExpbmVSaWdodFwiLFxuICAgICAgXCJDbWQtVVwiOiBcInVuZG9TZWxlY3Rpb25cIixcbiAgICAgIFwiU2hpZnQtQ21kLVVcIjogXCJyZWRvU2VsZWN0aW9uXCIsXG4gICAgICBcIkN0cmwtVXBcIjogXCJnb0RvY1N0YXJ0XCIsXG4gICAgICBcIkN0cmwtRG93blwiOiBcImdvRG9jRW5kXCIsXG4gICAgICBcImZhbGx0aHJvdWdoXCI6IFtcImJhc2ljXCIsIFwiZW1hY3N5XCJdXG4gICAgfTtcbiAgICBrZXlNYXBbXCJkZWZhdWx0XCJdID0gbWFjID8ga2V5TWFwLm1hY0RlZmF1bHQgOiBrZXlNYXAucGNEZWZhdWx0O1xuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUtleU5hbWUobmFtZSkge1xuICAgICAgdmFyIHBhcnRzID0gbmFtZS5zcGxpdCgvLSg/ISQpLyk7XG4gICAgICBuYW1lID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG4gICAgICB2YXIgYWx0LCBjdHJsLCBzaGlmdCwgY21kO1xuICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IHBhcnRzLmxlbmd0aCAtIDE7IGkyKyspIHtcbiAgICAgICAgdmFyIG1vZCA9IHBhcnRzW2kyXTtcbiAgICAgICAgaWYgKC9eKGNtZHxtZXRhfG0pJC9pLnRlc3QobW9kKSkge1xuICAgICAgICAgIGNtZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoL15hKGx0KT8kL2kudGVzdChtb2QpKSB7XG4gICAgICAgICAgYWx0ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICgvXihjfGN0cmx8Y29udHJvbCkkL2kudGVzdChtb2QpKSB7XG4gICAgICAgICAgY3RybCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoL15zKGhpZnQpPyQvaS50ZXN0KG1vZCkpIHtcbiAgICAgICAgICBzaGlmdCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIG1vZGlmaWVyIG5hbWU6IFwiICsgbW9kKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGFsdCkge1xuICAgICAgICBuYW1lID0gXCJBbHQtXCIgKyBuYW1lO1xuICAgICAgfVxuICAgICAgaWYgKGN0cmwpIHtcbiAgICAgICAgbmFtZSA9IFwiQ3RybC1cIiArIG5hbWU7XG4gICAgICB9XG4gICAgICBpZiAoY21kKSB7XG4gICAgICAgIG5hbWUgPSBcIkNtZC1cIiArIG5hbWU7XG4gICAgICB9XG4gICAgICBpZiAoc2hpZnQpIHtcbiAgICAgICAgbmFtZSA9IFwiU2hpZnQtXCIgKyBuYW1lO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICAgIF9fbmFtZShub3JtYWxpemVLZXlOYW1lLCBcIm5vcm1hbGl6ZUtleU5hbWVcIik7XG4gICAgZnVuY3Rpb24gbm9ybWFsaXplS2V5TWFwKGtleW1hcCkge1xuICAgICAgdmFyIGNvcHkgPSB7fTtcbiAgICAgIGZvciAodmFyIGtleW5hbWUgaW4ga2V5bWFwKSB7XG4gICAgICAgIGlmIChrZXltYXAuaGFzT3duUHJvcGVydHkoa2V5bmFtZSkpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBrZXltYXBba2V5bmFtZV07XG4gICAgICAgICAgaWYgKC9eKG5hbWV8ZmFsbHRocm91Z2h8KGRlfGF0KXRhY2gpJC8udGVzdChrZXluYW1lKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIi4uLlwiKSB7XG4gICAgICAgICAgICBkZWxldGUga2V5bWFwW2tleW5hbWVdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBrZXlzID0gbWFwKGtleW5hbWUuc3BsaXQoXCIgXCIpLCBub3JtYWxpemVLZXlOYW1lKTtcbiAgICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwga2V5cy5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSB2b2lkIDAsIG5hbWUgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoaTIgPT0ga2V5cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgIG5hbWUgPSBrZXlzLmpvaW4oXCIgXCIpO1xuICAgICAgICAgICAgICB2YWwgPSB2YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5hbWUgPSBrZXlzLnNsaWNlKDAsIGkyICsgMSkuam9pbihcIiBcIik7XG4gICAgICAgICAgICAgIHZhbCA9IFwiLi4uXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJldiA9IGNvcHlbbmFtZV07XG4gICAgICAgICAgICBpZiAoIXByZXYpIHtcbiAgICAgICAgICAgICAgY29weVtuYW1lXSA9IHZhbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJldiAhPSB2YWwpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5jb25zaXN0ZW50IGJpbmRpbmdzIGZvciBcIiArIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBkZWxldGUga2V5bWFwW2tleW5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBwcm9wMiBpbiBjb3B5KSB7XG4gICAgICAgIGtleW1hcFtwcm9wMl0gPSBjb3B5W3Byb3AyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXltYXA7XG4gICAgfVxuICAgIF9fbmFtZShub3JtYWxpemVLZXlNYXAsIFwibm9ybWFsaXplS2V5TWFwXCIpO1xuICAgIGZ1bmN0aW9uIGxvb2t1cEtleShrZXksIG1hcDIsIGhhbmRsZSwgY29udGV4dCkge1xuICAgICAgbWFwMiA9IGdldEtleU1hcChtYXAyKTtcbiAgICAgIHZhciBmb3VuZCA9IG1hcDIuY2FsbCA/IG1hcDIuY2FsbChrZXksIGNvbnRleHQpIDogbWFwMltrZXldO1xuICAgICAgaWYgKGZvdW5kID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gXCJub3RoaW5nXCI7XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQgPT09IFwiLi4uXCIpIHtcbiAgICAgICAgcmV0dXJuIFwibXVsdGlcIjtcbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCAhPSBudWxsICYmIGhhbmRsZShmb3VuZCkpIHtcbiAgICAgICAgcmV0dXJuIFwiaGFuZGxlZFwiO1xuICAgICAgfVxuICAgICAgaWYgKG1hcDIuZmFsbHRocm91Z2gpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtYXAyLmZhbGx0aHJvdWdoKSAhPSBcIltvYmplY3QgQXJyYXldXCIpIHtcbiAgICAgICAgICByZXR1cm4gbG9va3VwS2V5KGtleSwgbWFwMi5mYWxsdGhyb3VnaCwgaGFuZGxlLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgbWFwMi5mYWxsdGhyb3VnaC5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gbG9va3VwS2V5KGtleSwgbWFwMi5mYWxsdGhyb3VnaFtpMl0sIGhhbmRsZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKGxvb2t1cEtleSwgXCJsb29rdXBLZXlcIik7XG4gICAgZnVuY3Rpb24gaXNNb2RpZmllcktleSh2YWx1ZSkge1xuICAgICAgdmFyIG5hbWUgPSB0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIiA/IHZhbHVlIDoga2V5TmFtZXNbdmFsdWUua2V5Q29kZV07XG4gICAgICByZXR1cm4gbmFtZSA9PSBcIkN0cmxcIiB8fCBuYW1lID09IFwiQWx0XCIgfHwgbmFtZSA9PSBcIlNoaWZ0XCIgfHwgbmFtZSA9PSBcIk1vZFwiO1xuICAgIH1cbiAgICBfX25hbWUoaXNNb2RpZmllcktleSwgXCJpc01vZGlmaWVyS2V5XCIpO1xuICAgIGZ1bmN0aW9uIGFkZE1vZGlmaWVyTmFtZXMobmFtZSwgZXZlbnQsIG5vU2hpZnQpIHtcbiAgICAgIHZhciBiYXNlID0gbmFtZTtcbiAgICAgIGlmIChldmVudC5hbHRLZXkgJiYgYmFzZSAhPSBcIkFsdFwiKSB7XG4gICAgICAgIG5hbWUgPSBcIkFsdC1cIiArIG5hbWU7XG4gICAgICB9XG4gICAgICBpZiAoKGZsaXBDdHJsQ21kID8gZXZlbnQubWV0YUtleSA6IGV2ZW50LmN0cmxLZXkpICYmIGJhc2UgIT0gXCJDdHJsXCIpIHtcbiAgICAgICAgbmFtZSA9IFwiQ3RybC1cIiArIG5hbWU7XG4gICAgICB9XG4gICAgICBpZiAoKGZsaXBDdHJsQ21kID8gZXZlbnQuY3RybEtleSA6IGV2ZW50Lm1ldGFLZXkpICYmIGJhc2UgIT0gXCJNb2RcIikge1xuICAgICAgICBuYW1lID0gXCJDbWQtXCIgKyBuYW1lO1xuICAgICAgfVxuICAgICAgaWYgKCFub1NoaWZ0ICYmIGV2ZW50LnNoaWZ0S2V5ICYmIGJhc2UgIT0gXCJTaGlmdFwiKSB7XG4gICAgICAgIG5hbWUgPSBcIlNoaWZ0LVwiICsgbmFtZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgICBfX25hbWUoYWRkTW9kaWZpZXJOYW1lcywgXCJhZGRNb2RpZmllck5hbWVzXCIpO1xuICAgIGZ1bmN0aW9uIGtleU5hbWUoZXZlbnQsIG5vU2hpZnQpIHtcbiAgICAgIGlmIChwcmVzdG8gJiYgZXZlbnQua2V5Q29kZSA9PSAzNCAmJiBldmVudFtcImNoYXJcIl0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIG5hbWUgPSBrZXlOYW1lc1tldmVudC5rZXlDb2RlXTtcbiAgICAgIGlmIChuYW1lID09IG51bGwgfHwgZXZlbnQuYWx0R3JhcGhLZXkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gMyAmJiBldmVudC5jb2RlKSB7XG4gICAgICAgIG5hbWUgPSBldmVudC5jb2RlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFkZE1vZGlmaWVyTmFtZXMobmFtZSwgZXZlbnQsIG5vU2hpZnQpO1xuICAgIH1cbiAgICBfX25hbWUoa2V5TmFtZSwgXCJrZXlOYW1lXCIpO1xuICAgIGZ1bmN0aW9uIGdldEtleU1hcCh2YWwpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsID09IFwic3RyaW5nXCIgPyBrZXlNYXBbdmFsXSA6IHZhbDtcbiAgICB9XG4gICAgX19uYW1lKGdldEtleU1hcCwgXCJnZXRLZXlNYXBcIik7XG4gICAgZnVuY3Rpb24gZGVsZXRlTmVhclNlbGVjdGlvbihjbSwgY29tcHV0ZSkge1xuICAgICAgdmFyIHJhbmdlcyA9IGNtLmRvYy5zZWwucmFuZ2VzLCBraWxsID0gW107XG4gICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgcmFuZ2VzLmxlbmd0aDsgaTIrKykge1xuICAgICAgICB2YXIgdG9LaWxsID0gY29tcHV0ZShyYW5nZXNbaTJdKTtcbiAgICAgICAgd2hpbGUgKGtpbGwubGVuZ3RoICYmIGNtcCh0b0tpbGwuZnJvbSwgbHN0KGtpbGwpLnRvKSA8PSAwKSB7XG4gICAgICAgICAgdmFyIHJlcGxhY2VkID0ga2lsbC5wb3AoKTtcbiAgICAgICAgICBpZiAoY21wKHJlcGxhY2VkLmZyb20sIHRvS2lsbC5mcm9tKSA8IDApIHtcbiAgICAgICAgICAgIHRvS2lsbC5mcm9tID0gcmVwbGFjZWQuZnJvbTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBraWxsLnB1c2godG9LaWxsKTtcbiAgICAgIH1cbiAgICAgIHJ1bkluT3AoY20sIGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBpMyA9IGtpbGwubGVuZ3RoIC0gMTsgaTMgPj0gMDsgaTMtLSkge1xuICAgICAgICAgIHJlcGxhY2VSYW5nZShjbS5kb2MsIFwiXCIsIGtpbGxbaTNdLmZyb20sIGtpbGxbaTNdLnRvLCBcIitkZWxldGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgZW5zdXJlQ3Vyc29yVmlzaWJsZShjbSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgX19uYW1lKGRlbGV0ZU5lYXJTZWxlY3Rpb24sIFwiZGVsZXRlTmVhclNlbGVjdGlvblwiKTtcbiAgICBmdW5jdGlvbiBtb3ZlQ2hhckxvZ2ljYWxseShsaW5lLCBjaCwgZGlyKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gc2tpcEV4dGVuZGluZ0NoYXJzKGxpbmUudGV4dCwgY2ggKyBkaXIsIGRpcik7XG4gICAgICByZXR1cm4gdGFyZ2V0IDwgMCB8fCB0YXJnZXQgPiBsaW5lLnRleHQubGVuZ3RoID8gbnVsbCA6IHRhcmdldDtcbiAgICB9XG4gICAgX19uYW1lKG1vdmVDaGFyTG9naWNhbGx5LCBcIm1vdmVDaGFyTG9naWNhbGx5XCIpO1xuICAgIGZ1bmN0aW9uIG1vdmVMb2dpY2FsbHkobGluZSwgc3RhcnQsIGRpcikge1xuICAgICAgdmFyIGNoID0gbW92ZUNoYXJMb2dpY2FsbHkobGluZSwgc3RhcnQuY2gsIGRpcik7XG4gICAgICByZXR1cm4gY2ggPT0gbnVsbCA/IG51bGwgOiBuZXcgUG9zKHN0YXJ0LmxpbmUsIGNoLCBkaXIgPCAwID8gXCJhZnRlclwiIDogXCJiZWZvcmVcIik7XG4gICAgfVxuICAgIF9fbmFtZShtb3ZlTG9naWNhbGx5LCBcIm1vdmVMb2dpY2FsbHlcIik7XG4gICAgZnVuY3Rpb24gZW5kT2ZMaW5lKHZpc3VhbGx5LCBjbSwgbGluZU9iaiwgbGluZU5vMiwgZGlyKSB7XG4gICAgICBpZiAodmlzdWFsbHkpIHtcbiAgICAgICAgaWYgKGNtLmRvYy5kaXJlY3Rpb24gPT0gXCJydGxcIikge1xuICAgICAgICAgIGRpciA9IC1kaXI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9yZGVyID0gZ2V0T3JkZXIobGluZU9iaiwgY20uZG9jLmRpcmVjdGlvbik7XG4gICAgICAgIGlmIChvcmRlcikge1xuICAgICAgICAgIHZhciBwYXJ0ID0gZGlyIDwgMCA/IGxzdChvcmRlcikgOiBvcmRlclswXTtcbiAgICAgICAgICB2YXIgbW92ZUluU3RvcmFnZU9yZGVyID0gZGlyIDwgMCA9PSAocGFydC5sZXZlbCA9PSAxKTtcbiAgICAgICAgICB2YXIgc3RpY2t5ID0gbW92ZUluU3RvcmFnZU9yZGVyID8gXCJhZnRlclwiIDogXCJiZWZvcmVcIjtcbiAgICAgICAgICB2YXIgY2g7XG4gICAgICAgICAgaWYgKHBhcnQubGV2ZWwgPiAwIHx8IGNtLmRvYy5kaXJlY3Rpb24gPT0gXCJydGxcIikge1xuICAgICAgICAgICAgdmFyIHByZXAgPSBwcmVwYXJlTWVhc3VyZUZvckxpbmUoY20sIGxpbmVPYmopO1xuICAgICAgICAgICAgY2ggPSBkaXIgPCAwID8gbGluZU9iai50ZXh0Lmxlbmd0aCAtIDEgOiAwO1xuICAgICAgICAgICAgdmFyIHRhcmdldFRvcCA9IG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXAsIGNoKS50b3A7XG4gICAgICAgICAgICBjaCA9IGZpbmRGaXJzdChmdW5jdGlvbihjaDIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXAsIGNoMikudG9wID09IHRhcmdldFRvcDtcbiAgICAgICAgICAgIH0sIGRpciA8IDAgPT0gKHBhcnQubGV2ZWwgPT0gMSkgPyBwYXJ0LmZyb20gOiBwYXJ0LnRvIC0gMSwgY2gpO1xuICAgICAgICAgICAgaWYgKHN0aWNreSA9PSBcImJlZm9yZVwiKSB7XG4gICAgICAgICAgICAgIGNoID0gbW92ZUNoYXJMb2dpY2FsbHkobGluZU9iaiwgY2gsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaCA9IGRpciA8IDAgPyBwYXJ0LnRvIDogcGFydC5mcm9tO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFBvcyhsaW5lTm8yLCBjaCwgc3RpY2t5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBQb3MobGluZU5vMiwgZGlyIDwgMCA/IGxpbmVPYmoudGV4dC5sZW5ndGggOiAwLCBkaXIgPCAwID8gXCJiZWZvcmVcIiA6IFwiYWZ0ZXJcIik7XG4gICAgfVxuICAgIF9fbmFtZShlbmRPZkxpbmUsIFwiZW5kT2ZMaW5lXCIpO1xuICAgIGZ1bmN0aW9uIG1vdmVWaXN1YWxseShjbSwgbGluZSwgc3RhcnQsIGRpcikge1xuICAgICAgdmFyIGJpZGkgPSBnZXRPcmRlcihsaW5lLCBjbS5kb2MuZGlyZWN0aW9uKTtcbiAgICAgIGlmICghYmlkaSkge1xuICAgICAgICByZXR1cm4gbW92ZUxvZ2ljYWxseShsaW5lLCBzdGFydCwgZGlyKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydC5jaCA+PSBsaW5lLnRleHQubGVuZ3RoKSB7XG4gICAgICAgIHN0YXJ0LmNoID0gbGluZS50ZXh0Lmxlbmd0aDtcbiAgICAgICAgc3RhcnQuc3RpY2t5ID0gXCJiZWZvcmVcIjtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnQuY2ggPD0gMCkge1xuICAgICAgICBzdGFydC5jaCA9IDA7XG4gICAgICAgIHN0YXJ0LnN0aWNreSA9IFwiYWZ0ZXJcIjtcbiAgICAgIH1cbiAgICAgIHZhciBwYXJ0UG9zID0gZ2V0QmlkaVBhcnRBdChiaWRpLCBzdGFydC5jaCwgc3RhcnQuc3RpY2t5KSwgcGFydCA9IGJpZGlbcGFydFBvc107XG4gICAgICBpZiAoY20uZG9jLmRpcmVjdGlvbiA9PSBcImx0clwiICYmIHBhcnQubGV2ZWwgJSAyID09IDAgJiYgKGRpciA+IDAgPyBwYXJ0LnRvID4gc3RhcnQuY2ggOiBwYXJ0LmZyb20gPCBzdGFydC5jaCkpIHtcbiAgICAgICAgcmV0dXJuIG1vdmVMb2dpY2FsbHkobGluZSwgc3RhcnQsIGRpcik7XG4gICAgICB9XG4gICAgICB2YXIgbXYgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKHBvcywgZGlyMikge1xuICAgICAgICByZXR1cm4gbW92ZUNoYXJMb2dpY2FsbHkobGluZSwgcG9zIGluc3RhbmNlb2YgUG9zID8gcG9zLmNoIDogcG9zLCBkaXIyKTtcbiAgICAgIH0sIFwibXZcIik7XG4gICAgICB2YXIgcHJlcDtcbiAgICAgIHZhciBnZXRXcmFwcGVkTGluZUV4dGVudCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24oY2gyKSB7XG4gICAgICAgIGlmICghY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHtcbiAgICAgICAgICByZXR1cm4geyBiZWdpbjogMCwgZW5kOiBsaW5lLnRleHQubGVuZ3RoIH07XG4gICAgICAgIH1cbiAgICAgICAgcHJlcCA9IHByZXAgfHwgcHJlcGFyZU1lYXN1cmVGb3JMaW5lKGNtLCBsaW5lKTtcbiAgICAgICAgcmV0dXJuIHdyYXBwZWRMaW5lRXh0ZW50Q2hhcihjbSwgbGluZSwgcHJlcCwgY2gyKTtcbiAgICAgIH0sIFwiZ2V0V3JhcHBlZExpbmVFeHRlbnRcIik7XG4gICAgICB2YXIgd3JhcHBlZExpbmVFeHRlbnQyID0gZ2V0V3JhcHBlZExpbmVFeHRlbnQoc3RhcnQuc3RpY2t5ID09IFwiYmVmb3JlXCIgPyBtdihzdGFydCwgLTEpIDogc3RhcnQuY2gpO1xuICAgICAgaWYgKGNtLmRvYy5kaXJlY3Rpb24gPT0gXCJydGxcIiB8fCBwYXJ0LmxldmVsID09IDEpIHtcbiAgICAgICAgdmFyIG1vdmVJblN0b3JhZ2VPcmRlciA9IHBhcnQubGV2ZWwgPT0gMSA9PSBkaXIgPCAwO1xuICAgICAgICB2YXIgY2ggPSBtdihzdGFydCwgbW92ZUluU3RvcmFnZU9yZGVyID8gMSA6IC0xKTtcbiAgICAgICAgaWYgKGNoICE9IG51bGwgJiYgKCFtb3ZlSW5TdG9yYWdlT3JkZXIgPyBjaCA+PSBwYXJ0LmZyb20gJiYgY2ggPj0gd3JhcHBlZExpbmVFeHRlbnQyLmJlZ2luIDogY2ggPD0gcGFydC50byAmJiBjaCA8PSB3cmFwcGVkTGluZUV4dGVudDIuZW5kKSkge1xuICAgICAgICAgIHZhciBzdGlja3kgPSBtb3ZlSW5TdG9yYWdlT3JkZXIgPyBcImJlZm9yZVwiIDogXCJhZnRlclwiO1xuICAgICAgICAgIHJldHVybiBuZXcgUG9zKHN0YXJ0LmxpbmUsIGNoLCBzdGlja3kpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgc2VhcmNoSW5WaXN1YWxMaW5lID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbihwYXJ0UG9zMiwgZGlyMiwgd3JhcHBlZExpbmVFeHRlbnQzKSB7XG4gICAgICAgIHZhciBnZXRSZXMgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKGNoMywgbW92ZUluU3RvcmFnZU9yZGVyMykge1xuICAgICAgICAgIHJldHVybiBtb3ZlSW5TdG9yYWdlT3JkZXIzID8gbmV3IFBvcyhzdGFydC5saW5lLCBtdihjaDMsIDEpLCBcImJlZm9yZVwiKSA6IG5ldyBQb3Moc3RhcnQubGluZSwgY2gzLCBcImFmdGVyXCIpO1xuICAgICAgICB9LCBcImdldFJlc1wiKTtcbiAgICAgICAgZm9yICg7IHBhcnRQb3MyID49IDAgJiYgcGFydFBvczIgPCBiaWRpLmxlbmd0aDsgcGFydFBvczIgKz0gZGlyMikge1xuICAgICAgICAgIHZhciBwYXJ0MiA9IGJpZGlbcGFydFBvczJdO1xuICAgICAgICAgIHZhciBtb3ZlSW5TdG9yYWdlT3JkZXIyID0gZGlyMiA+IDAgPT0gKHBhcnQyLmxldmVsICE9IDEpO1xuICAgICAgICAgIHZhciBjaDIgPSBtb3ZlSW5TdG9yYWdlT3JkZXIyID8gd3JhcHBlZExpbmVFeHRlbnQzLmJlZ2luIDogbXYod3JhcHBlZExpbmVFeHRlbnQzLmVuZCwgLTEpO1xuICAgICAgICAgIGlmIChwYXJ0Mi5mcm9tIDw9IGNoMiAmJiBjaDIgPCBwYXJ0Mi50bykge1xuICAgICAgICAgICAgcmV0dXJuIGdldFJlcyhjaDIsIG1vdmVJblN0b3JhZ2VPcmRlcjIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjaDIgPSBtb3ZlSW5TdG9yYWdlT3JkZXIyID8gcGFydDIuZnJvbSA6IG12KHBhcnQyLnRvLCAtMSk7XG4gICAgICAgICAgaWYgKHdyYXBwZWRMaW5lRXh0ZW50My5iZWdpbiA8PSBjaDIgJiYgY2gyIDwgd3JhcHBlZExpbmVFeHRlbnQzLmVuZCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldFJlcyhjaDIsIG1vdmVJblN0b3JhZ2VPcmRlcjIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgXCJzZWFyY2hJblZpc3VhbExpbmVcIik7XG4gICAgICB2YXIgcmVzID0gc2VhcmNoSW5WaXN1YWxMaW5lKHBhcnRQb3MgKyBkaXIsIGRpciwgd3JhcHBlZExpbmVFeHRlbnQyKTtcbiAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICAgIHZhciBuZXh0Q2ggPSBkaXIgPiAwID8gd3JhcHBlZExpbmVFeHRlbnQyLmVuZCA6IG12KHdyYXBwZWRMaW5lRXh0ZW50Mi5iZWdpbiwgLTEpO1xuICAgICAgaWYgKG5leHRDaCAhPSBudWxsICYmICEoZGlyID4gMCAmJiBuZXh0Q2ggPT0gbGluZS50ZXh0Lmxlbmd0aCkpIHtcbiAgICAgICAgcmVzID0gc2VhcmNoSW5WaXN1YWxMaW5lKGRpciA+IDAgPyAwIDogYmlkaS5sZW5ndGggLSAxLCBkaXIsIGdldFdyYXBwZWRMaW5lRXh0ZW50KG5leHRDaCkpO1xuICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIF9fbmFtZShtb3ZlVmlzdWFsbHksIFwibW92ZVZpc3VhbGx5XCIpO1xuICAgIHZhciBjb21tYW5kcyA9IHtcbiAgICAgIHNlbGVjdEFsbCxcbiAgICAgIHNpbmdsZVNlbGVjdGlvbjogZnVuY3Rpb24oY20pIHtcbiAgICAgICAgcmV0dXJuIGNtLnNldFNlbGVjdGlvbihjbS5nZXRDdXJzb3IoXCJhbmNob3JcIiksIGNtLmdldEN1cnNvcihcImhlYWRcIiksIHNlbF9kb250U2Nyb2xsKTtcbiAgICAgIH0sXG4gICAgICBraWxsTGluZTogZnVuY3Rpb24oY20pIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZU5lYXJTZWxlY3Rpb24oY20sIGZ1bmN0aW9uKHJhbmdlMikge1xuICAgICAgICAgIGlmIChyYW5nZTIuZW1wdHkoKSkge1xuICAgICAgICAgICAgdmFyIGxlbiA9IGdldExpbmUoY20uZG9jLCByYW5nZTIuaGVhZC5saW5lKS50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChyYW5nZTIuaGVhZC5jaCA9PSBsZW4gJiYgcmFuZ2UyLmhlYWQubGluZSA8IGNtLmxhc3RMaW5lKCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgZnJvbTogcmFuZ2UyLmhlYWQsIHRvOiBQb3MocmFuZ2UyLmhlYWQubGluZSArIDEsIDApIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4geyBmcm9tOiByYW5nZTIuaGVhZCwgdG86IFBvcyhyYW5nZTIuaGVhZC5saW5lLCBsZW4pIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7IGZyb206IHJhbmdlMi5mcm9tKCksIHRvOiByYW5nZTIudG8oKSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZGVsZXRlTGluZTogZnVuY3Rpb24oY20pIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZU5lYXJTZWxlY3Rpb24oY20sIGZ1bmN0aW9uKHJhbmdlMikge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmcm9tOiBQb3MocmFuZ2UyLmZyb20oKS5saW5lLCAwKSxcbiAgICAgICAgICAgIHRvOiBjbGlwUG9zKGNtLmRvYywgUG9zKHJhbmdlMi50bygpLmxpbmUgKyAxLCAwKSlcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBkZWxMaW5lTGVmdDogZnVuY3Rpb24oY20pIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZU5lYXJTZWxlY3Rpb24oY20sIGZ1bmN0aW9uKHJhbmdlMikge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmcm9tOiBQb3MocmFuZ2UyLmZyb20oKS5saW5lLCAwKSxcbiAgICAgICAgICAgIHRvOiByYW5nZTIuZnJvbSgpXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZGVsV3JhcHBlZExpbmVMZWZ0OiBmdW5jdGlvbihjbSkge1xuICAgICAgICByZXR1cm4gZGVsZXRlTmVhclNlbGVjdGlvbihjbSwgZnVuY3Rpb24ocmFuZ2UyKSB7XG4gICAgICAgICAgdmFyIHRvcCA9IGNtLmNoYXJDb29yZHMocmFuZ2UyLmhlYWQsIFwiZGl2XCIpLnRvcCArIDU7XG4gICAgICAgICAgdmFyIGxlZnRQb3MgPSBjbS5jb29yZHNDaGFyKHsgbGVmdDogMCwgdG9wIH0sIFwiZGl2XCIpO1xuICAgICAgICAgIHJldHVybiB7IGZyb206IGxlZnRQb3MsIHRvOiByYW5nZTIuZnJvbSgpIH07XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGRlbFdyYXBwZWRMaW5lUmlnaHQ6IGZ1bmN0aW9uKGNtKSB7XG4gICAgICAgIHJldHVybiBkZWxldGVOZWFyU2VsZWN0aW9uKGNtLCBmdW5jdGlvbihyYW5nZTIpIHtcbiAgICAgICAgICB2YXIgdG9wID0gY20uY2hhckNvb3JkcyhyYW5nZTIuaGVhZCwgXCJkaXZcIikudG9wICsgNTtcbiAgICAgICAgICB2YXIgcmlnaHRQb3MgPSBjbS5jb29yZHNDaGFyKHsgbGVmdDogY20uZGlzcGxheS5saW5lRGl2Lm9mZnNldFdpZHRoICsgMTAwLCB0b3AgfSwgXCJkaXZcIik7XG4gICAgICAgICAgcmV0dXJuIHsgZnJvbTogcmFuZ2UyLmZyb20oKSwgdG86IHJpZ2h0UG9zIH07XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHVuZG86IGZ1bmN0aW9uKGNtKSB7XG4gICAgICAgIHJldHVybiBjbS51bmRvKCk7XG4gICAgICB9LFxuICAgICAgcmVkbzogZnVuY3Rpb24oY20pIHtcbiAgICAgICAgcmV0dXJuIGNtLnJlZG8oKTtcbiAgICAgIH0sXG4gICAgICB1bmRvU2VsZWN0aW9uOiBmdW5jdGlvbihjbSkge1xuICAgICAgICByZXR1cm4gY20udW5kb1NlbGVjdGlvbigpO1xuICAgICAgfSxcbiAgICAgIHJlZG9TZWxlY3Rpb246IGZ1bmN0aW9uKGNtKSB7XG4gICAgICAgIHJldHVybiBjbS5yZWRvU2VsZWN0aW9uKCk7XG4gICAgICB9LFxuICAgICAgZ29Eb2NTdGFydDogZnVuY3Rpb24oY20pIHtcbiAgICAgICAgcmV0dXJuIGNtLmV4dGVuZFNlbGVjdGlvbihQb3MoY20uZmlyc3RMaW5lKCksIDApKTtcbiAgICAgIH0sXG4gICAgICBnb0RvY0VuZDogZnVuY3Rpb24oY20pIHtcbiAgICAgICAgcmV0dXJuIGNtLmV4dGVuZFNlbGVjdGlvbihQb3MoY20ubGFzdExpbmUoKSkpO1xuICAgICAgfSxcbiAgICAgIGdvTGluZVN0YXJ0OiBmdW5jdGlvbihjbSkge1xuICAgICAgICByZXR1cm4gY20uZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uKHJhbmdlMikge1xuICAgICAgICAgIHJldHVybiBsaW5lU3RhcnQoY20sIHJhbmdlMi5oZWFkLmxpbmUpO1xuICAgICAgICB9LCB7IG9yaWdpbjogXCIrbW92ZVwiLCBiaWFzOiAxIH0pO1xuICAgICAgfSxcbiAgICAgIGdvTGluZVN0YXJ0U21hcnQ6IGZ1bmN0aW9uKGNtKSB7XG4gICAgICAgIHJldHVybiBjbS5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24ocmFuZ2UyKSB7XG4gICAgICAgICAgcmV0dXJuIGxpbmVTdGFydFNtYXJ0KGNtLCByYW5nZTIuaGVhZCk7XG4gICAgICAgIH0sIHsgb3JpZ2luOiBcIittb3ZlXCIsIGJpYXM6IDEgfSk7XG4gICAgICB9LFxuICAgICAgZ29MaW5lRW5kOiBmdW5jdGlvbihjbSkge1xuICAgICAgICByZXR1cm4gY20uZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uKHJhbmdlMikge1xuICAgICAgICAgIHJldHVybiBsaW5lRW5kKGNtLCByYW5nZTIuaGVhZC5saW5lKTtcbiAgICAgICAgfSwgeyBvcmlnaW46IFwiK21vdmVcIiwgYmlhczogLTEgfSk7XG4gICAgICB9LFxuICAgICAgZ29MaW5lUmlnaHQ6IGZ1bmN0aW9uKGNtKSB7XG4gICAgICAgIHJldHVybiBjbS5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24ocmFuZ2UyKSB7XG4gICAgICAgICAgdmFyIHRvcCA9IGNtLmN1cnNvckNvb3JkcyhyYW5nZTIuaGVhZCwgXCJkaXZcIikudG9wICsgNTtcbiAgICAgICAgICByZXR1cm4gY20uY29vcmRzQ2hhcih7IGxlZnQ6IGNtLmRpc3BsYXkubGluZURpdi5vZmZzZXRXaWR0aCArIDEwMCwgdG9wIH0sIFwiZGl2XCIpO1xuICAgICAgICB9LCBzZWxfbW92ZSk7XG4gICAgICB9LFxuICAgICAgZ29MaW5lTGVmdDogZnVuY3Rpb24oY20pIHtcbiAgICAgICAgcmV0dXJuIGNtLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbihyYW5nZTIpIHtcbiAgICAgICAgICB2YXIgdG9wID0gY20uY3Vyc29yQ29vcmRzKHJhbmdlMi5oZWFkLCBcImRpdlwiKS50b3AgKyA1O1xuICAgICAgICAgIHJldHVybiBjbS5jb29yZHNDaGFyKHsgbGVmdDogMCwgdG9wIH0sIFwiZGl2XCIpO1xuICAgICAgICB9LCBzZWxfbW92ZSk7XG4gICAgICB9LFxuICAgICAgZ29MaW5lTGVmdFNtYXJ0OiBmdW5jdGlvbihjbSkge1xuICAgICAgICByZXR1cm4gY20uZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uKHJhbmdlMikge1xuICAgICAgICAgIHZhciB0b3AgPSBjbS5jdXJzb3JDb29yZHMocmFuZ2UyLmhlYWQsIFwiZGl2XCIpLnRvcCArIDU7XG4gICAgICAgICAgdmFyIHBvcyA9IGNtLmNvb3Jkc0NoYXIoeyBsZWZ0OiAwLCB0b3AgfSwgXCJkaXZcIik7XG4gICAgICAgICAgaWYgKHBvcy5jaCA8IGNtLmdldExpbmUocG9zLmxpbmUpLnNlYXJjaCgvXFxTLykpIHtcbiAgICAgICAgICAgIHJldHVybiBsaW5lU3RhcnRTbWFydChjbSwgcmFuZ2UyLmhlYWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICB9LCBzZWxfbW92ZSk7XG4gICAgICB9LFxuICAgICAgZ29MaW5lVXA6IGZ1bmN0aW9uKGNtKSB7XG4gICAgICAgIHJldHVybiBjbS5tb3ZlVigtMSwgXCJsaW5lXCIpO1xuICAgICAgfSxcbiAgICAgIGdvTGluZURvd246IGZ1bmN0aW9uKGNtKSB7XG4gICAgICAgIHJldHVybiBjbS5tb3ZlVigxLCBcImxpbmVcIik7XG4gICAgICB9LFxuICAgICAgZ29QYWdlVXA6IGZ1bmN0aW9uKGNtKSB7XG4gICAgICAgIHJldHVybiBjbS5tb3ZlVigtMSwgXCJwYWdlXCIpO1xuICAgICAgfSxcbiAgICAgIGdvUGFnZURvd246IGZ1bmN0aW9uKGNtKSB7XG4gICAgICAgIHJldHVybiBjbS5tb3ZlVigxLCBcInBhZ2VcIik7XG4gICAgICB9LFxuICAgICAgZ29DaGFyTGVmdDogZnVuY3Rpb24oY20pIHtcbiAgICAgICAgcmV0dXJuIGNtLm1vdmVIKC0xLCBcImNoYXJcIik7XG4gICAgICB9LFxuICAgICAgZ29DaGFyUmlnaHQ6IGZ1bmN0aW9uKGNtKSB7XG4gICAgICAgIHJldHVybiBjbS5tb3ZlSCgxLCBcImNoYXJcIik7XG4gICAgICB9LFxuICAgICAgZ29Db2x1bW5MZWZ0OiBmdW5jdGlvbihjbSkge1xuICAgICAgICByZXR1cm4gY20ubW92ZUgoLTEsIFwiY29sdW1uXCIpO1xuICAgICAgfSxcbiAgICAgIGdvQ29sdW1uUmlnaHQ6IGZ1bmN0aW9uKGNtKSB7XG4gICAgICAgIHJldHVybiBjbS5tb3ZlSCgxLCBcImNvbHVtblwiKTtcbiAgICAgIH0sXG4gICAgICBnb1dvcmRMZWZ0OiBmdW5jdGlvbihjbSkge1xuICAgICAgICByZXR1cm4gY20ubW92ZUgoLTEsIFwid29yZFwiKTtcbiAgICAgIH0sXG4gICAgICBnb0dyb3VwUmlnaHQ6IGZ1bmN0aW9uKGNtKSB7XG4gICAgICAgIHJldHVybiBjbS5tb3ZlSCgxLCBcImdyb3VwXCIpO1xuICAgICAgfSxcbiAgICAgIGdvR3JvdXBMZWZ0OiBmdW5jdGlvbihjbSkge1xuICAgICAgICByZXR1cm4gY20ubW92ZUgoLTEsIFwiZ3JvdXBcIik7XG4gICAgICB9LFxuICAgICAgZ29Xb3JkUmlnaHQ6IGZ1bmN0aW9uKGNtKSB7XG4gICAgICAgIHJldHVybiBjbS5tb3ZlSCgxLCBcIndvcmRcIik7XG4gICAgICB9LFxuICAgICAgZGVsQ2hhckJlZm9yZTogZnVuY3Rpb24oY20pIHtcbiAgICAgICAgcmV0dXJuIGNtLmRlbGV0ZUgoLTEsIFwiY29kZXBvaW50XCIpO1xuICAgICAgfSxcbiAgICAgIGRlbENoYXJBZnRlcjogZnVuY3Rpb24oY20pIHtcbiAgICAgICAgcmV0dXJuIGNtLmRlbGV0ZUgoMSwgXCJjaGFyXCIpO1xuICAgICAgfSxcbiAgICAgIGRlbFdvcmRCZWZvcmU6IGZ1bmN0aW9uKGNtKSB7XG4gICAgICAgIHJldHVybiBjbS5kZWxldGVIKC0xLCBcIndvcmRcIik7XG4gICAgICB9LFxuICAgICAgZGVsV29yZEFmdGVyOiBmdW5jdGlvbihjbSkge1xuICAgICAgICByZXR1cm4gY20uZGVsZXRlSCgxLCBcIndvcmRcIik7XG4gICAgICB9LFxuICAgICAgZGVsR3JvdXBCZWZvcmU6IGZ1bmN0aW9uKGNtKSB7XG4gICAgICAgIHJldHVybiBjbS5kZWxldGVIKC0xLCBcImdyb3VwXCIpO1xuICAgICAgfSxcbiAgICAgIGRlbEdyb3VwQWZ0ZXI6IGZ1bmN0aW9uKGNtKSB7XG4gICAgICAgIHJldHVybiBjbS5kZWxldGVIKDEsIFwiZ3JvdXBcIik7XG4gICAgICB9LFxuICAgICAgaW5kZW50QXV0bzogZnVuY3Rpb24oY20pIHtcbiAgICAgICAgcmV0dXJuIGNtLmluZGVudFNlbGVjdGlvbihcInNtYXJ0XCIpO1xuICAgICAgfSxcbiAgICAgIGluZGVudE1vcmU6IGZ1bmN0aW9uKGNtKSB7XG4gICAgICAgIHJldHVybiBjbS5pbmRlbnRTZWxlY3Rpb24oXCJhZGRcIik7XG4gICAgICB9LFxuICAgICAgaW5kZW50TGVzczogZnVuY3Rpb24oY20pIHtcbiAgICAgICAgcmV0dXJuIGNtLmluZGVudFNlbGVjdGlvbihcInN1YnRyYWN0XCIpO1xuICAgICAgfSxcbiAgICAgIGluc2VydFRhYjogZnVuY3Rpb24oY20pIHtcbiAgICAgICAgcmV0dXJuIGNtLnJlcGxhY2VTZWxlY3Rpb24oXCJcdFwiKTtcbiAgICAgIH0sXG4gICAgICBpbnNlcnRTb2Z0VGFiOiBmdW5jdGlvbihjbSkge1xuICAgICAgICB2YXIgc3BhY2VzID0gW10sIHJhbmdlcyA9IGNtLmxpc3RTZWxlY3Rpb25zKCksIHRhYlNpemUgPSBjbS5vcHRpb25zLnRhYlNpemU7XG4gICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCByYW5nZXMubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgICAgdmFyIHBvcyA9IHJhbmdlc1tpMl0uZnJvbSgpO1xuICAgICAgICAgIHZhciBjb2wgPSBjb3VudENvbHVtbihjbS5nZXRMaW5lKHBvcy5saW5lKSwgcG9zLmNoLCB0YWJTaXplKTtcbiAgICAgICAgICBzcGFjZXMucHVzaChzcGFjZVN0cih0YWJTaXplIC0gY29sICUgdGFiU2l6ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGNtLnJlcGxhY2VTZWxlY3Rpb25zKHNwYWNlcyk7XG4gICAgICB9LFxuICAgICAgZGVmYXVsdFRhYjogZnVuY3Rpb24oY20pIHtcbiAgICAgICAgaWYgKGNtLnNvbWV0aGluZ1NlbGVjdGVkKCkpIHtcbiAgICAgICAgICBjbS5pbmRlbnRTZWxlY3Rpb24oXCJhZGRcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY20uZXhlY0NvbW1hbmQoXCJpbnNlcnRUYWJcIik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0cmFuc3Bvc2VDaGFyczogZnVuY3Rpb24oY20pIHtcbiAgICAgICAgcmV0dXJuIHJ1bkluT3AoY20sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciByYW5nZXMgPSBjbS5saXN0U2VsZWN0aW9ucygpLCBuZXdTZWwgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgcmFuZ2VzLmxlbmd0aDsgaTIrKykge1xuICAgICAgICAgICAgaWYgKCFyYW5nZXNbaTJdLmVtcHR5KCkpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY3VyID0gcmFuZ2VzW2kyXS5oZWFkLCBsaW5lID0gZ2V0TGluZShjbS5kb2MsIGN1ci5saW5lKS50ZXh0O1xuICAgICAgICAgICAgaWYgKGxpbmUpIHtcbiAgICAgICAgICAgICAgaWYgKGN1ci5jaCA9PSBsaW5lLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGN1ciA9IG5ldyBQb3MoY3VyLmxpbmUsIGN1ci5jaCAtIDEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjdXIuY2ggPiAwKSB7XG4gICAgICAgICAgICAgICAgY3VyID0gbmV3IFBvcyhjdXIubGluZSwgY3VyLmNoICsgMSk7XG4gICAgICAgICAgICAgICAgY20ucmVwbGFjZVJhbmdlKGxpbmUuY2hhckF0KGN1ci5jaCAtIDEpICsgbGluZS5jaGFyQXQoY3VyLmNoIC0gMiksIFBvcyhjdXIubGluZSwgY3VyLmNoIC0gMiksIGN1ciwgXCIrdHJhbnNwb3NlXCIpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1ci5saW5lID4gY20uZG9jLmZpcnN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZXYgPSBnZXRMaW5lKGNtLmRvYywgY3VyLmxpbmUgLSAxKS50ZXh0O1xuICAgICAgICAgICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICAgICAgICBjdXIgPSBuZXcgUG9zKGN1ci5saW5lLCAxKTtcbiAgICAgICAgICAgICAgICAgIGNtLnJlcGxhY2VSYW5nZShsaW5lLmNoYXJBdCgwKSArIGNtLmRvYy5saW5lU2VwYXJhdG9yKCkgKyBwcmV2LmNoYXJBdChwcmV2Lmxlbmd0aCAtIDEpLCBQb3MoY3VyLmxpbmUgLSAxLCBwcmV2Lmxlbmd0aCAtIDEpLCBjdXIsIFwiK3RyYW5zcG9zZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld1NlbC5wdXNoKG5ldyBSYW5nZShjdXIsIGN1cikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjbS5zZXRTZWxlY3Rpb25zKG5ld1NlbCk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIG5ld2xpbmVBbmRJbmRlbnQ6IGZ1bmN0aW9uKGNtKSB7XG4gICAgICAgIHJldHVybiBydW5Jbk9wKGNtLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgc2VscyA9IGNtLmxpc3RTZWxlY3Rpb25zKCk7XG4gICAgICAgICAgZm9yICh2YXIgaTIgPSBzZWxzLmxlbmd0aCAtIDE7IGkyID49IDA7IGkyLS0pIHtcbiAgICAgICAgICAgIGNtLnJlcGxhY2VSYW5nZShjbS5kb2MubGluZVNlcGFyYXRvcigpLCBzZWxzW2kyXS5hbmNob3IsIHNlbHNbaTJdLmhlYWQsIFwiK2lucHV0XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxzID0gY20ubGlzdFNlbGVjdGlvbnMoKTtcbiAgICAgICAgICBmb3IgKHZhciBpJDEyID0gMDsgaSQxMiA8IHNlbHMubGVuZ3RoOyBpJDEyKyspIHtcbiAgICAgICAgICAgIGNtLmluZGVudExpbmUoc2Vsc1tpJDEyXS5mcm9tKCkubGluZSwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVuc3VyZUN1cnNvclZpc2libGUoY20pO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBvcGVuTGluZTogZnVuY3Rpb24oY20pIHtcbiAgICAgICAgcmV0dXJuIGNtLnJlcGxhY2VTZWxlY3Rpb24oXCJcXG5cIiwgXCJzdGFydFwiKTtcbiAgICAgIH0sXG4gICAgICB0b2dnbGVPdmVyd3JpdGU6IGZ1bmN0aW9uKGNtKSB7XG4gICAgICAgIHJldHVybiBjbS50b2dnbGVPdmVyd3JpdGUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGxpbmVTdGFydChjbSwgbGluZU4pIHtcbiAgICAgIHZhciBsaW5lID0gZ2V0TGluZShjbS5kb2MsIGxpbmVOKTtcbiAgICAgIHZhciB2aXN1YWwgPSB2aXN1YWxMaW5lKGxpbmUpO1xuICAgICAgaWYgKHZpc3VhbCAhPSBsaW5lKSB7XG4gICAgICAgIGxpbmVOID0gbGluZU5vKHZpc3VhbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW5kT2ZMaW5lKHRydWUsIGNtLCB2aXN1YWwsIGxpbmVOLCAxKTtcbiAgICB9XG4gICAgX19uYW1lKGxpbmVTdGFydCwgXCJsaW5lU3RhcnRcIik7XG4gICAgZnVuY3Rpb24gbGluZUVuZChjbSwgbGluZU4pIHtcbiAgICAgIHZhciBsaW5lID0gZ2V0TGluZShjbS5kb2MsIGxpbmVOKTtcbiAgICAgIHZhciB2aXN1YWwgPSB2aXN1YWxMaW5lRW5kKGxpbmUpO1xuICAgICAgaWYgKHZpc3VhbCAhPSBsaW5lKSB7XG4gICAgICAgIGxpbmVOID0gbGluZU5vKHZpc3VhbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW5kT2ZMaW5lKHRydWUsIGNtLCBsaW5lLCBsaW5lTiwgLTEpO1xuICAgIH1cbiAgICBfX25hbWUobGluZUVuZCwgXCJsaW5lRW5kXCIpO1xuICAgIGZ1bmN0aW9uIGxpbmVTdGFydFNtYXJ0KGNtLCBwb3MpIHtcbiAgICAgIHZhciBzdGFydCA9IGxpbmVTdGFydChjbSwgcG9zLmxpbmUpO1xuICAgICAgdmFyIGxpbmUgPSBnZXRMaW5lKGNtLmRvYywgc3RhcnQubGluZSk7XG4gICAgICB2YXIgb3JkZXIgPSBnZXRPcmRlcihsaW5lLCBjbS5kb2MuZGlyZWN0aW9uKTtcbiAgICAgIGlmICghb3JkZXIgfHwgb3JkZXJbMF0ubGV2ZWwgPT0gMCkge1xuICAgICAgICB2YXIgZmlyc3ROb25XUyA9IE1hdGgubWF4KHN0YXJ0LmNoLCBsaW5lLnRleHQuc2VhcmNoKC9cXFMvKSk7XG4gICAgICAgIHZhciBpbldTID0gcG9zLmxpbmUgPT0gc3RhcnQubGluZSAmJiBwb3MuY2ggPD0gZmlyc3ROb25XUyAmJiBwb3MuY2g7XG4gICAgICAgIHJldHVybiBQb3Moc3RhcnQubGluZSwgaW5XUyA/IDAgOiBmaXJzdE5vbldTLCBzdGFydC5zdGlja3kpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0YXJ0O1xuICAgIH1cbiAgICBfX25hbWUobGluZVN0YXJ0U21hcnQsIFwibGluZVN0YXJ0U21hcnRcIik7XG4gICAgZnVuY3Rpb24gZG9IYW5kbGVCaW5kaW5nKGNtLCBib3VuZCwgZHJvcFNoaWZ0KSB7XG4gICAgICBpZiAodHlwZW9mIGJvdW5kID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgYm91bmQgPSBjb21tYW5kc1tib3VuZF07XG4gICAgICAgIGlmICghYm91bmQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNtLmRpc3BsYXkuaW5wdXQuZW5zdXJlUG9sbGVkKCk7XG4gICAgICB2YXIgcHJldlNoaWZ0ID0gY20uZGlzcGxheS5zaGlmdCwgZG9uZSA9IGZhbHNlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGNtLmlzUmVhZE9ubHkoKSkge1xuICAgICAgICAgIGNtLnN0YXRlLnN1cHByZXNzRWRpdHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkcm9wU2hpZnQpIHtcbiAgICAgICAgICBjbS5kaXNwbGF5LnNoaWZ0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZG9uZSA9IGJvdW5kKGNtKSAhPSBQYXNzO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY20uZGlzcGxheS5zaGlmdCA9IHByZXZTaGlmdDtcbiAgICAgICAgY20uc3RhdGUuc3VwcHJlc3NFZGl0cyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRvbmU7XG4gICAgfVxuICAgIF9fbmFtZShkb0hhbmRsZUJpbmRpbmcsIFwiZG9IYW5kbGVCaW5kaW5nXCIpO1xuICAgIGZ1bmN0aW9uIGxvb2t1cEtleUZvckVkaXRvcihjbSwgbmFtZSwgaGFuZGxlKSB7XG4gICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgY20uc3RhdGUua2V5TWFwcy5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGxvb2t1cEtleShuYW1lLCBjbS5zdGF0ZS5rZXlNYXBzW2kyXSwgaGFuZGxlLCBjbSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY20ub3B0aW9ucy5leHRyYUtleXMgJiYgbG9va3VwS2V5KG5hbWUsIGNtLm9wdGlvbnMuZXh0cmFLZXlzLCBoYW5kbGUsIGNtKSB8fCBsb29rdXBLZXkobmFtZSwgY20ub3B0aW9ucy5rZXlNYXAsIGhhbmRsZSwgY20pO1xuICAgIH1cbiAgICBfX25hbWUobG9va3VwS2V5Rm9yRWRpdG9yLCBcImxvb2t1cEtleUZvckVkaXRvclwiKTtcbiAgICB2YXIgc3RvcFNlcSA9IG5ldyBEZWxheWVkKCk7XG4gICAgZnVuY3Rpb24gZGlzcGF0Y2hLZXkoY20sIG5hbWUsIGUsIGhhbmRsZSkge1xuICAgICAgdmFyIHNlcSA9IGNtLnN0YXRlLmtleVNlcTtcbiAgICAgIGlmIChzZXEpIHtcbiAgICAgICAgaWYgKGlzTW9kaWZpZXJLZXkobmFtZSkpIHtcbiAgICAgICAgICByZXR1cm4gXCJoYW5kbGVkXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKC9cXCckLy50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgY20uc3RhdGUua2V5U2VxID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdG9wU2VxLnNldCg1MCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoY20uc3RhdGUua2V5U2VxID09IHNlcSkge1xuICAgICAgICAgICAgICBjbS5zdGF0ZS5rZXlTZXEgPSBudWxsO1xuICAgICAgICAgICAgICBjbS5kaXNwbGF5LmlucHV0LnJlc2V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpc3BhdGNoS2V5SW5uZXIoY20sIHNlcSArIFwiIFwiICsgbmFtZSwgZSwgaGFuZGxlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGlzcGF0Y2hLZXlJbm5lcihjbSwgbmFtZSwgZSwgaGFuZGxlKTtcbiAgICB9XG4gICAgX19uYW1lKGRpc3BhdGNoS2V5LCBcImRpc3BhdGNoS2V5XCIpO1xuICAgIGZ1bmN0aW9uIGRpc3BhdGNoS2V5SW5uZXIoY20sIG5hbWUsIGUsIGhhbmRsZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IGxvb2t1cEtleUZvckVkaXRvcihjbSwgbmFtZSwgaGFuZGxlKTtcbiAgICAgIGlmIChyZXN1bHQgPT0gXCJtdWx0aVwiKSB7XG4gICAgICAgIGNtLnN0YXRlLmtleVNlcSA9IG5hbWU7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0ID09IFwiaGFuZGxlZFwiKSB7XG4gICAgICAgIHNpZ25hbExhdGVyKGNtLCBcImtleUhhbmRsZWRcIiwgY20sIG5hbWUsIGUpO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdCA9PSBcImhhbmRsZWRcIiB8fCByZXN1bHQgPT0gXCJtdWx0aVwiKSB7XG4gICAgICAgIGVfcHJldmVudERlZmF1bHQoZSk7XG4gICAgICAgIHJlc3RhcnRCbGluayhjbSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gISFyZXN1bHQ7XG4gICAgfVxuICAgIF9fbmFtZShkaXNwYXRjaEtleUlubmVyLCBcImRpc3BhdGNoS2V5SW5uZXJcIik7XG4gICAgZnVuY3Rpb24gaGFuZGxlS2V5QmluZGluZyhjbSwgZSkge1xuICAgICAgdmFyIG5hbWUgPSBrZXlOYW1lKGUsIHRydWUpO1xuICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChlLnNoaWZ0S2V5ICYmICFjbS5zdGF0ZS5rZXlTZXEpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoS2V5KGNtLCBcIlNoaWZ0LVwiICsgbmFtZSwgZSwgZnVuY3Rpb24oYikge1xuICAgICAgICAgIHJldHVybiBkb0hhbmRsZUJpbmRpbmcoY20sIGIsIHRydWUpO1xuICAgICAgICB9KSB8fCBkaXNwYXRjaEtleShjbSwgbmFtZSwgZSwgZnVuY3Rpb24oYikge1xuICAgICAgICAgIGlmICh0eXBlb2YgYiA9PSBcInN0cmluZ1wiID8gL15nb1tBLVpdLy50ZXN0KGIpIDogYi5tb3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBkb0hhbmRsZUJpbmRpbmcoY20sIGIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2hLZXkoY20sIG5hbWUsIGUsIGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgICByZXR1cm4gZG9IYW5kbGVCaW5kaW5nKGNtLCBiKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShoYW5kbGVLZXlCaW5kaW5nLCBcImhhbmRsZUtleUJpbmRpbmdcIik7XG4gICAgZnVuY3Rpb24gaGFuZGxlQ2hhckJpbmRpbmcoY20sIGUsIGNoKSB7XG4gICAgICByZXR1cm4gZGlzcGF0Y2hLZXkoY20sIFwiJ1wiICsgY2ggKyBcIidcIiwgZSwgZnVuY3Rpb24oYikge1xuICAgICAgICByZXR1cm4gZG9IYW5kbGVCaW5kaW5nKGNtLCBiLCB0cnVlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBfX25hbWUoaGFuZGxlQ2hhckJpbmRpbmcsIFwiaGFuZGxlQ2hhckJpbmRpbmdcIik7XG4gICAgdmFyIGxhc3RTdG9wcGVkS2V5ID0gbnVsbDtcbiAgICBmdW5jdGlvbiBvbktleURvd24oZSkge1xuICAgICAgdmFyIGNtID0gdGhpcztcbiAgICAgIGlmIChlLnRhcmdldCAmJiBlLnRhcmdldCAhPSBjbS5kaXNwbGF5LmlucHV0LmdldEZpZWxkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY20uY3VyT3AuZm9jdXMgPSBhY3RpdmVFbHQoKTtcbiAgICAgIGlmIChzaWduYWxET01FdmVudChjbSwgZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCAxMSAmJiBlLmtleUNvZGUgPT0gMjcpIHtcbiAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGNvZGUgPSBlLmtleUNvZGU7XG4gICAgICBjbS5kaXNwbGF5LnNoaWZ0ID0gY29kZSA9PSAxNiB8fCBlLnNoaWZ0S2V5O1xuICAgICAgdmFyIGhhbmRsZWQgPSBoYW5kbGVLZXlCaW5kaW5nKGNtLCBlKTtcbiAgICAgIGlmIChwcmVzdG8pIHtcbiAgICAgICAgbGFzdFN0b3BwZWRLZXkgPSBoYW5kbGVkID8gY29kZSA6IG51bGw7XG4gICAgICAgIGlmICghaGFuZGxlZCAmJiBjb2RlID09IDg4ICYmICFoYXNDb3B5RXZlbnQgJiYgKG1hYyA/IGUubWV0YUtleSA6IGUuY3RybEtleSkpIHtcbiAgICAgICAgICBjbS5yZXBsYWNlU2VsZWN0aW9uKFwiXCIsIG51bGwsIFwiY3V0XCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZ2Vja28gJiYgIW1hYyAmJiAhaGFuZGxlZCAmJiBjb2RlID09IDQ2ICYmIGUuc2hpZnRLZXkgJiYgIWUuY3RybEtleSAmJiBkb2N1bWVudC5leGVjQ29tbWFuZCkge1xuICAgICAgICBkb2N1bWVudC5leGVjQ29tbWFuZChcImN1dFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb2RlID09IDE4ICYmICEvXFxiQ29kZU1pcnJvci1jcm9zc2hhaXJcXGIvLnRlc3QoY20uZGlzcGxheS5saW5lRGl2LmNsYXNzTmFtZSkpIHtcbiAgICAgICAgc2hvd0Nyb3NzSGFpcihjbSk7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShvbktleURvd24sIFwib25LZXlEb3duXCIpO1xuICAgIGZ1bmN0aW9uIHNob3dDcm9zc0hhaXIoY20pIHtcbiAgICAgIHZhciBsaW5lRGl2ID0gY20uZGlzcGxheS5saW5lRGl2O1xuICAgICAgYWRkQ2xhc3MobGluZURpdiwgXCJDb2RlTWlycm9yLWNyb3NzaGFpclwiKTtcbiAgICAgIGZ1bmN0aW9uIHVwKGUpIHtcbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PSAxOCB8fCAhZS5hbHRLZXkpIHtcbiAgICAgICAgICBybUNsYXNzKGxpbmVEaXYsIFwiQ29kZU1pcnJvci1jcm9zc2hhaXJcIik7XG4gICAgICAgICAgb2ZmKGRvY3VtZW50LCBcImtleXVwXCIsIHVwKTtcbiAgICAgICAgICBvZmYoZG9jdW1lbnQsIFwibW91c2VvdmVyXCIsIHVwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX19uYW1lKHVwLCBcInVwXCIpO1xuICAgICAgb24oZG9jdW1lbnQsIFwia2V5dXBcIiwgdXApO1xuICAgICAgb24oZG9jdW1lbnQsIFwibW91c2VvdmVyXCIsIHVwKTtcbiAgICB9XG4gICAgX19uYW1lKHNob3dDcm9zc0hhaXIsIFwic2hvd0Nyb3NzSGFpclwiKTtcbiAgICBmdW5jdGlvbiBvbktleVVwKGUpIHtcbiAgICAgIGlmIChlLmtleUNvZGUgPT0gMTYpIHtcbiAgICAgICAgdGhpcy5kb2Muc2VsLnNoaWZ0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBzaWduYWxET01FdmVudCh0aGlzLCBlKTtcbiAgICB9XG4gICAgX19uYW1lKG9uS2V5VXAsIFwib25LZXlVcFwiKTtcbiAgICBmdW5jdGlvbiBvbktleVByZXNzKGUpIHtcbiAgICAgIHZhciBjbSA9IHRoaXM7XG4gICAgICBpZiAoZS50YXJnZXQgJiYgZS50YXJnZXQgIT0gY20uZGlzcGxheS5pbnB1dC5nZXRGaWVsZCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudEluV2lkZ2V0KGNtLmRpc3BsYXksIGUpIHx8IHNpZ25hbERPTUV2ZW50KGNtLCBlKSB8fCBlLmN0cmxLZXkgJiYgIWUuYWx0S2V5IHx8IG1hYyAmJiBlLm1ldGFLZXkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGtleUNvZGUgPSBlLmtleUNvZGUsIGNoYXJDb2RlID0gZS5jaGFyQ29kZTtcbiAgICAgIGlmIChwcmVzdG8gJiYga2V5Q29kZSA9PSBsYXN0U3RvcHBlZEtleSkge1xuICAgICAgICBsYXN0U3RvcHBlZEtleSA9IG51bGw7XG4gICAgICAgIGVfcHJldmVudERlZmF1bHQoZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChwcmVzdG8gJiYgKCFlLndoaWNoIHx8IGUud2hpY2ggPCAxMCkgJiYgaGFuZGxlS2V5QmluZGluZyhjbSwgZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSA9PSBudWxsID8ga2V5Q29kZSA6IGNoYXJDb2RlKTtcbiAgICAgIGlmIChjaCA9PSBcIlxcYlwiKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChoYW5kbGVDaGFyQmluZGluZyhjbSwgZSwgY2gpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNtLmRpc3BsYXkuaW5wdXQub25LZXlQcmVzcyhlKTtcbiAgICB9XG4gICAgX19uYW1lKG9uS2V5UHJlc3MsIFwib25LZXlQcmVzc1wiKTtcbiAgICB2YXIgRE9VQkxFQ0xJQ0tfREVMQVkgPSA0MDA7XG4gICAgdmFyIFBhc3RDbGljayA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24odGltZSwgcG9zLCBidXR0b24pIHtcbiAgICAgIHRoaXMudGltZSA9IHRpbWU7XG4gICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgIHRoaXMuYnV0dG9uID0gYnV0dG9uO1xuICAgIH0sIFwiUGFzdENsaWNrXCIpO1xuICAgIFBhc3RDbGljay5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uKHRpbWUsIHBvcywgYnV0dG9uKSB7XG4gICAgICByZXR1cm4gdGhpcy50aW1lICsgRE9VQkxFQ0xJQ0tfREVMQVkgPiB0aW1lICYmIGNtcChwb3MsIHRoaXMucG9zKSA9PSAwICYmIGJ1dHRvbiA9PSB0aGlzLmJ1dHRvbjtcbiAgICB9O1xuICAgIHZhciBsYXN0Q2xpY2ssIGxhc3REb3VibGVDbGljaztcbiAgICBmdW5jdGlvbiBjbGlja1JlcGVhdChwb3MsIGJ1dHRvbikge1xuICAgICAgdmFyIG5vdyA9ICtuZXcgRGF0ZSgpO1xuICAgICAgaWYgKGxhc3REb3VibGVDbGljayAmJiBsYXN0RG91YmxlQ2xpY2suY29tcGFyZShub3csIHBvcywgYnV0dG9uKSkge1xuICAgICAgICBsYXN0Q2xpY2sgPSBsYXN0RG91YmxlQ2xpY2sgPSBudWxsO1xuICAgICAgICByZXR1cm4gXCJ0cmlwbGVcIjtcbiAgICAgIH0gZWxzZSBpZiAobGFzdENsaWNrICYmIGxhc3RDbGljay5jb21wYXJlKG5vdywgcG9zLCBidXR0b24pKSB7XG4gICAgICAgIGxhc3REb3VibGVDbGljayA9IG5ldyBQYXN0Q2xpY2sobm93LCBwb3MsIGJ1dHRvbik7XG4gICAgICAgIGxhc3RDbGljayA9IG51bGw7XG4gICAgICAgIHJldHVybiBcImRvdWJsZVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFzdENsaWNrID0gbmV3IFBhc3RDbGljayhub3csIHBvcywgYnV0dG9uKTtcbiAgICAgICAgbGFzdERvdWJsZUNsaWNrID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIFwic2luZ2xlXCI7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShjbGlja1JlcGVhdCwgXCJjbGlja1JlcGVhdFwiKTtcbiAgICBmdW5jdGlvbiBvbk1vdXNlRG93bihlKSB7XG4gICAgICB2YXIgY20gPSB0aGlzLCBkaXNwbGF5ID0gY20uZGlzcGxheTtcbiAgICAgIGlmIChzaWduYWxET01FdmVudChjbSwgZSkgfHwgZGlzcGxheS5hY3RpdmVUb3VjaCAmJiBkaXNwbGF5LmlucHV0LnN1cHBvcnRzVG91Y2goKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkaXNwbGF5LmlucHV0LmVuc3VyZVBvbGxlZCgpO1xuICAgICAgZGlzcGxheS5zaGlmdCA9IGUuc2hpZnRLZXk7XG4gICAgICBpZiAoZXZlbnRJbldpZGdldChkaXNwbGF5LCBlKSkge1xuICAgICAgICBpZiAoIXdlYmtpdCkge1xuICAgICAgICAgIGRpc3BsYXkuc2Nyb2xsZXIuZHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBkaXNwbGF5LnNjcm9sbGVyLmRyYWdnYWJsZSA9IHRydWU7XG4gICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoY2xpY2tJbkd1dHRlcihjbSwgZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHBvcyA9IHBvc0Zyb21Nb3VzZShjbSwgZSksIGJ1dHRvbiA9IGVfYnV0dG9uKGUpLCByZXBlYXQgPSBwb3MgPyBjbGlja1JlcGVhdChwb3MsIGJ1dHRvbikgOiBcInNpbmdsZVwiO1xuICAgICAgd2luZG93LmZvY3VzKCk7XG4gICAgICBpZiAoYnV0dG9uID09IDEgJiYgY20uc3RhdGUuc2VsZWN0aW5nVGV4dCkge1xuICAgICAgICBjbS5zdGF0ZS5zZWxlY3RpbmdUZXh0KGUpO1xuICAgICAgfVxuICAgICAgaWYgKHBvcyAmJiBoYW5kbGVNYXBwZWRCdXR0b24oY20sIGJ1dHRvbiwgcG9zLCByZXBlYXQsIGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChidXR0b24gPT0gMSkge1xuICAgICAgICBpZiAocG9zKSB7XG4gICAgICAgICAgbGVmdEJ1dHRvbkRvd24oY20sIHBvcywgcmVwZWF0LCBlKTtcbiAgICAgICAgfSBlbHNlIGlmIChlX3RhcmdldChlKSA9PSBkaXNwbGF5LnNjcm9sbGVyKSB7XG4gICAgICAgICAgZV9wcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChidXR0b24gPT0gMikge1xuICAgICAgICBpZiAocG9zKSB7XG4gICAgICAgICAgZXh0ZW5kU2VsZWN0aW9uKGNtLmRvYywgcG9zKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBkaXNwbGF5LmlucHV0LmZvY3VzKCk7XG4gICAgICAgIH0sIDIwKTtcbiAgICAgIH0gZWxzZSBpZiAoYnV0dG9uID09IDMpIHtcbiAgICAgICAgaWYgKGNhcHR1cmVSaWdodENsaWNrKSB7XG4gICAgICAgICAgY20uZGlzcGxheS5pbnB1dC5vbkNvbnRleHRNZW51KGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGF5Qmx1ckV2ZW50KGNtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUob25Nb3VzZURvd24sIFwib25Nb3VzZURvd25cIik7XG4gICAgZnVuY3Rpb24gaGFuZGxlTWFwcGVkQnV0dG9uKGNtLCBidXR0b24sIHBvcywgcmVwZWF0LCBldmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBcIkNsaWNrXCI7XG4gICAgICBpZiAocmVwZWF0ID09IFwiZG91YmxlXCIpIHtcbiAgICAgICAgbmFtZSA9IFwiRG91YmxlXCIgKyBuYW1lO1xuICAgICAgfSBlbHNlIGlmIChyZXBlYXQgPT0gXCJ0cmlwbGVcIikge1xuICAgICAgICBuYW1lID0gXCJUcmlwbGVcIiArIG5hbWU7XG4gICAgICB9XG4gICAgICBuYW1lID0gKGJ1dHRvbiA9PSAxID8gXCJMZWZ0XCIgOiBidXR0b24gPT0gMiA/IFwiTWlkZGxlXCIgOiBcIlJpZ2h0XCIpICsgbmFtZTtcbiAgICAgIHJldHVybiBkaXNwYXRjaEtleShjbSwgYWRkTW9kaWZpZXJOYW1lcyhuYW1lLCBldmVudCksIGV2ZW50LCBmdW5jdGlvbihib3VuZCkge1xuICAgICAgICBpZiAodHlwZW9mIGJvdW5kID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBib3VuZCA9IGNvbW1hbmRzW2JvdW5kXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWJvdW5kKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKGNtLmlzUmVhZE9ubHkoKSkge1xuICAgICAgICAgICAgY20uc3RhdGUuc3VwcHJlc3NFZGl0cyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRvbmUgPSBib3VuZChjbSwgcG9zKSAhPSBQYXNzO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGNtLnN0YXRlLnN1cHByZXNzRWRpdHMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9uZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBfX25hbWUoaGFuZGxlTWFwcGVkQnV0dG9uLCBcImhhbmRsZU1hcHBlZEJ1dHRvblwiKTtcbiAgICBmdW5jdGlvbiBjb25maWd1cmVNb3VzZShjbSwgcmVwZWF0LCBldmVudCkge1xuICAgICAgdmFyIG9wdGlvbiA9IGNtLmdldE9wdGlvbihcImNvbmZpZ3VyZU1vdXNlXCIpO1xuICAgICAgdmFyIHZhbHVlID0gb3B0aW9uID8gb3B0aW9uKGNtLCByZXBlYXQsIGV2ZW50KSA6IHt9O1xuICAgICAgaWYgKHZhbHVlLnVuaXQgPT0gbnVsbCkge1xuICAgICAgICB2YXIgcmVjdCA9IGNocm9tZU9TID8gZXZlbnQuc2hpZnRLZXkgJiYgZXZlbnQubWV0YUtleSA6IGV2ZW50LmFsdEtleTtcbiAgICAgICAgdmFsdWUudW5pdCA9IHJlY3QgPyBcInJlY3RhbmdsZVwiIDogcmVwZWF0ID09IFwic2luZ2xlXCIgPyBcImNoYXJcIiA6IHJlcGVhdCA9PSBcImRvdWJsZVwiID8gXCJ3b3JkXCIgOiBcImxpbmVcIjtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZS5leHRlbmQgPT0gbnVsbCB8fCBjbS5kb2MuZXh0ZW5kKSB7XG4gICAgICAgIHZhbHVlLmV4dGVuZCA9IGNtLmRvYy5leHRlbmQgfHwgZXZlbnQuc2hpZnRLZXk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUuYWRkTmV3ID09IG51bGwpIHtcbiAgICAgICAgdmFsdWUuYWRkTmV3ID0gbWFjID8gZXZlbnQubWV0YUtleSA6IGV2ZW50LmN0cmxLZXk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUubW92ZU9uRHJhZyA9PSBudWxsKSB7XG4gICAgICAgIHZhbHVlLm1vdmVPbkRyYWcgPSAhKG1hYyA/IGV2ZW50LmFsdEtleSA6IGV2ZW50LmN0cmxLZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBfX25hbWUoY29uZmlndXJlTW91c2UsIFwiY29uZmlndXJlTW91c2VcIik7XG4gICAgZnVuY3Rpb24gbGVmdEJ1dHRvbkRvd24oY20sIHBvcywgcmVwZWF0LCBldmVudCkge1xuICAgICAgaWYgKGllKSB7XG4gICAgICAgIHNldFRpbWVvdXQoYmluZChlbnN1cmVGb2N1cywgY20pLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNtLmN1ck9wLmZvY3VzID0gYWN0aXZlRWx0KCk7XG4gICAgICB9XG4gICAgICB2YXIgYmVoYXZpb3IgPSBjb25maWd1cmVNb3VzZShjbSwgcmVwZWF0LCBldmVudCk7XG4gICAgICB2YXIgc2VsID0gY20uZG9jLnNlbCwgY29udGFpbmVkO1xuICAgICAgaWYgKGNtLm9wdGlvbnMuZHJhZ0Ryb3AgJiYgZHJhZ0FuZERyb3AgJiYgIWNtLmlzUmVhZE9ubHkoKSAmJiByZXBlYXQgPT0gXCJzaW5nbGVcIiAmJiAoY29udGFpbmVkID0gc2VsLmNvbnRhaW5zKHBvcykpID4gLTEgJiYgKGNtcCgoY29udGFpbmVkID0gc2VsLnJhbmdlc1tjb250YWluZWRdKS5mcm9tKCksIHBvcykgPCAwIHx8IHBvcy54UmVsID4gMCkgJiYgKGNtcChjb250YWluZWQudG8oKSwgcG9zKSA+IDAgfHwgcG9zLnhSZWwgPCAwKSkge1xuICAgICAgICBsZWZ0QnV0dG9uU3RhcnREcmFnKGNtLCBldmVudCwgcG9zLCBiZWhhdmlvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWZ0QnV0dG9uU2VsZWN0KGNtLCBldmVudCwgcG9zLCBiZWhhdmlvcik7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShsZWZ0QnV0dG9uRG93biwgXCJsZWZ0QnV0dG9uRG93blwiKTtcbiAgICBmdW5jdGlvbiBsZWZ0QnV0dG9uU3RhcnREcmFnKGNtLCBldmVudCwgcG9zLCBiZWhhdmlvcikge1xuICAgICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBtb3ZlZCA9IGZhbHNlO1xuICAgICAgdmFyIGRyYWdFbmQgPSBvcGVyYXRpb24oY20sIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKHdlYmtpdCkge1xuICAgICAgICAgIGRpc3BsYXkuc2Nyb2xsZXIuZHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY20uc3RhdGUuZHJhZ2dpbmdUZXh0ID0gZmFsc2U7XG4gICAgICAgIGlmIChjbS5zdGF0ZS5kZWxheWluZ0JsdXJFdmVudCkge1xuICAgICAgICAgIGlmIChjbS5oYXNGb2N1cygpKSB7XG4gICAgICAgICAgICBjbS5zdGF0ZS5kZWxheWluZ0JsdXJFdmVudCA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxheUJsdXJFdmVudChjbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9mZihkaXNwbGF5LndyYXBwZXIub3duZXJEb2N1bWVudCwgXCJtb3VzZXVwXCIsIGRyYWdFbmQpO1xuICAgICAgICBvZmYoZGlzcGxheS53cmFwcGVyLm93bmVyRG9jdW1lbnQsIFwibW91c2Vtb3ZlXCIsIG1vdXNlTW92ZSk7XG4gICAgICAgIG9mZihkaXNwbGF5LnNjcm9sbGVyLCBcImRyYWdzdGFydFwiLCBkcmFnU3RhcnQpO1xuICAgICAgICBvZmYoZGlzcGxheS5zY3JvbGxlciwgXCJkcm9wXCIsIGRyYWdFbmQpO1xuICAgICAgICBpZiAoIW1vdmVkKSB7XG4gICAgICAgICAgZV9wcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgICBpZiAoIWJlaGF2aW9yLmFkZE5ldykge1xuICAgICAgICAgICAgZXh0ZW5kU2VsZWN0aW9uKGNtLmRvYywgcG9zLCBudWxsLCBudWxsLCBiZWhhdmlvci5leHRlbmQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAod2Via2l0ICYmICFzYWZhcmkgfHwgaWUgJiYgaWVfdmVyc2lvbiA9PSA5KSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBkaXNwbGF5LndyYXBwZXIub3duZXJEb2N1bWVudC5ib2R5LmZvY3VzKHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgZGlzcGxheS5pbnB1dC5mb2N1cygpO1xuICAgICAgICAgICAgfSwgMjApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaXNwbGF5LmlucHV0LmZvY3VzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHZhciBtb3VzZU1vdmUgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgIG1vdmVkID0gbW92ZWQgfHwgTWF0aC5hYnMoZXZlbnQuY2xpZW50WCAtIGUyLmNsaWVudFgpICsgTWF0aC5hYnMoZXZlbnQuY2xpZW50WSAtIGUyLmNsaWVudFkpID49IDEwO1xuICAgICAgfSwgXCJtb3VzZU1vdmVcIik7XG4gICAgICB2YXIgZHJhZ1N0YXJ0ID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG1vdmVkID0gdHJ1ZTtcbiAgICAgIH0sIFwiZHJhZ1N0YXJ0XCIpO1xuICAgICAgaWYgKHdlYmtpdCkge1xuICAgICAgICBkaXNwbGF5LnNjcm9sbGVyLmRyYWdnYWJsZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBjbS5zdGF0ZS5kcmFnZ2luZ1RleHQgPSBkcmFnRW5kO1xuICAgICAgZHJhZ0VuZC5jb3B5ID0gIWJlaGF2aW9yLm1vdmVPbkRyYWc7XG4gICAgICBvbihkaXNwbGF5LndyYXBwZXIub3duZXJEb2N1bWVudCwgXCJtb3VzZXVwXCIsIGRyYWdFbmQpO1xuICAgICAgb24oZGlzcGxheS53cmFwcGVyLm93bmVyRG9jdW1lbnQsIFwibW91c2Vtb3ZlXCIsIG1vdXNlTW92ZSk7XG4gICAgICBvbihkaXNwbGF5LnNjcm9sbGVyLCBcImRyYWdzdGFydFwiLCBkcmFnU3RhcnQpO1xuICAgICAgb24oZGlzcGxheS5zY3JvbGxlciwgXCJkcm9wXCIsIGRyYWdFbmQpO1xuICAgICAgY20uc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQgPSB0cnVlO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BsYXkuaW5wdXQuZm9jdXMoKTtcbiAgICAgIH0sIDIwKTtcbiAgICAgIGlmIChkaXNwbGF5LnNjcm9sbGVyLmRyYWdEcm9wKSB7XG4gICAgICAgIGRpc3BsYXkuc2Nyb2xsZXIuZHJhZ0Ryb3AoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKGxlZnRCdXR0b25TdGFydERyYWcsIFwibGVmdEJ1dHRvblN0YXJ0RHJhZ1wiKTtcbiAgICBmdW5jdGlvbiByYW5nZUZvclVuaXQoY20sIHBvcywgdW5pdCkge1xuICAgICAgaWYgKHVuaXQgPT0gXCJjaGFyXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShwb3MsIHBvcyk7XG4gICAgICB9XG4gICAgICBpZiAodW5pdCA9PSBcIndvcmRcIikge1xuICAgICAgICByZXR1cm4gY20uZmluZFdvcmRBdChwb3MpO1xuICAgICAgfVxuICAgICAgaWYgKHVuaXQgPT0gXCJsaW5lXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShQb3MocG9zLmxpbmUsIDApLCBjbGlwUG9zKGNtLmRvYywgUG9zKHBvcy5saW5lICsgMSwgMCkpKTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSB1bml0KGNtLCBwb3MpO1xuICAgICAgcmV0dXJuIG5ldyBSYW5nZShyZXN1bHQuZnJvbSwgcmVzdWx0LnRvKTtcbiAgICB9XG4gICAgX19uYW1lKHJhbmdlRm9yVW5pdCwgXCJyYW5nZUZvclVuaXRcIik7XG4gICAgZnVuY3Rpb24gbGVmdEJ1dHRvblNlbGVjdChjbSwgZXZlbnQsIHN0YXJ0LCBiZWhhdmlvcikge1xuICAgICAgaWYgKGllKSB7XG4gICAgICAgIGRlbGF5Qmx1ckV2ZW50KGNtKTtcbiAgICAgIH1cbiAgICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgZG9jID0gY20uZG9jO1xuICAgICAgZV9wcmV2ZW50RGVmYXVsdChldmVudCk7XG4gICAgICB2YXIgb3VyUmFuZ2UsIG91ckluZGV4LCBzdGFydFNlbCA9IGRvYy5zZWwsIHJhbmdlcyA9IHN0YXJ0U2VsLnJhbmdlcztcbiAgICAgIGlmIChiZWhhdmlvci5hZGROZXcgJiYgIWJlaGF2aW9yLmV4dGVuZCkge1xuICAgICAgICBvdXJJbmRleCA9IGRvYy5zZWwuY29udGFpbnMoc3RhcnQpO1xuICAgICAgICBpZiAob3VySW5kZXggPiAtMSkge1xuICAgICAgICAgIG91clJhbmdlID0gcmFuZ2VzW291ckluZGV4XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXJSYW5nZSA9IG5ldyBSYW5nZShzdGFydCwgc3RhcnQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXJSYW5nZSA9IGRvYy5zZWwucHJpbWFyeSgpO1xuICAgICAgICBvdXJJbmRleCA9IGRvYy5zZWwucHJpbUluZGV4O1xuICAgICAgfVxuICAgICAgaWYgKGJlaGF2aW9yLnVuaXQgPT0gXCJyZWN0YW5nbGVcIikge1xuICAgICAgICBpZiAoIWJlaGF2aW9yLmFkZE5ldykge1xuICAgICAgICAgIG91clJhbmdlID0gbmV3IFJhbmdlKHN0YXJ0LCBzdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhcnQgPSBwb3NGcm9tTW91c2UoY20sIGV2ZW50LCB0cnVlLCB0cnVlKTtcbiAgICAgICAgb3VySW5kZXggPSAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByYW5nZTIgPSByYW5nZUZvclVuaXQoY20sIHN0YXJ0LCBiZWhhdmlvci51bml0KTtcbiAgICAgICAgaWYgKGJlaGF2aW9yLmV4dGVuZCkge1xuICAgICAgICAgIG91clJhbmdlID0gZXh0ZW5kUmFuZ2Uob3VyUmFuZ2UsIHJhbmdlMi5hbmNob3IsIHJhbmdlMi5oZWFkLCBiZWhhdmlvci5leHRlbmQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91clJhbmdlID0gcmFuZ2UyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWJlaGF2aW9yLmFkZE5ldykge1xuICAgICAgICBvdXJJbmRleCA9IDA7XG4gICAgICAgIHNldFNlbGVjdGlvbihkb2MsIG5ldyBTZWxlY3Rpb24oW291clJhbmdlXSwgMCksIHNlbF9tb3VzZSk7XG4gICAgICAgIHN0YXJ0U2VsID0gZG9jLnNlbDtcbiAgICAgIH0gZWxzZSBpZiAob3VySW5kZXggPT0gLTEpIHtcbiAgICAgICAgb3VySW5kZXggPSByYW5nZXMubGVuZ3RoO1xuICAgICAgICBzZXRTZWxlY3Rpb24oZG9jLCBub3JtYWxpemVTZWxlY3Rpb24oY20sIHJhbmdlcy5jb25jYXQoW291clJhbmdlXSksIG91ckluZGV4KSwgeyBzY3JvbGw6IGZhbHNlLCBvcmlnaW46IFwiKm1vdXNlXCIgfSk7XG4gICAgICB9IGVsc2UgaWYgKHJhbmdlcy5sZW5ndGggPiAxICYmIHJhbmdlc1tvdXJJbmRleF0uZW1wdHkoKSAmJiBiZWhhdmlvci51bml0ID09IFwiY2hhclwiICYmICFiZWhhdmlvci5leHRlbmQpIHtcbiAgICAgICAgc2V0U2VsZWN0aW9uKGRvYywgbm9ybWFsaXplU2VsZWN0aW9uKGNtLCByYW5nZXMuc2xpY2UoMCwgb3VySW5kZXgpLmNvbmNhdChyYW5nZXMuc2xpY2Uob3VySW5kZXggKyAxKSksIDApLCB7IHNjcm9sbDogZmFsc2UsIG9yaWdpbjogXCIqbW91c2VcIiB9KTtcbiAgICAgICAgc3RhcnRTZWwgPSBkb2Muc2VsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVwbGFjZU9uZVNlbGVjdGlvbihkb2MsIG91ckluZGV4LCBvdXJSYW5nZSwgc2VsX21vdXNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBsYXN0UG9zID0gc3RhcnQ7XG4gICAgICBmdW5jdGlvbiBleHRlbmRUbyhwb3MpIHtcbiAgICAgICAgaWYgKGNtcChsYXN0UG9zLCBwb3MpID09IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFBvcyA9IHBvcztcbiAgICAgICAgaWYgKGJlaGF2aW9yLnVuaXQgPT0gXCJyZWN0YW5nbGVcIikge1xuICAgICAgICAgIHZhciByYW5nZXMyID0gW10sIHRhYlNpemUgPSBjbS5vcHRpb25zLnRhYlNpemU7XG4gICAgICAgICAgdmFyIHN0YXJ0Q29sID0gY291bnRDb2x1bW4oZ2V0TGluZShkb2MsIHN0YXJ0LmxpbmUpLnRleHQsIHN0YXJ0LmNoLCB0YWJTaXplKTtcbiAgICAgICAgICB2YXIgcG9zQ29sID0gY291bnRDb2x1bW4oZ2V0TGluZShkb2MsIHBvcy5saW5lKS50ZXh0LCBwb3MuY2gsIHRhYlNpemUpO1xuICAgICAgICAgIHZhciBsZWZ0ID0gTWF0aC5taW4oc3RhcnRDb2wsIHBvc0NvbCksIHJpZ2h0ID0gTWF0aC5tYXgoc3RhcnRDb2wsIHBvc0NvbCk7XG4gICAgICAgICAgZm9yICh2YXIgbGluZSA9IE1hdGgubWluKHN0YXJ0LmxpbmUsIHBvcy5saW5lKSwgZW5kID0gTWF0aC5taW4oY20ubGFzdExpbmUoKSwgTWF0aC5tYXgoc3RhcnQubGluZSwgcG9zLmxpbmUpKTsgbGluZSA8PSBlbmQ7IGxpbmUrKykge1xuICAgICAgICAgICAgdmFyIHRleHQgPSBnZXRMaW5lKGRvYywgbGluZSkudGV4dCwgbGVmdFBvcyA9IGZpbmRDb2x1bW4odGV4dCwgbGVmdCwgdGFiU2l6ZSk7XG4gICAgICAgICAgICBpZiAobGVmdCA9PSByaWdodCkge1xuICAgICAgICAgICAgICByYW5nZXMyLnB1c2gobmV3IFJhbmdlKFBvcyhsaW5lLCBsZWZ0UG9zKSwgUG9zKGxpbmUsIGxlZnRQb3MpKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRleHQubGVuZ3RoID4gbGVmdFBvcykge1xuICAgICAgICAgICAgICByYW5nZXMyLnB1c2gobmV3IFJhbmdlKFBvcyhsaW5lLCBsZWZ0UG9zKSwgUG9zKGxpbmUsIGZpbmRDb2x1bW4odGV4dCwgcmlnaHQsIHRhYlNpemUpKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXJhbmdlczIubGVuZ3RoKSB7XG4gICAgICAgICAgICByYW5nZXMyLnB1c2gobmV3IFJhbmdlKHN0YXJ0LCBzdGFydCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZXRTZWxlY3Rpb24oZG9jLCBub3JtYWxpemVTZWxlY3Rpb24oY20sIHN0YXJ0U2VsLnJhbmdlcy5zbGljZSgwLCBvdXJJbmRleCkuY29uY2F0KHJhbmdlczIpLCBvdXJJbmRleCksIHsgb3JpZ2luOiBcIiptb3VzZVwiLCBzY3JvbGw6IGZhbHNlIH0pO1xuICAgICAgICAgIGNtLnNjcm9sbEludG9WaWV3KHBvcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG9sZFJhbmdlID0gb3VyUmFuZ2U7XG4gICAgICAgICAgdmFyIHJhbmdlMyA9IHJhbmdlRm9yVW5pdChjbSwgcG9zLCBiZWhhdmlvci51bml0KTtcbiAgICAgICAgICB2YXIgYW5jaG9yID0gb2xkUmFuZ2UuYW5jaG9yLCBoZWFkO1xuICAgICAgICAgIGlmIChjbXAocmFuZ2UzLmFuY2hvciwgYW5jaG9yKSA+IDApIHtcbiAgICAgICAgICAgIGhlYWQgPSByYW5nZTMuaGVhZDtcbiAgICAgICAgICAgIGFuY2hvciA9IG1pblBvcyhvbGRSYW5nZS5mcm9tKCksIHJhbmdlMy5hbmNob3IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoZWFkID0gcmFuZ2UzLmFuY2hvcjtcbiAgICAgICAgICAgIGFuY2hvciA9IG1heFBvcyhvbGRSYW5nZS50bygpLCByYW5nZTMuaGVhZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByYW5nZXMkMSA9IHN0YXJ0U2VsLnJhbmdlcy5zbGljZSgwKTtcbiAgICAgICAgICByYW5nZXMkMVtvdXJJbmRleF0gPSBiaWRpU2ltcGxpZnkoY20sIG5ldyBSYW5nZShjbGlwUG9zKGRvYywgYW5jaG9yKSwgaGVhZCkpO1xuICAgICAgICAgIHNldFNlbGVjdGlvbihkb2MsIG5vcm1hbGl6ZVNlbGVjdGlvbihjbSwgcmFuZ2VzJDEsIG91ckluZGV4KSwgc2VsX21vdXNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX19uYW1lKGV4dGVuZFRvLCBcImV4dGVuZFRvXCIpO1xuICAgICAgdmFyIGVkaXRvclNpemUgPSBkaXNwbGF5LndyYXBwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgY291bnRlciA9IDA7XG4gICAgICBmdW5jdGlvbiBleHRlbmQoZSkge1xuICAgICAgICB2YXIgY3VyQ291bnQgPSArK2NvdW50ZXI7XG4gICAgICAgIHZhciBjdXIgPSBwb3NGcm9tTW91c2UoY20sIGUsIHRydWUsIGJlaGF2aW9yLnVuaXQgPT0gXCJyZWN0YW5nbGVcIik7XG4gICAgICAgIGlmICghY3VyKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbXAoY3VyLCBsYXN0UG9zKSAhPSAwKSB7XG4gICAgICAgICAgY20uY3VyT3AuZm9jdXMgPSBhY3RpdmVFbHQoKTtcbiAgICAgICAgICBleHRlbmRUbyhjdXIpO1xuICAgICAgICAgIHZhciB2aXNpYmxlID0gdmlzaWJsZUxpbmVzKGRpc3BsYXksIGRvYyk7XG4gICAgICAgICAgaWYgKGN1ci5saW5lID49IHZpc2libGUudG8gfHwgY3VyLmxpbmUgPCB2aXNpYmxlLmZyb20pIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQob3BlcmF0aW9uKGNtLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgaWYgKGNvdW50ZXIgPT0gY3VyQ291bnQpIHtcbiAgICAgICAgICAgICAgICBleHRlbmQoZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLCAxNTApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgb3V0c2lkZSA9IGUuY2xpZW50WSA8IGVkaXRvclNpemUudG9wID8gLTIwIDogZS5jbGllbnRZID4gZWRpdG9yU2l6ZS5ib3R0b20gPyAyMCA6IDA7XG4gICAgICAgICAgaWYgKG91dHNpZGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQob3BlcmF0aW9uKGNtLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgaWYgKGNvdW50ZXIgIT0gY3VyQ291bnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3AgKz0gb3V0c2lkZTtcbiAgICAgICAgICAgICAgZXh0ZW5kKGUpO1xuICAgICAgICAgICAgfSksIDUwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF9fbmFtZShleHRlbmQsIFwiZXh0ZW5kXCIpO1xuICAgICAgZnVuY3Rpb24gZG9uZShlKSB7XG4gICAgICAgIGNtLnN0YXRlLnNlbGVjdGluZ1RleHQgPSBmYWxzZTtcbiAgICAgICAgY291bnRlciA9IEluZmluaXR5O1xuICAgICAgICBpZiAoZSkge1xuICAgICAgICAgIGVfcHJldmVudERlZmF1bHQoZSk7XG4gICAgICAgICAgZGlzcGxheS5pbnB1dC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICAgIG9mZihkaXNwbGF5LndyYXBwZXIub3duZXJEb2N1bWVudCwgXCJtb3VzZW1vdmVcIiwgbW92ZSk7XG4gICAgICAgIG9mZihkaXNwbGF5LndyYXBwZXIub3duZXJEb2N1bWVudCwgXCJtb3VzZXVwXCIsIHVwKTtcbiAgICAgICAgZG9jLmhpc3RvcnkubGFzdFNlbE9yaWdpbiA9IG51bGw7XG4gICAgICB9XG4gICAgICBfX25hbWUoZG9uZSwgXCJkb25lXCIpO1xuICAgICAgdmFyIG1vdmUgPSBvcGVyYXRpb24oY20sIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKGUuYnV0dG9ucyA9PT0gMCB8fCAhZV9idXR0b24oZSkpIHtcbiAgICAgICAgICBkb25lKGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4dGVuZChlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgdXAgPSBvcGVyYXRpb24oY20sIGRvbmUpO1xuICAgICAgY20uc3RhdGUuc2VsZWN0aW5nVGV4dCA9IHVwO1xuICAgICAgb24oZGlzcGxheS53cmFwcGVyLm93bmVyRG9jdW1lbnQsIFwibW91c2Vtb3ZlXCIsIG1vdmUpO1xuICAgICAgb24oZGlzcGxheS53cmFwcGVyLm93bmVyRG9jdW1lbnQsIFwibW91c2V1cFwiLCB1cCk7XG4gICAgfVxuICAgIF9fbmFtZShsZWZ0QnV0dG9uU2VsZWN0LCBcImxlZnRCdXR0b25TZWxlY3RcIik7XG4gICAgZnVuY3Rpb24gYmlkaVNpbXBsaWZ5KGNtLCByYW5nZTIpIHtcbiAgICAgIHZhciBhbmNob3IgPSByYW5nZTIuYW5jaG9yO1xuICAgICAgdmFyIGhlYWQgPSByYW5nZTIuaGVhZDtcbiAgICAgIHZhciBhbmNob3JMaW5lID0gZ2V0TGluZShjbS5kb2MsIGFuY2hvci5saW5lKTtcbiAgICAgIGlmIChjbXAoYW5jaG9yLCBoZWFkKSA9PSAwICYmIGFuY2hvci5zdGlja3kgPT0gaGVhZC5zdGlja3kpIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlMjtcbiAgICAgIH1cbiAgICAgIHZhciBvcmRlciA9IGdldE9yZGVyKGFuY2hvckxpbmUpO1xuICAgICAgaWYgKCFvcmRlcikge1xuICAgICAgICByZXR1cm4gcmFuZ2UyO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gZ2V0QmlkaVBhcnRBdChvcmRlciwgYW5jaG9yLmNoLCBhbmNob3Iuc3RpY2t5KSwgcGFydCA9IG9yZGVyW2luZGV4XTtcbiAgICAgIGlmIChwYXJ0LmZyb20gIT0gYW5jaG9yLmNoICYmIHBhcnQudG8gIT0gYW5jaG9yLmNoKSB7XG4gICAgICAgIHJldHVybiByYW5nZTI7XG4gICAgICB9XG4gICAgICB2YXIgYm91bmRhcnkgPSBpbmRleCArIChwYXJ0LmZyb20gPT0gYW5jaG9yLmNoID09IChwYXJ0LmxldmVsICE9IDEpID8gMCA6IDEpO1xuICAgICAgaWYgKGJvdW5kYXJ5ID09IDAgfHwgYm91bmRhcnkgPT0gb3JkZXIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByYW5nZTI7XG4gICAgICB9XG4gICAgICB2YXIgbGVmdFNpZGU7XG4gICAgICBpZiAoaGVhZC5saW5lICE9IGFuY2hvci5saW5lKSB7XG4gICAgICAgIGxlZnRTaWRlID0gKGhlYWQubGluZSAtIGFuY2hvci5saW5lKSAqIChjbS5kb2MuZGlyZWN0aW9uID09IFwibHRyXCIgPyAxIDogLTEpID4gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBoZWFkSW5kZXggPSBnZXRCaWRpUGFydEF0KG9yZGVyLCBoZWFkLmNoLCBoZWFkLnN0aWNreSk7XG4gICAgICAgIHZhciBkaXIgPSBoZWFkSW5kZXggLSBpbmRleCB8fCAoaGVhZC5jaCAtIGFuY2hvci5jaCkgKiAocGFydC5sZXZlbCA9PSAxID8gLTEgOiAxKTtcbiAgICAgICAgaWYgKGhlYWRJbmRleCA9PSBib3VuZGFyeSAtIDEgfHwgaGVhZEluZGV4ID09IGJvdW5kYXJ5KSB7XG4gICAgICAgICAgbGVmdFNpZGUgPSBkaXIgPCAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxlZnRTaWRlID0gZGlyID4gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHVzZVBhcnQgPSBvcmRlcltib3VuZGFyeSArIChsZWZ0U2lkZSA/IC0xIDogMCldO1xuICAgICAgdmFyIGZyb20gPSBsZWZ0U2lkZSA9PSAodXNlUGFydC5sZXZlbCA9PSAxKTtcbiAgICAgIHZhciBjaCA9IGZyb20gPyB1c2VQYXJ0LmZyb20gOiB1c2VQYXJ0LnRvLCBzdGlja3kgPSBmcm9tID8gXCJhZnRlclwiIDogXCJiZWZvcmVcIjtcbiAgICAgIHJldHVybiBhbmNob3IuY2ggPT0gY2ggJiYgYW5jaG9yLnN0aWNreSA9PSBzdGlja3kgPyByYW5nZTIgOiBuZXcgUmFuZ2UobmV3IFBvcyhhbmNob3IubGluZSwgY2gsIHN0aWNreSksIGhlYWQpO1xuICAgIH1cbiAgICBfX25hbWUoYmlkaVNpbXBsaWZ5LCBcImJpZGlTaW1wbGlmeVwiKTtcbiAgICBmdW5jdGlvbiBndXR0ZXJFdmVudChjbSwgZSwgdHlwZSwgcHJldmVudCkge1xuICAgICAgdmFyIG1YLCBtWTtcbiAgICAgIGlmIChlLnRvdWNoZXMpIHtcbiAgICAgICAgbVggPSBlLnRvdWNoZXNbMF0uY2xpZW50WDtcbiAgICAgICAgbVkgPSBlLnRvdWNoZXNbMF0uY2xpZW50WTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbVggPSBlLmNsaWVudFg7XG4gICAgICAgICAgbVkgPSBlLmNsaWVudFk7XG4gICAgICAgIH0gY2F0Y2ggKGUkMSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1YID49IE1hdGguZmxvb3IoY20uZGlzcGxheS5ndXR0ZXJzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnJpZ2h0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAocHJldmVudCkge1xuICAgICAgICBlX3ByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgfVxuICAgICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xuICAgICAgdmFyIGxpbmVCb3ggPSBkaXNwbGF5LmxpbmVEaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBpZiAobVkgPiBsaW5lQm94LmJvdHRvbSB8fCAhaGFzSGFuZGxlcihjbSwgdHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIGVfZGVmYXVsdFByZXZlbnRlZChlKTtcbiAgICAgIH1cbiAgICAgIG1ZIC09IGxpbmVCb3gudG9wIC0gZGlzcGxheS52aWV3T2Zmc2V0O1xuICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IGNtLmRpc3BsYXkuZ3V0dGVyU3BlY3MubGVuZ3RoOyArK2kyKSB7XG4gICAgICAgIHZhciBnID0gZGlzcGxheS5ndXR0ZXJzLmNoaWxkTm9kZXNbaTJdO1xuICAgICAgICBpZiAoZyAmJiBnLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnJpZ2h0ID49IG1YKSB7XG4gICAgICAgICAgdmFyIGxpbmUgPSBsaW5lQXRIZWlnaHQoY20uZG9jLCBtWSk7XG4gICAgICAgICAgdmFyIGd1dHRlciA9IGNtLmRpc3BsYXkuZ3V0dGVyU3BlY3NbaTJdO1xuICAgICAgICAgIHNpZ25hbChjbSwgdHlwZSwgY20sIGxpbmUsIGd1dHRlci5jbGFzc05hbWUsIGUpO1xuICAgICAgICAgIHJldHVybiBlX2RlZmF1bHRQcmV2ZW50ZWQoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKGd1dHRlckV2ZW50LCBcImd1dHRlckV2ZW50XCIpO1xuICAgIGZ1bmN0aW9uIGNsaWNrSW5HdXR0ZXIoY20sIGUpIHtcbiAgICAgIHJldHVybiBndXR0ZXJFdmVudChjbSwgZSwgXCJndXR0ZXJDbGlja1wiLCB0cnVlKTtcbiAgICB9XG4gICAgX19uYW1lKGNsaWNrSW5HdXR0ZXIsIFwiY2xpY2tJbkd1dHRlclwiKTtcbiAgICBmdW5jdGlvbiBvbkNvbnRleHRNZW51KGNtLCBlKSB7XG4gICAgICBpZiAoZXZlbnRJbldpZGdldChjbS5kaXNwbGF5LCBlKSB8fCBjb250ZXh0TWVudUluR3V0dGVyKGNtLCBlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUsIFwiY29udGV4dG1lbnVcIikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFjYXB0dXJlUmlnaHRDbGljaykge1xuICAgICAgICBjbS5kaXNwbGF5LmlucHV0Lm9uQ29udGV4dE1lbnUoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShvbkNvbnRleHRNZW51LCBcIm9uQ29udGV4dE1lbnVcIik7XG4gICAgZnVuY3Rpb24gY29udGV4dE1lbnVJbkd1dHRlcihjbSwgZSkge1xuICAgICAgaWYgKCFoYXNIYW5kbGVyKGNtLCBcImd1dHRlckNvbnRleHRNZW51XCIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBndXR0ZXJFdmVudChjbSwgZSwgXCJndXR0ZXJDb250ZXh0TWVudVwiLCBmYWxzZSk7XG4gICAgfVxuICAgIF9fbmFtZShjb250ZXh0TWVudUluR3V0dGVyLCBcImNvbnRleHRNZW51SW5HdXR0ZXJcIik7XG4gICAgZnVuY3Rpb24gdGhlbWVDaGFuZ2VkKGNtKSB7XG4gICAgICBjbS5kaXNwbGF5LndyYXBwZXIuY2xhc3NOYW1lID0gY20uZGlzcGxheS53cmFwcGVyLmNsYXNzTmFtZS5yZXBsYWNlKC9cXHMqY20tcy1cXFMrL2csIFwiXCIpICsgY20ub3B0aW9ucy50aGVtZS5yZXBsYWNlKC8oXnxcXHMpXFxzKi9nLCBcIiBjbS1zLVwiKTtcbiAgICAgIGNsZWFyQ2FjaGVzKGNtKTtcbiAgICB9XG4gICAgX19uYW1lKHRoZW1lQ2hhbmdlZCwgXCJ0aGVtZUNoYW5nZWRcIik7XG4gICAgdmFyIEluaXQgPSB7IHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBcIkNvZGVNaXJyb3IuSW5pdFwiO1xuICAgIH0gfTtcbiAgICB2YXIgZGVmYXVsdHMgPSB7fTtcbiAgICB2YXIgb3B0aW9uSGFuZGxlcnMgPSB7fTtcbiAgICBmdW5jdGlvbiBkZWZpbmVPcHRpb25zKENvZGVNaXJyb3IzKSB7XG4gICAgICB2YXIgb3B0aW9uSGFuZGxlcnMyID0gQ29kZU1pcnJvcjMub3B0aW9uSGFuZGxlcnM7XG4gICAgICBmdW5jdGlvbiBvcHRpb24obmFtZSwgZGVmbHQsIGhhbmRsZSwgbm90T25Jbml0KSB7XG4gICAgICAgIENvZGVNaXJyb3IzLmRlZmF1bHRzW25hbWVdID0gZGVmbHQ7XG4gICAgICAgIGlmIChoYW5kbGUpIHtcbiAgICAgICAgICBvcHRpb25IYW5kbGVyczJbbmFtZV0gPSBub3RPbkluaXQgPyBmdW5jdGlvbihjbSwgdmFsLCBvbGQpIHtcbiAgICAgICAgICAgIGlmIChvbGQgIT0gSW5pdCkge1xuICAgICAgICAgICAgICBoYW5kbGUoY20sIHZhbCwgb2xkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IDogaGFuZGxlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBfX25hbWUob3B0aW9uLCBcIm9wdGlvblwiKTtcbiAgICAgIENvZGVNaXJyb3IzLmRlZmluZU9wdGlvbiA9IG9wdGlvbjtcbiAgICAgIENvZGVNaXJyb3IzLkluaXQgPSBJbml0O1xuICAgICAgb3B0aW9uKFwidmFsdWVcIiwgXCJcIiwgZnVuY3Rpb24oY20sIHZhbCkge1xuICAgICAgICByZXR1cm4gY20uc2V0VmFsdWUodmFsKTtcbiAgICAgIH0sIHRydWUpO1xuICAgICAgb3B0aW9uKFwibW9kZVwiLCBudWxsLCBmdW5jdGlvbihjbSwgdmFsKSB7XG4gICAgICAgIGNtLmRvYy5tb2RlT3B0aW9uID0gdmFsO1xuICAgICAgICBsb2FkTW9kZShjbSk7XG4gICAgICB9LCB0cnVlKTtcbiAgICAgIG9wdGlvbihcImluZGVudFVuaXRcIiwgMiwgbG9hZE1vZGUsIHRydWUpO1xuICAgICAgb3B0aW9uKFwiaW5kZW50V2l0aFRhYnNcIiwgZmFsc2UpO1xuICAgICAgb3B0aW9uKFwic21hcnRJbmRlbnRcIiwgdHJ1ZSk7XG4gICAgICBvcHRpb24oXCJ0YWJTaXplXCIsIDQsIGZ1bmN0aW9uKGNtKSB7XG4gICAgICAgIHJlc2V0TW9kZVN0YXRlKGNtKTtcbiAgICAgICAgY2xlYXJDYWNoZXMoY20pO1xuICAgICAgICByZWdDaGFuZ2UoY20pO1xuICAgICAgfSwgdHJ1ZSk7XG4gICAgICBvcHRpb24oXCJsaW5lU2VwYXJhdG9yXCIsIG51bGwsIGZ1bmN0aW9uKGNtLCB2YWwpIHtcbiAgICAgICAgY20uZG9jLmxpbmVTZXAgPSB2YWw7XG4gICAgICAgIGlmICghdmFsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdCcmVha3MgPSBbXSwgbGluZU5vMiA9IGNtLmRvYy5maXJzdDtcbiAgICAgICAgY20uZG9jLml0ZXIoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgIGZvciAodmFyIHBvcyA9IDA7IDsgKSB7XG4gICAgICAgICAgICB2YXIgZm91bmQgPSBsaW5lLnRleHQuaW5kZXhPZih2YWwsIHBvcyk7XG4gICAgICAgICAgICBpZiAoZm91bmQgPT0gLTEpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgPSBmb3VuZCArIHZhbC5sZW5ndGg7XG4gICAgICAgICAgICBuZXdCcmVha3MucHVzaChQb3MobGluZU5vMiwgZm91bmQpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGluZU5vMisrO1xuICAgICAgICB9KTtcbiAgICAgICAgZm9yICh2YXIgaTIgPSBuZXdCcmVha3MubGVuZ3RoIC0gMTsgaTIgPj0gMDsgaTItLSkge1xuICAgICAgICAgIHJlcGxhY2VSYW5nZShjbS5kb2MsIHZhbCwgbmV3QnJlYWtzW2kyXSwgUG9zKG5ld0JyZWFrc1tpMl0ubGluZSwgbmV3QnJlYWtzW2kyXS5jaCArIHZhbC5sZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBvcHRpb24oXCJzcGVjaWFsQ2hhcnNcIiwgL1tcXHUwMDAwLVxcdTAwMWZcXHUwMDdmLVxcdTAwOWZcXHUwMGFkXFx1MDYxY1xcdTIwMGJcXHUyMDBlXFx1MjAwZlxcdTIwMjhcXHUyMDI5XFx1ZmVmZlxcdWZmZjktXFx1ZmZmY10vZywgZnVuY3Rpb24oY20sIHZhbCwgb2xkKSB7XG4gICAgICAgIGNtLnN0YXRlLnNwZWNpYWxDaGFycyA9IG5ldyBSZWdFeHAodmFsLnNvdXJjZSArICh2YWwudGVzdChcIlx0XCIpID8gXCJcIiA6IFwifFx0XCIpLCBcImdcIik7XG4gICAgICAgIGlmIChvbGQgIT0gSW5pdCkge1xuICAgICAgICAgIGNtLnJlZnJlc2goKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBvcHRpb24oXCJzcGVjaWFsQ2hhclBsYWNlaG9sZGVyXCIsIGRlZmF1bHRTcGVjaWFsQ2hhclBsYWNlaG9sZGVyLCBmdW5jdGlvbihjbSkge1xuICAgICAgICByZXR1cm4gY20ucmVmcmVzaCgpO1xuICAgICAgfSwgdHJ1ZSk7XG4gICAgICBvcHRpb24oXCJlbGVjdHJpY0NoYXJzXCIsIHRydWUpO1xuICAgICAgb3B0aW9uKFwiaW5wdXRTdHlsZVwiLCBtb2JpbGUgPyBcImNvbnRlbnRlZGl0YWJsZVwiIDogXCJ0ZXh0YXJlYVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5wdXRTdHlsZSBjYW4gbm90ICh5ZXQpIGJlIGNoYW5nZWQgaW4gYSBydW5uaW5nIGVkaXRvclwiKTtcbiAgICAgIH0sIHRydWUpO1xuICAgICAgb3B0aW9uKFwic3BlbGxjaGVja1wiLCBmYWxzZSwgZnVuY3Rpb24oY20sIHZhbCkge1xuICAgICAgICByZXR1cm4gY20uZ2V0SW5wdXRGaWVsZCgpLnNwZWxsY2hlY2sgPSB2YWw7XG4gICAgICB9LCB0cnVlKTtcbiAgICAgIG9wdGlvbihcImF1dG9jb3JyZWN0XCIsIGZhbHNlLCBmdW5jdGlvbihjbSwgdmFsKSB7XG4gICAgICAgIHJldHVybiBjbS5nZXRJbnB1dEZpZWxkKCkuYXV0b2NvcnJlY3QgPSB2YWw7XG4gICAgICB9LCB0cnVlKTtcbiAgICAgIG9wdGlvbihcImF1dG9jYXBpdGFsaXplXCIsIGZhbHNlLCBmdW5jdGlvbihjbSwgdmFsKSB7XG4gICAgICAgIHJldHVybiBjbS5nZXRJbnB1dEZpZWxkKCkuYXV0b2NhcGl0YWxpemUgPSB2YWw7XG4gICAgICB9LCB0cnVlKTtcbiAgICAgIG9wdGlvbihcInJ0bE1vdmVWaXN1YWxseVwiLCAhd2luZG93cyk7XG4gICAgICBvcHRpb24oXCJ3aG9sZUxpbmVVcGRhdGVCZWZvcmVcIiwgdHJ1ZSk7XG4gICAgICBvcHRpb24oXCJ0aGVtZVwiLCBcImRlZmF1bHRcIiwgZnVuY3Rpb24oY20pIHtcbiAgICAgICAgdGhlbWVDaGFuZ2VkKGNtKTtcbiAgICAgICAgdXBkYXRlR3V0dGVycyhjbSk7XG4gICAgICB9LCB0cnVlKTtcbiAgICAgIG9wdGlvbihcImtleU1hcFwiLCBcImRlZmF1bHRcIiwgZnVuY3Rpb24oY20sIHZhbCwgb2xkKSB7XG4gICAgICAgIHZhciBuZXh0ID0gZ2V0S2V5TWFwKHZhbCk7XG4gICAgICAgIHZhciBwcmV2ID0gb2xkICE9IEluaXQgJiYgZ2V0S2V5TWFwKG9sZCk7XG4gICAgICAgIGlmIChwcmV2ICYmIHByZXYuZGV0YWNoKSB7XG4gICAgICAgICAgcHJldi5kZXRhY2goY20sIG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0LmF0dGFjaCkge1xuICAgICAgICAgIG5leHQuYXR0YWNoKGNtLCBwcmV2IHx8IG51bGwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG9wdGlvbihcImV4dHJhS2V5c1wiLCBudWxsKTtcbiAgICAgIG9wdGlvbihcImNvbmZpZ3VyZU1vdXNlXCIsIG51bGwpO1xuICAgICAgb3B0aW9uKFwibGluZVdyYXBwaW5nXCIsIGZhbHNlLCB3cmFwcGluZ0NoYW5nZWQsIHRydWUpO1xuICAgICAgb3B0aW9uKFwiZ3V0dGVyc1wiLCBbXSwgZnVuY3Rpb24oY20sIHZhbCkge1xuICAgICAgICBjbS5kaXNwbGF5Lmd1dHRlclNwZWNzID0gZ2V0R3V0dGVycyh2YWwsIGNtLm9wdGlvbnMubGluZU51bWJlcnMpO1xuICAgICAgICB1cGRhdGVHdXR0ZXJzKGNtKTtcbiAgICAgIH0sIHRydWUpO1xuICAgICAgb3B0aW9uKFwiZml4ZWRHdXR0ZXJcIiwgdHJ1ZSwgZnVuY3Rpb24oY20sIHZhbCkge1xuICAgICAgICBjbS5kaXNwbGF5Lmd1dHRlcnMuc3R5bGUubGVmdCA9IHZhbCA/IGNvbXBlbnNhdGVGb3JIU2Nyb2xsKGNtLmRpc3BsYXkpICsgXCJweFwiIDogXCIwXCI7XG4gICAgICAgIGNtLnJlZnJlc2goKTtcbiAgICAgIH0sIHRydWUpO1xuICAgICAgb3B0aW9uKFwiY292ZXJHdXR0ZXJOZXh0VG9TY3JvbGxiYXJcIiwgZmFsc2UsIGZ1bmN0aW9uKGNtKSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVTY3JvbGxiYXJzKGNtKTtcbiAgICAgIH0sIHRydWUpO1xuICAgICAgb3B0aW9uKFwic2Nyb2xsYmFyU3R5bGVcIiwgXCJuYXRpdmVcIiwgZnVuY3Rpb24oY20pIHtcbiAgICAgICAgaW5pdFNjcm9sbGJhcnMoY20pO1xuICAgICAgICB1cGRhdGVTY3JvbGxiYXJzKGNtKTtcbiAgICAgICAgY20uZGlzcGxheS5zY3JvbGxiYXJzLnNldFNjcm9sbFRvcChjbS5kb2Muc2Nyb2xsVG9wKTtcbiAgICAgICAgY20uZGlzcGxheS5zY3JvbGxiYXJzLnNldFNjcm9sbExlZnQoY20uZG9jLnNjcm9sbExlZnQpO1xuICAgICAgfSwgdHJ1ZSk7XG4gICAgICBvcHRpb24oXCJsaW5lTnVtYmVyc1wiLCBmYWxzZSwgZnVuY3Rpb24oY20sIHZhbCkge1xuICAgICAgICBjbS5kaXNwbGF5Lmd1dHRlclNwZWNzID0gZ2V0R3V0dGVycyhjbS5vcHRpb25zLmd1dHRlcnMsIHZhbCk7XG4gICAgICAgIHVwZGF0ZUd1dHRlcnMoY20pO1xuICAgICAgfSwgdHJ1ZSk7XG4gICAgICBvcHRpb24oXCJmaXJzdExpbmVOdW1iZXJcIiwgMSwgdXBkYXRlR3V0dGVycywgdHJ1ZSk7XG4gICAgICBvcHRpb24oXCJsaW5lTnVtYmVyRm9ybWF0dGVyXCIsIGZ1bmN0aW9uKGludGVnZXIpIHtcbiAgICAgICAgcmV0dXJuIGludGVnZXI7XG4gICAgICB9LCB1cGRhdGVHdXR0ZXJzLCB0cnVlKTtcbiAgICAgIG9wdGlvbihcInNob3dDdXJzb3JXaGVuU2VsZWN0aW5nXCIsIGZhbHNlLCB1cGRhdGVTZWxlY3Rpb24sIHRydWUpO1xuICAgICAgb3B0aW9uKFwicmVzZXRTZWxlY3Rpb25PbkNvbnRleHRNZW51XCIsIHRydWUpO1xuICAgICAgb3B0aW9uKFwibGluZVdpc2VDb3B5Q3V0XCIsIHRydWUpO1xuICAgICAgb3B0aW9uKFwicGFzdGVMaW5lc1BlclNlbGVjdGlvblwiLCB0cnVlKTtcbiAgICAgIG9wdGlvbihcInNlbGVjdGlvbnNNYXlUb3VjaFwiLCBmYWxzZSk7XG4gICAgICBvcHRpb24oXCJyZWFkT25seVwiLCBmYWxzZSwgZnVuY3Rpb24oY20sIHZhbCkge1xuICAgICAgICBpZiAodmFsID09IFwibm9jdXJzb3JcIikge1xuICAgICAgICAgIG9uQmx1cihjbSk7XG4gICAgICAgICAgY20uZGlzcGxheS5pbnB1dC5ibHVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgY20uZGlzcGxheS5pbnB1dC5yZWFkT25seUNoYW5nZWQodmFsKTtcbiAgICAgIH0pO1xuICAgICAgb3B0aW9uKFwic2NyZWVuUmVhZGVyTGFiZWxcIiwgbnVsbCwgZnVuY3Rpb24oY20sIHZhbCkge1xuICAgICAgICB2YWwgPSB2YWwgPT09IFwiXCIgPyBudWxsIDogdmFsO1xuICAgICAgICBjbS5kaXNwbGF5LmlucHV0LnNjcmVlblJlYWRlckxhYmVsQ2hhbmdlZCh2YWwpO1xuICAgICAgfSk7XG4gICAgICBvcHRpb24oXCJkaXNhYmxlSW5wdXRcIiwgZmFsc2UsIGZ1bmN0aW9uKGNtLCB2YWwpIHtcbiAgICAgICAgaWYgKCF2YWwpIHtcbiAgICAgICAgICBjbS5kaXNwbGF5LmlucHV0LnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRydWUpO1xuICAgICAgb3B0aW9uKFwiZHJhZ0Ryb3BcIiwgdHJ1ZSwgZHJhZ0Ryb3BDaGFuZ2VkKTtcbiAgICAgIG9wdGlvbihcImFsbG93RHJvcEZpbGVUeXBlc1wiLCBudWxsKTtcbiAgICAgIG9wdGlvbihcImN1cnNvckJsaW5rUmF0ZVwiLCA1MzApO1xuICAgICAgb3B0aW9uKFwiY3Vyc29yU2Nyb2xsTWFyZ2luXCIsIDApO1xuICAgICAgb3B0aW9uKFwiY3Vyc29ySGVpZ2h0XCIsIDEsIHVwZGF0ZVNlbGVjdGlvbiwgdHJ1ZSk7XG4gICAgICBvcHRpb24oXCJzaW5nbGVDdXJzb3JIZWlnaHRQZXJMaW5lXCIsIHRydWUsIHVwZGF0ZVNlbGVjdGlvbiwgdHJ1ZSk7XG4gICAgICBvcHRpb24oXCJ3b3JrVGltZVwiLCAxMDApO1xuICAgICAgb3B0aW9uKFwid29ya0RlbGF5XCIsIDEwMCk7XG4gICAgICBvcHRpb24oXCJmbGF0dGVuU3BhbnNcIiwgdHJ1ZSwgcmVzZXRNb2RlU3RhdGUsIHRydWUpO1xuICAgICAgb3B0aW9uKFwiYWRkTW9kZUNsYXNzXCIsIGZhbHNlLCByZXNldE1vZGVTdGF0ZSwgdHJ1ZSk7XG4gICAgICBvcHRpb24oXCJwb2xsSW50ZXJ2YWxcIiwgMTAwKTtcbiAgICAgIG9wdGlvbihcInVuZG9EZXB0aFwiLCAyMDAsIGZ1bmN0aW9uKGNtLCB2YWwpIHtcbiAgICAgICAgcmV0dXJuIGNtLmRvYy5oaXN0b3J5LnVuZG9EZXB0aCA9IHZhbDtcbiAgICAgIH0pO1xuICAgICAgb3B0aW9uKFwiaGlzdG9yeUV2ZW50RGVsYXlcIiwgMTI1MCk7XG4gICAgICBvcHRpb24oXCJ2aWV3cG9ydE1hcmdpblwiLCAxMCwgZnVuY3Rpb24oY20pIHtcbiAgICAgICAgcmV0dXJuIGNtLnJlZnJlc2goKTtcbiAgICAgIH0sIHRydWUpO1xuICAgICAgb3B0aW9uKFwibWF4SGlnaGxpZ2h0TGVuZ3RoXCIsIDFlNCwgcmVzZXRNb2RlU3RhdGUsIHRydWUpO1xuICAgICAgb3B0aW9uKFwibW92ZUlucHV0V2l0aEN1cnNvclwiLCB0cnVlLCBmdW5jdGlvbihjbSwgdmFsKSB7XG4gICAgICAgIGlmICghdmFsKSB7XG4gICAgICAgICAgY20uZGlzcGxheS5pbnB1dC5yZXNldFBvc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgb3B0aW9uKFwidGFiaW5kZXhcIiwgbnVsbCwgZnVuY3Rpb24oY20sIHZhbCkge1xuICAgICAgICByZXR1cm4gY20uZGlzcGxheS5pbnB1dC5nZXRGaWVsZCgpLnRhYkluZGV4ID0gdmFsIHx8IFwiXCI7XG4gICAgICB9KTtcbiAgICAgIG9wdGlvbihcImF1dG9mb2N1c1wiLCBudWxsKTtcbiAgICAgIG9wdGlvbihcImRpcmVjdGlvblwiLCBcImx0clwiLCBmdW5jdGlvbihjbSwgdmFsKSB7XG4gICAgICAgIHJldHVybiBjbS5kb2Muc2V0RGlyZWN0aW9uKHZhbCk7XG4gICAgICB9LCB0cnVlKTtcbiAgICAgIG9wdGlvbihcInBocmFzZXNcIiwgbnVsbCk7XG4gICAgfVxuICAgIF9fbmFtZShkZWZpbmVPcHRpb25zLCBcImRlZmluZU9wdGlvbnNcIik7XG4gICAgZnVuY3Rpb24gZHJhZ0Ryb3BDaGFuZ2VkKGNtLCB2YWx1ZSwgb2xkKSB7XG4gICAgICB2YXIgd2FzT24gPSBvbGQgJiYgb2xkICE9IEluaXQ7XG4gICAgICBpZiAoIXZhbHVlICE9ICF3YXNPbikge1xuICAgICAgICB2YXIgZnVuY3MgPSBjbS5kaXNwbGF5LmRyYWdGdW5jdGlvbnM7XG4gICAgICAgIHZhciB0b2dnbGUgPSB2YWx1ZSA/IG9uIDogb2ZmO1xuICAgICAgICB0b2dnbGUoY20uZGlzcGxheS5zY3JvbGxlciwgXCJkcmFnc3RhcnRcIiwgZnVuY3Muc3RhcnQpO1xuICAgICAgICB0b2dnbGUoY20uZGlzcGxheS5zY3JvbGxlciwgXCJkcmFnZW50ZXJcIiwgZnVuY3MuZW50ZXIpO1xuICAgICAgICB0b2dnbGUoY20uZGlzcGxheS5zY3JvbGxlciwgXCJkcmFnb3ZlclwiLCBmdW5jcy5vdmVyKTtcbiAgICAgICAgdG9nZ2xlKGNtLmRpc3BsYXkuc2Nyb2xsZXIsIFwiZHJhZ2xlYXZlXCIsIGZ1bmNzLmxlYXZlKTtcbiAgICAgICAgdG9nZ2xlKGNtLmRpc3BsYXkuc2Nyb2xsZXIsIFwiZHJvcFwiLCBmdW5jcy5kcm9wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKGRyYWdEcm9wQ2hhbmdlZCwgXCJkcmFnRHJvcENoYW5nZWRcIik7XG4gICAgZnVuY3Rpb24gd3JhcHBpbmdDaGFuZ2VkKGNtKSB7XG4gICAgICBpZiAoY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHtcbiAgICAgICAgYWRkQ2xhc3MoY20uZGlzcGxheS53cmFwcGVyLCBcIkNvZGVNaXJyb3Itd3JhcFwiKTtcbiAgICAgICAgY20uZGlzcGxheS5zaXplci5zdHlsZS5taW5XaWR0aCA9IFwiXCI7XG4gICAgICAgIGNtLmRpc3BsYXkuc2l6ZXJXaWR0aCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBybUNsYXNzKGNtLmRpc3BsYXkud3JhcHBlciwgXCJDb2RlTWlycm9yLXdyYXBcIik7XG4gICAgICAgIGZpbmRNYXhMaW5lKGNtKTtcbiAgICAgIH1cbiAgICAgIGVzdGltYXRlTGluZUhlaWdodHMoY20pO1xuICAgICAgcmVnQ2hhbmdlKGNtKTtcbiAgICAgIGNsZWFyQ2FjaGVzKGNtKTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVTY3JvbGxiYXJzKGNtKTtcbiAgICAgIH0sIDEwMCk7XG4gICAgfVxuICAgIF9fbmFtZSh3cmFwcGluZ0NoYW5nZWQsIFwid3JhcHBpbmdDaGFuZ2VkXCIpO1xuICAgIGZ1bmN0aW9uIENvZGVNaXJyb3IyKHBsYWNlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgdGhpcyQxJDEgPSB0aGlzO1xuICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENvZGVNaXJyb3IyKSkge1xuICAgICAgICByZXR1cm4gbmV3IENvZGVNaXJyb3IyKHBsYWNlLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgPSBvcHRpb25zID8gY29weU9iaihvcHRpb25zKSA6IHt9O1xuICAgICAgY29weU9iaihkZWZhdWx0cywgb3B0aW9ucywgZmFsc2UpO1xuICAgICAgdmFyIGRvYyA9IG9wdGlvbnMudmFsdWU7XG4gICAgICBpZiAodHlwZW9mIGRvYyA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGRvYyA9IG5ldyBEb2MoZG9jLCBvcHRpb25zLm1vZGUsIG51bGwsIG9wdGlvbnMubGluZVNlcGFyYXRvciwgb3B0aW9ucy5kaXJlY3Rpb24pO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLm1vZGUpIHtcbiAgICAgICAgZG9jLm1vZGVPcHRpb24gPSBvcHRpb25zLm1vZGU7XG4gICAgICB9XG4gICAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAgIHZhciBpbnB1dCA9IG5ldyBDb2RlTWlycm9yMi5pbnB1dFN0eWxlc1tvcHRpb25zLmlucHV0U3R5bGVdKHRoaXMpO1xuICAgICAgdmFyIGRpc3BsYXkgPSB0aGlzLmRpc3BsYXkgPSBuZXcgRGlzcGxheShwbGFjZSwgZG9jLCBpbnB1dCwgb3B0aW9ucyk7XG4gICAgICBkaXNwbGF5LndyYXBwZXIuQ29kZU1pcnJvciA9IHRoaXM7XG4gICAgICB0aGVtZUNoYW5nZWQodGhpcyk7XG4gICAgICBpZiAob3B0aW9ucy5saW5lV3JhcHBpbmcpIHtcbiAgICAgICAgdGhpcy5kaXNwbGF5LndyYXBwZXIuY2xhc3NOYW1lICs9IFwiIENvZGVNaXJyb3Itd3JhcFwiO1xuICAgICAgfVxuICAgICAgaW5pdFNjcm9sbGJhcnModGhpcyk7XG4gICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICBrZXlNYXBzOiBbXSxcbiAgICAgICAgb3ZlcmxheXM6IFtdLFxuICAgICAgICBtb2RlR2VuOiAwLFxuICAgICAgICBvdmVyd3JpdGU6IGZhbHNlLFxuICAgICAgICBkZWxheWluZ0JsdXJFdmVudDogZmFsc2UsXG4gICAgICAgIGZvY3VzZWQ6IGZhbHNlLFxuICAgICAgICBzdXBwcmVzc0VkaXRzOiBmYWxzZSxcbiAgICAgICAgcGFzdGVJbmNvbWluZzogLTEsXG4gICAgICAgIGN1dEluY29taW5nOiAtMSxcbiAgICAgICAgc2VsZWN0aW5nVGV4dDogZmFsc2UsXG4gICAgICAgIGRyYWdnaW5nVGV4dDogZmFsc2UsXG4gICAgICAgIGhpZ2hsaWdodDogbmV3IERlbGF5ZWQoKSxcbiAgICAgICAga2V5U2VxOiBudWxsLFxuICAgICAgICBzcGVjaWFsQ2hhcnM6IG51bGxcbiAgICAgIH07XG4gICAgICBpZiAob3B0aW9ucy5hdXRvZm9jdXMgJiYgIW1vYmlsZSkge1xuICAgICAgICBkaXNwbGF5LmlucHV0LmZvY3VzKCk7XG4gICAgICB9XG4gICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDExKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMkMSQxLmRpc3BsYXkuaW5wdXQucmVzZXQodHJ1ZSk7XG4gICAgICAgIH0sIDIwKTtcbiAgICAgIH1cbiAgICAgIHJlZ2lzdGVyRXZlbnRIYW5kbGVycyh0aGlzKTtcbiAgICAgIGVuc3VyZUdsb2JhbEhhbmRsZXJzKCk7XG4gICAgICBzdGFydE9wZXJhdGlvbih0aGlzKTtcbiAgICAgIHRoaXMuY3VyT3AuZm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgYXR0YWNoRG9jKHRoaXMsIGRvYyk7XG4gICAgICBpZiAob3B0aW9ucy5hdXRvZm9jdXMgJiYgIW1vYmlsZSB8fCB0aGlzLmhhc0ZvY3VzKCkpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAodGhpcyQxJDEuaGFzRm9jdXMoKSAmJiAhdGhpcyQxJDEuc3RhdGUuZm9jdXNlZCkge1xuICAgICAgICAgICAgb25Gb2N1cyh0aGlzJDEkMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAyMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbkJsdXIodGhpcyk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBvcHQgaW4gb3B0aW9uSGFuZGxlcnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbkhhbmRsZXJzLmhhc093blByb3BlcnR5KG9wdCkpIHtcbiAgICAgICAgICBvcHRpb25IYW5kbGVyc1tvcHRdKHRoaXMsIG9wdGlvbnNbb3B0XSwgSW5pdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1heWJlVXBkYXRlTGluZU51bWJlcldpZHRoKHRoaXMpO1xuICAgICAgaWYgKG9wdGlvbnMuZmluaXNoSW5pdCkge1xuICAgICAgICBvcHRpb25zLmZpbmlzaEluaXQodGhpcyk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgaW5pdEhvb2tzLmxlbmd0aDsgKytpMikge1xuICAgICAgICBpbml0SG9va3NbaTJdKHRoaXMpO1xuICAgICAgfVxuICAgICAgZW5kT3BlcmF0aW9uKHRoaXMpO1xuICAgICAgaWYgKHdlYmtpdCAmJiBvcHRpb25zLmxpbmVXcmFwcGluZyAmJiBnZXRDb21wdXRlZFN0eWxlKGRpc3BsYXkubGluZURpdikudGV4dFJlbmRlcmluZyA9PSBcIm9wdGltaXplbGVnaWJpbGl0eVwiKSB7XG4gICAgICAgIGRpc3BsYXkubGluZURpdi5zdHlsZS50ZXh0UmVuZGVyaW5nID0gXCJhdXRvXCI7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShDb2RlTWlycm9yMiwgXCJDb2RlTWlycm9yXCIpO1xuICAgIENvZGVNaXJyb3IyLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4gICAgQ29kZU1pcnJvcjIub3B0aW9uSGFuZGxlcnMgPSBvcHRpb25IYW5kbGVycztcbiAgICBmdW5jdGlvbiByZWdpc3RlckV2ZW50SGFuZGxlcnMoY20pIHtcbiAgICAgIHZhciBkID0gY20uZGlzcGxheTtcbiAgICAgIG9uKGQuc2Nyb2xsZXIsIFwibW91c2Vkb3duXCIsIG9wZXJhdGlvbihjbSwgb25Nb3VzZURvd24pKTtcbiAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgMTEpIHtcbiAgICAgICAgb24oZC5zY3JvbGxlciwgXCJkYmxjbGlja1wiLCBvcGVyYXRpb24oY20sIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBwb3MgPSBwb3NGcm9tTW91c2UoY20sIGUpO1xuICAgICAgICAgIGlmICghcG9zIHx8IGNsaWNrSW5HdXR0ZXIoY20sIGUpIHx8IGV2ZW50SW5XaWRnZXQoY20uZGlzcGxheSwgZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZV9wcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgICB2YXIgd29yZCA9IGNtLmZpbmRXb3JkQXQocG9zKTtcbiAgICAgICAgICBleHRlbmRTZWxlY3Rpb24oY20uZG9jLCB3b3JkLmFuY2hvciwgd29yZC5oZWFkKTtcbiAgICAgICAgfSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb24oZC5zY3JvbGxlciwgXCJkYmxjbGlja1wiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgcmV0dXJuIHNpZ25hbERPTUV2ZW50KGNtLCBlKSB8fCBlX3ByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIG9uKGQuc2Nyb2xsZXIsIFwiY29udGV4dG1lbnVcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICByZXR1cm4gb25Db250ZXh0TWVudShjbSwgZSk7XG4gICAgICB9KTtcbiAgICAgIG9uKGQuaW5wdXQuZ2V0RmllbGQoKSwgXCJjb250ZXh0bWVudVwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICghZC5zY3JvbGxlci5jb250YWlucyhlLnRhcmdldCkpIHtcbiAgICAgICAgICBvbkNvbnRleHRNZW51KGNtLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgdG91Y2hGaW5pc2hlZCwgcHJldlRvdWNoID0geyBlbmQ6IDAgfTtcbiAgICAgIGZ1bmN0aW9uIGZpbmlzaFRvdWNoKCkge1xuICAgICAgICBpZiAoZC5hY3RpdmVUb3VjaCkge1xuICAgICAgICAgIHRvdWNoRmluaXNoZWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGQuYWN0aXZlVG91Y2ggPSBudWxsO1xuICAgICAgICAgIH0sIDFlMyk7XG4gICAgICAgICAgcHJldlRvdWNoID0gZC5hY3RpdmVUb3VjaDtcbiAgICAgICAgICBwcmV2VG91Y2guZW5kID0gK25ldyBEYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF9fbmFtZShmaW5pc2hUb3VjaCwgXCJmaW5pc2hUb3VjaFwiKTtcbiAgICAgIGZ1bmN0aW9uIGlzTW91c2VMaWtlVG91Y2hFdmVudChlKSB7XG4gICAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoICE9IDEpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRvdWNoID0gZS50b3VjaGVzWzBdO1xuICAgICAgICByZXR1cm4gdG91Y2gucmFkaXVzWCA8PSAxICYmIHRvdWNoLnJhZGl1c1kgPD0gMTtcbiAgICAgIH1cbiAgICAgIF9fbmFtZShpc01vdXNlTGlrZVRvdWNoRXZlbnQsIFwiaXNNb3VzZUxpa2VUb3VjaEV2ZW50XCIpO1xuICAgICAgZnVuY3Rpb24gZmFyQXdheSh0b3VjaCwgb3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyLmxlZnQgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkeCA9IG90aGVyLmxlZnQgLSB0b3VjaC5sZWZ0LCBkeSA9IG90aGVyLnRvcCAtIHRvdWNoLnRvcDtcbiAgICAgICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5ID4gMjAgKiAyMDtcbiAgICAgIH1cbiAgICAgIF9fbmFtZShmYXJBd2F5LCBcImZhckF3YXlcIik7XG4gICAgICBvbihkLnNjcm9sbGVyLCBcInRvdWNoc3RhcnRcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoIXNpZ25hbERPTUV2ZW50KGNtLCBlKSAmJiAhaXNNb3VzZUxpa2VUb3VjaEV2ZW50KGUpICYmICFjbGlja0luR3V0dGVyKGNtLCBlKSkge1xuICAgICAgICAgIGQuaW5wdXQuZW5zdXJlUG9sbGVkKCk7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRvdWNoRmluaXNoZWQpO1xuICAgICAgICAgIHZhciBub3cgPSArbmV3IERhdGUoKTtcbiAgICAgICAgICBkLmFjdGl2ZVRvdWNoID0ge1xuICAgICAgICAgICAgc3RhcnQ6IG5vdyxcbiAgICAgICAgICAgIG1vdmVkOiBmYWxzZSxcbiAgICAgICAgICAgIHByZXY6IG5vdyAtIHByZXZUb3VjaC5lbmQgPD0gMzAwID8gcHJldlRvdWNoIDogbnVsbFxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgZC5hY3RpdmVUb3VjaC5sZWZ0ID0gZS50b3VjaGVzWzBdLnBhZ2VYO1xuICAgICAgICAgICAgZC5hY3RpdmVUb3VjaC50b3AgPSBlLnRvdWNoZXNbMF0ucGFnZVk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG9uKGQuc2Nyb2xsZXIsIFwidG91Y2htb3ZlXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoZC5hY3RpdmVUb3VjaCkge1xuICAgICAgICAgIGQuYWN0aXZlVG91Y2gubW92ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG9uKGQuc2Nyb2xsZXIsIFwidG91Y2hlbmRcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgdG91Y2ggPSBkLmFjdGl2ZVRvdWNoO1xuICAgICAgICBpZiAodG91Y2ggJiYgIWV2ZW50SW5XaWRnZXQoZCwgZSkgJiYgdG91Y2gubGVmdCAhPSBudWxsICYmICF0b3VjaC5tb3ZlZCAmJiBuZXcgRGF0ZSgpIC0gdG91Y2guc3RhcnQgPCAzMDApIHtcbiAgICAgICAgICB2YXIgcG9zID0gY20uY29vcmRzQ2hhcihkLmFjdGl2ZVRvdWNoLCBcInBhZ2VcIiksIHJhbmdlMjtcbiAgICAgICAgICBpZiAoIXRvdWNoLnByZXYgfHwgZmFyQXdheSh0b3VjaCwgdG91Y2gucHJldikpIHtcbiAgICAgICAgICAgIHJhbmdlMiA9IG5ldyBSYW5nZShwb3MsIHBvcyk7XG4gICAgICAgICAgfSBlbHNlIGlmICghdG91Y2gucHJldi5wcmV2IHx8IGZhckF3YXkodG91Y2gsIHRvdWNoLnByZXYucHJldikpIHtcbiAgICAgICAgICAgIHJhbmdlMiA9IGNtLmZpbmRXb3JkQXQocG9zKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmFuZ2UyID0gbmV3IFJhbmdlKFBvcyhwb3MubGluZSwgMCksIGNsaXBQb3MoY20uZG9jLCBQb3MocG9zLmxpbmUgKyAxLCAwKSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjbS5zZXRTZWxlY3Rpb24ocmFuZ2UyLmFuY2hvciwgcmFuZ2UyLmhlYWQpO1xuICAgICAgICAgIGNtLmZvY3VzKCk7XG4gICAgICAgICAgZV9wcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5pc2hUb3VjaCgpO1xuICAgICAgfSk7XG4gICAgICBvbihkLnNjcm9sbGVyLCBcInRvdWNoY2FuY2VsXCIsIGZpbmlzaFRvdWNoKTtcbiAgICAgIG9uKGQuc2Nyb2xsZXIsIFwic2Nyb2xsXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoZC5zY3JvbGxlci5jbGllbnRIZWlnaHQpIHtcbiAgICAgICAgICB1cGRhdGVTY3JvbGxUb3AoY20sIGQuc2Nyb2xsZXIuc2Nyb2xsVG9wKTtcbiAgICAgICAgICBzZXRTY3JvbGxMZWZ0KGNtLCBkLnNjcm9sbGVyLnNjcm9sbExlZnQsIHRydWUpO1xuICAgICAgICAgIHNpZ25hbChjbSwgXCJzY3JvbGxcIiwgY20pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG9uKGQuc2Nyb2xsZXIsIFwibW91c2V3aGVlbFwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHJldHVybiBvblNjcm9sbFdoZWVsKGNtLCBlKTtcbiAgICAgIH0pO1xuICAgICAgb24oZC5zY3JvbGxlciwgXCJET01Nb3VzZVNjcm9sbFwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHJldHVybiBvblNjcm9sbFdoZWVsKGNtLCBlKTtcbiAgICAgIH0pO1xuICAgICAgb24oZC53cmFwcGVyLCBcInNjcm9sbFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGQud3JhcHBlci5zY3JvbGxUb3AgPSBkLndyYXBwZXIuc2Nyb2xsTGVmdCA9IDA7XG4gICAgICB9KTtcbiAgICAgIGQuZHJhZ0Z1bmN0aW9ucyA9IHtcbiAgICAgICAgZW50ZXI6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBpZiAoIXNpZ25hbERPTUV2ZW50KGNtLCBlKSkge1xuICAgICAgICAgICAgZV9zdG9wKGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb3ZlcjogZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGlmICghc2lnbmFsRE9NRXZlbnQoY20sIGUpKSB7XG4gICAgICAgICAgICBvbkRyYWdPdmVyKGNtLCBlKTtcbiAgICAgICAgICAgIGVfc3RvcChlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN0YXJ0OiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgcmV0dXJuIG9uRHJhZ1N0YXJ0KGNtLCBlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZHJvcDogb3BlcmF0aW9uKGNtLCBvbkRyb3ApLFxuICAgICAgICBsZWF2ZTogZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGlmICghc2lnbmFsRE9NRXZlbnQoY20sIGUpKSB7XG4gICAgICAgICAgICBjbGVhckRyYWdDdXJzb3IoY20pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciBpbnAgPSBkLmlucHV0LmdldEZpZWxkKCk7XG4gICAgICBvbihpbnAsIFwia2V5dXBcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICByZXR1cm4gb25LZXlVcC5jYWxsKGNtLCBlKTtcbiAgICAgIH0pO1xuICAgICAgb24oaW5wLCBcImtleWRvd25cIiwgb3BlcmF0aW9uKGNtLCBvbktleURvd24pKTtcbiAgICAgIG9uKGlucCwgXCJrZXlwcmVzc1wiLCBvcGVyYXRpb24oY20sIG9uS2V5UHJlc3MpKTtcbiAgICAgIG9uKGlucCwgXCJmb2N1c1wiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHJldHVybiBvbkZvY3VzKGNtLCBlKTtcbiAgICAgIH0pO1xuICAgICAgb24oaW5wLCBcImJsdXJcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICByZXR1cm4gb25CbHVyKGNtLCBlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBfX25hbWUocmVnaXN0ZXJFdmVudEhhbmRsZXJzLCBcInJlZ2lzdGVyRXZlbnRIYW5kbGVyc1wiKTtcbiAgICB2YXIgaW5pdEhvb2tzID0gW107XG4gICAgQ29kZU1pcnJvcjIuZGVmaW5lSW5pdEhvb2sgPSBmdW5jdGlvbihmKSB7XG4gICAgICByZXR1cm4gaW5pdEhvb2tzLnB1c2goZik7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBpbmRlbnRMaW5lKGNtLCBuLCBob3csIGFnZ3Jlc3NpdmUpIHtcbiAgICAgIHZhciBkb2MgPSBjbS5kb2MsIHN0YXRlO1xuICAgICAgaWYgKGhvdyA9PSBudWxsKSB7XG4gICAgICAgIGhvdyA9IFwiYWRkXCI7XG4gICAgICB9XG4gICAgICBpZiAoaG93ID09IFwic21hcnRcIikge1xuICAgICAgICBpZiAoIWRvYy5tb2RlLmluZGVudCkge1xuICAgICAgICAgIGhvdyA9IFwicHJldlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlID0gZ2V0Q29udGV4dEJlZm9yZShjbSwgbikuc3RhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciB0YWJTaXplID0gY20ub3B0aW9ucy50YWJTaXplO1xuICAgICAgdmFyIGxpbmUgPSBnZXRMaW5lKGRvYywgbiksIGN1clNwYWNlID0gY291bnRDb2x1bW4obGluZS50ZXh0LCBudWxsLCB0YWJTaXplKTtcbiAgICAgIGlmIChsaW5lLnN0YXRlQWZ0ZXIpIHtcbiAgICAgICAgbGluZS5zdGF0ZUFmdGVyID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBjdXJTcGFjZVN0cmluZyA9IGxpbmUudGV4dC5tYXRjaCgvXlxccyovKVswXSwgaW5kZW50YXRpb247XG4gICAgICBpZiAoIWFnZ3Jlc3NpdmUgJiYgIS9cXFMvLnRlc3QobGluZS50ZXh0KSkge1xuICAgICAgICBpbmRlbnRhdGlvbiA9IDA7XG4gICAgICAgIGhvdyA9IFwibm90XCI7XG4gICAgICB9IGVsc2UgaWYgKGhvdyA9PSBcInNtYXJ0XCIpIHtcbiAgICAgICAgaW5kZW50YXRpb24gPSBkb2MubW9kZS5pbmRlbnQoc3RhdGUsIGxpbmUudGV4dC5zbGljZShjdXJTcGFjZVN0cmluZy5sZW5ndGgpLCBsaW5lLnRleHQpO1xuICAgICAgICBpZiAoaW5kZW50YXRpb24gPT0gUGFzcyB8fCBpbmRlbnRhdGlvbiA+IDE1MCkge1xuICAgICAgICAgIGlmICghYWdncmVzc2l2ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBob3cgPSBcInByZXZcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGhvdyA9PSBcInByZXZcIikge1xuICAgICAgICBpZiAobiA+IGRvYy5maXJzdCkge1xuICAgICAgICAgIGluZGVudGF0aW9uID0gY291bnRDb2x1bW4oZ2V0TGluZShkb2MsIG4gLSAxKS50ZXh0LCBudWxsLCB0YWJTaXplKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmRlbnRhdGlvbiA9IDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaG93ID09IFwiYWRkXCIpIHtcbiAgICAgICAgaW5kZW50YXRpb24gPSBjdXJTcGFjZSArIGNtLm9wdGlvbnMuaW5kZW50VW5pdDtcbiAgICAgIH0gZWxzZSBpZiAoaG93ID09IFwic3VidHJhY3RcIikge1xuICAgICAgICBpbmRlbnRhdGlvbiA9IGN1clNwYWNlIC0gY20ub3B0aW9ucy5pbmRlbnRVbml0O1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaG93ID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgaW5kZW50YXRpb24gPSBjdXJTcGFjZSArIGhvdztcbiAgICAgIH1cbiAgICAgIGluZGVudGF0aW9uID0gTWF0aC5tYXgoMCwgaW5kZW50YXRpb24pO1xuICAgICAgdmFyIGluZGVudFN0cmluZyA9IFwiXCIsIHBvcyA9IDA7XG4gICAgICBpZiAoY20ub3B0aW9ucy5pbmRlbnRXaXRoVGFicykge1xuICAgICAgICBmb3IgKHZhciBpMiA9IE1hdGguZmxvb3IoaW5kZW50YXRpb24gLyB0YWJTaXplKTsgaTI7IC0taTIpIHtcbiAgICAgICAgICBwb3MgKz0gdGFiU2l6ZTtcbiAgICAgICAgICBpbmRlbnRTdHJpbmcgKz0gXCJcdFwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocG9zIDwgaW5kZW50YXRpb24pIHtcbiAgICAgICAgaW5kZW50U3RyaW5nICs9IHNwYWNlU3RyKGluZGVudGF0aW9uIC0gcG9zKTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmRlbnRTdHJpbmcgIT0gY3VyU3BhY2VTdHJpbmcpIHtcbiAgICAgICAgcmVwbGFjZVJhbmdlKGRvYywgaW5kZW50U3RyaW5nLCBQb3MobiwgMCksIFBvcyhuLCBjdXJTcGFjZVN0cmluZy5sZW5ndGgpLCBcIitpbnB1dFwiKTtcbiAgICAgICAgbGluZS5zdGF0ZUFmdGVyID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpJDEyID0gMDsgaSQxMiA8IGRvYy5zZWwucmFuZ2VzLmxlbmd0aDsgaSQxMisrKSB7XG4gICAgICAgICAgdmFyIHJhbmdlMiA9IGRvYy5zZWwucmFuZ2VzW2kkMTJdO1xuICAgICAgICAgIGlmIChyYW5nZTIuaGVhZC5saW5lID09IG4gJiYgcmFuZ2UyLmhlYWQuY2ggPCBjdXJTcGFjZVN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBwb3MkMSA9IFBvcyhuLCBjdXJTcGFjZVN0cmluZy5sZW5ndGgpO1xuICAgICAgICAgICAgcmVwbGFjZU9uZVNlbGVjdGlvbihkb2MsIGkkMTIsIG5ldyBSYW5nZShwb3MkMSwgcG9zJDEpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoaW5kZW50TGluZSwgXCJpbmRlbnRMaW5lXCIpO1xuICAgIHZhciBsYXN0Q29waWVkID0gbnVsbDtcbiAgICBmdW5jdGlvbiBzZXRMYXN0Q29waWVkKG5ld0xhc3RDb3BpZWQpIHtcbiAgICAgIGxhc3RDb3BpZWQgPSBuZXdMYXN0Q29waWVkO1xuICAgIH1cbiAgICBfX25hbWUoc2V0TGFzdENvcGllZCwgXCJzZXRMYXN0Q29waWVkXCIpO1xuICAgIGZ1bmN0aW9uIGFwcGx5VGV4dElucHV0KGNtLCBpbnNlcnRlZCwgZGVsZXRlZCwgc2VsLCBvcmlnaW4pIHtcbiAgICAgIHZhciBkb2MgPSBjbS5kb2M7XG4gICAgICBjbS5kaXNwbGF5LnNoaWZ0ID0gZmFsc2U7XG4gICAgICBpZiAoIXNlbCkge1xuICAgICAgICBzZWwgPSBkb2Muc2VsO1xuICAgICAgfVxuICAgICAgdmFyIHJlY2VudCA9ICtuZXcgRGF0ZSgpIC0gMjAwO1xuICAgICAgdmFyIHBhc3RlID0gb3JpZ2luID09IFwicGFzdGVcIiB8fCBjbS5zdGF0ZS5wYXN0ZUluY29taW5nID4gcmVjZW50O1xuICAgICAgdmFyIHRleHRMaW5lcyA9IHNwbGl0TGluZXNBdXRvKGluc2VydGVkKSwgbXVsdGlQYXN0ZSA9IG51bGw7XG4gICAgICBpZiAocGFzdGUgJiYgc2VsLnJhbmdlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGlmIChsYXN0Q29waWVkICYmIGxhc3RDb3BpZWQudGV4dC5qb2luKFwiXFxuXCIpID09IGluc2VydGVkKSB7XG4gICAgICAgICAgaWYgKHNlbC5yYW5nZXMubGVuZ3RoICUgbGFzdENvcGllZC50ZXh0Lmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICBtdWx0aVBhc3RlID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgbGFzdENvcGllZC50ZXh0Lmxlbmd0aDsgaTIrKykge1xuICAgICAgICAgICAgICBtdWx0aVBhc3RlLnB1c2goZG9jLnNwbGl0TGluZXMobGFzdENvcGllZC50ZXh0W2kyXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0ZXh0TGluZXMubGVuZ3RoID09IHNlbC5yYW5nZXMubGVuZ3RoICYmIGNtLm9wdGlvbnMucGFzdGVMaW5lc1BlclNlbGVjdGlvbikge1xuICAgICAgICAgIG11bHRpUGFzdGUgPSBtYXAodGV4dExpbmVzLCBmdW5jdGlvbihsKSB7XG4gICAgICAgICAgICByZXR1cm4gW2xdO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgdXBkYXRlSW5wdXQgPSBjbS5jdXJPcC51cGRhdGVJbnB1dDtcbiAgICAgIGZvciAodmFyIGkkMTIgPSBzZWwucmFuZ2VzLmxlbmd0aCAtIDE7IGkkMTIgPj0gMDsgaSQxMi0tKSB7XG4gICAgICAgIHZhciByYW5nZTIgPSBzZWwucmFuZ2VzW2kkMTJdO1xuICAgICAgICB2YXIgZnJvbSA9IHJhbmdlMi5mcm9tKCksIHRvID0gcmFuZ2UyLnRvKCk7XG4gICAgICAgIGlmIChyYW5nZTIuZW1wdHkoKSkge1xuICAgICAgICAgIGlmIChkZWxldGVkICYmIGRlbGV0ZWQgPiAwKSB7XG4gICAgICAgICAgICBmcm9tID0gUG9zKGZyb20ubGluZSwgZnJvbS5jaCAtIGRlbGV0ZWQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY20uc3RhdGUub3ZlcndyaXRlICYmICFwYXN0ZSkge1xuICAgICAgICAgICAgdG8gPSBQb3ModG8ubGluZSwgTWF0aC5taW4oZ2V0TGluZShkb2MsIHRvLmxpbmUpLnRleHQubGVuZ3RoLCB0by5jaCArIGxzdCh0ZXh0TGluZXMpLmxlbmd0aCkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocGFzdGUgJiYgbGFzdENvcGllZCAmJiBsYXN0Q29waWVkLmxpbmVXaXNlICYmIGxhc3RDb3BpZWQudGV4dC5qb2luKFwiXFxuXCIpID09IHRleHRMaW5lcy5qb2luKFwiXFxuXCIpKSB7XG4gICAgICAgICAgICBmcm9tID0gdG8gPSBQb3MoZnJvbS5saW5lLCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoYW5nZUV2ZW50ID0ge1xuICAgICAgICAgIGZyb20sXG4gICAgICAgICAgdG8sXG4gICAgICAgICAgdGV4dDogbXVsdGlQYXN0ZSA/IG11bHRpUGFzdGVbaSQxMiAlIG11bHRpUGFzdGUubGVuZ3RoXSA6IHRleHRMaW5lcyxcbiAgICAgICAgICBvcmlnaW46IG9yaWdpbiB8fCAocGFzdGUgPyBcInBhc3RlXCIgOiBjbS5zdGF0ZS5jdXRJbmNvbWluZyA+IHJlY2VudCA/IFwiY3V0XCIgOiBcIitpbnB1dFwiKVxuICAgICAgICB9O1xuICAgICAgICBtYWtlQ2hhbmdlKGNtLmRvYywgY2hhbmdlRXZlbnQpO1xuICAgICAgICBzaWduYWxMYXRlcihjbSwgXCJpbnB1dFJlYWRcIiwgY20sIGNoYW5nZUV2ZW50KTtcbiAgICAgIH1cbiAgICAgIGlmIChpbnNlcnRlZCAmJiAhcGFzdGUpIHtcbiAgICAgICAgdHJpZ2dlckVsZWN0cmljKGNtLCBpbnNlcnRlZCk7XG4gICAgICB9XG4gICAgICBlbnN1cmVDdXJzb3JWaXNpYmxlKGNtKTtcbiAgICAgIGlmIChjbS5jdXJPcC51cGRhdGVJbnB1dCA8IDIpIHtcbiAgICAgICAgY20uY3VyT3AudXBkYXRlSW5wdXQgPSB1cGRhdGVJbnB1dDtcbiAgICAgIH1cbiAgICAgIGNtLmN1ck9wLnR5cGluZyA9IHRydWU7XG4gICAgICBjbS5zdGF0ZS5wYXN0ZUluY29taW5nID0gY20uc3RhdGUuY3V0SW5jb21pbmcgPSAtMTtcbiAgICB9XG4gICAgX19uYW1lKGFwcGx5VGV4dElucHV0LCBcImFwcGx5VGV4dElucHV0XCIpO1xuICAgIGZ1bmN0aW9uIGhhbmRsZVBhc3RlKGUsIGNtKSB7XG4gICAgICB2YXIgcGFzdGVkID0gZS5jbGlwYm9hcmREYXRhICYmIGUuY2xpcGJvYXJkRGF0YS5nZXREYXRhKFwiVGV4dFwiKTtcbiAgICAgIGlmIChwYXN0ZWQpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZiAoIWNtLmlzUmVhZE9ubHkoKSAmJiAhY20ub3B0aW9ucy5kaXNhYmxlSW5wdXQpIHtcbiAgICAgICAgICBydW5Jbk9wKGNtLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBhcHBseVRleHRJbnB1dChjbSwgcGFzdGVkLCAwLCBudWxsLCBcInBhc3RlXCIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoaGFuZGxlUGFzdGUsIFwiaGFuZGxlUGFzdGVcIik7XG4gICAgZnVuY3Rpb24gdHJpZ2dlckVsZWN0cmljKGNtLCBpbnNlcnRlZCkge1xuICAgICAgaWYgKCFjbS5vcHRpb25zLmVsZWN0cmljQ2hhcnMgfHwgIWNtLm9wdGlvbnMuc21hcnRJbmRlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHNlbCA9IGNtLmRvYy5zZWw7XG4gICAgICBmb3IgKHZhciBpMiA9IHNlbC5yYW5nZXMubGVuZ3RoIC0gMTsgaTIgPj0gMDsgaTItLSkge1xuICAgICAgICB2YXIgcmFuZ2UyID0gc2VsLnJhbmdlc1tpMl07XG4gICAgICAgIGlmIChyYW5nZTIuaGVhZC5jaCA+IDEwMCB8fCBpMiAmJiBzZWwucmFuZ2VzW2kyIC0gMV0uaGVhZC5saW5lID09IHJhbmdlMi5oZWFkLmxpbmUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbW9kZSA9IGNtLmdldE1vZGVBdChyYW5nZTIuaGVhZCk7XG4gICAgICAgIHZhciBpbmRlbnRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAobW9kZS5lbGVjdHJpY0NoYXJzKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtb2RlLmVsZWN0cmljQ2hhcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChpbnNlcnRlZC5pbmRleE9mKG1vZGUuZWxlY3RyaWNDaGFycy5jaGFyQXQoaikpID4gLTEpIHtcbiAgICAgICAgICAgICAgaW5kZW50ZWQgPSBpbmRlbnRMaW5lKGNtLCByYW5nZTIuaGVhZC5saW5lLCBcInNtYXJ0XCIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobW9kZS5lbGVjdHJpY0lucHV0KSB7XG4gICAgICAgICAgaWYgKG1vZGUuZWxlY3RyaWNJbnB1dC50ZXN0KGdldExpbmUoY20uZG9jLCByYW5nZTIuaGVhZC5saW5lKS50ZXh0LnNsaWNlKDAsIHJhbmdlMi5oZWFkLmNoKSkpIHtcbiAgICAgICAgICAgIGluZGVudGVkID0gaW5kZW50TGluZShjbSwgcmFuZ2UyLmhlYWQubGluZSwgXCJzbWFydFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGVudGVkKSB7XG4gICAgICAgICAgc2lnbmFsTGF0ZXIoY20sIFwiZWxlY3RyaWNJbnB1dFwiLCBjbSwgcmFuZ2UyLmhlYWQubGluZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKHRyaWdnZXJFbGVjdHJpYywgXCJ0cmlnZ2VyRWxlY3RyaWNcIik7XG4gICAgZnVuY3Rpb24gY29weWFibGVSYW5nZXMoY20pIHtcbiAgICAgIHZhciB0ZXh0ID0gW10sIHJhbmdlcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IGNtLmRvYy5zZWwucmFuZ2VzLmxlbmd0aDsgaTIrKykge1xuICAgICAgICB2YXIgbGluZSA9IGNtLmRvYy5zZWwucmFuZ2VzW2kyXS5oZWFkLmxpbmU7XG4gICAgICAgIHZhciBsaW5lUmFuZ2UgPSB7IGFuY2hvcjogUG9zKGxpbmUsIDApLCBoZWFkOiBQb3MobGluZSArIDEsIDApIH07XG4gICAgICAgIHJhbmdlcy5wdXNoKGxpbmVSYW5nZSk7XG4gICAgICAgIHRleHQucHVzaChjbS5nZXRSYW5nZShsaW5lUmFuZ2UuYW5jaG9yLCBsaW5lUmFuZ2UuaGVhZCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgdGV4dCwgcmFuZ2VzIH07XG4gICAgfVxuICAgIF9fbmFtZShjb3B5YWJsZVJhbmdlcywgXCJjb3B5YWJsZVJhbmdlc1wiKTtcbiAgICBmdW5jdGlvbiBkaXNhYmxlQnJvd3Nlck1hZ2ljKGZpZWxkLCBzcGVsbGNoZWNrLCBhdXRvY29ycmVjdCwgYXV0b2NhcGl0YWxpemUpIHtcbiAgICAgIGZpZWxkLnNldEF0dHJpYnV0ZShcImF1dG9jb3JyZWN0XCIsIGF1dG9jb3JyZWN0ID8gXCJcIiA6IFwib2ZmXCIpO1xuICAgICAgZmllbGQuc2V0QXR0cmlidXRlKFwiYXV0b2NhcGl0YWxpemVcIiwgYXV0b2NhcGl0YWxpemUgPyBcIlwiIDogXCJvZmZcIik7XG4gICAgICBmaWVsZC5zZXRBdHRyaWJ1dGUoXCJzcGVsbGNoZWNrXCIsICEhc3BlbGxjaGVjayk7XG4gICAgfVxuICAgIF9fbmFtZShkaXNhYmxlQnJvd3Nlck1hZ2ljLCBcImRpc2FibGVCcm93c2VyTWFnaWNcIik7XG4gICAgZnVuY3Rpb24gaGlkZGVuVGV4dGFyZWEoKSB7XG4gICAgICB2YXIgdGUgPSBlbHQoXCJ0ZXh0YXJlYVwiLCBudWxsLCBudWxsLCBcInBvc2l0aW9uOiBhYnNvbHV0ZTsgYm90dG9tOiAtMWVtOyBwYWRkaW5nOiAwOyB3aWR0aDogMXB4OyBoZWlnaHQ6IDFlbTsgbWluLWhlaWdodDogMWVtOyBvdXRsaW5lOiBub25lXCIpO1xuICAgICAgdmFyIGRpdiA9IGVsdChcImRpdlwiLCBbdGVdLCBudWxsLCBcIm92ZXJmbG93OiBoaWRkZW47IHBvc2l0aW9uOiByZWxhdGl2ZTsgd2lkdGg6IDNweDsgaGVpZ2h0OiAwcHg7XCIpO1xuICAgICAgaWYgKHdlYmtpdCkge1xuICAgICAgICB0ZS5zdHlsZS53aWR0aCA9IFwiMTAwMHB4XCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZS5zZXRBdHRyaWJ1dGUoXCJ3cmFwXCIsIFwib2ZmXCIpO1xuICAgICAgfVxuICAgICAgaWYgKGlvcykge1xuICAgICAgICB0ZS5zdHlsZS5ib3JkZXIgPSBcIjFweCBzb2xpZCBibGFja1wiO1xuICAgICAgfVxuICAgICAgZGlzYWJsZUJyb3dzZXJNYWdpYyh0ZSk7XG4gICAgICByZXR1cm4gZGl2O1xuICAgIH1cbiAgICBfX25hbWUoaGlkZGVuVGV4dGFyZWEsIFwiaGlkZGVuVGV4dGFyZWFcIik7XG4gICAgZnVuY3Rpb24gYWRkRWRpdG9yTWV0aG9kcyhDb2RlTWlycm9yMykge1xuICAgICAgdmFyIG9wdGlvbkhhbmRsZXJzMiA9IENvZGVNaXJyb3IzLm9wdGlvbkhhbmRsZXJzO1xuICAgICAgdmFyIGhlbHBlcnMgPSBDb2RlTWlycm9yMy5oZWxwZXJzID0ge307XG4gICAgICBDb2RlTWlycm9yMy5wcm90b3R5cGUgPSB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiBDb2RlTWlycm9yMyxcbiAgICAgICAgZm9jdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHdpbmRvdy5mb2N1cygpO1xuICAgICAgICAgIHRoaXMuZGlzcGxheS5pbnB1dC5mb2N1cygpO1xuICAgICAgICB9LFxuICAgICAgICBzZXRPcHRpb246IGZ1bmN0aW9uKG9wdGlvbiwgdmFsdWUpIHtcbiAgICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucywgb2xkID0gb3B0aW9uc1tvcHRpb25dO1xuICAgICAgICAgIGlmIChvcHRpb25zW29wdGlvbl0gPT0gdmFsdWUgJiYgb3B0aW9uICE9IFwibW9kZVwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIG9wdGlvbnNbb3B0aW9uXSA9IHZhbHVlO1xuICAgICAgICAgIGlmIChvcHRpb25IYW5kbGVyczIuaGFzT3duUHJvcGVydHkob3B0aW9uKSkge1xuICAgICAgICAgICAgb3BlcmF0aW9uKHRoaXMsIG9wdGlvbkhhbmRsZXJzMltvcHRpb25dKSh0aGlzLCB2YWx1ZSwgb2xkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2lnbmFsKHRoaXMsIFwib3B0aW9uQ2hhbmdlXCIsIHRoaXMsIG9wdGlvbik7XG4gICAgICAgIH0sXG4gICAgICAgIGdldE9wdGlvbjogZnVuY3Rpb24ob3B0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1tvcHRpb25dO1xuICAgICAgICB9LFxuICAgICAgICBnZXREb2M6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmRvYztcbiAgICAgICAgfSxcbiAgICAgICAgYWRkS2V5TWFwOiBmdW5jdGlvbihtYXAyLCBib3R0b20pIHtcbiAgICAgICAgICB0aGlzLnN0YXRlLmtleU1hcHNbYm90dG9tID8gXCJwdXNoXCIgOiBcInVuc2hpZnRcIl0oZ2V0S2V5TWFwKG1hcDIpKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlS2V5TWFwOiBmdW5jdGlvbihtYXAyKSB7XG4gICAgICAgICAgdmFyIG1hcHMgPSB0aGlzLnN0YXRlLmtleU1hcHM7XG4gICAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IG1hcHMubGVuZ3RoOyArK2kyKSB7XG4gICAgICAgICAgICBpZiAobWFwc1tpMl0gPT0gbWFwMiB8fCBtYXBzW2kyXS5uYW1lID09IG1hcDIpIHtcbiAgICAgICAgICAgICAgbWFwcy5zcGxpY2UoaTIsIDEpO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFkZE92ZXJsYXk6IG1ldGhvZE9wKGZ1bmN0aW9uKHNwZWMsIG9wdGlvbnMpIHtcbiAgICAgICAgICB2YXIgbW9kZSA9IHNwZWMudG9rZW4gPyBzcGVjIDogQ29kZU1pcnJvcjMuZ2V0TW9kZSh0aGlzLm9wdGlvbnMsIHNwZWMpO1xuICAgICAgICAgIGlmIChtb2RlLnN0YXJ0U3RhdGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk92ZXJsYXlzIG1heSBub3QgYmUgc3RhdGVmdWwuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbnNlcnRTb3J0ZWQodGhpcy5zdGF0ZS5vdmVybGF5cywge1xuICAgICAgICAgICAgbW9kZSxcbiAgICAgICAgICAgIG1vZGVTcGVjOiBzcGVjLFxuICAgICAgICAgICAgb3BhcXVlOiBvcHRpb25zICYmIG9wdGlvbnMub3BhcXVlLFxuICAgICAgICAgICAgcHJpb3JpdHk6IG9wdGlvbnMgJiYgb3B0aW9ucy5wcmlvcml0eSB8fCAwXG4gICAgICAgICAgfSwgZnVuY3Rpb24ob3ZlcmxheSkge1xuICAgICAgICAgICAgcmV0dXJuIG92ZXJsYXkucHJpb3JpdHk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5zdGF0ZS5tb2RlR2VuKys7XG4gICAgICAgICAgcmVnQ2hhbmdlKHRoaXMpO1xuICAgICAgICB9KSxcbiAgICAgICAgcmVtb3ZlT3ZlcmxheTogbWV0aG9kT3AoZnVuY3Rpb24oc3BlYykge1xuICAgICAgICAgIHZhciBvdmVybGF5cyA9IHRoaXMuc3RhdGUub3ZlcmxheXM7XG4gICAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IG92ZXJsYXlzLmxlbmd0aDsgKytpMikge1xuICAgICAgICAgICAgdmFyIGN1ciA9IG92ZXJsYXlzW2kyXS5tb2RlU3BlYztcbiAgICAgICAgICAgIGlmIChjdXIgPT0gc3BlYyB8fCB0eXBlb2Ygc3BlYyA9PSBcInN0cmluZ1wiICYmIGN1ci5uYW1lID09IHNwZWMpIHtcbiAgICAgICAgICAgICAgb3ZlcmxheXMuc3BsaWNlKGkyLCAxKTtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5tb2RlR2VuKys7XG4gICAgICAgICAgICAgIHJlZ0NoYW5nZSh0aGlzKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIGluZGVudExpbmU6IG1ldGhvZE9wKGZ1bmN0aW9uKG4sIGRpciwgYWdncmVzc2l2ZSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgZGlyICE9IFwic3RyaW5nXCIgJiYgdHlwZW9mIGRpciAhPSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBpZiAoZGlyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgZGlyID0gdGhpcy5vcHRpb25zLnNtYXJ0SW5kZW50ID8gXCJzbWFydFwiIDogXCJwcmV2XCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkaXIgPSBkaXIgPyBcImFkZFwiIDogXCJzdWJ0cmFjdFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNMaW5lKHRoaXMuZG9jLCBuKSkge1xuICAgICAgICAgICAgaW5kZW50TGluZSh0aGlzLCBuLCBkaXIsIGFnZ3Jlc3NpdmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIGluZGVudFNlbGVjdGlvbjogbWV0aG9kT3AoZnVuY3Rpb24oaG93KSB7XG4gICAgICAgICAgdmFyIHJhbmdlcyA9IHRoaXMuZG9jLnNlbC5yYW5nZXMsIGVuZCA9IC0xO1xuICAgICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCByYW5nZXMubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UyID0gcmFuZ2VzW2kyXTtcbiAgICAgICAgICAgIGlmICghcmFuZ2UyLmVtcHR5KCkpIHtcbiAgICAgICAgICAgICAgdmFyIGZyb20gPSByYW5nZTIuZnJvbSgpLCB0byA9IHJhbmdlMi50bygpO1xuICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBNYXRoLm1heChlbmQsIGZyb20ubGluZSk7XG4gICAgICAgICAgICAgIGVuZCA9IE1hdGgubWluKHRoaXMubGFzdExpbmUoKSwgdG8ubGluZSAtICh0by5jaCA/IDAgOiAxKSkgKyAxO1xuICAgICAgICAgICAgICBmb3IgKHZhciBqID0gc3RhcnQ7IGogPCBlbmQ7ICsraikge1xuICAgICAgICAgICAgICAgIGluZGVudExpbmUodGhpcywgaiwgaG93KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgbmV3UmFuZ2VzID0gdGhpcy5kb2Muc2VsLnJhbmdlcztcbiAgICAgICAgICAgICAgaWYgKGZyb20uY2ggPT0gMCAmJiByYW5nZXMubGVuZ3RoID09IG5ld1Jhbmdlcy5sZW5ndGggJiYgbmV3UmFuZ2VzW2kyXS5mcm9tKCkuY2ggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZU9uZVNlbGVjdGlvbih0aGlzLmRvYywgaTIsIG5ldyBSYW5nZShmcm9tLCBuZXdSYW5nZXNbaTJdLnRvKCkpLCBzZWxfZG9udFNjcm9sbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmFuZ2UyLmhlYWQubGluZSA+IGVuZCkge1xuICAgICAgICAgICAgICBpbmRlbnRMaW5lKHRoaXMsIHJhbmdlMi5oZWFkLmxpbmUsIGhvdywgdHJ1ZSk7XG4gICAgICAgICAgICAgIGVuZCA9IHJhbmdlMi5oZWFkLmxpbmU7XG4gICAgICAgICAgICAgIGlmIChpMiA9PSB0aGlzLmRvYy5zZWwucHJpbUluZGV4KSB7XG4gICAgICAgICAgICAgICAgZW5zdXJlQ3Vyc29yVmlzaWJsZSh0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIGdldFRva2VuQXQ6IGZ1bmN0aW9uKHBvcywgcHJlY2lzZSkge1xuICAgICAgICAgIHJldHVybiB0YWtlVG9rZW4odGhpcywgcG9zLCBwcmVjaXNlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0TGluZVRva2VuczogZnVuY3Rpb24obGluZSwgcHJlY2lzZSkge1xuICAgICAgICAgIHJldHVybiB0YWtlVG9rZW4odGhpcywgUG9zKGxpbmUpLCBwcmVjaXNlLCB0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0VG9rZW5UeXBlQXQ6IGZ1bmN0aW9uKHBvcykge1xuICAgICAgICAgIHBvcyA9IGNsaXBQb3ModGhpcy5kb2MsIHBvcyk7XG4gICAgICAgICAgdmFyIHN0eWxlcyA9IGdldExpbmVTdHlsZXModGhpcywgZ2V0TGluZSh0aGlzLmRvYywgcG9zLmxpbmUpKTtcbiAgICAgICAgICB2YXIgYmVmb3JlID0gMCwgYWZ0ZXIgPSAoc3R5bGVzLmxlbmd0aCAtIDEpIC8gMiwgY2ggPSBwb3MuY2g7XG4gICAgICAgICAgdmFyIHR5cGU7XG4gICAgICAgICAgaWYgKGNoID09IDApIHtcbiAgICAgICAgICAgIHR5cGUgPSBzdHlsZXNbMl07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoOyA7ICkge1xuICAgICAgICAgICAgICB2YXIgbWlkID0gYmVmb3JlICsgYWZ0ZXIgPj4gMTtcbiAgICAgICAgICAgICAgaWYgKChtaWQgPyBzdHlsZXNbbWlkICogMiAtIDFdIDogMCkgPj0gY2gpIHtcbiAgICAgICAgICAgICAgICBhZnRlciA9IG1pZDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHlsZXNbbWlkICogMiArIDFdIDwgY2gpIHtcbiAgICAgICAgICAgICAgICBiZWZvcmUgPSBtaWQgKyAxO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHR5cGUgPSBzdHlsZXNbbWlkICogMiArIDJdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjdXQgPSB0eXBlID8gdHlwZS5pbmRleE9mKFwib3ZlcmxheSBcIikgOiAtMTtcbiAgICAgICAgICByZXR1cm4gY3V0IDwgMCA/IHR5cGUgOiBjdXQgPT0gMCA/IG51bGwgOiB0eXBlLnNsaWNlKDAsIGN1dCAtIDEpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRNb2RlQXQ6IGZ1bmN0aW9uKHBvcykge1xuICAgICAgICAgIHZhciBtb2RlID0gdGhpcy5kb2MubW9kZTtcbiAgICAgICAgICBpZiAoIW1vZGUuaW5uZXJNb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIENvZGVNaXJyb3IzLmlubmVyTW9kZShtb2RlLCB0aGlzLmdldFRva2VuQXQocG9zKS5zdGF0ZSkubW9kZTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0SGVscGVyOiBmdW5jdGlvbihwb3MsIHR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRIZWxwZXJzKHBvcywgdHlwZSlbMF07XG4gICAgICAgIH0sXG4gICAgICAgIGdldEhlbHBlcnM6IGZ1bmN0aW9uKHBvcywgdHlwZSkge1xuICAgICAgICAgIHZhciBmb3VuZCA9IFtdO1xuICAgICAgICAgIGlmICghaGVscGVycy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaGVscCA9IGhlbHBlcnNbdHlwZV0sIG1vZGUgPSB0aGlzLmdldE1vZGVBdChwb3MpO1xuICAgICAgICAgIGlmICh0eXBlb2YgbW9kZVt0eXBlXSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoaGVscFttb2RlW3R5cGVdXSkge1xuICAgICAgICAgICAgICBmb3VuZC5wdXNoKGhlbHBbbW9kZVt0eXBlXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAobW9kZVt0eXBlXSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IG1vZGVbdHlwZV0ubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgICAgICAgIHZhciB2YWwgPSBoZWxwW21vZGVbdHlwZV1baTJdXTtcbiAgICAgICAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgICAgIGZvdW5kLnB1c2godmFsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAobW9kZS5oZWxwZXJUeXBlICYmIGhlbHBbbW9kZS5oZWxwZXJUeXBlXSkge1xuICAgICAgICAgICAgZm91bmQucHVzaChoZWxwW21vZGUuaGVscGVyVHlwZV0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaGVscFttb2RlLm5hbWVdKSB7XG4gICAgICAgICAgICBmb3VuZC5wdXNoKGhlbHBbbW9kZS5uYW1lXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIGkkMTIgPSAwOyBpJDEyIDwgaGVscC5fZ2xvYmFsLmxlbmd0aDsgaSQxMisrKSB7XG4gICAgICAgICAgICB2YXIgY3VyID0gaGVscC5fZ2xvYmFsW2kkMTJdO1xuICAgICAgICAgICAgaWYgKGN1ci5wcmVkKG1vZGUsIHRoaXMpICYmIGluZGV4T2YoZm91bmQsIGN1ci52YWwpID09IC0xKSB7XG4gICAgICAgICAgICAgIGZvdW5kLnB1c2goY3VyLnZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0U3RhdGVBZnRlcjogZnVuY3Rpb24obGluZSwgcHJlY2lzZSkge1xuICAgICAgICAgIHZhciBkb2MgPSB0aGlzLmRvYztcbiAgICAgICAgICBsaW5lID0gY2xpcExpbmUoZG9jLCBsaW5lID09IG51bGwgPyBkb2MuZmlyc3QgKyBkb2Muc2l6ZSAtIDEgOiBsaW5lKTtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29udGV4dEJlZm9yZSh0aGlzLCBsaW5lICsgMSwgcHJlY2lzZSkuc3RhdGU7XG4gICAgICAgIH0sXG4gICAgICAgIGN1cnNvckNvb3JkczogZnVuY3Rpb24oc3RhcnQsIG1vZGUpIHtcbiAgICAgICAgICB2YXIgcG9zLCByYW5nZTIgPSB0aGlzLmRvYy5zZWwucHJpbWFyeSgpO1xuICAgICAgICAgIGlmIChzdGFydCA9PSBudWxsKSB7XG4gICAgICAgICAgICBwb3MgPSByYW5nZTIuaGVhZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzdGFydCA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBwb3MgPSBjbGlwUG9zKHRoaXMuZG9jLCBzdGFydCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvcyA9IHN0YXJ0ID8gcmFuZ2UyLmZyb20oKSA6IHJhbmdlMi50bygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY3Vyc29yQ29vcmRzKHRoaXMsIHBvcywgbW9kZSB8fCBcInBhZ2VcIik7XG4gICAgICAgIH0sXG4gICAgICAgIGNoYXJDb29yZHM6IGZ1bmN0aW9uKHBvcywgbW9kZSkge1xuICAgICAgICAgIHJldHVybiBjaGFyQ29vcmRzKHRoaXMsIGNsaXBQb3ModGhpcy5kb2MsIHBvcyksIG1vZGUgfHwgXCJwYWdlXCIpO1xuICAgICAgICB9LFxuICAgICAgICBjb29yZHNDaGFyOiBmdW5jdGlvbihjb29yZHMsIG1vZGUpIHtcbiAgICAgICAgICBjb29yZHMgPSBmcm9tQ29vcmRTeXN0ZW0odGhpcywgY29vcmRzLCBtb2RlIHx8IFwicGFnZVwiKTtcbiAgICAgICAgICByZXR1cm4gY29vcmRzQ2hhcih0aGlzLCBjb29yZHMubGVmdCwgY29vcmRzLnRvcCk7XG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVBdEhlaWdodDogZnVuY3Rpb24oaGVpZ2h0LCBtb2RlKSB7XG4gICAgICAgICAgaGVpZ2h0ID0gZnJvbUNvb3JkU3lzdGVtKHRoaXMsIHsgdG9wOiBoZWlnaHQsIGxlZnQ6IDAgfSwgbW9kZSB8fCBcInBhZ2VcIikudG9wO1xuICAgICAgICAgIHJldHVybiBsaW5lQXRIZWlnaHQodGhpcy5kb2MsIGhlaWdodCArIHRoaXMuZGlzcGxheS52aWV3T2Zmc2V0KTtcbiAgICAgICAgfSxcbiAgICAgICAgaGVpZ2h0QXRMaW5lOiBmdW5jdGlvbihsaW5lLCBtb2RlLCBpbmNsdWRlV2lkZ2V0cykge1xuICAgICAgICAgIHZhciBlbmQgPSBmYWxzZSwgbGluZU9iajtcbiAgICAgICAgICBpZiAodHlwZW9mIGxpbmUgPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdmFyIGxhc3QgPSB0aGlzLmRvYy5maXJzdCArIHRoaXMuZG9jLnNpemUgLSAxO1xuICAgICAgICAgICAgaWYgKGxpbmUgPCB0aGlzLmRvYy5maXJzdCkge1xuICAgICAgICAgICAgICBsaW5lID0gdGhpcy5kb2MuZmlyc3Q7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxpbmUgPiBsYXN0KSB7XG4gICAgICAgICAgICAgIGxpbmUgPSBsYXN0O1xuICAgICAgICAgICAgICBlbmQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGluZU9iaiA9IGdldExpbmUodGhpcy5kb2MsIGxpbmUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsaW5lT2JqID0gbGluZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGludG9Db29yZFN5c3RlbSh0aGlzLCBsaW5lT2JqLCB7IHRvcDogMCwgbGVmdDogMCB9LCBtb2RlIHx8IFwicGFnZVwiLCBpbmNsdWRlV2lkZ2V0cyB8fCBlbmQpLnRvcCArIChlbmQgPyB0aGlzLmRvYy5oZWlnaHQgLSBoZWlnaHRBdExpbmUobGluZU9iaikgOiAwKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVmYXVsdFRleHRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0ZXh0SGVpZ2h0KHRoaXMuZGlzcGxheSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlZmF1bHRDaGFyV2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBjaGFyV2lkdGgodGhpcy5kaXNwbGF5KTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Vmlld3BvcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB7IGZyb206IHRoaXMuZGlzcGxheS52aWV3RnJvbSwgdG86IHRoaXMuZGlzcGxheS52aWV3VG8gfTtcbiAgICAgICAgfSxcbiAgICAgICAgYWRkV2lkZ2V0OiBmdW5jdGlvbihwb3MsIG5vZGUsIHNjcm9sbCwgdmVydCwgaG9yaXopIHtcbiAgICAgICAgICB2YXIgZGlzcGxheSA9IHRoaXMuZGlzcGxheTtcbiAgICAgICAgICBwb3MgPSBjdXJzb3JDb29yZHModGhpcywgY2xpcFBvcyh0aGlzLmRvYywgcG9zKSk7XG4gICAgICAgICAgdmFyIHRvcCA9IHBvcy5ib3R0b20sIGxlZnQgPSBwb3MubGVmdDtcbiAgICAgICAgICBub2RlLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiY20taWdub3JlLWV2ZW50c1wiLCBcInRydWVcIik7XG4gICAgICAgICAgdGhpcy5kaXNwbGF5LmlucHV0LnNldFVuZWRpdGFibGUobm9kZSk7XG4gICAgICAgICAgZGlzcGxheS5zaXplci5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICBpZiAodmVydCA9PSBcIm92ZXJcIikge1xuICAgICAgICAgICAgdG9wID0gcG9zLnRvcDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHZlcnQgPT0gXCJhYm92ZVwiIHx8IHZlcnQgPT0gXCJuZWFyXCIpIHtcbiAgICAgICAgICAgIHZhciB2c3BhY2UgPSBNYXRoLm1heChkaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0LCB0aGlzLmRvYy5oZWlnaHQpLCBoc3BhY2UgPSBNYXRoLm1heChkaXNwbGF5LnNpemVyLmNsaWVudFdpZHRoLCBkaXNwbGF5LmxpbmVTcGFjZS5jbGllbnRXaWR0aCk7XG4gICAgICAgICAgICBpZiAoKHZlcnQgPT0gXCJhYm92ZVwiIHx8IHBvcy5ib3R0b20gKyBub2RlLm9mZnNldEhlaWdodCA+IHZzcGFjZSkgJiYgcG9zLnRvcCA+IG5vZGUub2Zmc2V0SGVpZ2h0KSB7XG4gICAgICAgICAgICAgIHRvcCA9IHBvcy50b3AgLSBub2RlLm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocG9zLmJvdHRvbSArIG5vZGUub2Zmc2V0SGVpZ2h0IDw9IHZzcGFjZSkge1xuICAgICAgICAgICAgICB0b3AgPSBwb3MuYm90dG9tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlZnQgKyBub2RlLm9mZnNldFdpZHRoID4gaHNwYWNlKSB7XG4gICAgICAgICAgICAgIGxlZnQgPSBoc3BhY2UgLSBub2RlLm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLnN0eWxlLnRvcCA9IHRvcCArIFwicHhcIjtcbiAgICAgICAgICBub2RlLnN0eWxlLmxlZnQgPSBub2RlLnN0eWxlLnJpZ2h0ID0gXCJcIjtcbiAgICAgICAgICBpZiAoaG9yaXogPT0gXCJyaWdodFwiKSB7XG4gICAgICAgICAgICBsZWZ0ID0gZGlzcGxheS5zaXplci5jbGllbnRXaWR0aCAtIG5vZGUub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICBub2RlLnN0eWxlLnJpZ2h0ID0gXCIwcHhcIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGhvcml6ID09IFwibGVmdFwiKSB7XG4gICAgICAgICAgICAgIGxlZnQgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChob3JpeiA9PSBcIm1pZGRsZVwiKSB7XG4gICAgICAgICAgICAgIGxlZnQgPSAoZGlzcGxheS5zaXplci5jbGllbnRXaWR0aCAtIG5vZGUub2Zmc2V0V2lkdGgpIC8gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUuc3R5bGUubGVmdCA9IGxlZnQgKyBcInB4XCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzY3JvbGwpIHtcbiAgICAgICAgICAgIHNjcm9sbEludG9WaWV3KHRoaXMsIHsgbGVmdCwgdG9wLCByaWdodDogbGVmdCArIG5vZGUub2Zmc2V0V2lkdGgsIGJvdHRvbTogdG9wICsgbm9kZS5vZmZzZXRIZWlnaHQgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0cmlnZ2VyT25LZXlEb3duOiBtZXRob2RPcChvbktleURvd24pLFxuICAgICAgICB0cmlnZ2VyT25LZXlQcmVzczogbWV0aG9kT3Aob25LZXlQcmVzcyksXG4gICAgICAgIHRyaWdnZXJPbktleVVwOiBvbktleVVwLFxuICAgICAgICB0cmlnZ2VyT25Nb3VzZURvd246IG1ldGhvZE9wKG9uTW91c2VEb3duKSxcbiAgICAgICAgZXhlY0NvbW1hbmQ6IGZ1bmN0aW9uKGNtZCkge1xuICAgICAgICAgIGlmIChjb21tYW5kcy5oYXNPd25Qcm9wZXJ0eShjbWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tbWFuZHNbY21kXS5jYWxsKG51bGwsIHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdHJpZ2dlckVsZWN0cmljOiBtZXRob2RPcChmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgICAgdHJpZ2dlckVsZWN0cmljKHRoaXMsIHRleHQpO1xuICAgICAgICB9KSxcbiAgICAgICAgZmluZFBvc0g6IGZ1bmN0aW9uKGZyb20sIGFtb3VudCwgdW5pdCwgdmlzdWFsbHkpIHtcbiAgICAgICAgICB2YXIgZGlyID0gMTtcbiAgICAgICAgICBpZiAoYW1vdW50IDwgMCkge1xuICAgICAgICAgICAgZGlyID0gLTE7XG4gICAgICAgICAgICBhbW91bnQgPSAtYW1vdW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgY3VyID0gY2xpcFBvcyh0aGlzLmRvYywgZnJvbSk7XG4gICAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IGFtb3VudDsgKytpMikge1xuICAgICAgICAgICAgY3VyID0gZmluZFBvc0godGhpcy5kb2MsIGN1ciwgZGlyLCB1bml0LCB2aXN1YWxseSk7XG4gICAgICAgICAgICBpZiAoY3VyLmhpdFNpZGUpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjdXI7XG4gICAgICAgIH0sXG4gICAgICAgIG1vdmVIOiBtZXRob2RPcChmdW5jdGlvbihkaXIsIHVuaXQpIHtcbiAgICAgICAgICB2YXIgdGhpcyQxJDEgPSB0aGlzO1xuICAgICAgICAgIHRoaXMuZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uKHJhbmdlMikge1xuICAgICAgICAgICAgaWYgKHRoaXMkMSQxLmRpc3BsYXkuc2hpZnQgfHwgdGhpcyQxJDEuZG9jLmV4dGVuZCB8fCByYW5nZTIuZW1wdHkoKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmluZFBvc0godGhpcyQxJDEuZG9jLCByYW5nZTIuaGVhZCwgZGlyLCB1bml0LCB0aGlzJDEkMS5vcHRpb25zLnJ0bE1vdmVWaXN1YWxseSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gZGlyIDwgMCA/IHJhbmdlMi5mcm9tKCkgOiByYW5nZTIudG8oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBzZWxfbW92ZSk7XG4gICAgICAgIH0pLFxuICAgICAgICBkZWxldGVIOiBtZXRob2RPcChmdW5jdGlvbihkaXIsIHVuaXQpIHtcbiAgICAgICAgICB2YXIgc2VsID0gdGhpcy5kb2Muc2VsLCBkb2MgPSB0aGlzLmRvYztcbiAgICAgICAgICBpZiAoc2VsLnNvbWV0aGluZ1NlbGVjdGVkKCkpIHtcbiAgICAgICAgICAgIGRvYy5yZXBsYWNlU2VsZWN0aW9uKFwiXCIsIG51bGwsIFwiK2RlbGV0ZVwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlTmVhclNlbGVjdGlvbih0aGlzLCBmdW5jdGlvbihyYW5nZTIpIHtcbiAgICAgICAgICAgICAgdmFyIG90aGVyID0gZmluZFBvc0goZG9jLCByYW5nZTIuaGVhZCwgZGlyLCB1bml0LCBmYWxzZSk7XG4gICAgICAgICAgICAgIHJldHVybiBkaXIgPCAwID8geyBmcm9tOiBvdGhlciwgdG86IHJhbmdlMi5oZWFkIH0gOiB7IGZyb206IHJhbmdlMi5oZWFkLCB0bzogb3RoZXIgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIGZpbmRQb3NWOiBmdW5jdGlvbihmcm9tLCBhbW91bnQsIHVuaXQsIGdvYWxDb2x1bW4pIHtcbiAgICAgICAgICB2YXIgZGlyID0gMSwgeCA9IGdvYWxDb2x1bW47XG4gICAgICAgICAgaWYgKGFtb3VudCA8IDApIHtcbiAgICAgICAgICAgIGRpciA9IC0xO1xuICAgICAgICAgICAgYW1vdW50ID0gLWFtb3VudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGN1ciA9IGNsaXBQb3ModGhpcy5kb2MsIGZyb20pO1xuICAgICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBhbW91bnQ7ICsraTIpIHtcbiAgICAgICAgICAgIHZhciBjb29yZHMgPSBjdXJzb3JDb29yZHModGhpcywgY3VyLCBcImRpdlwiKTtcbiAgICAgICAgICAgIGlmICh4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgeCA9IGNvb3Jkcy5sZWZ0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29vcmRzLmxlZnQgPSB4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyID0gZmluZFBvc1YodGhpcywgY29vcmRzLCBkaXIsIHVuaXQpO1xuICAgICAgICAgICAgaWYgKGN1ci5oaXRTaWRlKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY3VyO1xuICAgICAgICB9LFxuICAgICAgICBtb3ZlVjogbWV0aG9kT3AoZnVuY3Rpb24oZGlyLCB1bml0KSB7XG4gICAgICAgICAgdmFyIHRoaXMkMSQxID0gdGhpcztcbiAgICAgICAgICB2YXIgZG9jID0gdGhpcy5kb2MsIGdvYWxzID0gW107XG4gICAgICAgICAgdmFyIGNvbGxhcHNlID0gIXRoaXMuZGlzcGxheS5zaGlmdCAmJiAhZG9jLmV4dGVuZCAmJiBkb2Muc2VsLnNvbWV0aGluZ1NlbGVjdGVkKCk7XG4gICAgICAgICAgZG9jLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbihyYW5nZTIpIHtcbiAgICAgICAgICAgIGlmIChjb2xsYXBzZSkge1xuICAgICAgICAgICAgICByZXR1cm4gZGlyIDwgMCA/IHJhbmdlMi5mcm9tKCkgOiByYW5nZTIudG8oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBoZWFkUG9zID0gY3Vyc29yQ29vcmRzKHRoaXMkMSQxLCByYW5nZTIuaGVhZCwgXCJkaXZcIik7XG4gICAgICAgICAgICBpZiAocmFuZ2UyLmdvYWxDb2x1bW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgICBoZWFkUG9zLmxlZnQgPSByYW5nZTIuZ29hbENvbHVtbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdvYWxzLnB1c2goaGVhZFBvcy5sZWZ0KTtcbiAgICAgICAgICAgIHZhciBwb3MgPSBmaW5kUG9zVih0aGlzJDEkMSwgaGVhZFBvcywgZGlyLCB1bml0KTtcbiAgICAgICAgICAgIGlmICh1bml0ID09IFwicGFnZVwiICYmIHJhbmdlMiA9PSBkb2Muc2VsLnByaW1hcnkoKSkge1xuICAgICAgICAgICAgICBhZGRUb1Njcm9sbFRvcCh0aGlzJDEkMSwgY2hhckNvb3Jkcyh0aGlzJDEkMSwgcG9zLCBcImRpdlwiKS50b3AgLSBoZWFkUG9zLnRvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICAgIH0sIHNlbF9tb3ZlKTtcbiAgICAgICAgICBpZiAoZ29hbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgZG9jLnNlbC5yYW5nZXMubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgICAgICAgIGRvYy5zZWwucmFuZ2VzW2kyXS5nb2FsQ29sdW1uID0gZ29hbHNbaTJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIGZpbmRXb3JkQXQ6IGZ1bmN0aW9uKHBvcykge1xuICAgICAgICAgIHZhciBkb2MgPSB0aGlzLmRvYywgbGluZSA9IGdldExpbmUoZG9jLCBwb3MubGluZSkudGV4dDtcbiAgICAgICAgICB2YXIgc3RhcnQgPSBwb3MuY2gsIGVuZCA9IHBvcy5jaDtcbiAgICAgICAgICBpZiAobGluZSkge1xuICAgICAgICAgICAgdmFyIGhlbHBlciA9IHRoaXMuZ2V0SGVscGVyKHBvcywgXCJ3b3JkQ2hhcnNcIik7XG4gICAgICAgICAgICBpZiAoKHBvcy5zdGlja3kgPT0gXCJiZWZvcmVcIiB8fCBlbmQgPT0gbGluZS5sZW5ndGgpICYmIHN0YXJ0KSB7XG4gICAgICAgICAgICAgIC0tc3RhcnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICArK2VuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdGFydENoYXIgPSBsaW5lLmNoYXJBdChzdGFydCk7XG4gICAgICAgICAgICB2YXIgY2hlY2sgPSBpc1dvcmRDaGFyKHN0YXJ0Q2hhciwgaGVscGVyKSA/IGZ1bmN0aW9uKGNoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpc1dvcmRDaGFyKGNoLCBoZWxwZXIpO1xuICAgICAgICAgICAgfSA6IC9cXHMvLnRlc3Qoc3RhcnRDaGFyKSA/IGZ1bmN0aW9uKGNoKSB7XG4gICAgICAgICAgICAgIHJldHVybiAvXFxzLy50ZXN0KGNoKTtcbiAgICAgICAgICAgIH0gOiBmdW5jdGlvbihjaCkge1xuICAgICAgICAgICAgICByZXR1cm4gIS9cXHMvLnRlc3QoY2gpICYmICFpc1dvcmRDaGFyKGNoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3aGlsZSAoc3RhcnQgPiAwICYmIGNoZWNrKGxpbmUuY2hhckF0KHN0YXJ0IC0gMSkpKSB7XG4gICAgICAgICAgICAgIC0tc3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoZW5kIDwgbGluZS5sZW5ndGggJiYgY2hlY2sobGluZS5jaGFyQXQoZW5kKSkpIHtcbiAgICAgICAgICAgICAgKytlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgUmFuZ2UoUG9zKHBvcy5saW5lLCBzdGFydCksIFBvcyhwb3MubGluZSwgZW5kKSk7XG4gICAgICAgIH0sXG4gICAgICAgIHRvZ2dsZU92ZXJ3cml0ZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSA9PSB0aGlzLnN0YXRlLm92ZXJ3cml0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5vdmVyd3JpdGUgPSAhdGhpcy5zdGF0ZS5vdmVyd3JpdGUpIHtcbiAgICAgICAgICAgIGFkZENsYXNzKHRoaXMuZGlzcGxheS5jdXJzb3JEaXYsIFwiQ29kZU1pcnJvci1vdmVyd3JpdGVcIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJtQ2xhc3ModGhpcy5kaXNwbGF5LmN1cnNvckRpdiwgXCJDb2RlTWlycm9yLW92ZXJ3cml0ZVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2lnbmFsKHRoaXMsIFwib3ZlcndyaXRlVG9nZ2xlXCIsIHRoaXMsIHRoaXMuc3RhdGUub3ZlcndyaXRlKTtcbiAgICAgICAgfSxcbiAgICAgICAgaGFzRm9jdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmRpc3BsYXkuaW5wdXQuZ2V0RmllbGQoKSA9PSBhY3RpdmVFbHQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNSZWFkT25seTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuICEhKHRoaXMub3B0aW9ucy5yZWFkT25seSB8fCB0aGlzLmRvYy5jYW50RWRpdCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNjcm9sbFRvOiBtZXRob2RPcChmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgICAgc2Nyb2xsVG9Db29yZHModGhpcywgeCwgeSk7XG4gICAgICAgIH0pLFxuICAgICAgICBnZXRTY3JvbGxJbmZvOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgc2Nyb2xsZXIgPSB0aGlzLmRpc3BsYXkuc2Nyb2xsZXI7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IHNjcm9sbGVyLnNjcm9sbExlZnQsXG4gICAgICAgICAgICB0b3A6IHNjcm9sbGVyLnNjcm9sbFRvcCxcbiAgICAgICAgICAgIGhlaWdodDogc2Nyb2xsZXIuc2Nyb2xsSGVpZ2h0IC0gc2Nyb2xsR2FwKHRoaXMpIC0gdGhpcy5kaXNwbGF5LmJhckhlaWdodCxcbiAgICAgICAgICAgIHdpZHRoOiBzY3JvbGxlci5zY3JvbGxXaWR0aCAtIHNjcm9sbEdhcCh0aGlzKSAtIHRoaXMuZGlzcGxheS5iYXJXaWR0aCxcbiAgICAgICAgICAgIGNsaWVudEhlaWdodDogZGlzcGxheUhlaWdodCh0aGlzKSxcbiAgICAgICAgICAgIGNsaWVudFdpZHRoOiBkaXNwbGF5V2lkdGgodGhpcylcbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogbWV0aG9kT3AoZnVuY3Rpb24ocmFuZ2UyLCBtYXJnaW4pIHtcbiAgICAgICAgICBpZiAocmFuZ2UyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJhbmdlMiA9IHsgZnJvbTogdGhpcy5kb2Muc2VsLnByaW1hcnkoKS5oZWFkLCB0bzogbnVsbCB9O1xuICAgICAgICAgICAgaWYgKG1hcmdpbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIG1hcmdpbiA9IHRoaXMub3B0aW9ucy5jdXJzb3JTY3JvbGxNYXJnaW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmFuZ2UyID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJhbmdlMiA9IHsgZnJvbTogUG9zKHJhbmdlMiwgMCksIHRvOiBudWxsIH07XG4gICAgICAgICAgfSBlbHNlIGlmIChyYW5nZTIuZnJvbSA9PSBudWxsKSB7XG4gICAgICAgICAgICByYW5nZTIgPSB7IGZyb206IHJhbmdlMiwgdG86IG51bGwgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFyYW5nZTIudG8pIHtcbiAgICAgICAgICAgIHJhbmdlMi50byA9IHJhbmdlMi5mcm9tO1xuICAgICAgICAgIH1cbiAgICAgICAgICByYW5nZTIubWFyZ2luID0gbWFyZ2luIHx8IDA7XG4gICAgICAgICAgaWYgKHJhbmdlMi5mcm9tLmxpbmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2Nyb2xsVG9SYW5nZSh0aGlzLCByYW5nZTIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY3JvbGxUb0Nvb3Jkc1JhbmdlKHRoaXMsIHJhbmdlMi5mcm9tLCByYW5nZTIudG8sIHJhbmdlMi5tYXJnaW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIHNldFNpemU6IG1ldGhvZE9wKGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICB2YXIgdGhpcyQxJDEgPSB0aGlzO1xuICAgICAgICAgIHZhciBpbnRlcnByZXQgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWwgPT0gXCJudW1iZXJcIiB8fCAvXlxcZCskLy50ZXN0KFN0cmluZyh2YWwpKSA/IHZhbCArIFwicHhcIiA6IHZhbDtcbiAgICAgICAgICB9LCBcImludGVycHJldFwiKTtcbiAgICAgICAgICBpZiAod2lkdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5LndyYXBwZXIuc3R5bGUud2lkdGggPSBpbnRlcnByZXQod2lkdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGVpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheS53cmFwcGVyLnN0eWxlLmhlaWdodCA9IGludGVycHJldChoZWlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxpbmVXcmFwcGluZykge1xuICAgICAgICAgICAgY2xlYXJMaW5lTWVhc3VyZW1lbnRDYWNoZSh0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGxpbmVObzIgPSB0aGlzLmRpc3BsYXkudmlld0Zyb207XG4gICAgICAgICAgdGhpcy5kb2MuaXRlcihsaW5lTm8yLCB0aGlzLmRpc3BsYXkudmlld1RvLCBmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICBpZiAobGluZS53aWRnZXRzKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBsaW5lLndpZGdldHMubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUud2lkZ2V0c1tpMl0ubm9IU2Nyb2xsKSB7XG4gICAgICAgICAgICAgICAgICByZWdMaW5lQ2hhbmdlKHRoaXMkMSQxLCBsaW5lTm8yLCBcIndpZGdldFwiKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKytsaW5lTm8yO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuY3VyT3AuZm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgIHNpZ25hbCh0aGlzLCBcInJlZnJlc2hcIiwgdGhpcyk7XG4gICAgICAgIH0pLFxuICAgICAgICBvcGVyYXRpb246IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICByZXR1cm4gcnVuSW5PcCh0aGlzLCBmKTtcbiAgICAgICAgfSxcbiAgICAgICAgc3RhcnRPcGVyYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBzdGFydE9wZXJhdGlvbih0aGlzKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW5kT3BlcmF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gZW5kT3BlcmF0aW9uKHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICByZWZyZXNoOiBtZXRob2RPcChmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgb2xkSGVpZ2h0ID0gdGhpcy5kaXNwbGF5LmNhY2hlZFRleHRIZWlnaHQ7XG4gICAgICAgICAgcmVnQ2hhbmdlKHRoaXMpO1xuICAgICAgICAgIHRoaXMuY3VyT3AuZm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgIGNsZWFyQ2FjaGVzKHRoaXMpO1xuICAgICAgICAgIHNjcm9sbFRvQ29vcmRzKHRoaXMsIHRoaXMuZG9jLnNjcm9sbExlZnQsIHRoaXMuZG9jLnNjcm9sbFRvcCk7XG4gICAgICAgICAgdXBkYXRlR3V0dGVyU3BhY2UodGhpcy5kaXNwbGF5KTtcbiAgICAgICAgICBpZiAob2xkSGVpZ2h0ID09IG51bGwgfHwgTWF0aC5hYnMob2xkSGVpZ2h0IC0gdGV4dEhlaWdodCh0aGlzLmRpc3BsYXkpKSA+IDAuNSB8fCB0aGlzLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7XG4gICAgICAgICAgICBlc3RpbWF0ZUxpbmVIZWlnaHRzKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzaWduYWwodGhpcywgXCJyZWZyZXNoXCIsIHRoaXMpO1xuICAgICAgICB9KSxcbiAgICAgICAgc3dhcERvYzogbWV0aG9kT3AoZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgICAgdmFyIG9sZCA9IHRoaXMuZG9jO1xuICAgICAgICAgIG9sZC5jbSA9IG51bGw7XG4gICAgICAgICAgaWYgKHRoaXMuc3RhdGUuc2VsZWN0aW5nVGV4dCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZWxlY3RpbmdUZXh0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF0dGFjaERvYyh0aGlzLCBkb2MpO1xuICAgICAgICAgIGNsZWFyQ2FjaGVzKHRoaXMpO1xuICAgICAgICAgIHRoaXMuZGlzcGxheS5pbnB1dC5yZXNldCgpO1xuICAgICAgICAgIHNjcm9sbFRvQ29vcmRzKHRoaXMsIGRvYy5zY3JvbGxMZWZ0LCBkb2Muc2Nyb2xsVG9wKTtcbiAgICAgICAgICB0aGlzLmN1ck9wLmZvcmNlU2Nyb2xsID0gdHJ1ZTtcbiAgICAgICAgICBzaWduYWxMYXRlcih0aGlzLCBcInN3YXBEb2NcIiwgdGhpcywgb2xkKTtcbiAgICAgICAgICByZXR1cm4gb2xkO1xuICAgICAgICB9KSxcbiAgICAgICAgcGhyYXNlOiBmdW5jdGlvbihwaHJhc2VUZXh0KSB7XG4gICAgICAgICAgdmFyIHBocmFzZXMgPSB0aGlzLm9wdGlvbnMucGhyYXNlcztcbiAgICAgICAgICByZXR1cm4gcGhyYXNlcyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGhyYXNlcywgcGhyYXNlVGV4dCkgPyBwaHJhc2VzW3BocmFzZVRleHRdIDogcGhyYXNlVGV4dDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0SW5wdXRGaWVsZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGxheS5pbnB1dC5nZXRGaWVsZCgpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRXcmFwcGVyRWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGxheS53cmFwcGVyO1xuICAgICAgICB9LFxuICAgICAgICBnZXRTY3JvbGxlckVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmRpc3BsYXkuc2Nyb2xsZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEd1dHRlckVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmRpc3BsYXkuZ3V0dGVycztcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGV2ZW50TWl4aW4oQ29kZU1pcnJvcjMpO1xuICAgICAgQ29kZU1pcnJvcjMucmVnaXN0ZXJIZWxwZXIgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAoIWhlbHBlcnMuaGFzT3duUHJvcGVydHkodHlwZSkpIHtcbiAgICAgICAgICBoZWxwZXJzW3R5cGVdID0gQ29kZU1pcnJvcjNbdHlwZV0gPSB7IF9nbG9iYWw6IFtdIH07XG4gICAgICAgIH1cbiAgICAgICAgaGVscGVyc1t0eXBlXVtuYW1lXSA9IHZhbHVlO1xuICAgICAgfTtcbiAgICAgIENvZGVNaXJyb3IzLnJlZ2lzdGVyR2xvYmFsSGVscGVyID0gZnVuY3Rpb24odHlwZSwgbmFtZSwgcHJlZGljYXRlLCB2YWx1ZSkge1xuICAgICAgICBDb2RlTWlycm9yMy5yZWdpc3RlckhlbHBlcih0eXBlLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIGhlbHBlcnNbdHlwZV0uX2dsb2JhbC5wdXNoKHsgcHJlZDogcHJlZGljYXRlLCB2YWw6IHZhbHVlIH0pO1xuICAgICAgfTtcbiAgICB9XG4gICAgX19uYW1lKGFkZEVkaXRvck1ldGhvZHMsIFwiYWRkRWRpdG9yTWV0aG9kc1wiKTtcbiAgICBmdW5jdGlvbiBmaW5kUG9zSChkb2MsIHBvcywgZGlyLCB1bml0LCB2aXN1YWxseSkge1xuICAgICAgdmFyIG9sZFBvcyA9IHBvcztcbiAgICAgIHZhciBvcmlnRGlyID0gZGlyO1xuICAgICAgdmFyIGxpbmVPYmogPSBnZXRMaW5lKGRvYywgcG9zLmxpbmUpO1xuICAgICAgdmFyIGxpbmVEaXIgPSB2aXN1YWxseSAmJiBkb2MuZGlyZWN0aW9uID09IFwicnRsXCIgPyAtZGlyIDogZGlyO1xuICAgICAgZnVuY3Rpb24gZmluZE5leHRMaW5lKCkge1xuICAgICAgICB2YXIgbCA9IHBvcy5saW5lICsgbGluZURpcjtcbiAgICAgICAgaWYgKGwgPCBkb2MuZmlyc3QgfHwgbCA+PSBkb2MuZmlyc3QgKyBkb2Muc2l6ZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgPSBuZXcgUG9zKGwsIHBvcy5jaCwgcG9zLnN0aWNreSk7XG4gICAgICAgIHJldHVybiBsaW5lT2JqID0gZ2V0TGluZShkb2MsIGwpO1xuICAgICAgfVxuICAgICAgX19uYW1lKGZpbmROZXh0TGluZSwgXCJmaW5kTmV4dExpbmVcIik7XG4gICAgICBmdW5jdGlvbiBtb3ZlT25jZShib3VuZFRvTGluZSkge1xuICAgICAgICB2YXIgbmV4dDtcbiAgICAgICAgaWYgKHVuaXQgPT0gXCJjb2RlcG9pbnRcIikge1xuICAgICAgICAgIHZhciBjaCA9IGxpbmVPYmoudGV4dC5jaGFyQ29kZUF0KHBvcy5jaCArIChkaXIgPiAwID8gMCA6IC0xKSk7XG4gICAgICAgICAgaWYgKGlzTmFOKGNoKSkge1xuICAgICAgICAgICAgbmV4dCA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBhc3RyYWwgPSBkaXIgPiAwID8gY2ggPj0gNTUyOTYgJiYgY2ggPCA1NjMyMCA6IGNoID49IDU2MzIwICYmIGNoIDwgNTczNDM7XG4gICAgICAgICAgICBuZXh0ID0gbmV3IFBvcyhwb3MubGluZSwgTWF0aC5tYXgoMCwgTWF0aC5taW4obGluZU9iai50ZXh0Lmxlbmd0aCwgcG9zLmNoICsgZGlyICogKGFzdHJhbCA/IDIgOiAxKSkpLCAtZGlyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodmlzdWFsbHkpIHtcbiAgICAgICAgICBuZXh0ID0gbW92ZVZpc3VhbGx5KGRvYy5jbSwgbGluZU9iaiwgcG9zLCBkaXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHQgPSBtb3ZlTG9naWNhbGx5KGxpbmVPYmosIHBvcywgZGlyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dCA9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKCFib3VuZFRvTGluZSAmJiBmaW5kTmV4dExpbmUoKSkge1xuICAgICAgICAgICAgcG9zID0gZW5kT2ZMaW5lKHZpc3VhbGx5LCBkb2MuY20sIGxpbmVPYmosIHBvcy5saW5lLCBsaW5lRGlyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwb3MgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgX19uYW1lKG1vdmVPbmNlLCBcIm1vdmVPbmNlXCIpO1xuICAgICAgaWYgKHVuaXQgPT0gXCJjaGFyXCIgfHwgdW5pdCA9PSBcImNvZGVwb2ludFwiKSB7XG4gICAgICAgIG1vdmVPbmNlKCk7XG4gICAgICB9IGVsc2UgaWYgKHVuaXQgPT0gXCJjb2x1bW5cIikge1xuICAgICAgICBtb3ZlT25jZSh0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAodW5pdCA9PSBcIndvcmRcIiB8fCB1bml0ID09IFwiZ3JvdXBcIikge1xuICAgICAgICB2YXIgc2F3VHlwZSA9IG51bGwsIGdyb3VwID0gdW5pdCA9PSBcImdyb3VwXCI7XG4gICAgICAgIHZhciBoZWxwZXIgPSBkb2MuY20gJiYgZG9jLmNtLmdldEhlbHBlcihwb3MsIFwid29yZENoYXJzXCIpO1xuICAgICAgICBmb3IgKHZhciBmaXJzdCA9IHRydWU7IDsgZmlyc3QgPSBmYWxzZSkge1xuICAgICAgICAgIGlmIChkaXIgPCAwICYmICFtb3ZlT25jZSghZmlyc3QpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGN1ciA9IGxpbmVPYmoudGV4dC5jaGFyQXQocG9zLmNoKSB8fCBcIlxcblwiO1xuICAgICAgICAgIHZhciB0eXBlID0gaXNXb3JkQ2hhcihjdXIsIGhlbHBlcikgPyBcIndcIiA6IGdyb3VwICYmIGN1ciA9PSBcIlxcblwiID8gXCJuXCIgOiAhZ3JvdXAgfHwgL1xccy8udGVzdChjdXIpID8gbnVsbCA6IFwicFwiO1xuICAgICAgICAgIGlmIChncm91cCAmJiAhZmlyc3QgJiYgIXR5cGUpIHtcbiAgICAgICAgICAgIHR5cGUgPSBcInNcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNhd1R5cGUgJiYgc2F3VHlwZSAhPSB0eXBlKSB7XG4gICAgICAgICAgICBpZiAoZGlyIDwgMCkge1xuICAgICAgICAgICAgICBkaXIgPSAxO1xuICAgICAgICAgICAgICBtb3ZlT25jZSgpO1xuICAgICAgICAgICAgICBwb3Muc3RpY2t5ID0gXCJhZnRlclwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICBzYXdUeXBlID0gdHlwZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRpciA+IDAgJiYgIW1vdmVPbmNlKCFmaXJzdCkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHNraXBBdG9taWMoZG9jLCBwb3MsIG9sZFBvcywgb3JpZ0RpciwgdHJ1ZSk7XG4gICAgICBpZiAoZXF1YWxDdXJzb3JQb3Mob2xkUG9zLCByZXN1bHQpKSB7XG4gICAgICAgIHJlc3VsdC5oaXRTaWRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIF9fbmFtZShmaW5kUG9zSCwgXCJmaW5kUG9zSFwiKTtcbiAgICBmdW5jdGlvbiBmaW5kUG9zVihjbSwgcG9zLCBkaXIsIHVuaXQpIHtcbiAgICAgIHZhciBkb2MgPSBjbS5kb2MsIHggPSBwb3MubGVmdCwgeTtcbiAgICAgIGlmICh1bml0ID09IFwicGFnZVwiKSB7XG4gICAgICAgIHZhciBwYWdlU2l6ZSA9IE1hdGgubWluKGNtLmRpc3BsYXkud3JhcHBlci5jbGllbnRIZWlnaHQsIHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0KTtcbiAgICAgICAgdmFyIG1vdmVBbW91bnQgPSBNYXRoLm1heChwYWdlU2l6ZSAtIDAuNSAqIHRleHRIZWlnaHQoY20uZGlzcGxheSksIDMpO1xuICAgICAgICB5ID0gKGRpciA+IDAgPyBwb3MuYm90dG9tIDogcG9zLnRvcCkgKyBkaXIgKiBtb3ZlQW1vdW50O1xuICAgICAgfSBlbHNlIGlmICh1bml0ID09IFwibGluZVwiKSB7XG4gICAgICAgIHkgPSBkaXIgPiAwID8gcG9zLmJvdHRvbSArIDMgOiBwb3MudG9wIC0gMztcbiAgICAgIH1cbiAgICAgIHZhciB0YXJnZXQ7XG4gICAgICBmb3IgKDsgOyApIHtcbiAgICAgICAgdGFyZ2V0ID0gY29vcmRzQ2hhcihjbSwgeCwgeSk7XG4gICAgICAgIGlmICghdGFyZ2V0Lm91dHNpZGUpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlyIDwgMCA/IHkgPD0gMCA6IHkgPj0gZG9jLmhlaWdodCkge1xuICAgICAgICAgIHRhcmdldC5oaXRTaWRlID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB5ICs9IGRpciAqIDU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICBfX25hbWUoZmluZFBvc1YsIFwiZmluZFBvc1ZcIik7XG4gICAgdmFyIENvbnRlbnRFZGl0YWJsZUlucHV0ID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbihjbSkge1xuICAgICAgdGhpcy5jbSA9IGNtO1xuICAgICAgdGhpcy5sYXN0QW5jaG9yTm9kZSA9IHRoaXMubGFzdEFuY2hvck9mZnNldCA9IHRoaXMubGFzdEZvY3VzTm9kZSA9IHRoaXMubGFzdEZvY3VzT2Zmc2V0ID0gbnVsbDtcbiAgICAgIHRoaXMucG9sbGluZyA9IG5ldyBEZWxheWVkKCk7XG4gICAgICB0aGlzLmNvbXBvc2luZyA9IG51bGw7XG4gICAgICB0aGlzLmdyYWNlUGVyaW9kID0gZmFsc2U7XG4gICAgICB0aGlzLnJlYWRET01UaW1lb3V0ID0gbnVsbDtcbiAgICB9LCBcIkNvbnRlbnRFZGl0YWJsZUlucHV0XCIpO1xuICAgIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oZGlzcGxheSkge1xuICAgICAgdmFyIHRoaXMkMSQxID0gdGhpcztcbiAgICAgIHZhciBpbnB1dCA9IHRoaXMsIGNtID0gaW5wdXQuY207XG4gICAgICB2YXIgZGl2ID0gaW5wdXQuZGl2ID0gZGlzcGxheS5saW5lRGl2O1xuICAgICAgZGl2LmNvbnRlbnRFZGl0YWJsZSA9IHRydWU7XG4gICAgICBkaXNhYmxlQnJvd3Nlck1hZ2ljKGRpdiwgY20ub3B0aW9ucy5zcGVsbGNoZWNrLCBjbS5vcHRpb25zLmF1dG9jb3JyZWN0LCBjbS5vcHRpb25zLmF1dG9jYXBpdGFsaXplKTtcbiAgICAgIGZ1bmN0aW9uIGJlbG9uZ3NUb0lucHV0KGUpIHtcbiAgICAgICAgZm9yICh2YXIgdCA9IGUudGFyZ2V0OyB0OyB0ID0gdC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgaWYgKHQgPT0gZGl2KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKC9cXGJDb2RlTWlycm9yLSg/OmxpbmUpP3dpZGdldFxcYi8udGVzdCh0LmNsYXNzTmFtZSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBfX25hbWUoYmVsb25nc1RvSW5wdXQsIFwiYmVsb25nc1RvSW5wdXRcIik7XG4gICAgICBvbihkaXYsIFwicGFzdGVcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoIWJlbG9uZ3NUb0lucHV0KGUpIHx8IHNpZ25hbERPTUV2ZW50KGNtLCBlKSB8fCBoYW5kbGVQYXN0ZShlLCBjbSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGllX3ZlcnNpb24gPD0gMTEpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KG9wZXJhdGlvbihjbSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcyQxJDEudXBkYXRlRnJvbURPTSgpO1xuICAgICAgICAgIH0pLCAyMCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgb24oZGl2LCBcImNvbXBvc2l0aW9uc3RhcnRcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzJDEkMS5jb21wb3NpbmcgPSB7IGRhdGE6IGUuZGF0YSwgZG9uZTogZmFsc2UgfTtcbiAgICAgIH0pO1xuICAgICAgb24oZGl2LCBcImNvbXBvc2l0aW9udXBkYXRlXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzJDEkMS5jb21wb3NpbmcpIHtcbiAgICAgICAgICB0aGlzJDEkMS5jb21wb3NpbmcgPSB7IGRhdGE6IGUuZGF0YSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBvbihkaXYsIFwiY29tcG9zaXRpb25lbmRcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAodGhpcyQxJDEuY29tcG9zaW5nKSB7XG4gICAgICAgICAgaWYgKGUuZGF0YSAhPSB0aGlzJDEkMS5jb21wb3NpbmcuZGF0YSkge1xuICAgICAgICAgICAgdGhpcyQxJDEucmVhZEZyb21ET01Tb29uKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMkMSQxLmNvbXBvc2luZy5kb25lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBvbihkaXYsIFwidG91Y2hzdGFydFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0LmZvcmNlQ29tcG9zaXRpb25FbmQoKTtcbiAgICAgIH0pO1xuICAgICAgb24oZGl2LCBcImlucHV0XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMkMSQxLmNvbXBvc2luZykge1xuICAgICAgICAgIHRoaXMkMSQxLnJlYWRGcm9tRE9NU29vbigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGZ1bmN0aW9uIG9uQ29weUN1dChlKSB7XG4gICAgICAgIGlmICghYmVsb25nc1RvSW5wdXQoZSkgfHwgc2lnbmFsRE9NRXZlbnQoY20sIGUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbS5zb21ldGhpbmdTZWxlY3RlZCgpKSB7XG4gICAgICAgICAgc2V0TGFzdENvcGllZCh7IGxpbmVXaXNlOiBmYWxzZSwgdGV4dDogY20uZ2V0U2VsZWN0aW9ucygpIH0pO1xuICAgICAgICAgIGlmIChlLnR5cGUgPT0gXCJjdXRcIikge1xuICAgICAgICAgICAgY20ucmVwbGFjZVNlbGVjdGlvbihcIlwiLCBudWxsLCBcImN1dFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWNtLm9wdGlvbnMubGluZVdpc2VDb3B5Q3V0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByYW5nZXMgPSBjb3B5YWJsZVJhbmdlcyhjbSk7XG4gICAgICAgICAgc2V0TGFzdENvcGllZCh7IGxpbmVXaXNlOiB0cnVlLCB0ZXh0OiByYW5nZXMudGV4dCB9KTtcbiAgICAgICAgICBpZiAoZS50eXBlID09IFwiY3V0XCIpIHtcbiAgICAgICAgICAgIGNtLm9wZXJhdGlvbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgY20uc2V0U2VsZWN0aW9ucyhyYW5nZXMucmFuZ2VzLCAwLCBzZWxfZG9udFNjcm9sbCk7XG4gICAgICAgICAgICAgIGNtLnJlcGxhY2VTZWxlY3Rpb24oXCJcIiwgbnVsbCwgXCJjdXRcIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUuY2xpcGJvYXJkRGF0YSkge1xuICAgICAgICAgIGUuY2xpcGJvYXJkRGF0YS5jbGVhckRhdGEoKTtcbiAgICAgICAgICB2YXIgY29udGVudCA9IGxhc3RDb3BpZWQudGV4dC5qb2luKFwiXFxuXCIpO1xuICAgICAgICAgIGUuY2xpcGJvYXJkRGF0YS5zZXREYXRhKFwiVGV4dFwiLCBjb250ZW50KTtcbiAgICAgICAgICBpZiAoZS5jbGlwYm9hcmREYXRhLmdldERhdGEoXCJUZXh0XCIpID09IGNvbnRlbnQpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtsdWRnZSA9IGhpZGRlblRleHRhcmVhKCksIHRlID0ga2x1ZGdlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGNtLmRpc3BsYXkubGluZVNwYWNlLmluc2VydEJlZm9yZShrbHVkZ2UsIGNtLmRpc3BsYXkubGluZVNwYWNlLmZpcnN0Q2hpbGQpO1xuICAgICAgICB0ZS52YWx1ZSA9IGxhc3RDb3BpZWQudGV4dC5qb2luKFwiXFxuXCIpO1xuICAgICAgICB2YXIgaGFkRm9jdXMgPSBhY3RpdmVFbHQoKTtcbiAgICAgICAgc2VsZWN0SW5wdXQodGUpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNtLmRpc3BsYXkubGluZVNwYWNlLnJlbW92ZUNoaWxkKGtsdWRnZSk7XG4gICAgICAgICAgaGFkRm9jdXMuZm9jdXMoKTtcbiAgICAgICAgICBpZiAoaGFkRm9jdXMgPT0gZGl2KSB7XG4gICAgICAgICAgICBpbnB1dC5zaG93UHJpbWFyeVNlbGVjdGlvbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgNTApO1xuICAgICAgfVxuICAgICAgX19uYW1lKG9uQ29weUN1dCwgXCJvbkNvcHlDdXRcIik7XG4gICAgICBvbihkaXYsIFwiY29weVwiLCBvbkNvcHlDdXQpO1xuICAgICAgb24oZGl2LCBcImN1dFwiLCBvbkNvcHlDdXQpO1xuICAgIH07XG4gICAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnNjcmVlblJlYWRlckxhYmVsQ2hhbmdlZCA9IGZ1bmN0aW9uKGxhYmVsKSB7XG4gICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgdGhpcy5kaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBsYWJlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRpdi5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIpO1xuICAgICAgfVxuICAgIH07XG4gICAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnByZXBhcmVTZWxlY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZXN1bHQgPSBwcmVwYXJlU2VsZWN0aW9uKHRoaXMuY20sIGZhbHNlKTtcbiAgICAgIHJlc3VsdC5mb2N1cyA9IGFjdGl2ZUVsdCgpID09IHRoaXMuZGl2O1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5zaG93U2VsZWN0aW9uID0gZnVuY3Rpb24oaW5mbywgdGFrZUZvY3VzKSB7XG4gICAgICBpZiAoIWluZm8gfHwgIXRoaXMuY20uZGlzcGxheS52aWV3Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaW5mby5mb2N1cyB8fCB0YWtlRm9jdXMpIHtcbiAgICAgICAgdGhpcy5zaG93UHJpbWFyeVNlbGVjdGlvbigpO1xuICAgICAgfVxuICAgICAgdGhpcy5zaG93TXVsdGlwbGVTZWxlY3Rpb25zKGluZm8pO1xuICAgIH07XG4gICAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLmdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY20uZGlzcGxheS53cmFwcGVyLm93bmVyRG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCk7XG4gICAgfTtcbiAgICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuc2hvd1ByaW1hcnlTZWxlY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWwgPSB0aGlzLmdldFNlbGVjdGlvbigpLCBjbSA9IHRoaXMuY20sIHByaW0gPSBjbS5kb2Muc2VsLnByaW1hcnkoKTtcbiAgICAgIHZhciBmcm9tID0gcHJpbS5mcm9tKCksIHRvID0gcHJpbS50bygpO1xuICAgICAgaWYgKGNtLmRpc3BsYXkudmlld1RvID09IGNtLmRpc3BsYXkudmlld0Zyb20gfHwgZnJvbS5saW5lID49IGNtLmRpc3BsYXkudmlld1RvIHx8IHRvLmxpbmUgPCBjbS5kaXNwbGF5LnZpZXdGcm9tKSB7XG4gICAgICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGN1ckFuY2hvciA9IGRvbVRvUG9zKGNtLCBzZWwuYW5jaG9yTm9kZSwgc2VsLmFuY2hvck9mZnNldCk7XG4gICAgICB2YXIgY3VyRm9jdXMgPSBkb21Ub1BvcyhjbSwgc2VsLmZvY3VzTm9kZSwgc2VsLmZvY3VzT2Zmc2V0KTtcbiAgICAgIGlmIChjdXJBbmNob3IgJiYgIWN1ckFuY2hvci5iYWQgJiYgY3VyRm9jdXMgJiYgIWN1ckZvY3VzLmJhZCAmJiBjbXAobWluUG9zKGN1ckFuY2hvciwgY3VyRm9jdXMpLCBmcm9tKSA9PSAwICYmIGNtcChtYXhQb3MoY3VyQW5jaG9yLCBjdXJGb2N1cyksIHRvKSA9PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB2aWV3ID0gY20uZGlzcGxheS52aWV3O1xuICAgICAgdmFyIHN0YXJ0ID0gZnJvbS5saW5lID49IGNtLmRpc3BsYXkudmlld0Zyb20gJiYgcG9zVG9ET00oY20sIGZyb20pIHx8IHsgbm9kZTogdmlld1swXS5tZWFzdXJlLm1hcFsyXSwgb2Zmc2V0OiAwIH07XG4gICAgICB2YXIgZW5kID0gdG8ubGluZSA8IGNtLmRpc3BsYXkudmlld1RvICYmIHBvc1RvRE9NKGNtLCB0byk7XG4gICAgICBpZiAoIWVuZCkge1xuICAgICAgICB2YXIgbWVhc3VyZSA9IHZpZXdbdmlldy5sZW5ndGggLSAxXS5tZWFzdXJlO1xuICAgICAgICB2YXIgbWFwMiA9IG1lYXN1cmUubWFwcyA/IG1lYXN1cmUubWFwc1ttZWFzdXJlLm1hcHMubGVuZ3RoIC0gMV0gOiBtZWFzdXJlLm1hcDtcbiAgICAgICAgZW5kID0geyBub2RlOiBtYXAyW21hcDIubGVuZ3RoIC0gMV0sIG9mZnNldDogbWFwMlttYXAyLmxlbmd0aCAtIDJdIC0gbWFwMlttYXAyLmxlbmd0aCAtIDNdIH07XG4gICAgICB9XG4gICAgICBpZiAoIXN0YXJ0IHx8ICFlbmQpIHtcbiAgICAgICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgb2xkID0gc2VsLnJhbmdlQ291bnQgJiYgc2VsLmdldFJhbmdlQXQoMCksIHJuZztcbiAgICAgIHRyeSB7XG4gICAgICAgIHJuZyA9IHJhbmdlKHN0YXJ0Lm5vZGUsIHN0YXJ0Lm9mZnNldCwgZW5kLm9mZnNldCwgZW5kLm5vZGUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgfVxuICAgICAgaWYgKHJuZykge1xuICAgICAgICBpZiAoIWdlY2tvICYmIGNtLnN0YXRlLmZvY3VzZWQpIHtcbiAgICAgICAgICBzZWwuY29sbGFwc2Uoc3RhcnQubm9kZSwgc3RhcnQub2Zmc2V0KTtcbiAgICAgICAgICBpZiAoIXJuZy5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgIHNlbC5hZGRSYW5nZShybmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgICAgc2VsLmFkZFJhbmdlKHJuZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9sZCAmJiBzZWwuYW5jaG9yTm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgc2VsLmFkZFJhbmdlKG9sZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZ2Vja28pIHtcbiAgICAgICAgICB0aGlzLnN0YXJ0R3JhY2VQZXJpb2QoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5yZW1lbWJlclNlbGVjdGlvbigpO1xuICAgIH07XG4gICAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnN0YXJ0R3JhY2VQZXJpb2QgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0aGlzJDEkMSA9IHRoaXM7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5ncmFjZVBlcmlvZCk7XG4gICAgICB0aGlzLmdyYWNlUGVyaW9kID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcyQxJDEuZ3JhY2VQZXJpb2QgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMkMSQxLnNlbGVjdGlvbkNoYW5nZWQoKSkge1xuICAgICAgICAgIHRoaXMkMSQxLmNtLm9wZXJhdGlvbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzJDEkMS5jbS5jdXJPcC5zZWxlY3Rpb25DaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSwgMjApO1xuICAgIH07XG4gICAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnNob3dNdWx0aXBsZVNlbGVjdGlvbnMgPSBmdW5jdGlvbihpbmZvKSB7XG4gICAgICByZW1vdmVDaGlsZHJlbkFuZEFkZCh0aGlzLmNtLmRpc3BsYXkuY3Vyc29yRGl2LCBpbmZvLmN1cnNvcnMpO1xuICAgICAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQodGhpcy5jbS5kaXNwbGF5LnNlbGVjdGlvbkRpdiwgaW5mby5zZWxlY3Rpb24pO1xuICAgIH07XG4gICAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnJlbWVtYmVyU2VsZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcbiAgICAgIHRoaXMubGFzdEFuY2hvck5vZGUgPSBzZWwuYW5jaG9yTm9kZTtcbiAgICAgIHRoaXMubGFzdEFuY2hvck9mZnNldCA9IHNlbC5hbmNob3JPZmZzZXQ7XG4gICAgICB0aGlzLmxhc3RGb2N1c05vZGUgPSBzZWwuZm9jdXNOb2RlO1xuICAgICAgdGhpcy5sYXN0Rm9jdXNPZmZzZXQgPSBzZWwuZm9jdXNPZmZzZXQ7XG4gICAgfTtcbiAgICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuc2VsZWN0aW9uSW5FZGl0b3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWwgPSB0aGlzLmdldFNlbGVjdGlvbigpO1xuICAgICAgaWYgKCFzZWwucmFuZ2VDb3VudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgbm9kZSA9IHNlbC5nZXRSYW5nZUF0KDApLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xuICAgICAgcmV0dXJuIGNvbnRhaW5zKHRoaXMuZGl2LCBub2RlKTtcbiAgICB9O1xuICAgIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuY20ub3B0aW9ucy5yZWFkT25seSAhPSBcIm5vY3Vyc29yXCIpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGlvbkluRWRpdG9yKCkgfHwgYWN0aXZlRWx0KCkgIT0gdGhpcy5kaXYpIHtcbiAgICAgICAgICB0aGlzLnNob3dTZWxlY3Rpb24odGhpcy5wcmVwYXJlU2VsZWN0aW9uKCksIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGl2LmZvY3VzKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuYmx1ciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kaXYuYmx1cigpO1xuICAgIH07XG4gICAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLmdldEZpZWxkID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5kaXY7XG4gICAgfTtcbiAgICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuc3VwcG9ydHNUb3VjaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUucmVjZWl2ZWRGb2N1cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRoaXMkMSQxID0gdGhpcztcbiAgICAgIHZhciBpbnB1dCA9IHRoaXM7XG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb25JbkVkaXRvcigpKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMkMSQxLnBvbGxTZWxlY3Rpb24oKTtcbiAgICAgICAgfSwgMjApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcnVuSW5PcCh0aGlzLmNtLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gaW5wdXQuY20uY3VyT3Auc2VsZWN0aW9uQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcG9sbCgpIHtcbiAgICAgICAgaWYgKGlucHV0LmNtLnN0YXRlLmZvY3VzZWQpIHtcbiAgICAgICAgICBpbnB1dC5wb2xsU2VsZWN0aW9uKCk7XG4gICAgICAgICAgaW5wdXQucG9sbGluZy5zZXQoaW5wdXQuY20ub3B0aW9ucy5wb2xsSW50ZXJ2YWwsIHBvbGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBfX25hbWUocG9sbCwgXCJwb2xsXCIpO1xuICAgICAgdGhpcy5wb2xsaW5nLnNldCh0aGlzLmNtLm9wdGlvbnMucG9sbEludGVydmFsLCBwb2xsKTtcbiAgICB9O1xuICAgIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5zZWxlY3Rpb25DaGFuZ2VkID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcbiAgICAgIHJldHVybiBzZWwuYW5jaG9yTm9kZSAhPSB0aGlzLmxhc3RBbmNob3JOb2RlIHx8IHNlbC5hbmNob3JPZmZzZXQgIT0gdGhpcy5sYXN0QW5jaG9yT2Zmc2V0IHx8IHNlbC5mb2N1c05vZGUgIT0gdGhpcy5sYXN0Rm9jdXNOb2RlIHx8IHNlbC5mb2N1c09mZnNldCAhPSB0aGlzLmxhc3RGb2N1c09mZnNldDtcbiAgICB9O1xuICAgIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5wb2xsU2VsZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5yZWFkRE9NVGltZW91dCAhPSBudWxsIHx8IHRoaXMuZ3JhY2VQZXJpb2QgfHwgIXRoaXMuc2VsZWN0aW9uQ2hhbmdlZCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBzZWwgPSB0aGlzLmdldFNlbGVjdGlvbigpLCBjbSA9IHRoaXMuY207XG4gICAgICBpZiAoYW5kcm9pZCAmJiBjaHJvbWUgJiYgdGhpcy5jbS5kaXNwbGF5Lmd1dHRlclNwZWNzLmxlbmd0aCAmJiBpc0luR3V0dGVyKHNlbC5hbmNob3JOb2RlKSkge1xuICAgICAgICB0aGlzLmNtLnRyaWdnZXJPbktleURvd24oeyB0eXBlOiBcImtleWRvd25cIiwga2V5Q29kZTogOCwgcHJldmVudERlZmF1bHQ6IE1hdGguYWJzIH0pO1xuICAgICAgICB0aGlzLmJsdXIoKTtcbiAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jb21wb3NpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5yZW1lbWJlclNlbGVjdGlvbigpO1xuICAgICAgdmFyIGFuY2hvciA9IGRvbVRvUG9zKGNtLCBzZWwuYW5jaG9yTm9kZSwgc2VsLmFuY2hvck9mZnNldCk7XG4gICAgICB2YXIgaGVhZCA9IGRvbVRvUG9zKGNtLCBzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQpO1xuICAgICAgaWYgKGFuY2hvciAmJiBoZWFkKSB7XG4gICAgICAgIHJ1bkluT3AoY20sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNldFNlbGVjdGlvbihjbS5kb2MsIHNpbXBsZVNlbGVjdGlvbihhbmNob3IsIGhlYWQpLCBzZWxfZG9udFNjcm9sbCk7XG4gICAgICAgICAgaWYgKGFuY2hvci5iYWQgfHwgaGVhZC5iYWQpIHtcbiAgICAgICAgICAgIGNtLmN1ck9wLnNlbGVjdGlvbkNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUucG9sbENvbnRlbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnJlYWRET01UaW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVhZERPTVRpbWVvdXQpO1xuICAgICAgICB0aGlzLnJlYWRET01UaW1lb3V0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBjbSA9IHRoaXMuY20sIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBzZWwgPSBjbS5kb2Muc2VsLnByaW1hcnkoKTtcbiAgICAgIHZhciBmcm9tID0gc2VsLmZyb20oKSwgdG8gPSBzZWwudG8oKTtcbiAgICAgIGlmIChmcm9tLmNoID09IDAgJiYgZnJvbS5saW5lID4gY20uZmlyc3RMaW5lKCkpIHtcbiAgICAgICAgZnJvbSA9IFBvcyhmcm9tLmxpbmUgLSAxLCBnZXRMaW5lKGNtLmRvYywgZnJvbS5saW5lIC0gMSkubGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0by5jaCA9PSBnZXRMaW5lKGNtLmRvYywgdG8ubGluZSkudGV4dC5sZW5ndGggJiYgdG8ubGluZSA8IGNtLmxhc3RMaW5lKCkpIHtcbiAgICAgICAgdG8gPSBQb3ModG8ubGluZSArIDEsIDApO1xuICAgICAgfVxuICAgICAgaWYgKGZyb20ubGluZSA8IGRpc3BsYXkudmlld0Zyb20gfHwgdG8ubGluZSA+IGRpc3BsYXkudmlld1RvIC0gMSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgZnJvbUluZGV4LCBmcm9tTGluZSwgZnJvbU5vZGU7XG4gICAgICBpZiAoZnJvbS5saW5lID09IGRpc3BsYXkudmlld0Zyb20gfHwgKGZyb21JbmRleCA9IGZpbmRWaWV3SW5kZXgoY20sIGZyb20ubGluZSkpID09IDApIHtcbiAgICAgICAgZnJvbUxpbmUgPSBsaW5lTm8oZGlzcGxheS52aWV3WzBdLmxpbmUpO1xuICAgICAgICBmcm9tTm9kZSA9IGRpc3BsYXkudmlld1swXS5ub2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnJvbUxpbmUgPSBsaW5lTm8oZGlzcGxheS52aWV3W2Zyb21JbmRleF0ubGluZSk7XG4gICAgICAgIGZyb21Ob2RlID0gZGlzcGxheS52aWV3W2Zyb21JbmRleCAtIDFdLm5vZGUubmV4dFNpYmxpbmc7XG4gICAgICB9XG4gICAgICB2YXIgdG9JbmRleCA9IGZpbmRWaWV3SW5kZXgoY20sIHRvLmxpbmUpO1xuICAgICAgdmFyIHRvTGluZSwgdG9Ob2RlO1xuICAgICAgaWYgKHRvSW5kZXggPT0gZGlzcGxheS52aWV3Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgdG9MaW5lID0gZGlzcGxheS52aWV3VG8gLSAxO1xuICAgICAgICB0b05vZGUgPSBkaXNwbGF5LmxpbmVEaXYubGFzdENoaWxkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9MaW5lID0gbGluZU5vKGRpc3BsYXkudmlld1t0b0luZGV4ICsgMV0ubGluZSkgLSAxO1xuICAgICAgICB0b05vZGUgPSBkaXNwbGF5LnZpZXdbdG9JbmRleCArIDFdLm5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgfVxuICAgICAgaWYgKCFmcm9tTm9kZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgbmV3VGV4dCA9IGNtLmRvYy5zcGxpdExpbmVzKGRvbVRleHRCZXR3ZWVuKGNtLCBmcm9tTm9kZSwgdG9Ob2RlLCBmcm9tTGluZSwgdG9MaW5lKSk7XG4gICAgICB2YXIgb2xkVGV4dCA9IGdldEJldHdlZW4oY20uZG9jLCBQb3MoZnJvbUxpbmUsIDApLCBQb3ModG9MaW5lLCBnZXRMaW5lKGNtLmRvYywgdG9MaW5lKS50ZXh0Lmxlbmd0aCkpO1xuICAgICAgd2hpbGUgKG5ld1RleHQubGVuZ3RoID4gMSAmJiBvbGRUZXh0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgaWYgKGxzdChuZXdUZXh0KSA9PSBsc3Qob2xkVGV4dCkpIHtcbiAgICAgICAgICBuZXdUZXh0LnBvcCgpO1xuICAgICAgICAgIG9sZFRleHQucG9wKCk7XG4gICAgICAgICAgdG9MaW5lLS07XG4gICAgICAgIH0gZWxzZSBpZiAobmV3VGV4dFswXSA9PSBvbGRUZXh0WzBdKSB7XG4gICAgICAgICAgbmV3VGV4dC5zaGlmdCgpO1xuICAgICAgICAgIG9sZFRleHQuc2hpZnQoKTtcbiAgICAgICAgICBmcm9tTGluZSsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgY3V0RnJvbnQgPSAwLCBjdXRFbmQgPSAwO1xuICAgICAgdmFyIG5ld1RvcCA9IG5ld1RleHRbMF0sIG9sZFRvcCA9IG9sZFRleHRbMF0sIG1heEN1dEZyb250ID0gTWF0aC5taW4obmV3VG9wLmxlbmd0aCwgb2xkVG9wLmxlbmd0aCk7XG4gICAgICB3aGlsZSAoY3V0RnJvbnQgPCBtYXhDdXRGcm9udCAmJiBuZXdUb3AuY2hhckNvZGVBdChjdXRGcm9udCkgPT0gb2xkVG9wLmNoYXJDb2RlQXQoY3V0RnJvbnQpKSB7XG4gICAgICAgICsrY3V0RnJvbnQ7XG4gICAgICB9XG4gICAgICB2YXIgbmV3Qm90ID0gbHN0KG5ld1RleHQpLCBvbGRCb3QgPSBsc3Qob2xkVGV4dCk7XG4gICAgICB2YXIgbWF4Q3V0RW5kID0gTWF0aC5taW4obmV3Qm90Lmxlbmd0aCAtIChuZXdUZXh0Lmxlbmd0aCA9PSAxID8gY3V0RnJvbnQgOiAwKSwgb2xkQm90Lmxlbmd0aCAtIChvbGRUZXh0Lmxlbmd0aCA9PSAxID8gY3V0RnJvbnQgOiAwKSk7XG4gICAgICB3aGlsZSAoY3V0RW5kIDwgbWF4Q3V0RW5kICYmIG5ld0JvdC5jaGFyQ29kZUF0KG5ld0JvdC5sZW5ndGggLSBjdXRFbmQgLSAxKSA9PSBvbGRCb3QuY2hhckNvZGVBdChvbGRCb3QubGVuZ3RoIC0gY3V0RW5kIC0gMSkpIHtcbiAgICAgICAgKytjdXRFbmQ7XG4gICAgICB9XG4gICAgICBpZiAobmV3VGV4dC5sZW5ndGggPT0gMSAmJiBvbGRUZXh0Lmxlbmd0aCA9PSAxICYmIGZyb21MaW5lID09IGZyb20ubGluZSkge1xuICAgICAgICB3aGlsZSAoY3V0RnJvbnQgJiYgY3V0RnJvbnQgPiBmcm9tLmNoICYmIG5ld0JvdC5jaGFyQ29kZUF0KG5ld0JvdC5sZW5ndGggLSBjdXRFbmQgLSAxKSA9PSBvbGRCb3QuY2hhckNvZGVBdChvbGRCb3QubGVuZ3RoIC0gY3V0RW5kIC0gMSkpIHtcbiAgICAgICAgICBjdXRGcm9udC0tO1xuICAgICAgICAgIGN1dEVuZCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBuZXdUZXh0W25ld1RleHQubGVuZ3RoIC0gMV0gPSBuZXdCb3Quc2xpY2UoMCwgbmV3Qm90Lmxlbmd0aCAtIGN1dEVuZCkucmVwbGFjZSgvXlxcdTIwMGIrLywgXCJcIik7XG4gICAgICBuZXdUZXh0WzBdID0gbmV3VGV4dFswXS5zbGljZShjdXRGcm9udCkucmVwbGFjZSgvXFx1MjAwYiskLywgXCJcIik7XG4gICAgICB2YXIgY2hGcm9tID0gUG9zKGZyb21MaW5lLCBjdXRGcm9udCk7XG4gICAgICB2YXIgY2hUbyA9IFBvcyh0b0xpbmUsIG9sZFRleHQubGVuZ3RoID8gbHN0KG9sZFRleHQpLmxlbmd0aCAtIGN1dEVuZCA6IDApO1xuICAgICAgaWYgKG5ld1RleHQubGVuZ3RoID4gMSB8fCBuZXdUZXh0WzBdIHx8IGNtcChjaEZyb20sIGNoVG8pKSB7XG4gICAgICAgIHJlcGxhY2VSYW5nZShjbS5kb2MsIG5ld1RleHQsIGNoRnJvbSwgY2hUbywgXCIraW5wdXRcIik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gICAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLmVuc3VyZVBvbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5mb3JjZUNvbXBvc2l0aW9uRW5kKCk7XG4gICAgfTtcbiAgICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZm9yY2VDb21wb3NpdGlvbkVuZCgpO1xuICAgIH07XG4gICAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLmZvcmNlQ29tcG9zaXRpb25FbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5jb21wb3NpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVhZERPTVRpbWVvdXQpO1xuICAgICAgdGhpcy5jb21wb3NpbmcgPSBudWxsO1xuICAgICAgdGhpcy51cGRhdGVGcm9tRE9NKCk7XG4gICAgICB0aGlzLmRpdi5ibHVyKCk7XG4gICAgICB0aGlzLmRpdi5mb2N1cygpO1xuICAgIH07XG4gICAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnJlYWRGcm9tRE9NU29vbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRoaXMkMSQxID0gdGhpcztcbiAgICAgIGlmICh0aGlzLnJlYWRET01UaW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5yZWFkRE9NVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMkMSQxLnJlYWRET01UaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMkMSQxLmNvbXBvc2luZykge1xuICAgICAgICAgIGlmICh0aGlzJDEkMS5jb21wb3NpbmcuZG9uZSkge1xuICAgICAgICAgICAgdGhpcyQxJDEuY29tcG9zaW5nID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzJDEkMS51cGRhdGVGcm9tRE9NKCk7XG4gICAgICB9LCA4MCk7XG4gICAgfTtcbiAgICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUudXBkYXRlRnJvbURPTSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRoaXMkMSQxID0gdGhpcztcbiAgICAgIGlmICh0aGlzLmNtLmlzUmVhZE9ubHkoKSB8fCAhdGhpcy5wb2xsQ29udGVudCgpKSB7XG4gICAgICAgIHJ1bkluT3AodGhpcy5jbSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHJlZ0NoYW5nZSh0aGlzJDEkMS5jbSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnNldFVuZWRpdGFibGUgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICBub2RlLmNvbnRlbnRFZGl0YWJsZSA9IFwiZmFsc2VcIjtcbiAgICB9O1xuICAgIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5vbktleVByZXNzID0gZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGUuY2hhckNvZGUgPT0gMCB8fCB0aGlzLmNvbXBvc2luZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAoIXRoaXMuY20uaXNSZWFkT25seSgpKSB7XG4gICAgICAgIG9wZXJhdGlvbih0aGlzLmNtLCBhcHBseVRleHRJbnB1dCkodGhpcy5jbSwgU3RyaW5nLmZyb21DaGFyQ29kZShlLmNoYXJDb2RlID09IG51bGwgPyBlLmtleUNvZGUgOiBlLmNoYXJDb2RlKSwgMCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUucmVhZE9ubHlDaGFuZ2VkID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICB0aGlzLmRpdi5jb250ZW50RWRpdGFibGUgPSBTdHJpbmcodmFsICE9IFwibm9jdXJzb3JcIik7XG4gICAgfTtcbiAgICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUub25Db250ZXh0TWVudSA9IGZ1bmN0aW9uKCkge1xuICAgIH07XG4gICAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnJlc2V0UG9zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICB9O1xuICAgIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5uZWVkc0NvbnRlbnRBdHRyaWJ1dGUgPSB0cnVlO1xuICAgIGZ1bmN0aW9uIHBvc1RvRE9NKGNtLCBwb3MpIHtcbiAgICAgIHZhciB2aWV3ID0gZmluZFZpZXdGb3JMaW5lKGNtLCBwb3MubGluZSk7XG4gICAgICBpZiAoIXZpZXcgfHwgdmlldy5oaWRkZW4pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgbGluZSA9IGdldExpbmUoY20uZG9jLCBwb3MubGluZSk7XG4gICAgICB2YXIgaW5mbyA9IG1hcEZyb21MaW5lVmlldyh2aWV3LCBsaW5lLCBwb3MubGluZSk7XG4gICAgICB2YXIgb3JkZXIgPSBnZXRPcmRlcihsaW5lLCBjbS5kb2MuZGlyZWN0aW9uKSwgc2lkZSA9IFwibGVmdFwiO1xuICAgICAgaWYgKG9yZGVyKSB7XG4gICAgICAgIHZhciBwYXJ0UG9zID0gZ2V0QmlkaVBhcnRBdChvcmRlciwgcG9zLmNoKTtcbiAgICAgICAgc2lkZSA9IHBhcnRQb3MgJSAyID8gXCJyaWdodFwiIDogXCJsZWZ0XCI7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gbm9kZUFuZE9mZnNldEluTGluZU1hcChpbmZvLm1hcCwgcG9zLmNoLCBzaWRlKTtcbiAgICAgIHJlc3VsdC5vZmZzZXQgPSByZXN1bHQuY29sbGFwc2UgPT0gXCJyaWdodFwiID8gcmVzdWx0LmVuZCA6IHJlc3VsdC5zdGFydDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIF9fbmFtZShwb3NUb0RPTSwgXCJwb3NUb0RPTVwiKTtcbiAgICBmdW5jdGlvbiBpc0luR3V0dGVyKG5vZGUpIHtcbiAgICAgIGZvciAodmFyIHNjYW4gPSBub2RlOyBzY2FuOyBzY2FuID0gc2Nhbi5wYXJlbnROb2RlKSB7XG4gICAgICAgIGlmICgvQ29kZU1pcnJvci1ndXR0ZXItd3JhcHBlci8udGVzdChzY2FuLmNsYXNzTmFtZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBfX25hbWUoaXNJbkd1dHRlciwgXCJpc0luR3V0dGVyXCIpO1xuICAgIGZ1bmN0aW9uIGJhZFBvcyhwb3MsIGJhZCkge1xuICAgICAgaWYgKGJhZCkge1xuICAgICAgICBwb3MuYmFkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIF9fbmFtZShiYWRQb3MsIFwiYmFkUG9zXCIpO1xuICAgIGZ1bmN0aW9uIGRvbVRleHRCZXR3ZWVuKGNtLCBmcm9tLCB0bywgZnJvbUxpbmUsIHRvTGluZSkge1xuICAgICAgdmFyIHRleHQgPSBcIlwiLCBjbG9zaW5nID0gZmFsc2UsIGxpbmVTZXAgPSBjbS5kb2MubGluZVNlcGFyYXRvcigpLCBleHRyYUxpbmVicmVhayA9IGZhbHNlO1xuICAgICAgZnVuY3Rpb24gcmVjb2duaXplTWFya2VyKGlkKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihtYXJrZXIpIHtcbiAgICAgICAgICByZXR1cm4gbWFya2VyLmlkID09IGlkO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgX19uYW1lKHJlY29nbml6ZU1hcmtlciwgXCJyZWNvZ25pemVNYXJrZXJcIik7XG4gICAgICBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgICAgaWYgKGNsb3NpbmcpIHtcbiAgICAgICAgICB0ZXh0ICs9IGxpbmVTZXA7XG4gICAgICAgICAgaWYgKGV4dHJhTGluZWJyZWFrKSB7XG4gICAgICAgICAgICB0ZXh0ICs9IGxpbmVTZXA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsb3NpbmcgPSBleHRyYUxpbmVicmVhayA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBfX25hbWUoY2xvc2UsIFwiY2xvc2VcIik7XG4gICAgICBmdW5jdGlvbiBhZGRUZXh0KHN0cikge1xuICAgICAgICBpZiAoc3RyKSB7XG4gICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICB0ZXh0ICs9IHN0cjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX19uYW1lKGFkZFRleHQsIFwiYWRkVGV4dFwiKTtcbiAgICAgIGZ1bmN0aW9uIHdhbGsobm9kZSkge1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgdmFyIGNtVGV4dCA9IG5vZGUuZ2V0QXR0cmlidXRlKFwiY20tdGV4dFwiKTtcbiAgICAgICAgICBpZiAoY21UZXh0KSB7XG4gICAgICAgICAgICBhZGRUZXh0KGNtVGV4dCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBtYXJrZXJJRCA9IG5vZGUuZ2V0QXR0cmlidXRlKFwiY20tbWFya2VyXCIpLCByYW5nZTI7XG4gICAgICAgICAgaWYgKG1hcmtlcklEKSB7XG4gICAgICAgICAgICB2YXIgZm91bmQgPSBjbS5maW5kTWFya3MoUG9zKGZyb21MaW5lLCAwKSwgUG9zKHRvTGluZSArIDEsIDApLCByZWNvZ25pemVNYXJrZXIoK21hcmtlcklEKSk7XG4gICAgICAgICAgICBpZiAoZm91bmQubGVuZ3RoICYmIChyYW5nZTIgPSBmb3VuZFswXS5maW5kKDApKSkge1xuICAgICAgICAgICAgICBhZGRUZXh0KGdldEJldHdlZW4oY20uZG9jLCByYW5nZTIuZnJvbSwgcmFuZ2UyLnRvKS5qb2luKGxpbmVTZXApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5vZGUuZ2V0QXR0cmlidXRlKFwiY29udGVudGVkaXRhYmxlXCIpID09IFwiZmFsc2VcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaXNCbG9jayA9IC9eKHByZXxkaXZ8cHxsaXx0YWJsZXxicikkL2kudGVzdChub2RlLm5vZGVOYW1lKTtcbiAgICAgICAgICBpZiAoIS9eYnIkL2kudGVzdChub2RlLm5vZGVOYW1lKSAmJiBub2RlLnRleHRDb250ZW50Lmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0Jsb2NrKSB7XG4gICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaTIrKykge1xuICAgICAgICAgICAgd2Fsayhub2RlLmNoaWxkTm9kZXNbaTJdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKC9eKHByZXxwKSQvaS50ZXN0KG5vZGUubm9kZU5hbWUpKSB7XG4gICAgICAgICAgICBleHRyYUxpbmVicmVhayA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0Jsb2NrKSB7XG4gICAgICAgICAgICBjbG9zaW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICAgICAgYWRkVGV4dChub2RlLm5vZGVWYWx1ZS5yZXBsYWNlKC9cXHUyMDBiL2csIFwiXCIpLnJlcGxhY2UoL1xcdTAwYTAvZywgXCIgXCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX19uYW1lKHdhbGssIFwid2Fsa1wiKTtcbiAgICAgIGZvciAoOyA7ICkge1xuICAgICAgICB3YWxrKGZyb20pO1xuICAgICAgICBpZiAoZnJvbSA9PSB0bykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGZyb20gPSBmcm9tLm5leHRTaWJsaW5nO1xuICAgICAgICBleHRyYUxpbmVicmVhayA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIF9fbmFtZShkb21UZXh0QmV0d2VlbiwgXCJkb21UZXh0QmV0d2VlblwiKTtcbiAgICBmdW5jdGlvbiBkb21Ub1BvcyhjbSwgbm9kZSwgb2Zmc2V0KSB7XG4gICAgICB2YXIgbGluZU5vZGU7XG4gICAgICBpZiAobm9kZSA9PSBjbS5kaXNwbGF5LmxpbmVEaXYpIHtcbiAgICAgICAgbGluZU5vZGUgPSBjbS5kaXNwbGF5LmxpbmVEaXYuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICBpZiAoIWxpbmVOb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIGJhZFBvcyhjbS5jbGlwUG9zKFBvcyhjbS5kaXNwbGF5LnZpZXdUbyAtIDEpKSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG51bGw7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxpbmVOb2RlID0gbm9kZTsgOyBsaW5lTm9kZSA9IGxpbmVOb2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBpZiAoIWxpbmVOb2RlIHx8IGxpbmVOb2RlID09IGNtLmRpc3BsYXkubGluZURpdikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsaW5lTm9kZS5wYXJlbnROb2RlICYmIGxpbmVOb2RlLnBhcmVudE5vZGUgPT0gY20uZGlzcGxheS5saW5lRGl2KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBjbS5kaXNwbGF5LnZpZXcubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgIHZhciBsaW5lVmlldyA9IGNtLmRpc3BsYXkudmlld1tpMl07XG4gICAgICAgIGlmIChsaW5lVmlldy5ub2RlID09IGxpbmVOb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIGxvY2F0ZU5vZGVJbkxpbmVWaWV3KGxpbmVWaWV3LCBub2RlLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShkb21Ub1BvcywgXCJkb21Ub1Bvc1wiKTtcbiAgICBmdW5jdGlvbiBsb2NhdGVOb2RlSW5MaW5lVmlldyhsaW5lVmlldywgbm9kZSwgb2Zmc2V0KSB7XG4gICAgICB2YXIgd3JhcHBlciA9IGxpbmVWaWV3LnRleHQuZmlyc3RDaGlsZCwgYmFkID0gZmFsc2U7XG4gICAgICBpZiAoIW5vZGUgfHwgIWNvbnRhaW5zKHdyYXBwZXIsIG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBiYWRQb3MoUG9zKGxpbmVObyhsaW5lVmlldy5saW5lKSwgMCksIHRydWUpO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUgPT0gd3JhcHBlcikge1xuICAgICAgICBiYWQgPSB0cnVlO1xuICAgICAgICBub2RlID0gd3JhcHBlci5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgIHZhciBsaW5lID0gbGluZVZpZXcucmVzdCA/IGxzdChsaW5lVmlldy5yZXN0KSA6IGxpbmVWaWV3LmxpbmU7XG4gICAgICAgICAgcmV0dXJuIGJhZFBvcyhQb3MobGluZU5vKGxpbmUpLCBsaW5lLnRleHQubGVuZ3RoKSwgYmFkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHRleHROb2RlID0gbm9kZS5ub2RlVHlwZSA9PSAzID8gbm9kZSA6IG51bGwsIHRvcE5vZGUgPSBub2RlO1xuICAgICAgaWYgKCF0ZXh0Tm9kZSAmJiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoID09IDEgJiYgbm9kZS5maXJzdENoaWxkLm5vZGVUeXBlID09IDMpIHtcbiAgICAgICAgdGV4dE5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmIChvZmZzZXQpIHtcbiAgICAgICAgICBvZmZzZXQgPSB0ZXh0Tm9kZS5ub2RlVmFsdWUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAodG9wTm9kZS5wYXJlbnROb2RlICE9IHdyYXBwZXIpIHtcbiAgICAgICAgdG9wTm9kZSA9IHRvcE5vZGUucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICAgIHZhciBtZWFzdXJlID0gbGluZVZpZXcubWVhc3VyZSwgbWFwcyA9IG1lYXN1cmUubWFwcztcbiAgICAgIGZ1bmN0aW9uIGZpbmQodGV4dE5vZGUyLCB0b3BOb2RlMiwgb2Zmc2V0Mikge1xuICAgICAgICBmb3IgKHZhciBpMiA9IC0xOyBpMiA8IChtYXBzID8gbWFwcy5sZW5ndGggOiAwKTsgaTIrKykge1xuICAgICAgICAgIHZhciBtYXAyID0gaTIgPCAwID8gbWVhc3VyZS5tYXAgOiBtYXBzW2kyXTtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1hcDIubGVuZ3RoOyBqICs9IDMpIHtcbiAgICAgICAgICAgIHZhciBjdXJOb2RlID0gbWFwMltqICsgMl07XG4gICAgICAgICAgICBpZiAoY3VyTm9kZSA9PSB0ZXh0Tm9kZTIgfHwgY3VyTm9kZSA9PSB0b3BOb2RlMikge1xuICAgICAgICAgICAgICB2YXIgbGluZTIgPSBsaW5lTm8oaTIgPCAwID8gbGluZVZpZXcubGluZSA6IGxpbmVWaWV3LnJlc3RbaTJdKTtcbiAgICAgICAgICAgICAgdmFyIGNoID0gbWFwMltqXSArIG9mZnNldDI7XG4gICAgICAgICAgICAgIGlmIChvZmZzZXQyIDwgMCB8fCBjdXJOb2RlICE9IHRleHROb2RlMikge1xuICAgICAgICAgICAgICAgIGNoID0gbWFwMltqICsgKG9mZnNldDIgPyAxIDogMCldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBQb3MobGluZTIsIGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF9fbmFtZShmaW5kLCBcImZpbmRcIik7XG4gICAgICB2YXIgZm91bmQgPSBmaW5kKHRleHROb2RlLCB0b3BOb2RlLCBvZmZzZXQpO1xuICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgIHJldHVybiBiYWRQb3MoZm91bmQsIGJhZCk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBhZnRlciA9IHRvcE5vZGUubmV4dFNpYmxpbmcsIGRpc3QgPSB0ZXh0Tm9kZSA/IHRleHROb2RlLm5vZGVWYWx1ZS5sZW5ndGggLSBvZmZzZXQgOiAwOyBhZnRlcjsgYWZ0ZXIgPSBhZnRlci5uZXh0U2libGluZykge1xuICAgICAgICBmb3VuZCA9IGZpbmQoYWZ0ZXIsIGFmdGVyLmZpcnN0Q2hpbGQsIDApO1xuICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICByZXR1cm4gYmFkUG9zKFBvcyhmb3VuZC5saW5lLCBmb3VuZC5jaCAtIGRpc3QpLCBiYWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpc3QgKz0gYWZ0ZXIudGV4dENvbnRlbnQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBiZWZvcmUgPSB0b3BOb2RlLnByZXZpb3VzU2libGluZywgZGlzdCQxID0gb2Zmc2V0OyBiZWZvcmU7IGJlZm9yZSA9IGJlZm9yZS5wcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgICAgZm91bmQgPSBmaW5kKGJlZm9yZSwgYmVmb3JlLmZpcnN0Q2hpbGQsIC0xKTtcbiAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgcmV0dXJuIGJhZFBvcyhQb3MoZm91bmQubGluZSwgZm91bmQuY2ggKyBkaXN0JDEpLCBiYWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpc3QkMSArPSBiZWZvcmUudGV4dENvbnRlbnQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShsb2NhdGVOb2RlSW5MaW5lVmlldywgXCJsb2NhdGVOb2RlSW5MaW5lVmlld1wiKTtcbiAgICB2YXIgVGV4dGFyZWFJbnB1dCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24oY20pIHtcbiAgICAgIHRoaXMuY20gPSBjbTtcbiAgICAgIHRoaXMucHJldklucHV0ID0gXCJcIjtcbiAgICAgIHRoaXMucG9sbGluZ0Zhc3QgPSBmYWxzZTtcbiAgICAgIHRoaXMucG9sbGluZyA9IG5ldyBEZWxheWVkKCk7XG4gICAgICB0aGlzLmhhc1NlbGVjdGlvbiA9IGZhbHNlO1xuICAgICAgdGhpcy5jb21wb3NpbmcgPSBudWxsO1xuICAgIH0sIFwiVGV4dGFyZWFJbnB1dFwiKTtcbiAgICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oZGlzcGxheSkge1xuICAgICAgdmFyIHRoaXMkMSQxID0gdGhpcztcbiAgICAgIHZhciBpbnB1dCA9IHRoaXMsIGNtID0gdGhpcy5jbTtcbiAgICAgIHRoaXMuY3JlYXRlRmllbGQoZGlzcGxheSk7XG4gICAgICB2YXIgdGUgPSB0aGlzLnRleHRhcmVhO1xuICAgICAgZGlzcGxheS53cmFwcGVyLmluc2VydEJlZm9yZSh0aGlzLndyYXBwZXIsIGRpc3BsYXkud3JhcHBlci5maXJzdENoaWxkKTtcbiAgICAgIGlmIChpb3MpIHtcbiAgICAgICAgdGUuc3R5bGUud2lkdGggPSBcIjBweFwiO1xuICAgICAgfVxuICAgICAgb24odGUsIFwiaW5wdXRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uID49IDkgJiYgdGhpcyQxJDEuaGFzU2VsZWN0aW9uKSB7XG4gICAgICAgICAgdGhpcyQxJDEuaGFzU2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpbnB1dC5wb2xsKCk7XG4gICAgICB9KTtcbiAgICAgIG9uKHRlLCBcInBhc3RlXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKHNpZ25hbERPTUV2ZW50KGNtLCBlKSB8fCBoYW5kbGVQYXN0ZShlLCBjbSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY20uc3RhdGUucGFzdGVJbmNvbWluZyA9ICtuZXcgRGF0ZSgpO1xuICAgICAgICBpbnB1dC5mYXN0UG9sbCgpO1xuICAgICAgfSk7XG4gICAgICBmdW5jdGlvbiBwcmVwYXJlQ29weUN1dChlKSB7XG4gICAgICAgIGlmIChzaWduYWxET01FdmVudChjbSwgZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNtLnNvbWV0aGluZ1NlbGVjdGVkKCkpIHtcbiAgICAgICAgICBzZXRMYXN0Q29waWVkKHsgbGluZVdpc2U6IGZhbHNlLCB0ZXh0OiBjbS5nZXRTZWxlY3Rpb25zKCkgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWNtLm9wdGlvbnMubGluZVdpc2VDb3B5Q3V0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByYW5nZXMgPSBjb3B5YWJsZVJhbmdlcyhjbSk7XG4gICAgICAgICAgc2V0TGFzdENvcGllZCh7IGxpbmVXaXNlOiB0cnVlLCB0ZXh0OiByYW5nZXMudGV4dCB9KTtcbiAgICAgICAgICBpZiAoZS50eXBlID09IFwiY3V0XCIpIHtcbiAgICAgICAgICAgIGNtLnNldFNlbGVjdGlvbnMocmFuZ2VzLnJhbmdlcywgbnVsbCwgc2VsX2RvbnRTY3JvbGwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnB1dC5wcmV2SW5wdXQgPSBcIlwiO1xuICAgICAgICAgICAgdGUudmFsdWUgPSByYW5nZXMudGV4dC5qb2luKFwiXFxuXCIpO1xuICAgICAgICAgICAgc2VsZWN0SW5wdXQodGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZS50eXBlID09IFwiY3V0XCIpIHtcbiAgICAgICAgICBjbS5zdGF0ZS5jdXRJbmNvbWluZyA9ICtuZXcgRGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBfX25hbWUocHJlcGFyZUNvcHlDdXQsIFwicHJlcGFyZUNvcHlDdXRcIik7XG4gICAgICBvbih0ZSwgXCJjdXRcIiwgcHJlcGFyZUNvcHlDdXQpO1xuICAgICAgb24odGUsIFwiY29weVwiLCBwcmVwYXJlQ29weUN1dCk7XG4gICAgICBvbihkaXNwbGF5LnNjcm9sbGVyLCBcInBhc3RlXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKGV2ZW50SW5XaWRnZXQoZGlzcGxheSwgZSkgfHwgc2lnbmFsRE9NRXZlbnQoY20sIGUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGUuZGlzcGF0Y2hFdmVudCkge1xuICAgICAgICAgIGNtLnN0YXRlLnBhc3RlSW5jb21pbmcgPSArbmV3IERhdGUoKTtcbiAgICAgICAgICBpbnB1dC5mb2N1cygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXZlbnQgPSBuZXcgRXZlbnQoXCJwYXN0ZVwiKTtcbiAgICAgICAgZXZlbnQuY2xpcGJvYXJkRGF0YSA9IGUuY2xpcGJvYXJkRGF0YTtcbiAgICAgICAgdGUuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICB9KTtcbiAgICAgIG9uKGRpc3BsYXkubGluZVNwYWNlLCBcInNlbGVjdHN0YXJ0XCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCFldmVudEluV2lkZ2V0KGRpc3BsYXksIGUpKSB7XG4gICAgICAgICAgZV9wcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBvbih0ZSwgXCJjb21wb3NpdGlvbnN0YXJ0XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSBjbS5nZXRDdXJzb3IoXCJmcm9tXCIpO1xuICAgICAgICBpZiAoaW5wdXQuY29tcG9zaW5nKSB7XG4gICAgICAgICAgaW5wdXQuY29tcG9zaW5nLnJhbmdlLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXQuY29tcG9zaW5nID0ge1xuICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgIHJhbmdlOiBjbS5tYXJrVGV4dChzdGFydCwgY20uZ2V0Q3Vyc29yKFwidG9cIiksIHsgY2xhc3NOYW1lOiBcIkNvZGVNaXJyb3ItY29tcG9zaW5nXCIgfSlcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgb24odGUsIFwiY29tcG9zaXRpb25lbmRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChpbnB1dC5jb21wb3NpbmcpIHtcbiAgICAgICAgICBpbnB1dC5wb2xsKCk7XG4gICAgICAgICAgaW5wdXQuY29tcG9zaW5nLnJhbmdlLmNsZWFyKCk7XG4gICAgICAgICAgaW5wdXQuY29tcG9zaW5nID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5jcmVhdGVGaWVsZCA9IGZ1bmN0aW9uKF9kaXNwbGF5KSB7XG4gICAgICB0aGlzLndyYXBwZXIgPSBoaWRkZW5UZXh0YXJlYSgpO1xuICAgICAgdGhpcy50ZXh0YXJlYSA9IHRoaXMud3JhcHBlci5maXJzdENoaWxkO1xuICAgIH07XG4gICAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUuc2NyZWVuUmVhZGVyTGFiZWxDaGFuZ2VkID0gZnVuY3Rpb24obGFiZWwpIHtcbiAgICAgIGlmIChsYWJlbCkge1xuICAgICAgICB0aGlzLnRleHRhcmVhLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgbGFiZWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50ZXh0YXJlYS5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIpO1xuICAgICAgfVxuICAgIH07XG4gICAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUucHJlcGFyZVNlbGVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNtID0gdGhpcy5jbSwgZGlzcGxheSA9IGNtLmRpc3BsYXksIGRvYyA9IGNtLmRvYztcbiAgICAgIHZhciByZXN1bHQgPSBwcmVwYXJlU2VsZWN0aW9uKGNtKTtcbiAgICAgIGlmIChjbS5vcHRpb25zLm1vdmVJbnB1dFdpdGhDdXJzb3IpIHtcbiAgICAgICAgdmFyIGhlYWRQb3MgPSBjdXJzb3JDb29yZHMoY20sIGRvYy5zZWwucHJpbWFyeSgpLmhlYWQsIFwiZGl2XCIpO1xuICAgICAgICB2YXIgd3JhcE9mZiA9IGRpc3BsYXkud3JhcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgbGluZU9mZiA9IGRpc3BsYXkubGluZURpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgcmVzdWx0LnRlVG9wID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodCAtIDEwLCBoZWFkUG9zLnRvcCArIGxpbmVPZmYudG9wIC0gd3JhcE9mZi50b3ApKTtcbiAgICAgICAgcmVzdWx0LnRlTGVmdCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGRpc3BsYXkud3JhcHBlci5jbGllbnRXaWR0aCAtIDEwLCBoZWFkUG9zLmxlZnQgKyBsaW5lT2ZmLmxlZnQgLSB3cmFwT2ZmLmxlZnQpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5zaG93U2VsZWN0aW9uID0gZnVuY3Rpb24oZHJhd24pIHtcbiAgICAgIHZhciBjbSA9IHRoaXMuY20sIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xuICAgICAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQoZGlzcGxheS5jdXJzb3JEaXYsIGRyYXduLmN1cnNvcnMpO1xuICAgICAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQoZGlzcGxheS5zZWxlY3Rpb25EaXYsIGRyYXduLnNlbGVjdGlvbik7XG4gICAgICBpZiAoZHJhd24udGVUb3AgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLndyYXBwZXIuc3R5bGUudG9wID0gZHJhd24udGVUb3AgKyBcInB4XCI7XG4gICAgICAgIHRoaXMud3JhcHBlci5zdHlsZS5sZWZ0ID0gZHJhd24udGVMZWZ0ICsgXCJweFwiO1xuICAgICAgfVxuICAgIH07XG4gICAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbih0eXBpbmcpIHtcbiAgICAgIGlmICh0aGlzLmNvbnRleHRNZW51UGVuZGluZyB8fCB0aGlzLmNvbXBvc2luZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgY20gPSB0aGlzLmNtO1xuICAgICAgaWYgKGNtLnNvbWV0aGluZ1NlbGVjdGVkKCkpIHtcbiAgICAgICAgdGhpcy5wcmV2SW5wdXQgPSBcIlwiO1xuICAgICAgICB2YXIgY29udGVudCA9IGNtLmdldFNlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLnRleHRhcmVhLnZhbHVlID0gY29udGVudDtcbiAgICAgICAgaWYgKGNtLnN0YXRlLmZvY3VzZWQpIHtcbiAgICAgICAgICBzZWxlY3RJbnB1dCh0aGlzLnRleHRhcmVhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA+PSA5KSB7XG4gICAgICAgICAgdGhpcy5oYXNTZWxlY3Rpb24gPSBjb250ZW50O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCF0eXBpbmcpIHtcbiAgICAgICAgdGhpcy5wcmV2SW5wdXQgPSB0aGlzLnRleHRhcmVhLnZhbHVlID0gXCJcIjtcbiAgICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPj0gOSkge1xuICAgICAgICAgIHRoaXMuaGFzU2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUuZ2V0RmllbGQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHRhcmVhO1xuICAgIH07XG4gICAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUuc3VwcG9ydHNUb3VjaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmNtLm9wdGlvbnMucmVhZE9ubHkgIT0gXCJub2N1cnNvclwiICYmICghbW9iaWxlIHx8IGFjdGl2ZUVsdCgpICE9IHRoaXMudGV4dGFyZWEpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy50ZXh0YXJlYS5mb2N1cygpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLmJsdXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMudGV4dGFyZWEuYmx1cigpO1xuICAgIH07XG4gICAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUucmVzZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy53cmFwcGVyLnN0eWxlLnRvcCA9IHRoaXMud3JhcHBlci5zdHlsZS5sZWZ0ID0gMDtcbiAgICB9O1xuICAgIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLnJlY2VpdmVkRm9jdXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc2xvd1BvbGwoKTtcbiAgICB9O1xuICAgIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLnNsb3dQb2xsID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdGhpcyQxJDEgPSB0aGlzO1xuICAgICAgaWYgKHRoaXMucG9sbGluZ0Zhc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5wb2xsaW5nLnNldCh0aGlzLmNtLm9wdGlvbnMucG9sbEludGVydmFsLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcyQxJDEucG9sbCgpO1xuICAgICAgICBpZiAodGhpcyQxJDEuY20uc3RhdGUuZm9jdXNlZCkge1xuICAgICAgICAgIHRoaXMkMSQxLnNsb3dQb2xsKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUuZmFzdFBvbGwgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBtaXNzZWQgPSBmYWxzZSwgaW5wdXQgPSB0aGlzO1xuICAgICAgaW5wdXQucG9sbGluZ0Zhc3QgPSB0cnVlO1xuICAgICAgZnVuY3Rpb24gcCgpIHtcbiAgICAgICAgdmFyIGNoYW5nZWQgPSBpbnB1dC5wb2xsKCk7XG4gICAgICAgIGlmICghY2hhbmdlZCAmJiAhbWlzc2VkKSB7XG4gICAgICAgICAgbWlzc2VkID0gdHJ1ZTtcbiAgICAgICAgICBpbnB1dC5wb2xsaW5nLnNldCg2MCwgcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5wdXQucG9sbGluZ0Zhc3QgPSBmYWxzZTtcbiAgICAgICAgICBpbnB1dC5zbG93UG9sbCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBfX25hbWUocCwgXCJwXCIpO1xuICAgICAgaW5wdXQucG9sbGluZy5zZXQoMjAsIHApO1xuICAgIH07XG4gICAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUucG9sbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRoaXMkMSQxID0gdGhpcztcbiAgICAgIHZhciBjbSA9IHRoaXMuY20sIGlucHV0ID0gdGhpcy50ZXh0YXJlYSwgcHJldklucHV0ID0gdGhpcy5wcmV2SW5wdXQ7XG4gICAgICBpZiAodGhpcy5jb250ZXh0TWVudVBlbmRpbmcgfHwgIWNtLnN0YXRlLmZvY3VzZWQgfHwgaGFzU2VsZWN0aW9uKGlucHV0KSAmJiAhcHJldklucHV0ICYmICF0aGlzLmNvbXBvc2luZyB8fCBjbS5pc1JlYWRPbmx5KCkgfHwgY20ub3B0aW9ucy5kaXNhYmxlSW5wdXQgfHwgY20uc3RhdGUua2V5U2VxKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB0ZXh0ID0gaW5wdXQudmFsdWU7XG4gICAgICBpZiAodGV4dCA9PSBwcmV2SW5wdXQgJiYgIWNtLnNvbWV0aGluZ1NlbGVjdGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPj0gOSAmJiB0aGlzLmhhc1NlbGVjdGlvbiA9PT0gdGV4dCB8fCBtYWMgJiYgL1tcXHVmNzAwLVxcdWY3ZmZdLy50ZXN0KHRleHQpKSB7XG4gICAgICAgIGNtLmRpc3BsYXkuaW5wdXQucmVzZXQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGNtLmRvYy5zZWwgPT0gY20uZGlzcGxheS5zZWxGb3JDb250ZXh0TWVudSkge1xuICAgICAgICB2YXIgZmlyc3QgPSB0ZXh0LmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIGlmIChmaXJzdCA9PSA4MjAzICYmICFwcmV2SW5wdXQpIHtcbiAgICAgICAgICBwcmV2SW5wdXQgPSBcIlxcdTIwMEJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlyc3QgPT0gODY2Nikge1xuICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jbS5leGVjQ29tbWFuZChcInVuZG9cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBzYW1lID0gMCwgbCA9IE1hdGgubWluKHByZXZJbnB1dC5sZW5ndGgsIHRleHQubGVuZ3RoKTtcbiAgICAgIHdoaWxlIChzYW1lIDwgbCAmJiBwcmV2SW5wdXQuY2hhckNvZGVBdChzYW1lKSA9PSB0ZXh0LmNoYXJDb2RlQXQoc2FtZSkpIHtcbiAgICAgICAgKytzYW1lO1xuICAgICAgfVxuICAgICAgcnVuSW5PcChjbSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGFwcGx5VGV4dElucHV0KGNtLCB0ZXh0LnNsaWNlKHNhbWUpLCBwcmV2SW5wdXQubGVuZ3RoIC0gc2FtZSwgbnVsbCwgdGhpcyQxJDEuY29tcG9zaW5nID8gXCIqY29tcG9zZVwiIDogbnVsbCk7XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDFlMyB8fCB0ZXh0LmluZGV4T2YoXCJcXG5cIikgPiAtMSkge1xuICAgICAgICAgIGlucHV0LnZhbHVlID0gdGhpcyQxJDEucHJldklucHV0ID0gXCJcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzJDEkMS5wcmV2SW5wdXQgPSB0ZXh0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzJDEkMS5jb21wb3NpbmcpIHtcbiAgICAgICAgICB0aGlzJDEkMS5jb21wb3NpbmcucmFuZ2UuY2xlYXIoKTtcbiAgICAgICAgICB0aGlzJDEkMS5jb21wb3NpbmcucmFuZ2UgPSBjbS5tYXJrVGV4dCh0aGlzJDEkMS5jb21wb3Npbmcuc3RhcnQsIGNtLmdldEN1cnNvcihcInRvXCIpLCB7IGNsYXNzTmFtZTogXCJDb2RlTWlycm9yLWNvbXBvc2luZ1wiIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUuZW5zdXJlUG9sbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5wb2xsaW5nRmFzdCAmJiB0aGlzLnBvbGwoKSkge1xuICAgICAgICB0aGlzLnBvbGxpbmdGYXN0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5vbktleVByZXNzID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA+PSA5KSB7XG4gICAgICAgIHRoaXMuaGFzU2VsZWN0aW9uID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuZmFzdFBvbGwoKTtcbiAgICB9O1xuICAgIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLm9uQ29udGV4dE1lbnUgPSBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgaW5wdXQgPSB0aGlzLCBjbSA9IGlucHV0LmNtLCBkaXNwbGF5ID0gY20uZGlzcGxheSwgdGUgPSBpbnB1dC50ZXh0YXJlYTtcbiAgICAgIGlmIChpbnB1dC5jb250ZXh0TWVudVBlbmRpbmcpIHtcbiAgICAgICAgaW5wdXQuY29udGV4dE1lbnVQZW5kaW5nKCk7XG4gICAgICB9XG4gICAgICB2YXIgcG9zID0gcG9zRnJvbU1vdXNlKGNtLCBlKSwgc2Nyb2xsUG9zID0gZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3A7XG4gICAgICBpZiAoIXBvcyB8fCBwcmVzdG8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHJlc2V0ID0gY20ub3B0aW9ucy5yZXNldFNlbGVjdGlvbk9uQ29udGV4dE1lbnU7XG4gICAgICBpZiAocmVzZXQgJiYgY20uZG9jLnNlbC5jb250YWlucyhwb3MpID09IC0xKSB7XG4gICAgICAgIG9wZXJhdGlvbihjbSwgc2V0U2VsZWN0aW9uKShjbS5kb2MsIHNpbXBsZVNlbGVjdGlvbihwb3MpLCBzZWxfZG9udFNjcm9sbCk7XG4gICAgICB9XG4gICAgICB2YXIgb2xkQ1NTID0gdGUuc3R5bGUuY3NzVGV4dCwgb2xkV3JhcHBlckNTUyA9IGlucHV0LndyYXBwZXIuc3R5bGUuY3NzVGV4dDtcbiAgICAgIHZhciB3cmFwcGVyQm94ID0gaW5wdXQud3JhcHBlci5vZmZzZXRQYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBpbnB1dC53cmFwcGVyLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBzdGF0aWNcIjtcbiAgICAgIHRlLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBhYnNvbHV0ZTsgd2lkdGg6IDMwcHg7IGhlaWdodDogMzBweDtcXG4gICAgICB0b3A6IFwiICsgKGUuY2xpZW50WSAtIHdyYXBwZXJCb3gudG9wIC0gNSkgKyBcInB4OyBsZWZ0OiBcIiArIChlLmNsaWVudFggLSB3cmFwcGVyQm94LmxlZnQgLSA1KSArIFwicHg7XFxuICAgICAgei1pbmRleDogMTAwMDsgYmFja2dyb3VuZDogXCIgKyAoaWUgPyBcInJnYmEoMjU1LCAyNTUsIDI1NSwgLjA1KVwiIDogXCJ0cmFuc3BhcmVudFwiKSArIFwiO1xcbiAgICAgIG91dGxpbmU6IG5vbmU7IGJvcmRlci13aWR0aDogMDsgb3V0bGluZTogbm9uZTsgb3ZlcmZsb3c6IGhpZGRlbjsgb3BhY2l0eTogLjA1OyBmaWx0ZXI6IGFscGhhKG9wYWNpdHk9NSk7XCI7XG4gICAgICB2YXIgb2xkU2Nyb2xsWTtcbiAgICAgIGlmICh3ZWJraXQpIHtcbiAgICAgICAgb2xkU2Nyb2xsWSA9IHdpbmRvdy5zY3JvbGxZO1xuICAgICAgfVxuICAgICAgZGlzcGxheS5pbnB1dC5mb2N1cygpO1xuICAgICAgaWYgKHdlYmtpdCkge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8obnVsbCwgb2xkU2Nyb2xsWSk7XG4gICAgICB9XG4gICAgICBkaXNwbGF5LmlucHV0LnJlc2V0KCk7XG4gICAgICBpZiAoIWNtLnNvbWV0aGluZ1NlbGVjdGVkKCkpIHtcbiAgICAgICAgdGUudmFsdWUgPSBpbnB1dC5wcmV2SW5wdXQgPSBcIiBcIjtcbiAgICAgIH1cbiAgICAgIGlucHV0LmNvbnRleHRNZW51UGVuZGluZyA9IHJlaGlkZTtcbiAgICAgIGRpc3BsYXkuc2VsRm9yQ29udGV4dE1lbnUgPSBjbS5kb2Muc2VsO1xuICAgICAgY2xlYXJUaW1lb3V0KGRpc3BsYXkuZGV0ZWN0aW5nU2VsZWN0QWxsKTtcbiAgICAgIGZ1bmN0aW9uIHByZXBhcmVTZWxlY3RBbGxIYWNrKCkge1xuICAgICAgICBpZiAodGUuc2VsZWN0aW9uU3RhcnQgIT0gbnVsbCkge1xuICAgICAgICAgIHZhciBzZWxlY3RlZCA9IGNtLnNvbWV0aGluZ1NlbGVjdGVkKCk7XG4gICAgICAgICAgdmFyIGV4dHZhbCA9IFwiXFx1MjAwQlwiICsgKHNlbGVjdGVkID8gdGUudmFsdWUgOiBcIlwiKTtcbiAgICAgICAgICB0ZS52YWx1ZSA9IFwiXFx1MjFEQVwiO1xuICAgICAgICAgIHRlLnZhbHVlID0gZXh0dmFsO1xuICAgICAgICAgIGlucHV0LnByZXZJbnB1dCA9IHNlbGVjdGVkID8gXCJcIiA6IFwiXFx1MjAwQlwiO1xuICAgICAgICAgIHRlLnNlbGVjdGlvblN0YXJ0ID0gMTtcbiAgICAgICAgICB0ZS5zZWxlY3Rpb25FbmQgPSBleHR2YWwubGVuZ3RoO1xuICAgICAgICAgIGRpc3BsYXkuc2VsRm9yQ29udGV4dE1lbnUgPSBjbS5kb2Muc2VsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBfX25hbWUocHJlcGFyZVNlbGVjdEFsbEhhY2ssIFwicHJlcGFyZVNlbGVjdEFsbEhhY2tcIik7XG4gICAgICBmdW5jdGlvbiByZWhpZGUoKSB7XG4gICAgICAgIGlmIChpbnB1dC5jb250ZXh0TWVudVBlbmRpbmcgIT0gcmVoaWRlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0LmNvbnRleHRNZW51UGVuZGluZyA9IGZhbHNlO1xuICAgICAgICBpbnB1dC53cmFwcGVyLnN0eWxlLmNzc1RleHQgPSBvbGRXcmFwcGVyQ1NTO1xuICAgICAgICB0ZS5zdHlsZS5jc3NUZXh0ID0gb2xkQ1NTO1xuICAgICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDkpIHtcbiAgICAgICAgICBkaXNwbGF5LnNjcm9sbGJhcnMuc2V0U2Nyb2xsVG9wKGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wID0gc2Nyb2xsUG9zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGUuc2VsZWN0aW9uU3RhcnQgIT0gbnVsbCkge1xuICAgICAgICAgIGlmICghaWUgfHwgaWUgJiYgaWVfdmVyc2lvbiA8IDkpIHtcbiAgICAgICAgICAgIHByZXBhcmVTZWxlY3RBbGxIYWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpMiA9IDAsIHBvbGwgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGRpc3BsYXkuc2VsRm9yQ29udGV4dE1lbnUgPT0gY20uZG9jLnNlbCAmJiB0ZS5zZWxlY3Rpb25TdGFydCA9PSAwICYmIHRlLnNlbGVjdGlvbkVuZCA+IDAgJiYgaW5wdXQucHJldklucHV0ID09IFwiXFx1MjAwQlwiKSB7XG4gICAgICAgICAgICAgIG9wZXJhdGlvbihjbSwgc2VsZWN0QWxsKShjbSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGkyKysgPCAxMCkge1xuICAgICAgICAgICAgICBkaXNwbGF5LmRldGVjdGluZ1NlbGVjdEFsbCA9IHNldFRpbWVvdXQocG9sbCwgNTAwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRpc3BsYXkuc2VsRm9yQ29udGV4dE1lbnUgPSBudWxsO1xuICAgICAgICAgICAgICBkaXNwbGF5LmlucHV0LnJlc2V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgXCJwb2xsXCIpO1xuICAgICAgICAgIGRpc3BsYXkuZGV0ZWN0aW5nU2VsZWN0QWxsID0gc2V0VGltZW91dChwb2xsLCAyMDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBfX25hbWUocmVoaWRlLCBcInJlaGlkZVwiKTtcbiAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uID49IDkpIHtcbiAgICAgICAgcHJlcGFyZVNlbGVjdEFsbEhhY2soKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYXB0dXJlUmlnaHRDbGljaykge1xuICAgICAgICBlX3N0b3AoZSk7XG4gICAgICAgIHZhciBtb3VzZXVwID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgICBvZmYod2luZG93LCBcIm1vdXNldXBcIiwgbW91c2V1cCk7XG4gICAgICAgICAgc2V0VGltZW91dChyZWhpZGUsIDIwKTtcbiAgICAgICAgfSwgXCJtb3VzZXVwXCIpO1xuICAgICAgICBvbih3aW5kb3csIFwibW91c2V1cFwiLCBtb3VzZXVwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFRpbWVvdXQocmVoaWRlLCA1MCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5yZWFkT25seUNoYW5nZWQgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgIGlmICghdmFsKSB7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudGV4dGFyZWEuZGlzYWJsZWQgPSB2YWwgPT0gXCJub2N1cnNvclwiO1xuICAgICAgdGhpcy50ZXh0YXJlYS5yZWFkT25seSA9ICEhdmFsO1xuICAgIH07XG4gICAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUuc2V0VW5lZGl0YWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIH07XG4gICAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUubmVlZHNDb250ZW50QXR0cmlidXRlID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gZnJvbVRleHRBcmVhKHRleHRhcmVhLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyA/IGNvcHlPYmoob3B0aW9ucykgOiB7fTtcbiAgICAgIG9wdGlvbnMudmFsdWUgPSB0ZXh0YXJlYS52YWx1ZTtcbiAgICAgIGlmICghb3B0aW9ucy50YWJpbmRleCAmJiB0ZXh0YXJlYS50YWJJbmRleCkge1xuICAgICAgICBvcHRpb25zLnRhYmluZGV4ID0gdGV4dGFyZWEudGFiSW5kZXg7XG4gICAgICB9XG4gICAgICBpZiAoIW9wdGlvbnMucGxhY2Vob2xkZXIgJiYgdGV4dGFyZWEucGxhY2Vob2xkZXIpIHtcbiAgICAgICAgb3B0aW9ucy5wbGFjZWhvbGRlciA9IHRleHRhcmVhLnBsYWNlaG9sZGVyO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuYXV0b2ZvY3VzID09IG51bGwpIHtcbiAgICAgICAgdmFyIGhhc0ZvY3VzID0gYWN0aXZlRWx0KCk7XG4gICAgICAgIG9wdGlvbnMuYXV0b2ZvY3VzID0gaGFzRm9jdXMgPT0gdGV4dGFyZWEgfHwgdGV4dGFyZWEuZ2V0QXR0cmlidXRlKFwiYXV0b2ZvY3VzXCIpICE9IG51bGwgJiYgaGFzRm9jdXMgPT0gZG9jdW1lbnQuYm9keTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHNhdmUoKSB7XG4gICAgICAgIHRleHRhcmVhLnZhbHVlID0gY20uZ2V0VmFsdWUoKTtcbiAgICAgIH1cbiAgICAgIF9fbmFtZShzYXZlLCBcInNhdmVcIik7XG4gICAgICB2YXIgcmVhbFN1Ym1pdDtcbiAgICAgIGlmICh0ZXh0YXJlYS5mb3JtKSB7XG4gICAgICAgIG9uKHRleHRhcmVhLmZvcm0sIFwic3VibWl0XCIsIHNhdmUpO1xuICAgICAgICBpZiAoIW9wdGlvbnMubGVhdmVTdWJtaXRNZXRob2RBbG9uZSkge1xuICAgICAgICAgIHZhciBmb3JtID0gdGV4dGFyZWEuZm9ybTtcbiAgICAgICAgICByZWFsU3VibWl0ID0gZm9ybS5zdWJtaXQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciB3cmFwcGVkU3VibWl0ID0gZm9ybS5zdWJtaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgc2F2ZSgpO1xuICAgICAgICAgICAgICBmb3JtLnN1Ym1pdCA9IHJlYWxTdWJtaXQ7XG4gICAgICAgICAgICAgIGZvcm0uc3VibWl0KCk7XG4gICAgICAgICAgICAgIGZvcm0uc3VibWl0ID0gd3JhcHBlZFN1Ym1pdDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb3B0aW9ucy5maW5pc2hJbml0ID0gZnVuY3Rpb24oY20yKSB7XG4gICAgICAgIGNtMi5zYXZlID0gc2F2ZTtcbiAgICAgICAgY20yLmdldFRleHRBcmVhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRleHRhcmVhO1xuICAgICAgICB9O1xuICAgICAgICBjbTIudG9UZXh0QXJlYSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNtMi50b1RleHRBcmVhID0gaXNOYU47XG4gICAgICAgICAgc2F2ZSgpO1xuICAgICAgICAgIHRleHRhcmVhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY20yLmdldFdyYXBwZXJFbGVtZW50KCkpO1xuICAgICAgICAgIHRleHRhcmVhLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICAgICAgICAgIGlmICh0ZXh0YXJlYS5mb3JtKSB7XG4gICAgICAgICAgICBvZmYodGV4dGFyZWEuZm9ybSwgXCJzdWJtaXRcIiwgc2F2ZSk7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMubGVhdmVTdWJtaXRNZXRob2RBbG9uZSAmJiB0eXBlb2YgdGV4dGFyZWEuZm9ybS5zdWJtaXQgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgIHRleHRhcmVhLmZvcm0uc3VibWl0ID0gcmVhbFN1Ym1pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgdGV4dGFyZWEuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgdmFyIGNtID0gQ29kZU1pcnJvcjIoZnVuY3Rpb24obm9kZSkge1xuICAgICAgICByZXR1cm4gdGV4dGFyZWEucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZSwgdGV4dGFyZWEubmV4dFNpYmxpbmcpO1xuICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gY207XG4gICAgfVxuICAgIF9fbmFtZShmcm9tVGV4dEFyZWEsIFwiZnJvbVRleHRBcmVhXCIpO1xuICAgIGZ1bmN0aW9uIGFkZExlZ2FjeVByb3BzKENvZGVNaXJyb3IzKSB7XG4gICAgICBDb2RlTWlycm9yMy5vZmYgPSBvZmY7XG4gICAgICBDb2RlTWlycm9yMy5vbiA9IG9uO1xuICAgICAgQ29kZU1pcnJvcjMud2hlZWxFdmVudFBpeGVscyA9IHdoZWVsRXZlbnRQaXhlbHM7XG4gICAgICBDb2RlTWlycm9yMy5Eb2MgPSBEb2M7XG4gICAgICBDb2RlTWlycm9yMy5zcGxpdExpbmVzID0gc3BsaXRMaW5lc0F1dG87XG4gICAgICBDb2RlTWlycm9yMy5jb3VudENvbHVtbiA9IGNvdW50Q29sdW1uO1xuICAgICAgQ29kZU1pcnJvcjMuZmluZENvbHVtbiA9IGZpbmRDb2x1bW47XG4gICAgICBDb2RlTWlycm9yMy5pc1dvcmRDaGFyID0gaXNXb3JkQ2hhckJhc2ljO1xuICAgICAgQ29kZU1pcnJvcjMuUGFzcyA9IFBhc3M7XG4gICAgICBDb2RlTWlycm9yMy5zaWduYWwgPSBzaWduYWw7XG4gICAgICBDb2RlTWlycm9yMy5MaW5lID0gTGluZTtcbiAgICAgIENvZGVNaXJyb3IzLmNoYW5nZUVuZCA9IGNoYW5nZUVuZDtcbiAgICAgIENvZGVNaXJyb3IzLnNjcm9sbGJhck1vZGVsID0gc2Nyb2xsYmFyTW9kZWw7XG4gICAgICBDb2RlTWlycm9yMy5Qb3MgPSBQb3M7XG4gICAgICBDb2RlTWlycm9yMy5jbXBQb3MgPSBjbXA7XG4gICAgICBDb2RlTWlycm9yMy5tb2RlcyA9IG1vZGVzO1xuICAgICAgQ29kZU1pcnJvcjMubWltZU1vZGVzID0gbWltZU1vZGVzO1xuICAgICAgQ29kZU1pcnJvcjMucmVzb2x2ZU1vZGUgPSByZXNvbHZlTW9kZTtcbiAgICAgIENvZGVNaXJyb3IzLmdldE1vZGUgPSBnZXRNb2RlO1xuICAgICAgQ29kZU1pcnJvcjMubW9kZUV4dGVuc2lvbnMgPSBtb2RlRXh0ZW5zaW9ucztcbiAgICAgIENvZGVNaXJyb3IzLmV4dGVuZE1vZGUgPSBleHRlbmRNb2RlO1xuICAgICAgQ29kZU1pcnJvcjMuY29weVN0YXRlID0gY29weVN0YXRlO1xuICAgICAgQ29kZU1pcnJvcjMuc3RhcnRTdGF0ZSA9IHN0YXJ0U3RhdGU7XG4gICAgICBDb2RlTWlycm9yMy5pbm5lck1vZGUgPSBpbm5lck1vZGU7XG4gICAgICBDb2RlTWlycm9yMy5jb21tYW5kcyA9IGNvbW1hbmRzO1xuICAgICAgQ29kZU1pcnJvcjMua2V5TWFwID0ga2V5TWFwO1xuICAgICAgQ29kZU1pcnJvcjMua2V5TmFtZSA9IGtleU5hbWU7XG4gICAgICBDb2RlTWlycm9yMy5pc01vZGlmaWVyS2V5ID0gaXNNb2RpZmllcktleTtcbiAgICAgIENvZGVNaXJyb3IzLmxvb2t1cEtleSA9IGxvb2t1cEtleTtcbiAgICAgIENvZGVNaXJyb3IzLm5vcm1hbGl6ZUtleU1hcCA9IG5vcm1hbGl6ZUtleU1hcDtcbiAgICAgIENvZGVNaXJyb3IzLlN0cmluZ1N0cmVhbSA9IFN0cmluZ1N0cmVhbTtcbiAgICAgIENvZGVNaXJyb3IzLlNoYXJlZFRleHRNYXJrZXIgPSBTaGFyZWRUZXh0TWFya2VyO1xuICAgICAgQ29kZU1pcnJvcjMuVGV4dE1hcmtlciA9IFRleHRNYXJrZXI7XG4gICAgICBDb2RlTWlycm9yMy5MaW5lV2lkZ2V0ID0gTGluZVdpZGdldDtcbiAgICAgIENvZGVNaXJyb3IzLmVfcHJldmVudERlZmF1bHQgPSBlX3ByZXZlbnREZWZhdWx0O1xuICAgICAgQ29kZU1pcnJvcjMuZV9zdG9wUHJvcGFnYXRpb24gPSBlX3N0b3BQcm9wYWdhdGlvbjtcbiAgICAgIENvZGVNaXJyb3IzLmVfc3RvcCA9IGVfc3RvcDtcbiAgICAgIENvZGVNaXJyb3IzLmFkZENsYXNzID0gYWRkQ2xhc3M7XG4gICAgICBDb2RlTWlycm9yMy5jb250YWlucyA9IGNvbnRhaW5zO1xuICAgICAgQ29kZU1pcnJvcjMucm1DbGFzcyA9IHJtQ2xhc3M7XG4gICAgICBDb2RlTWlycm9yMy5rZXlOYW1lcyA9IGtleU5hbWVzO1xuICAgIH1cbiAgICBfX25hbWUoYWRkTGVnYWN5UHJvcHMsIFwiYWRkTGVnYWN5UHJvcHNcIik7XG4gICAgZGVmaW5lT3B0aW9ucyhDb2RlTWlycm9yMik7XG4gICAgYWRkRWRpdG9yTWV0aG9kcyhDb2RlTWlycm9yMik7XG4gICAgdmFyIGRvbnREZWxlZ2F0ZSA9IFwiaXRlciBpbnNlcnQgcmVtb3ZlIGNvcHkgZ2V0RWRpdG9yIGNvbnN0cnVjdG9yXCIuc3BsaXQoXCIgXCIpO1xuICAgIGZvciAodmFyIHByb3AgaW4gRG9jLnByb3RvdHlwZSkge1xuICAgICAgaWYgKERvYy5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkocHJvcCkgJiYgaW5kZXhPZihkb250RGVsZWdhdGUsIHByb3ApIDwgMCkge1xuICAgICAgICBDb2RlTWlycm9yMi5wcm90b3R5cGVbcHJvcF0gPSBmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kLmFwcGx5KHRoaXMuZG9jLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0oRG9jLnByb3RvdHlwZVtwcm9wXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGV2ZW50TWl4aW4oRG9jKTtcbiAgICBDb2RlTWlycm9yMi5pbnB1dFN0eWxlcyA9IHsgXCJ0ZXh0YXJlYVwiOiBUZXh0YXJlYUlucHV0LCBcImNvbnRlbnRlZGl0YWJsZVwiOiBDb250ZW50RWRpdGFibGVJbnB1dCB9O1xuICAgIENvZGVNaXJyb3IyLmRlZmluZU1vZGUgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICBpZiAoIUNvZGVNaXJyb3IyLmRlZmF1bHRzLm1vZGUgJiYgbmFtZSAhPSBcIm51bGxcIikge1xuICAgICAgICBDb2RlTWlycm9yMi5kZWZhdWx0cy5tb2RlID0gbmFtZTtcbiAgICAgIH1cbiAgICAgIGRlZmluZU1vZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIENvZGVNaXJyb3IyLmRlZmluZU1JTUUgPSBkZWZpbmVNSU1FO1xuICAgIENvZGVNaXJyb3IyLmRlZmluZU1vZGUoXCJudWxsXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHsgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICByZXR1cm4gc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgfSB9O1xuICAgIH0pO1xuICAgIENvZGVNaXJyb3IyLmRlZmluZU1JTUUoXCJ0ZXh0L3BsYWluXCIsIFwibnVsbFwiKTtcbiAgICBDb2RlTWlycm9yMi5kZWZpbmVFeHRlbnNpb24gPSBmdW5jdGlvbihuYW1lLCBmdW5jKSB7XG4gICAgICBDb2RlTWlycm9yMi5wcm90b3R5cGVbbmFtZV0gPSBmdW5jO1xuICAgIH07XG4gICAgQ29kZU1pcnJvcjIuZGVmaW5lRG9jRXh0ZW5zaW9uID0gZnVuY3Rpb24obmFtZSwgZnVuYykge1xuICAgICAgRG9jLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmM7XG4gICAgfTtcbiAgICBDb2RlTWlycm9yMi5mcm9tVGV4dEFyZWEgPSBmcm9tVGV4dEFyZWE7XG4gICAgYWRkTGVnYWN5UHJvcHMoQ29kZU1pcnJvcjIpO1xuICAgIENvZGVNaXJyb3IyLnZlcnNpb24gPSBcIjUuNjUuM1wiO1xuICAgIHJldHVybiBDb2RlTWlycm9yMjtcbiAgfSk7XG59KShjb2RlbWlycm9yJDEpO1xudmFyIENvZGVNaXJyb3IgPSBjb2RlbWlycm9yJDEuZXhwb3J0cztcbnZhciBjb2RlbWlycm9yID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIF9tZXJnZU5hbWVzcGFjZXMoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiBcIk1vZHVsZVwiLFxuICBcImRlZmF1bHRcIjogQ29kZU1pcnJvclxufSwgW2NvZGVtaXJyb3IkMS5leHBvcnRzXSkpO1xuZXhwb3J0IHsgQ29kZU1pcnJvciBhcyBDLCBjb2RlbWlycm9yJDEgYXMgYSwgY29kZW1pcnJvciBhcyBjIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///97480\n')}}]);