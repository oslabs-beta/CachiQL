"use strict";(self.webpackChunkcachiql_demo=self.webpackChunkcachiql_demo||[]).push([[481],{17481:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "l": () => (/* binding */ lint$1)\n/* harmony export */ });\n/* harmony import */ var _codemirror_es_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97480);\nvar __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, "name", { value, configurable: true });\n\nfunction _mergeNamespaces(n, m) {\n  m.forEach(function(e) {\n    e && typeof e !== "string" && !Array.isArray(e) && Object.keys(e).forEach(function(k) {\n      if (k !== "default" && !(k in n)) {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function() {\n            return e[k];\n          }\n        });\n      }\n    });\n  });\n  return Object.freeze(n);\n}\n__name(_mergeNamespaces, "_mergeNamespaces");\nvar lint$2 = { exports: {} };\n(function(module, exports) {\n  (function(mod) {\n    mod(_codemirror_es_js__WEBPACK_IMPORTED_MODULE_0__.a.exports);\n  })(function(CodeMirror) {\n    var GUTTER_ID = "CodeMirror-lint-markers";\n    var LINT_LINE_ID = "CodeMirror-lint-line-";\n    function showTooltip(cm, e, content) {\n      var tt = document.createElement("div");\n      tt.className = "CodeMirror-lint-tooltip cm-s-" + cm.options.theme;\n      tt.appendChild(content.cloneNode(true));\n      if (cm.state.lint.options.selfContain)\n        cm.getWrapperElement().appendChild(tt);\n      else\n        document.body.appendChild(tt);\n      function position(e2) {\n        if (!tt.parentNode)\n          return CodeMirror.off(document, "mousemove", position);\n        tt.style.top = Math.max(0, e2.clientY - tt.offsetHeight - 5) + "px";\n        tt.style.left = e2.clientX + 5 + "px";\n      }\n      __name(position, "position");\n      CodeMirror.on(document, "mousemove", position);\n      position(e);\n      if (tt.style.opacity != null)\n        tt.style.opacity = 1;\n      return tt;\n    }\n    __name(showTooltip, "showTooltip");\n    function rm(elt) {\n      if (elt.parentNode)\n        elt.parentNode.removeChild(elt);\n    }\n    __name(rm, "rm");\n    function hideTooltip(tt) {\n      if (!tt.parentNode)\n        return;\n      if (tt.style.opacity == null)\n        rm(tt);\n      tt.style.opacity = 0;\n      setTimeout(function() {\n        rm(tt);\n      }, 600);\n    }\n    __name(hideTooltip, "hideTooltip");\n    function showTooltipFor(cm, e, content, node) {\n      var tooltip = showTooltip(cm, e, content);\n      function hide() {\n        CodeMirror.off(node, "mouseout", hide);\n        if (tooltip) {\n          hideTooltip(tooltip);\n          tooltip = null;\n        }\n      }\n      __name(hide, "hide");\n      var poll = setInterval(function() {\n        if (tooltip)\n          for (var n = node; ; n = n.parentNode) {\n            if (n && n.nodeType == 11)\n              n = n.host;\n            if (n == document.body)\n              return;\n            if (!n) {\n              hide();\n              break;\n            }\n          }\n        if (!tooltip)\n          return clearInterval(poll);\n      }, 400);\n      CodeMirror.on(node, "mouseout", hide);\n    }\n    __name(showTooltipFor, "showTooltipFor");\n    function LintState(cm, conf, hasGutter) {\n      this.marked = [];\n      if (conf instanceof Function)\n        conf = { getAnnotations: conf };\n      if (!conf || conf === true)\n        conf = {};\n      this.options = {};\n      this.linterOptions = conf.options || {};\n      for (var prop in defaults)\n        this.options[prop] = defaults[prop];\n      for (var prop in conf) {\n        if (defaults.hasOwnProperty(prop)) {\n          if (conf[prop] != null)\n            this.options[prop] = conf[prop];\n        } else if (!conf.options) {\n          this.linterOptions[prop] = conf[prop];\n        }\n      }\n      this.timeout = null;\n      this.hasGutter = hasGutter;\n      this.onMouseOver = function(e) {\n        onMouseOver(cm, e);\n      };\n      this.waitingFor = 0;\n    }\n    __name(LintState, "LintState");\n    var defaults = {\n      highlightLines: false,\n      tooltips: true,\n      delay: 500,\n      lintOnChange: true,\n      getAnnotations: null,\n      async: false,\n      selfContain: null,\n      formatAnnotation: null,\n      onUpdateLinting: null\n    };\n    function clearMarks(cm) {\n      var state = cm.state.lint;\n      if (state.hasGutter)\n        cm.clearGutter(GUTTER_ID);\n      if (state.options.highlightLines)\n        clearErrorLines(cm);\n      for (var i = 0; i < state.marked.length; ++i)\n        state.marked[i].clear();\n      state.marked.length = 0;\n    }\n    __name(clearMarks, "clearMarks");\n    function clearErrorLines(cm) {\n      cm.eachLine(function(line) {\n        var has = line.wrapClass && /\\bCodeMirror-lint-line-\\w+\\b/.exec(line.wrapClass);\n        if (has)\n          cm.removeLineClass(line, "wrap", has[0]);\n      });\n    }\n    __name(clearErrorLines, "clearErrorLines");\n    function makeMarker(cm, labels, severity, multiple, tooltips) {\n      var marker = document.createElement("div"), inner = marker;\n      marker.className = "CodeMirror-lint-marker CodeMirror-lint-marker-" + severity;\n      if (multiple) {\n        inner = marker.appendChild(document.createElement("div"));\n        inner.className = "CodeMirror-lint-marker CodeMirror-lint-marker-multiple";\n      }\n      if (tooltips != false)\n        CodeMirror.on(inner, "mouseover", function(e) {\n          showTooltipFor(cm, e, labels, inner);\n        });\n      return marker;\n    }\n    __name(makeMarker, "makeMarker");\n    function getMaxSeverity(a, b) {\n      if (a == "error")\n        return a;\n      else\n        return b;\n    }\n    __name(getMaxSeverity, "getMaxSeverity");\n    function groupByLine(annotations) {\n      var lines = [];\n      for (var i = 0; i < annotations.length; ++i) {\n        var ann = annotations[i], line = ann.from.line;\n        (lines[line] || (lines[line] = [])).push(ann);\n      }\n      return lines;\n    }\n    __name(groupByLine, "groupByLine");\n    function annotationTooltip(ann) {\n      var severity = ann.severity;\n      if (!severity)\n        severity = "error";\n      var tip = document.createElement("div");\n      tip.className = "CodeMirror-lint-message CodeMirror-lint-message-" + severity;\n      if (typeof ann.messageHTML != "undefined") {\n        tip.innerHTML = ann.messageHTML;\n      } else {\n        tip.appendChild(document.createTextNode(ann.message));\n      }\n      return tip;\n    }\n    __name(annotationTooltip, "annotationTooltip");\n    function lintAsync(cm, getAnnotations) {\n      var state = cm.state.lint;\n      var id = ++state.waitingFor;\n      function abort() {\n        id = -1;\n        cm.off("change", abort);\n      }\n      __name(abort, "abort");\n      cm.on("change", abort);\n      getAnnotations(cm.getValue(), function(annotations, arg2) {\n        cm.off("change", abort);\n        if (state.waitingFor != id)\n          return;\n        if (arg2 && annotations instanceof CodeMirror)\n          annotations = arg2;\n        cm.operation(function() {\n          updateLinting(cm, annotations);\n        });\n      }, state.linterOptions, cm);\n    }\n    __name(lintAsync, "lintAsync");\n    function startLinting(cm) {\n      var state = cm.state.lint;\n      if (!state)\n        return;\n      var options = state.options;\n      var getAnnotations = options.getAnnotations || cm.getHelper(CodeMirror.Pos(0, 0), "lint");\n      if (!getAnnotations)\n        return;\n      if (options.async || getAnnotations.async) {\n        lintAsync(cm, getAnnotations);\n      } else {\n        var annotations = getAnnotations(cm.getValue(), state.linterOptions, cm);\n        if (!annotations)\n          return;\n        if (annotations.then)\n          annotations.then(function(issues) {\n            cm.operation(function() {\n              updateLinting(cm, issues);\n            });\n          });\n        else\n          cm.operation(function() {\n            updateLinting(cm, annotations);\n          });\n      }\n    }\n    __name(startLinting, "startLinting");\n    function updateLinting(cm, annotationsNotSorted) {\n      var state = cm.state.lint;\n      if (!state)\n        return;\n      var options = state.options;\n      clearMarks(cm);\n      var annotations = groupByLine(annotationsNotSorted);\n      for (var line = 0; line < annotations.length; ++line) {\n        var anns = annotations[line];\n        if (!anns)\n          continue;\n        var message = [];\n        anns = anns.filter(function(item) {\n          return message.indexOf(item.message) > -1 ? false : message.push(item.message);\n        });\n        var maxSeverity = null;\n        var tipLabel = state.hasGutter && document.createDocumentFragment();\n        for (var i = 0; i < anns.length; ++i) {\n          var ann = anns[i];\n          var severity = ann.severity;\n          if (!severity)\n            severity = "error";\n          maxSeverity = getMaxSeverity(maxSeverity, severity);\n          if (options.formatAnnotation)\n            ann = options.formatAnnotation(ann);\n          if (state.hasGutter)\n            tipLabel.appendChild(annotationTooltip(ann));\n          if (ann.to)\n            state.marked.push(cm.markText(ann.from, ann.to, {\n              className: "CodeMirror-lint-mark CodeMirror-lint-mark-" + severity,\n              __annotation: ann\n            }));\n        }\n        if (state.hasGutter)\n          cm.setGutterMarker(line, GUTTER_ID, makeMarker(cm, tipLabel, maxSeverity, annotations[line].length > 1, options.tooltips));\n        if (options.highlightLines)\n          cm.addLineClass(line, "wrap", LINT_LINE_ID + maxSeverity);\n      }\n      if (options.onUpdateLinting)\n        options.onUpdateLinting(annotationsNotSorted, annotations, cm);\n    }\n    __name(updateLinting, "updateLinting");\n    function onChange(cm) {\n      var state = cm.state.lint;\n      if (!state)\n        return;\n      clearTimeout(state.timeout);\n      state.timeout = setTimeout(function() {\n        startLinting(cm);\n      }, state.options.delay);\n    }\n    __name(onChange, "onChange");\n    function popupTooltips(cm, annotations, e) {\n      var target = e.target || e.srcElement;\n      var tooltip = document.createDocumentFragment();\n      for (var i = 0; i < annotations.length; i++) {\n        var ann = annotations[i];\n        tooltip.appendChild(annotationTooltip(ann));\n      }\n      showTooltipFor(cm, e, tooltip, target);\n    }\n    __name(popupTooltips, "popupTooltips");\n    function onMouseOver(cm, e) {\n      var target = e.target || e.srcElement;\n      if (!/\\bCodeMirror-lint-mark-/.test(target.className))\n        return;\n      var box = target.getBoundingClientRect(), x = (box.left + box.right) / 2, y = (box.top + box.bottom) / 2;\n      var spans = cm.findMarksAt(cm.coordsChar({ left: x, top: y }, "client"));\n      var annotations = [];\n      for (var i = 0; i < spans.length; ++i) {\n        var ann = spans[i].__annotation;\n        if (ann)\n          annotations.push(ann);\n      }\n      if (annotations.length)\n        popupTooltips(cm, annotations, e);\n    }\n    __name(onMouseOver, "onMouseOver");\n    CodeMirror.defineOption("lint", false, function(cm, val, old) {\n      if (old && old != CodeMirror.Init) {\n        clearMarks(cm);\n        if (cm.state.lint.options.lintOnChange !== false)\n          cm.off("change", onChange);\n        CodeMirror.off(cm.getWrapperElement(), "mouseover", cm.state.lint.onMouseOver);\n        clearTimeout(cm.state.lint.timeout);\n        delete cm.state.lint;\n      }\n      if (val) {\n        var gutters = cm.getOption("gutters"), hasLintGutter = false;\n        for (var i = 0; i < gutters.length; ++i)\n          if (gutters[i] == GUTTER_ID)\n            hasLintGutter = true;\n        var state = cm.state.lint = new LintState(cm, val, hasLintGutter);\n        if (state.options.lintOnChange)\n          cm.on("change", onChange);\n        if (state.options.tooltips != false && state.options.tooltips != "gutter")\n          CodeMirror.on(cm.getWrapperElement(), "mouseover", state.onMouseOver);\n        startLinting(cm);\n      }\n    });\n    CodeMirror.defineExtension("performLint", function() {\n      startLinting(this);\n    });\n  });\n})();\nvar lint = lint$2.exports;\nvar lint$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  [Symbol.toStringTag]: "Module",\n  "default": lint\n}, [lint$2.exports]));\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBLGlEQUFpRCxpQkFBaUI7QUFDbEU7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ3NCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2FjaGlxbC1kZW1vLy4vbm9kZV9tb2R1bGVzL0BncmFwaGlxbC9yZWFjdC9kaXN0L2xpbnQuZXMzLmpzPzk3OGYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX25hbWUgPSAodGFyZ2V0LCB2YWx1ZSkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJuYW1lXCIsIHsgdmFsdWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbmltcG9ydCB7IGEgYXMgY29kZW1pcnJvciB9IGZyb20gXCIuL2NvZGVtaXJyb3IuZXMuanNcIjtcbmZ1bmN0aW9uIF9tZXJnZU5hbWVzcGFjZXMobiwgbSkge1xuICBtLmZvckVhY2goZnVuY3Rpb24oZSkge1xuICAgIGUgJiYgdHlwZW9mIGUgIT09IFwic3RyaW5nXCIgJiYgIUFycmF5LmlzQXJyYXkoZSkgJiYgT2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgIShrIGluIG4pKSB7XG4gICAgICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGssIGQuZ2V0ID8gZCA6IHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZVtrXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUobik7XG59XG5fX25hbWUoX21lcmdlTmFtZXNwYWNlcywgXCJfbWVyZ2VOYW1lc3BhY2VzXCIpO1xudmFyIGxpbnQkMiA9IHsgZXhwb3J0czoge30gfTtcbihmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcbiAgKGZ1bmN0aW9uKG1vZCkge1xuICAgIG1vZChjb2RlbWlycm9yLmV4cG9ydHMpO1xuICB9KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG4gICAgdmFyIEdVVFRFUl9JRCA9IFwiQ29kZU1pcnJvci1saW50LW1hcmtlcnNcIjtcbiAgICB2YXIgTElOVF9MSU5FX0lEID0gXCJDb2RlTWlycm9yLWxpbnQtbGluZS1cIjtcbiAgICBmdW5jdGlvbiBzaG93VG9vbHRpcChjbSwgZSwgY29udGVudCkge1xuICAgICAgdmFyIHR0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHR0LmNsYXNzTmFtZSA9IFwiQ29kZU1pcnJvci1saW50LXRvb2x0aXAgY20tcy1cIiArIGNtLm9wdGlvbnMudGhlbWU7XG4gICAgICB0dC5hcHBlbmRDaGlsZChjb250ZW50LmNsb25lTm9kZSh0cnVlKSk7XG4gICAgICBpZiAoY20uc3RhdGUubGludC5vcHRpb25zLnNlbGZDb250YWluKVxuICAgICAgICBjbS5nZXRXcmFwcGVyRWxlbWVudCgpLmFwcGVuZENoaWxkKHR0KTtcbiAgICAgIGVsc2VcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0dCk7XG4gICAgICBmdW5jdGlvbiBwb3NpdGlvbihlMikge1xuICAgICAgICBpZiAoIXR0LnBhcmVudE5vZGUpXG4gICAgICAgICAgcmV0dXJuIENvZGVNaXJyb3Iub2ZmKGRvY3VtZW50LCBcIm1vdXNlbW92ZVwiLCBwb3NpdGlvbik7XG4gICAgICAgIHR0LnN0eWxlLnRvcCA9IE1hdGgubWF4KDAsIGUyLmNsaWVudFkgLSB0dC5vZmZzZXRIZWlnaHQgLSA1KSArIFwicHhcIjtcbiAgICAgICAgdHQuc3R5bGUubGVmdCA9IGUyLmNsaWVudFggKyA1ICsgXCJweFwiO1xuICAgICAgfVxuICAgICAgX19uYW1lKHBvc2l0aW9uLCBcInBvc2l0aW9uXCIpO1xuICAgICAgQ29kZU1pcnJvci5vbihkb2N1bWVudCwgXCJtb3VzZW1vdmVcIiwgcG9zaXRpb24pO1xuICAgICAgcG9zaXRpb24oZSk7XG4gICAgICBpZiAodHQuc3R5bGUub3BhY2l0eSAhPSBudWxsKVxuICAgICAgICB0dC5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICAgIHJldHVybiB0dDtcbiAgICB9XG4gICAgX19uYW1lKHNob3dUb29sdGlwLCBcInNob3dUb29sdGlwXCIpO1xuICAgIGZ1bmN0aW9uIHJtKGVsdCkge1xuICAgICAgaWYgKGVsdC5wYXJlbnROb2RlKVxuICAgICAgICBlbHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbHQpO1xuICAgIH1cbiAgICBfX25hbWUocm0sIFwicm1cIik7XG4gICAgZnVuY3Rpb24gaGlkZVRvb2x0aXAodHQpIHtcbiAgICAgIGlmICghdHQucGFyZW50Tm9kZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKHR0LnN0eWxlLm9wYWNpdHkgPT0gbnVsbClcbiAgICAgICAgcm0odHQpO1xuICAgICAgdHQuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBybSh0dCk7XG4gICAgICB9LCA2MDApO1xuICAgIH1cbiAgICBfX25hbWUoaGlkZVRvb2x0aXAsIFwiaGlkZVRvb2x0aXBcIik7XG4gICAgZnVuY3Rpb24gc2hvd1Rvb2x0aXBGb3IoY20sIGUsIGNvbnRlbnQsIG5vZGUpIHtcbiAgICAgIHZhciB0b29sdGlwID0gc2hvd1Rvb2x0aXAoY20sIGUsIGNvbnRlbnQpO1xuICAgICAgZnVuY3Rpb24gaGlkZSgpIHtcbiAgICAgICAgQ29kZU1pcnJvci5vZmYobm9kZSwgXCJtb3VzZW91dFwiLCBoaWRlKTtcbiAgICAgICAgaWYgKHRvb2x0aXApIHtcbiAgICAgICAgICBoaWRlVG9vbHRpcCh0b29sdGlwKTtcbiAgICAgICAgICB0b29sdGlwID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX19uYW1lKGhpZGUsIFwiaGlkZVwiKTtcbiAgICAgIHZhciBwb2xsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0b29sdGlwKVxuICAgICAgICAgIGZvciAodmFyIG4gPSBub2RlOyA7IG4gPSBuLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGlmIChuICYmIG4ubm9kZVR5cGUgPT0gMTEpXG4gICAgICAgICAgICAgIG4gPSBuLmhvc3Q7XG4gICAgICAgICAgICBpZiAobiA9PSBkb2N1bWVudC5ib2R5KVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoIW4pIHtcbiAgICAgICAgICAgICAgaGlkZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIGlmICghdG9vbHRpcClcbiAgICAgICAgICByZXR1cm4gY2xlYXJJbnRlcnZhbChwb2xsKTtcbiAgICAgIH0sIDQwMCk7XG4gICAgICBDb2RlTWlycm9yLm9uKG5vZGUsIFwibW91c2VvdXRcIiwgaGlkZSk7XG4gICAgfVxuICAgIF9fbmFtZShzaG93VG9vbHRpcEZvciwgXCJzaG93VG9vbHRpcEZvclwiKTtcbiAgICBmdW5jdGlvbiBMaW50U3RhdGUoY20sIGNvbmYsIGhhc0d1dHRlcikge1xuICAgICAgdGhpcy5tYXJrZWQgPSBbXTtcbiAgICAgIGlmIChjb25mIGluc3RhbmNlb2YgRnVuY3Rpb24pXG4gICAgICAgIGNvbmYgPSB7IGdldEFubm90YXRpb25zOiBjb25mIH07XG4gICAgICBpZiAoIWNvbmYgfHwgY29uZiA9PT0gdHJ1ZSlcbiAgICAgICAgY29uZiA9IHt9O1xuICAgICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgICB0aGlzLmxpbnRlck9wdGlvbnMgPSBjb25mLm9wdGlvbnMgfHwge307XG4gICAgICBmb3IgKHZhciBwcm9wIGluIGRlZmF1bHRzKVxuICAgICAgICB0aGlzLm9wdGlvbnNbcHJvcF0gPSBkZWZhdWx0c1twcm9wXTtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gY29uZikge1xuICAgICAgICBpZiAoZGVmYXVsdHMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICBpZiAoY29uZltwcm9wXSAhPSBudWxsKVxuICAgICAgICAgICAgdGhpcy5vcHRpb25zW3Byb3BdID0gY29uZltwcm9wXTtcbiAgICAgICAgfSBlbHNlIGlmICghY29uZi5vcHRpb25zKSB7XG4gICAgICAgICAgdGhpcy5saW50ZXJPcHRpb25zW3Byb3BdID0gY29uZltwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy50aW1lb3V0ID0gbnVsbDtcbiAgICAgIHRoaXMuaGFzR3V0dGVyID0gaGFzR3V0dGVyO1xuICAgICAgdGhpcy5vbk1vdXNlT3ZlciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgb25Nb3VzZU92ZXIoY20sIGUpO1xuICAgICAgfTtcbiAgICAgIHRoaXMud2FpdGluZ0ZvciA9IDA7XG4gICAgfVxuICAgIF9fbmFtZShMaW50U3RhdGUsIFwiTGludFN0YXRlXCIpO1xuICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgIGhpZ2hsaWdodExpbmVzOiBmYWxzZSxcbiAgICAgIHRvb2x0aXBzOiB0cnVlLFxuICAgICAgZGVsYXk6IDUwMCxcbiAgICAgIGxpbnRPbkNoYW5nZTogdHJ1ZSxcbiAgICAgIGdldEFubm90YXRpb25zOiBudWxsLFxuICAgICAgYXN5bmM6IGZhbHNlLFxuICAgICAgc2VsZkNvbnRhaW46IG51bGwsXG4gICAgICBmb3JtYXRBbm5vdGF0aW9uOiBudWxsLFxuICAgICAgb25VcGRhdGVMaW50aW5nOiBudWxsXG4gICAgfTtcbiAgICBmdW5jdGlvbiBjbGVhck1hcmtzKGNtKSB7XG4gICAgICB2YXIgc3RhdGUgPSBjbS5zdGF0ZS5saW50O1xuICAgICAgaWYgKHN0YXRlLmhhc0d1dHRlcilcbiAgICAgICAgY20uY2xlYXJHdXR0ZXIoR1VUVEVSX0lEKTtcbiAgICAgIGlmIChzdGF0ZS5vcHRpb25zLmhpZ2hsaWdodExpbmVzKVxuICAgICAgICBjbGVhckVycm9yTGluZXMoY20pO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS5tYXJrZWQubGVuZ3RoOyArK2kpXG4gICAgICAgIHN0YXRlLm1hcmtlZFtpXS5jbGVhcigpO1xuICAgICAgc3RhdGUubWFya2VkLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIF9fbmFtZShjbGVhck1hcmtzLCBcImNsZWFyTWFya3NcIik7XG4gICAgZnVuY3Rpb24gY2xlYXJFcnJvckxpbmVzKGNtKSB7XG4gICAgICBjbS5lYWNoTGluZShmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgIHZhciBoYXMgPSBsaW5lLndyYXBDbGFzcyAmJiAvXFxiQ29kZU1pcnJvci1saW50LWxpbmUtXFx3K1xcYi8uZXhlYyhsaW5lLndyYXBDbGFzcyk7XG4gICAgICAgIGlmIChoYXMpXG4gICAgICAgICAgY20ucmVtb3ZlTGluZUNsYXNzKGxpbmUsIFwid3JhcFwiLCBoYXNbMF0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIF9fbmFtZShjbGVhckVycm9yTGluZXMsIFwiY2xlYXJFcnJvckxpbmVzXCIpO1xuICAgIGZ1bmN0aW9uIG1ha2VNYXJrZXIoY20sIGxhYmVscywgc2V2ZXJpdHksIG11bHRpcGxlLCB0b29sdGlwcykge1xuICAgICAgdmFyIG1hcmtlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIGlubmVyID0gbWFya2VyO1xuICAgICAgbWFya2VyLmNsYXNzTmFtZSA9IFwiQ29kZU1pcnJvci1saW50LW1hcmtlciBDb2RlTWlycm9yLWxpbnQtbWFya2VyLVwiICsgc2V2ZXJpdHk7XG4gICAgICBpZiAobXVsdGlwbGUpIHtcbiAgICAgICAgaW5uZXIgPSBtYXJrZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgICAgIGlubmVyLmNsYXNzTmFtZSA9IFwiQ29kZU1pcnJvci1saW50LW1hcmtlciBDb2RlTWlycm9yLWxpbnQtbWFya2VyLW11bHRpcGxlXCI7XG4gICAgICB9XG4gICAgICBpZiAodG9vbHRpcHMgIT0gZmFsc2UpXG4gICAgICAgIENvZGVNaXJyb3Iub24oaW5uZXIsIFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBzaG93VG9vbHRpcEZvcihjbSwgZSwgbGFiZWxzLCBpbm5lcik7XG4gICAgICAgIH0pO1xuICAgICAgcmV0dXJuIG1hcmtlcjtcbiAgICB9XG4gICAgX19uYW1lKG1ha2VNYXJrZXIsIFwibWFrZU1hcmtlclwiKTtcbiAgICBmdW5jdGlvbiBnZXRNYXhTZXZlcml0eShhLCBiKSB7XG4gICAgICBpZiAoYSA9PSBcImVycm9yXCIpXG4gICAgICAgIHJldHVybiBhO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gYjtcbiAgICB9XG4gICAgX19uYW1lKGdldE1heFNldmVyaXR5LCBcImdldE1heFNldmVyaXR5XCIpO1xuICAgIGZ1bmN0aW9uIGdyb3VwQnlMaW5lKGFubm90YXRpb25zKSB7XG4gICAgICB2YXIgbGluZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5ub3RhdGlvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGFubiA9IGFubm90YXRpb25zW2ldLCBsaW5lID0gYW5uLmZyb20ubGluZTtcbiAgICAgICAgKGxpbmVzW2xpbmVdIHx8IChsaW5lc1tsaW5lXSA9IFtdKSkucHVzaChhbm4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxpbmVzO1xuICAgIH1cbiAgICBfX25hbWUoZ3JvdXBCeUxpbmUsIFwiZ3JvdXBCeUxpbmVcIik7XG4gICAgZnVuY3Rpb24gYW5ub3RhdGlvblRvb2x0aXAoYW5uKSB7XG4gICAgICB2YXIgc2V2ZXJpdHkgPSBhbm4uc2V2ZXJpdHk7XG4gICAgICBpZiAoIXNldmVyaXR5KVxuICAgICAgICBzZXZlcml0eSA9IFwiZXJyb3JcIjtcbiAgICAgIHZhciB0aXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGlwLmNsYXNzTmFtZSA9IFwiQ29kZU1pcnJvci1saW50LW1lc3NhZ2UgQ29kZU1pcnJvci1saW50LW1lc3NhZ2UtXCIgKyBzZXZlcml0eTtcbiAgICAgIGlmICh0eXBlb2YgYW5uLm1lc3NhZ2VIVE1MICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGlwLmlubmVySFRNTCA9IGFubi5tZXNzYWdlSFRNTDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpcC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShhbm4ubWVzc2FnZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRpcDtcbiAgICB9XG4gICAgX19uYW1lKGFubm90YXRpb25Ub29sdGlwLCBcImFubm90YXRpb25Ub29sdGlwXCIpO1xuICAgIGZ1bmN0aW9uIGxpbnRBc3luYyhjbSwgZ2V0QW5ub3RhdGlvbnMpIHtcbiAgICAgIHZhciBzdGF0ZSA9IGNtLnN0YXRlLmxpbnQ7XG4gICAgICB2YXIgaWQgPSArK3N0YXRlLndhaXRpbmdGb3I7XG4gICAgICBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICAgICAgaWQgPSAtMTtcbiAgICAgICAgY20ub2ZmKFwiY2hhbmdlXCIsIGFib3J0KTtcbiAgICAgIH1cbiAgICAgIF9fbmFtZShhYm9ydCwgXCJhYm9ydFwiKTtcbiAgICAgIGNtLm9uKFwiY2hhbmdlXCIsIGFib3J0KTtcbiAgICAgIGdldEFubm90YXRpb25zKGNtLmdldFZhbHVlKCksIGZ1bmN0aW9uKGFubm90YXRpb25zLCBhcmcyKSB7XG4gICAgICAgIGNtLm9mZihcImNoYW5nZVwiLCBhYm9ydCk7XG4gICAgICAgIGlmIChzdGF0ZS53YWl0aW5nRm9yICE9IGlkKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGFyZzIgJiYgYW5ub3RhdGlvbnMgaW5zdGFuY2VvZiBDb2RlTWlycm9yKVxuICAgICAgICAgIGFubm90YXRpb25zID0gYXJnMjtcbiAgICAgICAgY20ub3BlcmF0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHVwZGF0ZUxpbnRpbmcoY20sIGFubm90YXRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgICB9LCBzdGF0ZS5saW50ZXJPcHRpb25zLCBjbSk7XG4gICAgfVxuICAgIF9fbmFtZShsaW50QXN5bmMsIFwibGludEFzeW5jXCIpO1xuICAgIGZ1bmN0aW9uIHN0YXJ0TGludGluZyhjbSkge1xuICAgICAgdmFyIHN0YXRlID0gY20uc3RhdGUubGludDtcbiAgICAgIGlmICghc3RhdGUpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHZhciBvcHRpb25zID0gc3RhdGUub3B0aW9ucztcbiAgICAgIHZhciBnZXRBbm5vdGF0aW9ucyA9IG9wdGlvbnMuZ2V0QW5ub3RhdGlvbnMgfHwgY20uZ2V0SGVscGVyKENvZGVNaXJyb3IuUG9zKDAsIDApLCBcImxpbnRcIik7XG4gICAgICBpZiAoIWdldEFubm90YXRpb25zKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAob3B0aW9ucy5hc3luYyB8fCBnZXRBbm5vdGF0aW9ucy5hc3luYykge1xuICAgICAgICBsaW50QXN5bmMoY20sIGdldEFubm90YXRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBhbm5vdGF0aW9ucyA9IGdldEFubm90YXRpb25zKGNtLmdldFZhbHVlKCksIHN0YXRlLmxpbnRlck9wdGlvbnMsIGNtKTtcbiAgICAgICAgaWYgKCFhbm5vdGF0aW9ucylcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChhbm5vdGF0aW9ucy50aGVuKVxuICAgICAgICAgIGFubm90YXRpb25zLnRoZW4oZnVuY3Rpb24oaXNzdWVzKSB7XG4gICAgICAgICAgICBjbS5vcGVyYXRpb24oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHVwZGF0ZUxpbnRpbmcoY20sIGlzc3Vlcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGNtLm9wZXJhdGlvbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHVwZGF0ZUxpbnRpbmcoY20sIGFubm90YXRpb25zKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKHN0YXJ0TGludGluZywgXCJzdGFydExpbnRpbmdcIik7XG4gICAgZnVuY3Rpb24gdXBkYXRlTGludGluZyhjbSwgYW5ub3RhdGlvbnNOb3RTb3J0ZWQpIHtcbiAgICAgIHZhciBzdGF0ZSA9IGNtLnN0YXRlLmxpbnQ7XG4gICAgICBpZiAoIXN0YXRlKVxuICAgICAgICByZXR1cm47XG4gICAgICB2YXIgb3B0aW9ucyA9IHN0YXRlLm9wdGlvbnM7XG4gICAgICBjbGVhck1hcmtzKGNtKTtcbiAgICAgIHZhciBhbm5vdGF0aW9ucyA9IGdyb3VwQnlMaW5lKGFubm90YXRpb25zTm90U29ydGVkKTtcbiAgICAgIGZvciAodmFyIGxpbmUgPSAwOyBsaW5lIDwgYW5ub3RhdGlvbnMubGVuZ3RoOyArK2xpbmUpIHtcbiAgICAgICAgdmFyIGFubnMgPSBhbm5vdGF0aW9uc1tsaW5lXTtcbiAgICAgICAgaWYgKCFhbm5zKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB2YXIgbWVzc2FnZSA9IFtdO1xuICAgICAgICBhbm5zID0gYW5ucy5maWx0ZXIoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgIHJldHVybiBtZXNzYWdlLmluZGV4T2YoaXRlbS5tZXNzYWdlKSA+IC0xID8gZmFsc2UgOiBtZXNzYWdlLnB1c2goaXRlbS5tZXNzYWdlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBtYXhTZXZlcml0eSA9IG51bGw7XG4gICAgICAgIHZhciB0aXBMYWJlbCA9IHN0YXRlLmhhc0d1dHRlciAmJiBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhciBhbm4gPSBhbm5zW2ldO1xuICAgICAgICAgIHZhciBzZXZlcml0eSA9IGFubi5zZXZlcml0eTtcbiAgICAgICAgICBpZiAoIXNldmVyaXR5KVxuICAgICAgICAgICAgc2V2ZXJpdHkgPSBcImVycm9yXCI7XG4gICAgICAgICAgbWF4U2V2ZXJpdHkgPSBnZXRNYXhTZXZlcml0eShtYXhTZXZlcml0eSwgc2V2ZXJpdHkpO1xuICAgICAgICAgIGlmIChvcHRpb25zLmZvcm1hdEFubm90YXRpb24pXG4gICAgICAgICAgICBhbm4gPSBvcHRpb25zLmZvcm1hdEFubm90YXRpb24oYW5uKTtcbiAgICAgICAgICBpZiAoc3RhdGUuaGFzR3V0dGVyKVxuICAgICAgICAgICAgdGlwTGFiZWwuYXBwZW5kQ2hpbGQoYW5ub3RhdGlvblRvb2x0aXAoYW5uKSk7XG4gICAgICAgICAgaWYgKGFubi50bylcbiAgICAgICAgICAgIHN0YXRlLm1hcmtlZC5wdXNoKGNtLm1hcmtUZXh0KGFubi5mcm9tLCBhbm4udG8sIHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIkNvZGVNaXJyb3ItbGludC1tYXJrIENvZGVNaXJyb3ItbGludC1tYXJrLVwiICsgc2V2ZXJpdHksXG4gICAgICAgICAgICAgIF9fYW5ub3RhdGlvbjogYW5uXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmhhc0d1dHRlcilcbiAgICAgICAgICBjbS5zZXRHdXR0ZXJNYXJrZXIobGluZSwgR1VUVEVSX0lELCBtYWtlTWFya2VyKGNtLCB0aXBMYWJlbCwgbWF4U2V2ZXJpdHksIGFubm90YXRpb25zW2xpbmVdLmxlbmd0aCA+IDEsIG9wdGlvbnMudG9vbHRpcHMpKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuaGlnaGxpZ2h0TGluZXMpXG4gICAgICAgICAgY20uYWRkTGluZUNsYXNzKGxpbmUsIFwid3JhcFwiLCBMSU5UX0xJTkVfSUQgKyBtYXhTZXZlcml0eSk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5vblVwZGF0ZUxpbnRpbmcpXG4gICAgICAgIG9wdGlvbnMub25VcGRhdGVMaW50aW5nKGFubm90YXRpb25zTm90U29ydGVkLCBhbm5vdGF0aW9ucywgY20pO1xuICAgIH1cbiAgICBfX25hbWUodXBkYXRlTGludGluZywgXCJ1cGRhdGVMaW50aW5nXCIpO1xuICAgIGZ1bmN0aW9uIG9uQ2hhbmdlKGNtKSB7XG4gICAgICB2YXIgc3RhdGUgPSBjbS5zdGF0ZS5saW50O1xuICAgICAgaWYgKCFzdGF0ZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2xlYXJUaW1lb3V0KHN0YXRlLnRpbWVvdXQpO1xuICAgICAgc3RhdGUudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0YXJ0TGludGluZyhjbSk7XG4gICAgICB9LCBzdGF0ZS5vcHRpb25zLmRlbGF5KTtcbiAgICB9XG4gICAgX19uYW1lKG9uQ2hhbmdlLCBcIm9uQ2hhbmdlXCIpO1xuICAgIGZ1bmN0aW9uIHBvcHVwVG9vbHRpcHMoY20sIGFubm90YXRpb25zLCBlKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xuICAgICAgdmFyIHRvb2x0aXAgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFubm90YXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBhbm4gPSBhbm5vdGF0aW9uc1tpXTtcbiAgICAgICAgdG9vbHRpcC5hcHBlbmRDaGlsZChhbm5vdGF0aW9uVG9vbHRpcChhbm4pKTtcbiAgICAgIH1cbiAgICAgIHNob3dUb29sdGlwRm9yKGNtLCBlLCB0b29sdGlwLCB0YXJnZXQpO1xuICAgIH1cbiAgICBfX25hbWUocG9wdXBUb29sdGlwcywgXCJwb3B1cFRvb2x0aXBzXCIpO1xuICAgIGZ1bmN0aW9uIG9uTW91c2VPdmVyKGNtLCBlKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xuICAgICAgaWYgKCEvXFxiQ29kZU1pcnJvci1saW50LW1hcmstLy50ZXN0KHRhcmdldC5jbGFzc05hbWUpKVxuICAgICAgICByZXR1cm47XG4gICAgICB2YXIgYm94ID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB4ID0gKGJveC5sZWZ0ICsgYm94LnJpZ2h0KSAvIDIsIHkgPSAoYm94LnRvcCArIGJveC5ib3R0b20pIC8gMjtcbiAgICAgIHZhciBzcGFucyA9IGNtLmZpbmRNYXJrc0F0KGNtLmNvb3Jkc0NoYXIoeyBsZWZ0OiB4LCB0b3A6IHkgfSwgXCJjbGllbnRcIikpO1xuICAgICAgdmFyIGFubm90YXRpb25zID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBhbm4gPSBzcGFuc1tpXS5fX2Fubm90YXRpb247XG4gICAgICAgIGlmIChhbm4pXG4gICAgICAgICAgYW5ub3RhdGlvbnMucHVzaChhbm4pO1xuICAgICAgfVxuICAgICAgaWYgKGFubm90YXRpb25zLmxlbmd0aClcbiAgICAgICAgcG9wdXBUb29sdGlwcyhjbSwgYW5ub3RhdGlvbnMsIGUpO1xuICAgIH1cbiAgICBfX25hbWUob25Nb3VzZU92ZXIsIFwib25Nb3VzZU92ZXJcIik7XG4gICAgQ29kZU1pcnJvci5kZWZpbmVPcHRpb24oXCJsaW50XCIsIGZhbHNlLCBmdW5jdGlvbihjbSwgdmFsLCBvbGQpIHtcbiAgICAgIGlmIChvbGQgJiYgb2xkICE9IENvZGVNaXJyb3IuSW5pdCkge1xuICAgICAgICBjbGVhck1hcmtzKGNtKTtcbiAgICAgICAgaWYgKGNtLnN0YXRlLmxpbnQub3B0aW9ucy5saW50T25DaGFuZ2UgIT09IGZhbHNlKVxuICAgICAgICAgIGNtLm9mZihcImNoYW5nZVwiLCBvbkNoYW5nZSk7XG4gICAgICAgIENvZGVNaXJyb3Iub2ZmKGNtLmdldFdyYXBwZXJFbGVtZW50KCksIFwibW91c2VvdmVyXCIsIGNtLnN0YXRlLmxpbnQub25Nb3VzZU92ZXIpO1xuICAgICAgICBjbGVhclRpbWVvdXQoY20uc3RhdGUubGludC50aW1lb3V0KTtcbiAgICAgICAgZGVsZXRlIGNtLnN0YXRlLmxpbnQ7XG4gICAgICB9XG4gICAgICBpZiAodmFsKSB7XG4gICAgICAgIHZhciBndXR0ZXJzID0gY20uZ2V0T3B0aW9uKFwiZ3V0dGVyc1wiKSwgaGFzTGludEd1dHRlciA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGd1dHRlcnMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgaWYgKGd1dHRlcnNbaV0gPT0gR1VUVEVSX0lEKVxuICAgICAgICAgICAgaGFzTGludEd1dHRlciA9IHRydWU7XG4gICAgICAgIHZhciBzdGF0ZSA9IGNtLnN0YXRlLmxpbnQgPSBuZXcgTGludFN0YXRlKGNtLCB2YWwsIGhhc0xpbnRHdXR0ZXIpO1xuICAgICAgICBpZiAoc3RhdGUub3B0aW9ucy5saW50T25DaGFuZ2UpXG4gICAgICAgICAgY20ub24oXCJjaGFuZ2VcIiwgb25DaGFuZ2UpO1xuICAgICAgICBpZiAoc3RhdGUub3B0aW9ucy50b29sdGlwcyAhPSBmYWxzZSAmJiBzdGF0ZS5vcHRpb25zLnRvb2x0aXBzICE9IFwiZ3V0dGVyXCIpXG4gICAgICAgICAgQ29kZU1pcnJvci5vbihjbS5nZXRXcmFwcGVyRWxlbWVudCgpLCBcIm1vdXNlb3ZlclwiLCBzdGF0ZS5vbk1vdXNlT3Zlcik7XG4gICAgICAgIHN0YXJ0TGludGluZyhjbSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgQ29kZU1pcnJvci5kZWZpbmVFeHRlbnNpb24oXCJwZXJmb3JtTGludFwiLCBmdW5jdGlvbigpIHtcbiAgICAgIHN0YXJ0TGludGluZyh0aGlzKTtcbiAgICB9KTtcbiAgfSk7XG59KSgpO1xudmFyIGxpbnQgPSBsaW50JDIuZXhwb3J0cztcbnZhciBsaW50JDEgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gX21lcmdlTmFtZXNwYWNlcyh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106IFwiTW9kdWxlXCIsXG4gIFwiZGVmYXVsdFwiOiBsaW50XG59LCBbbGludCQyLmV4cG9ydHNdKSk7XG5leHBvcnQgeyBsaW50JDEgYXMgbCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///17481\n')}}]);