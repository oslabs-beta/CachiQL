"use strict";(self.webpackChunkcachiql_demo=self.webpackChunkcachiql_demo||[]).push([[571,980,105],{54980:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "a": () => (/* binding */ matchbrackets$2),\n/* harmony export */   "m": () => (/* binding */ matchbrackets$1)\n/* harmony export */ });\n/* harmony import */ var _codemirror_es_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97480);\nvar __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, "name", { value, configurable: true });\n\nfunction _mergeNamespaces(n, m) {\n  m.forEach(function(e) {\n    e && typeof e !== "string" && !Array.isArray(e) && Object.keys(e).forEach(function(k) {\n      if (k !== "default" && !(k in n)) {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function() {\n            return e[k];\n          }\n        });\n      }\n    });\n  });\n  return Object.freeze(n);\n}\n__name(_mergeNamespaces, "_mergeNamespaces");\nvar matchbrackets$2 = { exports: {} };\n(function(module, exports) {\n  (function(mod) {\n    mod(_codemirror_es_js__WEBPACK_IMPORTED_MODULE_0__.a.exports);\n  })(function(CodeMirror) {\n    var ie_lt8 = /MSIE \\d/.test(navigator.userAgent) && (document.documentMode == null || document.documentMode < 8);\n    var Pos = CodeMirror.Pos;\n    var matching = { "(": ")>", ")": "(<", "[": "]>", "]": "[<", "{": "}>", "}": "{<", "<": ">>", ">": "<<" };\n    function bracketRegex(config) {\n      return config && config.bracketRegex || /[(){}[\\]]/;\n    }\n    __name(bracketRegex, "bracketRegex");\n    function findMatchingBracket(cm, where, config) {\n      var line = cm.getLineHandle(where.line), pos = where.ch - 1;\n      var afterCursor = config && config.afterCursor;\n      if (afterCursor == null)\n        afterCursor = /(^| )cm-fat-cursor($| )/.test(cm.getWrapperElement().className);\n      var re = bracketRegex(config);\n      var match = !afterCursor && pos >= 0 && re.test(line.text.charAt(pos)) && matching[line.text.charAt(pos)] || re.test(line.text.charAt(pos + 1)) && matching[line.text.charAt(++pos)];\n      if (!match)\n        return null;\n      var dir = match.charAt(1) == ">" ? 1 : -1;\n      if (config && config.strict && dir > 0 != (pos == where.ch))\n        return null;\n      var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));\n      var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style, config);\n      if (found == null)\n        return null;\n      return {\n        from: Pos(where.line, pos),\n        to: found && found.pos,\n        match: found && found.ch == match.charAt(0),\n        forward: dir > 0\n      };\n    }\n    __name(findMatchingBracket, "findMatchingBracket");\n    function scanForBracket(cm, where, dir, style, config) {\n      var maxScanLen = config && config.maxScanLineLength || 1e4;\n      var maxScanLines = config && config.maxScanLines || 1e3;\n      var stack = [];\n      var re = bracketRegex(config);\n      var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1) : Math.max(cm.firstLine() - 1, where.line - maxScanLines);\n      for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {\n        var line = cm.getLine(lineNo);\n        if (!line)\n          continue;\n        var pos = dir > 0 ? 0 : line.length - 1, end = dir > 0 ? line.length : -1;\n        if (line.length > maxScanLen)\n          continue;\n        if (lineNo == where.line)\n          pos = where.ch - (dir < 0 ? 1 : 0);\n        for (; pos != end; pos += dir) {\n          var ch = line.charAt(pos);\n          if (re.test(ch) && (style === void 0 || (cm.getTokenTypeAt(Pos(lineNo, pos + 1)) || "") == (style || ""))) {\n            var match = matching[ch];\n            if (match && match.charAt(1) == ">" == dir > 0)\n              stack.push(ch);\n            else if (!stack.length)\n              return { pos: Pos(lineNo, pos), ch };\n            else\n              stack.pop();\n          }\n        }\n      }\n      return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;\n    }\n    __name(scanForBracket, "scanForBracket");\n    function matchBrackets(cm, autoclear, config) {\n      var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1e3, highlightNonMatching = config && config.highlightNonMatching;\n      var marks = [], ranges = cm.listSelections();\n      for (var i = 0; i < ranges.length; i++) {\n        var match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, config);\n        if (match && (match.match || highlightNonMatching !== false) && cm.getLine(match.from.line).length <= maxHighlightLen) {\n          var style = match.match ? "CodeMirror-matchingbracket" : "CodeMirror-nonmatchingbracket";\n          marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), { className: style }));\n          if (match.to && cm.getLine(match.to.line).length <= maxHighlightLen)\n            marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), { className: style }));\n        }\n      }\n      if (marks.length) {\n        if (ie_lt8 && cm.state.focused)\n          cm.focus();\n        var clear = /* @__PURE__ */ __name(function() {\n          cm.operation(function() {\n            for (var i2 = 0; i2 < marks.length; i2++)\n              marks[i2].clear();\n          });\n        }, "clear");\n        if (autoclear)\n          setTimeout(clear, 800);\n        else\n          return clear;\n      }\n    }\n    __name(matchBrackets, "matchBrackets");\n    function doMatchBrackets(cm) {\n      cm.operation(function() {\n        if (cm.state.matchBrackets.currentlyHighlighted) {\n          cm.state.matchBrackets.currentlyHighlighted();\n          cm.state.matchBrackets.currentlyHighlighted = null;\n        }\n        cm.state.matchBrackets.currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);\n      });\n    }\n    __name(doMatchBrackets, "doMatchBrackets");\n    function clearHighlighted(cm) {\n      if (cm.state.matchBrackets && cm.state.matchBrackets.currentlyHighlighted) {\n        cm.state.matchBrackets.currentlyHighlighted();\n        cm.state.matchBrackets.currentlyHighlighted = null;\n      }\n    }\n    __name(clearHighlighted, "clearHighlighted");\n    CodeMirror.defineOption("matchBrackets", false, function(cm, val, old) {\n      if (old && old != CodeMirror.Init) {\n        cm.off("cursorActivity", doMatchBrackets);\n        cm.off("focus", doMatchBrackets);\n        cm.off("blur", clearHighlighted);\n        clearHighlighted(cm);\n      }\n      if (val) {\n        cm.state.matchBrackets = typeof val == "object" ? val : {};\n        cm.on("cursorActivity", doMatchBrackets);\n        cm.on("focus", doMatchBrackets);\n        cm.on("blur", clearHighlighted);\n      }\n    });\n    CodeMirror.defineExtension("matchBrackets", function() {\n      matchBrackets(this, true);\n    });\n    CodeMirror.defineExtension("findMatchingBracket", function(pos, config, oldConfig) {\n      if (oldConfig || typeof config == "boolean") {\n        if (!oldConfig) {\n          config = config ? { strict: true } : null;\n        } else {\n          oldConfig.strict = config;\n          config = oldConfig;\n        }\n      }\n      return findMatchingBracket(this, pos, config);\n    });\n    CodeMirror.defineExtension("scanForBracket", function(pos, dir, style, config) {\n      return scanForBracket(this, pos, dir, style, config);\n    });\n  });\n})();\nvar matchbrackets = matchbrackets$2.exports;\nvar matchbrackets$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  [Symbol.toStringTag]: "Module",\n  "default": matchbrackets\n}, [matchbrackets$2.exports]));\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQ5ODAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQSw0REFBNEQsMkJBQTJCO0FBQ2xDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLFFBQVEsd0RBQWtCO0FBQzFCLEdBQUc7QUFDSDtBQUNBO0FBQ0EscUJBQXFCLDhDQUE4QyxLQUFLLE1BQU0sS0FBSztBQUNuRjtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG1CQUFtQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSx3RkFBd0Ysa0JBQWtCO0FBQzFHO0FBQ0Esb0ZBQW9GLGtCQUFrQjtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQkFBbUI7QUFDaEQ7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZUFBZTtBQUM3QyxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDcUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYWNoaXFsLWRlbW8vLi9ub2RlX21vZHVsZXMvQGdyYXBoaXFsL3JlYWN0L2Rpc3QvbWF0Y2hicmFja2V0cy5lcy5qcz9lY2JlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19uYW1lID0gKHRhcmdldCwgdmFsdWUpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwibmFtZVwiLCB7IHZhbHVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG5pbXBvcnQgeyBhIGFzIGNvZGVtaXJyb3IgfSBmcm9tIFwiLi9jb2RlbWlycm9yLmVzLmpzXCI7XG5mdW5jdGlvbiBfbWVyZ2VOYW1lc3BhY2VzKG4sIG0pIHtcbiAgbS5mb3JFYWNoKGZ1bmN0aW9uKGUpIHtcbiAgICBlICYmIHR5cGVvZiBlICE9PSBcInN0cmluZ1wiICYmICFBcnJheS5pc0FycmF5KGUpICYmIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmICEoayBpbiBuKSkge1xuICAgICAgICB2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgayk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBrLCBkLmdldCA/IGQgOiB7XG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGVba107XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xufVxuX19uYW1lKF9tZXJnZU5hbWVzcGFjZXMsIFwiX21lcmdlTmFtZXNwYWNlc1wiKTtcbnZhciBtYXRjaGJyYWNrZXRzJDIgPSB7IGV4cG9ydHM6IHt9IH07XG4oZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG4gIChmdW5jdGlvbihtb2QpIHtcbiAgICBtb2QoY29kZW1pcnJvci5leHBvcnRzKTtcbiAgfSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuICAgIHZhciBpZV9sdDggPSAvTVNJRSBcXGQvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgKGRvY3VtZW50LmRvY3VtZW50TW9kZSA9PSBudWxsIHx8IGRvY3VtZW50LmRvY3VtZW50TW9kZSA8IDgpO1xuICAgIHZhciBQb3MgPSBDb2RlTWlycm9yLlBvcztcbiAgICB2YXIgbWF0Y2hpbmcgPSB7IFwiKFwiOiBcIik+XCIsIFwiKVwiOiBcIig8XCIsIFwiW1wiOiBcIl0+XCIsIFwiXVwiOiBcIls8XCIsIFwie1wiOiBcIn0+XCIsIFwifVwiOiBcIns8XCIsIFwiPFwiOiBcIj4+XCIsIFwiPlwiOiBcIjw8XCIgfTtcbiAgICBmdW5jdGlvbiBicmFja2V0UmVnZXgoY29uZmlnKSB7XG4gICAgICByZXR1cm4gY29uZmlnICYmIGNvbmZpZy5icmFja2V0UmVnZXggfHwgL1soKXt9W1xcXV0vO1xuICAgIH1cbiAgICBfX25hbWUoYnJhY2tldFJlZ2V4LCBcImJyYWNrZXRSZWdleFwiKTtcbiAgICBmdW5jdGlvbiBmaW5kTWF0Y2hpbmdCcmFja2V0KGNtLCB3aGVyZSwgY29uZmlnKSB7XG4gICAgICB2YXIgbGluZSA9IGNtLmdldExpbmVIYW5kbGUod2hlcmUubGluZSksIHBvcyA9IHdoZXJlLmNoIC0gMTtcbiAgICAgIHZhciBhZnRlckN1cnNvciA9IGNvbmZpZyAmJiBjb25maWcuYWZ0ZXJDdXJzb3I7XG4gICAgICBpZiAoYWZ0ZXJDdXJzb3IgPT0gbnVsbClcbiAgICAgICAgYWZ0ZXJDdXJzb3IgPSAvKF58ICljbS1mYXQtY3Vyc29yKCR8ICkvLnRlc3QoY20uZ2V0V3JhcHBlckVsZW1lbnQoKS5jbGFzc05hbWUpO1xuICAgICAgdmFyIHJlID0gYnJhY2tldFJlZ2V4KGNvbmZpZyk7XG4gICAgICB2YXIgbWF0Y2ggPSAhYWZ0ZXJDdXJzb3IgJiYgcG9zID49IDAgJiYgcmUudGVzdChsaW5lLnRleHQuY2hhckF0KHBvcykpICYmIG1hdGNoaW5nW2xpbmUudGV4dC5jaGFyQXQocG9zKV0gfHwgcmUudGVzdChsaW5lLnRleHQuY2hhckF0KHBvcyArIDEpKSAmJiBtYXRjaGluZ1tsaW5lLnRleHQuY2hhckF0KCsrcG9zKV07XG4gICAgICBpZiAoIW1hdGNoKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBkaXIgPSBtYXRjaC5jaGFyQXQoMSkgPT0gXCI+XCIgPyAxIDogLTE7XG4gICAgICBpZiAoY29uZmlnICYmIGNvbmZpZy5zdHJpY3QgJiYgZGlyID4gMCAhPSAocG9zID09IHdoZXJlLmNoKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgc3R5bGUgPSBjbS5nZXRUb2tlblR5cGVBdChQb3Mod2hlcmUubGluZSwgcG9zICsgMSkpO1xuICAgICAgdmFyIGZvdW5kID0gc2NhbkZvckJyYWNrZXQoY20sIFBvcyh3aGVyZS5saW5lLCBwb3MgKyAoZGlyID4gMCA/IDEgOiAwKSksIGRpciwgc3R5bGUsIGNvbmZpZyk7XG4gICAgICBpZiAoZm91bmQgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBmcm9tOiBQb3Mod2hlcmUubGluZSwgcG9zKSxcbiAgICAgICAgdG86IGZvdW5kICYmIGZvdW5kLnBvcyxcbiAgICAgICAgbWF0Y2g6IGZvdW5kICYmIGZvdW5kLmNoID09IG1hdGNoLmNoYXJBdCgwKSxcbiAgICAgICAgZm9yd2FyZDogZGlyID4gMFxuICAgICAgfTtcbiAgICB9XG4gICAgX19uYW1lKGZpbmRNYXRjaGluZ0JyYWNrZXQsIFwiZmluZE1hdGNoaW5nQnJhY2tldFwiKTtcbiAgICBmdW5jdGlvbiBzY2FuRm9yQnJhY2tldChjbSwgd2hlcmUsIGRpciwgc3R5bGUsIGNvbmZpZykge1xuICAgICAgdmFyIG1heFNjYW5MZW4gPSBjb25maWcgJiYgY29uZmlnLm1heFNjYW5MaW5lTGVuZ3RoIHx8IDFlNDtcbiAgICAgIHZhciBtYXhTY2FuTGluZXMgPSBjb25maWcgJiYgY29uZmlnLm1heFNjYW5MaW5lcyB8fCAxZTM7XG4gICAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICAgIHZhciByZSA9IGJyYWNrZXRSZWdleChjb25maWcpO1xuICAgICAgdmFyIGxpbmVFbmQgPSBkaXIgPiAwID8gTWF0aC5taW4od2hlcmUubGluZSArIG1heFNjYW5MaW5lcywgY20ubGFzdExpbmUoKSArIDEpIDogTWF0aC5tYXgoY20uZmlyc3RMaW5lKCkgLSAxLCB3aGVyZS5saW5lIC0gbWF4U2NhbkxpbmVzKTtcbiAgICAgIGZvciAodmFyIGxpbmVObyA9IHdoZXJlLmxpbmU7IGxpbmVObyAhPSBsaW5lRW5kOyBsaW5lTm8gKz0gZGlyKSB7XG4gICAgICAgIHZhciBsaW5lID0gY20uZ2V0TGluZShsaW5lTm8pO1xuICAgICAgICBpZiAoIWxpbmUpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIHZhciBwb3MgPSBkaXIgPiAwID8gMCA6IGxpbmUubGVuZ3RoIC0gMSwgZW5kID0gZGlyID4gMCA/IGxpbmUubGVuZ3RoIDogLTE7XG4gICAgICAgIGlmIChsaW5lLmxlbmd0aCA+IG1heFNjYW5MZW4pXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChsaW5lTm8gPT0gd2hlcmUubGluZSlcbiAgICAgICAgICBwb3MgPSB3aGVyZS5jaCAtIChkaXIgPCAwID8gMSA6IDApO1xuICAgICAgICBmb3IgKDsgcG9zICE9IGVuZDsgcG9zICs9IGRpcikge1xuICAgICAgICAgIHZhciBjaCA9IGxpbmUuY2hhckF0KHBvcyk7XG4gICAgICAgICAgaWYgKHJlLnRlc3QoY2gpICYmIChzdHlsZSA9PT0gdm9pZCAwIHx8IChjbS5nZXRUb2tlblR5cGVBdChQb3MobGluZU5vLCBwb3MgKyAxKSkgfHwgXCJcIikgPT0gKHN0eWxlIHx8IFwiXCIpKSkge1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gbWF0Y2hpbmdbY2hdO1xuICAgICAgICAgICAgaWYgKG1hdGNoICYmIG1hdGNoLmNoYXJBdCgxKSA9PSBcIj5cIiA9PSBkaXIgPiAwKVxuICAgICAgICAgICAgICBzdGFjay5wdXNoKGNoKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKCFzdGFjay5sZW5ndGgpXG4gICAgICAgICAgICAgIHJldHVybiB7IHBvczogUG9zKGxpbmVObywgcG9zKSwgY2ggfTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbGluZU5vIC0gZGlyID09IChkaXIgPiAwID8gY20ubGFzdExpbmUoKSA6IGNtLmZpcnN0TGluZSgpKSA/IGZhbHNlIDogbnVsbDtcbiAgICB9XG4gICAgX19uYW1lKHNjYW5Gb3JCcmFja2V0LCBcInNjYW5Gb3JCcmFja2V0XCIpO1xuICAgIGZ1bmN0aW9uIG1hdGNoQnJhY2tldHMoY20sIGF1dG9jbGVhciwgY29uZmlnKSB7XG4gICAgICB2YXIgbWF4SGlnaGxpZ2h0TGVuID0gY20uc3RhdGUubWF0Y2hCcmFja2V0cy5tYXhIaWdobGlnaHRMaW5lTGVuZ3RoIHx8IDFlMywgaGlnaGxpZ2h0Tm9uTWF0Y2hpbmcgPSBjb25maWcgJiYgY29uZmlnLmhpZ2hsaWdodE5vbk1hdGNoaW5nO1xuICAgICAgdmFyIG1hcmtzID0gW10sIHJhbmdlcyA9IGNtLmxpc3RTZWxlY3Rpb25zKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbWF0Y2ggPSByYW5nZXNbaV0uZW1wdHkoKSAmJiBmaW5kTWF0Y2hpbmdCcmFja2V0KGNtLCByYW5nZXNbaV0uaGVhZCwgY29uZmlnKTtcbiAgICAgICAgaWYgKG1hdGNoICYmIChtYXRjaC5tYXRjaCB8fCBoaWdobGlnaHROb25NYXRjaGluZyAhPT0gZmFsc2UpICYmIGNtLmdldExpbmUobWF0Y2guZnJvbS5saW5lKS5sZW5ndGggPD0gbWF4SGlnaGxpZ2h0TGVuKSB7XG4gICAgICAgICAgdmFyIHN0eWxlID0gbWF0Y2gubWF0Y2ggPyBcIkNvZGVNaXJyb3ItbWF0Y2hpbmdicmFja2V0XCIgOiBcIkNvZGVNaXJyb3Itbm9ubWF0Y2hpbmdicmFja2V0XCI7XG4gICAgICAgICAgbWFya3MucHVzaChjbS5tYXJrVGV4dChtYXRjaC5mcm9tLCBQb3MobWF0Y2guZnJvbS5saW5lLCBtYXRjaC5mcm9tLmNoICsgMSksIHsgY2xhc3NOYW1lOiBzdHlsZSB9KSk7XG4gICAgICAgICAgaWYgKG1hdGNoLnRvICYmIGNtLmdldExpbmUobWF0Y2gudG8ubGluZSkubGVuZ3RoIDw9IG1heEhpZ2hsaWdodExlbilcbiAgICAgICAgICAgIG1hcmtzLnB1c2goY20ubWFya1RleHQobWF0Y2gudG8sIFBvcyhtYXRjaC50by5saW5lLCBtYXRjaC50by5jaCArIDEpLCB7IGNsYXNzTmFtZTogc3R5bGUgfSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWFya3MubGVuZ3RoKSB7XG4gICAgICAgIGlmIChpZV9sdDggJiYgY20uc3RhdGUuZm9jdXNlZClcbiAgICAgICAgICBjbS5mb2N1cygpO1xuICAgICAgICB2YXIgY2xlYXIgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNtLm9wZXJhdGlvbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBtYXJrcy5sZW5ndGg7IGkyKyspXG4gICAgICAgICAgICAgIG1hcmtzW2kyXS5jbGVhcigpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBcImNsZWFyXCIpO1xuICAgICAgICBpZiAoYXV0b2NsZWFyKVxuICAgICAgICAgIHNldFRpbWVvdXQoY2xlYXIsIDgwMCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXR1cm4gY2xlYXI7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShtYXRjaEJyYWNrZXRzLCBcIm1hdGNoQnJhY2tldHNcIik7XG4gICAgZnVuY3Rpb24gZG9NYXRjaEJyYWNrZXRzKGNtKSB7XG4gICAgICBjbS5vcGVyYXRpb24oZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChjbS5zdGF0ZS5tYXRjaEJyYWNrZXRzLmN1cnJlbnRseUhpZ2hsaWdodGVkKSB7XG4gICAgICAgICAgY20uc3RhdGUubWF0Y2hCcmFja2V0cy5jdXJyZW50bHlIaWdobGlnaHRlZCgpO1xuICAgICAgICAgIGNtLnN0YXRlLm1hdGNoQnJhY2tldHMuY3VycmVudGx5SGlnaGxpZ2h0ZWQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNtLnN0YXRlLm1hdGNoQnJhY2tldHMuY3VycmVudGx5SGlnaGxpZ2h0ZWQgPSBtYXRjaEJyYWNrZXRzKGNtLCBmYWxzZSwgY20uc3RhdGUubWF0Y2hCcmFja2V0cyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgX19uYW1lKGRvTWF0Y2hCcmFja2V0cywgXCJkb01hdGNoQnJhY2tldHNcIik7XG4gICAgZnVuY3Rpb24gY2xlYXJIaWdobGlnaHRlZChjbSkge1xuICAgICAgaWYgKGNtLnN0YXRlLm1hdGNoQnJhY2tldHMgJiYgY20uc3RhdGUubWF0Y2hCcmFja2V0cy5jdXJyZW50bHlIaWdobGlnaHRlZCkge1xuICAgICAgICBjbS5zdGF0ZS5tYXRjaEJyYWNrZXRzLmN1cnJlbnRseUhpZ2hsaWdodGVkKCk7XG4gICAgICAgIGNtLnN0YXRlLm1hdGNoQnJhY2tldHMuY3VycmVudGx5SGlnaGxpZ2h0ZWQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoY2xlYXJIaWdobGlnaHRlZCwgXCJjbGVhckhpZ2hsaWdodGVkXCIpO1xuICAgIENvZGVNaXJyb3IuZGVmaW5lT3B0aW9uKFwibWF0Y2hCcmFja2V0c1wiLCBmYWxzZSwgZnVuY3Rpb24oY20sIHZhbCwgb2xkKSB7XG4gICAgICBpZiAob2xkICYmIG9sZCAhPSBDb2RlTWlycm9yLkluaXQpIHtcbiAgICAgICAgY20ub2ZmKFwiY3Vyc29yQWN0aXZpdHlcIiwgZG9NYXRjaEJyYWNrZXRzKTtcbiAgICAgICAgY20ub2ZmKFwiZm9jdXNcIiwgZG9NYXRjaEJyYWNrZXRzKTtcbiAgICAgICAgY20ub2ZmKFwiYmx1clwiLCBjbGVhckhpZ2hsaWdodGVkKTtcbiAgICAgICAgY2xlYXJIaWdobGlnaHRlZChjbSk7XG4gICAgICB9XG4gICAgICBpZiAodmFsKSB7XG4gICAgICAgIGNtLnN0YXRlLm1hdGNoQnJhY2tldHMgPSB0eXBlb2YgdmFsID09IFwib2JqZWN0XCIgPyB2YWwgOiB7fTtcbiAgICAgICAgY20ub24oXCJjdXJzb3JBY3Rpdml0eVwiLCBkb01hdGNoQnJhY2tldHMpO1xuICAgICAgICBjbS5vbihcImZvY3VzXCIsIGRvTWF0Y2hCcmFja2V0cyk7XG4gICAgICAgIGNtLm9uKFwiYmx1clwiLCBjbGVhckhpZ2hsaWdodGVkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBDb2RlTWlycm9yLmRlZmluZUV4dGVuc2lvbihcIm1hdGNoQnJhY2tldHNcIiwgZnVuY3Rpb24oKSB7XG4gICAgICBtYXRjaEJyYWNrZXRzKHRoaXMsIHRydWUpO1xuICAgIH0pO1xuICAgIENvZGVNaXJyb3IuZGVmaW5lRXh0ZW5zaW9uKFwiZmluZE1hdGNoaW5nQnJhY2tldFwiLCBmdW5jdGlvbihwb3MsIGNvbmZpZywgb2xkQ29uZmlnKSB7XG4gICAgICBpZiAob2xkQ29uZmlnIHx8IHR5cGVvZiBjb25maWcgPT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgaWYgKCFvbGRDb25maWcpIHtcbiAgICAgICAgICBjb25maWcgPSBjb25maWcgPyB7IHN0cmljdDogdHJ1ZSB9IDogbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbGRDb25maWcuc3RyaWN0ID0gY29uZmlnO1xuICAgICAgICAgIGNvbmZpZyA9IG9sZENvbmZpZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZpbmRNYXRjaGluZ0JyYWNrZXQodGhpcywgcG9zLCBjb25maWcpO1xuICAgIH0pO1xuICAgIENvZGVNaXJyb3IuZGVmaW5lRXh0ZW5zaW9uKFwic2NhbkZvckJyYWNrZXRcIiwgZnVuY3Rpb24ocG9zLCBkaXIsIHN0eWxlLCBjb25maWcpIHtcbiAgICAgIHJldHVybiBzY2FuRm9yQnJhY2tldCh0aGlzLCBwb3MsIGRpciwgc3R5bGUsIGNvbmZpZyk7XG4gICAgfSk7XG4gIH0pO1xufSkoKTtcbnZhciBtYXRjaGJyYWNrZXRzID0gbWF0Y2hicmFja2V0cyQyLmV4cG9ydHM7XG52YXIgbWF0Y2hicmFja2V0cyQxID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIF9tZXJnZU5hbWVzcGFjZXMoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiBcIk1vZHVsZVwiLFxuICBcImRlZmF1bHRcIjogbWF0Y2hicmFja2V0c1xufSwgW21hdGNoYnJhY2tldHMkMi5leHBvcnRzXSkpO1xuZXhwb3J0IHsgbWF0Y2hicmFja2V0cyQyIGFzIGEsIG1hdGNoYnJhY2tldHMkMSBhcyBtIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///54980\n')},26105:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "a": () => (/* binding */ searchcursor$2),\n/* harmony export */   "s": () => (/* binding */ searchcursor$1)\n/* harmony export */ });\n/* harmony import */ var _codemirror_es_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97480);\nvar __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, "name", { value, configurable: true });\n\nfunction _mergeNamespaces(n, m) {\n  m.forEach(function(e) {\n    e && typeof e !== "string" && !Array.isArray(e) && Object.keys(e).forEach(function(k) {\n      if (k !== "default" && !(k in n)) {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function() {\n            return e[k];\n          }\n        });\n      }\n    });\n  });\n  return Object.freeze(n);\n}\n__name(_mergeNamespaces, "_mergeNamespaces");\nvar searchcursor$2 = { exports: {} };\n(function(module, exports) {\n  (function(mod) {\n    mod(_codemirror_es_js__WEBPACK_IMPORTED_MODULE_0__.a.exports);\n  })(function(CodeMirror) {\n    var Pos = CodeMirror.Pos;\n    function regexpFlags(regexp) {\n      var flags = regexp.flags;\n      return flags != null ? flags : (regexp.ignoreCase ? "i" : "") + (regexp.global ? "g" : "") + (regexp.multiline ? "m" : "");\n    }\n    __name(regexpFlags, "regexpFlags");\n    function ensureFlags(regexp, flags) {\n      var current = regexpFlags(regexp), target = current;\n      for (var i = 0; i < flags.length; i++)\n        if (target.indexOf(flags.charAt(i)) == -1)\n          target += flags.charAt(i);\n      return current == target ? regexp : new RegExp(regexp.source, target);\n    }\n    __name(ensureFlags, "ensureFlags");\n    function maybeMultiline(regexp) {\n      return /\\\\s|\\\\n|\\n|\\\\W|\\\\D|\\[\\^/.test(regexp.source);\n    }\n    __name(maybeMultiline, "maybeMultiline");\n    function searchRegexpForward(doc, regexp, start) {\n      regexp = ensureFlags(regexp, "g");\n      for (var line = start.line, ch = start.ch, last = doc.lastLine(); line <= last; line++, ch = 0) {\n        regexp.lastIndex = ch;\n        var string = doc.getLine(line), match = regexp.exec(string);\n        if (match)\n          return {\n            from: Pos(line, match.index),\n            to: Pos(line, match.index + match[0].length),\n            match\n          };\n      }\n    }\n    __name(searchRegexpForward, "searchRegexpForward");\n    function searchRegexpForwardMultiline(doc, regexp, start) {\n      if (!maybeMultiline(regexp))\n        return searchRegexpForward(doc, regexp, start);\n      regexp = ensureFlags(regexp, "gm");\n      var string, chunk = 1;\n      for (var line = start.line, last = doc.lastLine(); line <= last; ) {\n        for (var i = 0; i < chunk; i++) {\n          if (line > last)\n            break;\n          var curLine = doc.getLine(line++);\n          string = string == null ? curLine : string + "\\n" + curLine;\n        }\n        chunk = chunk * 2;\n        regexp.lastIndex = start.ch;\n        var match = regexp.exec(string);\n        if (match) {\n          var before = string.slice(0, match.index).split("\\n"), inside = match[0].split("\\n");\n          var startLine = start.line + before.length - 1, startCh = before[before.length - 1].length;\n          return {\n            from: Pos(startLine, startCh),\n            to: Pos(startLine + inside.length - 1, inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\n            match\n          };\n        }\n      }\n    }\n    __name(searchRegexpForwardMultiline, "searchRegexpForwardMultiline");\n    function lastMatchIn(string, regexp, endMargin) {\n      var match, from = 0;\n      while (from <= string.length) {\n        regexp.lastIndex = from;\n        var newMatch = regexp.exec(string);\n        if (!newMatch)\n          break;\n        var end = newMatch.index + newMatch[0].length;\n        if (end > string.length - endMargin)\n          break;\n        if (!match || end > match.index + match[0].length)\n          match = newMatch;\n        from = newMatch.index + 1;\n      }\n      return match;\n    }\n    __name(lastMatchIn, "lastMatchIn");\n    function searchRegexpBackward(doc, regexp, start) {\n      regexp = ensureFlags(regexp, "g");\n      for (var line = start.line, ch = start.ch, first = doc.firstLine(); line >= first; line--, ch = -1) {\n        var string = doc.getLine(line);\n        var match = lastMatchIn(string, regexp, ch < 0 ? 0 : string.length - ch);\n        if (match)\n          return {\n            from: Pos(line, match.index),\n            to: Pos(line, match.index + match[0].length),\n            match\n          };\n      }\n    }\n    __name(searchRegexpBackward, "searchRegexpBackward");\n    function searchRegexpBackwardMultiline(doc, regexp, start) {\n      if (!maybeMultiline(regexp))\n        return searchRegexpBackward(doc, regexp, start);\n      regexp = ensureFlags(regexp, "gm");\n      var string, chunkSize = 1, endMargin = doc.getLine(start.line).length - start.ch;\n      for (var line = start.line, first = doc.firstLine(); line >= first; ) {\n        for (var i = 0; i < chunkSize && line >= first; i++) {\n          var curLine = doc.getLine(line--);\n          string = string == null ? curLine : curLine + "\\n" + string;\n        }\n        chunkSize *= 2;\n        var match = lastMatchIn(string, regexp, endMargin);\n        if (match) {\n          var before = string.slice(0, match.index).split("\\n"), inside = match[0].split("\\n");\n          var startLine = line + before.length, startCh = before[before.length - 1].length;\n          return {\n            from: Pos(startLine, startCh),\n            to: Pos(startLine + inside.length - 1, inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\n            match\n          };\n        }\n      }\n    }\n    __name(searchRegexpBackwardMultiline, "searchRegexpBackwardMultiline");\n    var doFold, noFold;\n    if (String.prototype.normalize) {\n      doFold = /* @__PURE__ */ __name(function(str) {\n        return str.normalize("NFD").toLowerCase();\n      }, "doFold");\n      noFold = /* @__PURE__ */ __name(function(str) {\n        return str.normalize("NFD");\n      }, "noFold");\n    } else {\n      doFold = /* @__PURE__ */ __name(function(str) {\n        return str.toLowerCase();\n      }, "doFold");\n      noFold = /* @__PURE__ */ __name(function(str) {\n        return str;\n      }, "noFold");\n    }\n    function adjustPos(orig, folded, pos, foldFunc) {\n      if (orig.length == folded.length)\n        return pos;\n      for (var min = 0, max = pos + Math.max(0, orig.length - folded.length); ; ) {\n        if (min == max)\n          return min;\n        var mid = min + max >> 1;\n        var len = foldFunc(orig.slice(0, mid)).length;\n        if (len == pos)\n          return mid;\n        else if (len > pos)\n          max = mid;\n        else\n          min = mid + 1;\n      }\n    }\n    __name(adjustPos, "adjustPos");\n    function searchStringForward(doc, query, start, caseFold) {\n      if (!query.length)\n        return null;\n      var fold = caseFold ? doFold : noFold;\n      var lines = fold(query).split(/\\r|\\n\\r?/);\n      search:\n        for (var line = start.line, ch = start.ch, last = doc.lastLine() + 1 - lines.length; line <= last; line++, ch = 0) {\n          var orig = doc.getLine(line).slice(ch), string = fold(orig);\n          if (lines.length == 1) {\n            var found = string.indexOf(lines[0]);\n            if (found == -1)\n              continue search;\n            var start = adjustPos(orig, string, found, fold) + ch;\n            return {\n              from: Pos(line, adjustPos(orig, string, found, fold) + ch),\n              to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold) + ch)\n            };\n          } else {\n            var cutFrom = string.length - lines[0].length;\n            if (string.slice(cutFrom) != lines[0])\n              continue search;\n            for (var i = 1; i < lines.length - 1; i++)\n              if (fold(doc.getLine(line + i)) != lines[i])\n                continue search;\n            var end = doc.getLine(line + lines.length - 1), endString = fold(end), lastLine = lines[lines.length - 1];\n            if (endString.slice(0, lastLine.length) != lastLine)\n              continue search;\n            return {\n              from: Pos(line, adjustPos(orig, string, cutFrom, fold) + ch),\n              to: Pos(line + lines.length - 1, adjustPos(end, endString, lastLine.length, fold))\n            };\n          }\n        }\n    }\n    __name(searchStringForward, "searchStringForward");\n    function searchStringBackward(doc, query, start, caseFold) {\n      if (!query.length)\n        return null;\n      var fold = caseFold ? doFold : noFold;\n      var lines = fold(query).split(/\\r|\\n\\r?/);\n      search:\n        for (var line = start.line, ch = start.ch, first = doc.firstLine() - 1 + lines.length; line >= first; line--, ch = -1) {\n          var orig = doc.getLine(line);\n          if (ch > -1)\n            orig = orig.slice(0, ch);\n          var string = fold(orig);\n          if (lines.length == 1) {\n            var found = string.lastIndexOf(lines[0]);\n            if (found == -1)\n              continue search;\n            return {\n              from: Pos(line, adjustPos(orig, string, found, fold)),\n              to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold))\n            };\n          } else {\n            var lastLine = lines[lines.length - 1];\n            if (string.slice(0, lastLine.length) != lastLine)\n              continue search;\n            for (var i = 1, start = line - lines.length + 1; i < lines.length - 1; i++)\n              if (fold(doc.getLine(start + i)) != lines[i])\n                continue search;\n            var top = doc.getLine(line + 1 - lines.length), topString = fold(top);\n            if (topString.slice(topString.length - lines[0].length) != lines[0])\n              continue search;\n            return {\n              from: Pos(line + 1 - lines.length, adjustPos(top, topString, top.length - lines[0].length, fold)),\n              to: Pos(line, adjustPos(orig, string, lastLine.length, fold))\n            };\n          }\n        }\n    }\n    __name(searchStringBackward, "searchStringBackward");\n    function SearchCursor(doc, query, pos, options) {\n      this.atOccurrence = false;\n      this.afterEmptyMatch = false;\n      this.doc = doc;\n      pos = pos ? doc.clipPos(pos) : Pos(0, 0);\n      this.pos = { from: pos, to: pos };\n      var caseFold;\n      if (typeof options == "object") {\n        caseFold = options.caseFold;\n      } else {\n        caseFold = options;\n        options = null;\n      }\n      if (typeof query == "string") {\n        if (caseFold == null)\n          caseFold = false;\n        this.matches = function(reverse, pos2) {\n          return (reverse ? searchStringBackward : searchStringForward)(doc, query, pos2, caseFold);\n        };\n      } else {\n        query = ensureFlags(query, "gm");\n        if (!options || options.multiline !== false)\n          this.matches = function(reverse, pos2) {\n            return (reverse ? searchRegexpBackwardMultiline : searchRegexpForwardMultiline)(doc, query, pos2);\n          };\n        else\n          this.matches = function(reverse, pos2) {\n            return (reverse ? searchRegexpBackward : searchRegexpForward)(doc, query, pos2);\n          };\n      }\n    }\n    __name(SearchCursor, "SearchCursor");\n    SearchCursor.prototype = {\n      findNext: function() {\n        return this.find(false);\n      },\n      findPrevious: function() {\n        return this.find(true);\n      },\n      find: function(reverse) {\n        var head = this.doc.clipPos(reverse ? this.pos.from : this.pos.to);\n        if (this.afterEmptyMatch && this.atOccurrence) {\n          head = Pos(head.line, head.ch);\n          if (reverse) {\n            head.ch--;\n            if (head.ch < 0) {\n              head.line--;\n              head.ch = (this.doc.getLine(head.line) || "").length;\n            }\n          } else {\n            head.ch++;\n            if (head.ch > (this.doc.getLine(head.line) || "").length) {\n              head.ch = 0;\n              head.line++;\n            }\n          }\n          if (CodeMirror.cmpPos(head, this.doc.clipPos(head)) != 0) {\n            return this.atOccurrence = false;\n          }\n        }\n        var result = this.matches(reverse, head);\n        this.afterEmptyMatch = result && CodeMirror.cmpPos(result.from, result.to) == 0;\n        if (result) {\n          this.pos = result;\n          this.atOccurrence = true;\n          return this.pos.match || true;\n        } else {\n          var end = Pos(reverse ? this.doc.firstLine() : this.doc.lastLine() + 1, 0);\n          this.pos = { from: end, to: end };\n          return this.atOccurrence = false;\n        }\n      },\n      from: function() {\n        if (this.atOccurrence)\n          return this.pos.from;\n      },\n      to: function() {\n        if (this.atOccurrence)\n          return this.pos.to;\n      },\n      replace: function(newText, origin) {\n        if (!this.atOccurrence)\n          return;\n        var lines = CodeMirror.splitLines(newText);\n        this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin);\n        this.pos.to = Pos(this.pos.from.line + lines.length - 1, lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0));\n      }\n    };\n    CodeMirror.defineExtension("getSearchCursor", function(query, pos, caseFold) {\n      return new SearchCursor(this.doc, query, pos, caseFold);\n    });\n    CodeMirror.defineDocExtension("getSearchCursor", function(query, pos, caseFold) {\n      return new SearchCursor(this, query, pos, caseFold);\n    });\n    CodeMirror.defineExtension("selectMatches", function(query, caseFold) {\n      var ranges = [];\n      var cur = this.getSearchCursor(query, this.getCursor("from"), caseFold);\n      while (cur.findNext()) {\n        if (CodeMirror.cmpPos(cur.to(), this.getCursor("to")) > 0)\n          break;\n        ranges.push({ anchor: cur.from(), head: cur.to() });\n      }\n      if (ranges.length)\n        this.setSelections(ranges, 0);\n    });\n  });\n})();\nvar searchcursor = searchcursor$2.exports;\nvar searchcursor$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  [Symbol.toStringTag]: "Module",\n  "default": searchcursor\n}, [searchcursor$2.exports]));\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0NBQW9DO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ21EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2FjaGlxbC1kZW1vLy4vbm9kZV9tb2R1bGVzL0BncmFwaGlxbC9yZWFjdC9kaXN0L3NlYXJjaGN1cnNvci5lcy5qcz8xY2JhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19uYW1lID0gKHRhcmdldCwgdmFsdWUpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwibmFtZVwiLCB7IHZhbHVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG5pbXBvcnQgeyBhIGFzIGNvZGVtaXJyb3IgfSBmcm9tIFwiLi9jb2RlbWlycm9yLmVzLmpzXCI7XG5mdW5jdGlvbiBfbWVyZ2VOYW1lc3BhY2VzKG4sIG0pIHtcbiAgbS5mb3JFYWNoKGZ1bmN0aW9uKGUpIHtcbiAgICBlICYmIHR5cGVvZiBlICE9PSBcInN0cmluZ1wiICYmICFBcnJheS5pc0FycmF5KGUpICYmIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmICEoayBpbiBuKSkge1xuICAgICAgICB2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgayk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBrLCBkLmdldCA/IGQgOiB7XG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGVba107XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xufVxuX19uYW1lKF9tZXJnZU5hbWVzcGFjZXMsIFwiX21lcmdlTmFtZXNwYWNlc1wiKTtcbnZhciBzZWFyY2hjdXJzb3IkMiA9IHsgZXhwb3J0czoge30gfTtcbihmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcbiAgKGZ1bmN0aW9uKG1vZCkge1xuICAgIG1vZChjb2RlbWlycm9yLmV4cG9ydHMpO1xuICB9KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG4gICAgdmFyIFBvcyA9IENvZGVNaXJyb3IuUG9zO1xuICAgIGZ1bmN0aW9uIHJlZ2V4cEZsYWdzKHJlZ2V4cCkge1xuICAgICAgdmFyIGZsYWdzID0gcmVnZXhwLmZsYWdzO1xuICAgICAgcmV0dXJuIGZsYWdzICE9IG51bGwgPyBmbGFncyA6IChyZWdleHAuaWdub3JlQ2FzZSA/IFwiaVwiIDogXCJcIikgKyAocmVnZXhwLmdsb2JhbCA/IFwiZ1wiIDogXCJcIikgKyAocmVnZXhwLm11bHRpbGluZSA/IFwibVwiIDogXCJcIik7XG4gICAgfVxuICAgIF9fbmFtZShyZWdleHBGbGFncywgXCJyZWdleHBGbGFnc1wiKTtcbiAgICBmdW5jdGlvbiBlbnN1cmVGbGFncyhyZWdleHAsIGZsYWdzKSB7XG4gICAgICB2YXIgY3VycmVudCA9IHJlZ2V4cEZsYWdzKHJlZ2V4cCksIHRhcmdldCA9IGN1cnJlbnQ7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZsYWdzLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAodGFyZ2V0LmluZGV4T2YoZmxhZ3MuY2hhckF0KGkpKSA9PSAtMSlcbiAgICAgICAgICB0YXJnZXQgKz0gZmxhZ3MuY2hhckF0KGkpO1xuICAgICAgcmV0dXJuIGN1cnJlbnQgPT0gdGFyZ2V0ID8gcmVnZXhwIDogbmV3IFJlZ0V4cChyZWdleHAuc291cmNlLCB0YXJnZXQpO1xuICAgIH1cbiAgICBfX25hbWUoZW5zdXJlRmxhZ3MsIFwiZW5zdXJlRmxhZ3NcIik7XG4gICAgZnVuY3Rpb24gbWF5YmVNdWx0aWxpbmUocmVnZXhwKSB7XG4gICAgICByZXR1cm4gL1xcXFxzfFxcXFxufFxcbnxcXFxcV3xcXFxcRHxcXFtcXF4vLnRlc3QocmVnZXhwLnNvdXJjZSk7XG4gICAgfVxuICAgIF9fbmFtZShtYXliZU11bHRpbGluZSwgXCJtYXliZU11bHRpbGluZVwiKTtcbiAgICBmdW5jdGlvbiBzZWFyY2hSZWdleHBGb3J3YXJkKGRvYywgcmVnZXhwLCBzdGFydCkge1xuICAgICAgcmVnZXhwID0gZW5zdXJlRmxhZ3MocmVnZXhwLCBcImdcIik7XG4gICAgICBmb3IgKHZhciBsaW5lID0gc3RhcnQubGluZSwgY2ggPSBzdGFydC5jaCwgbGFzdCA9IGRvYy5sYXN0TGluZSgpOyBsaW5lIDw9IGxhc3Q7IGxpbmUrKywgY2ggPSAwKSB7XG4gICAgICAgIHJlZ2V4cC5sYXN0SW5kZXggPSBjaDtcbiAgICAgICAgdmFyIHN0cmluZyA9IGRvYy5nZXRMaW5lKGxpbmUpLCBtYXRjaCA9IHJlZ2V4cC5leGVjKHN0cmluZyk7XG4gICAgICAgIGlmIChtYXRjaClcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZnJvbTogUG9zKGxpbmUsIG1hdGNoLmluZGV4KSxcbiAgICAgICAgICAgIHRvOiBQb3MobGluZSwgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpLFxuICAgICAgICAgICAgbWF0Y2hcbiAgICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoc2VhcmNoUmVnZXhwRm9yd2FyZCwgXCJzZWFyY2hSZWdleHBGb3J3YXJkXCIpO1xuICAgIGZ1bmN0aW9uIHNlYXJjaFJlZ2V4cEZvcndhcmRNdWx0aWxpbmUoZG9jLCByZWdleHAsIHN0YXJ0KSB7XG4gICAgICBpZiAoIW1heWJlTXVsdGlsaW5lKHJlZ2V4cCkpXG4gICAgICAgIHJldHVybiBzZWFyY2hSZWdleHBGb3J3YXJkKGRvYywgcmVnZXhwLCBzdGFydCk7XG4gICAgICByZWdleHAgPSBlbnN1cmVGbGFncyhyZWdleHAsIFwiZ21cIik7XG4gICAgICB2YXIgc3RyaW5nLCBjaHVuayA9IDE7XG4gICAgICBmb3IgKHZhciBsaW5lID0gc3RhcnQubGluZSwgbGFzdCA9IGRvYy5sYXN0TGluZSgpOyBsaW5lIDw9IGxhc3Q7ICkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNodW5rOyBpKyspIHtcbiAgICAgICAgICBpZiAobGluZSA+IGxhc3QpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB2YXIgY3VyTGluZSA9IGRvYy5nZXRMaW5lKGxpbmUrKyk7XG4gICAgICAgICAgc3RyaW5nID0gc3RyaW5nID09IG51bGwgPyBjdXJMaW5lIDogc3RyaW5nICsgXCJcXG5cIiArIGN1ckxpbmU7XG4gICAgICAgIH1cbiAgICAgICAgY2h1bmsgPSBjaHVuayAqIDI7XG4gICAgICAgIHJlZ2V4cC5sYXN0SW5kZXggPSBzdGFydC5jaDtcbiAgICAgICAgdmFyIG1hdGNoID0gcmVnZXhwLmV4ZWMoc3RyaW5nKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgdmFyIGJlZm9yZSA9IHN0cmluZy5zbGljZSgwLCBtYXRjaC5pbmRleCkuc3BsaXQoXCJcXG5cIiksIGluc2lkZSA9IG1hdGNoWzBdLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICAgIHZhciBzdGFydExpbmUgPSBzdGFydC5saW5lICsgYmVmb3JlLmxlbmd0aCAtIDEsIHN0YXJ0Q2ggPSBiZWZvcmVbYmVmb3JlLmxlbmd0aCAtIDFdLmxlbmd0aDtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZnJvbTogUG9zKHN0YXJ0TGluZSwgc3RhcnRDaCksXG4gICAgICAgICAgICB0bzogUG9zKHN0YXJ0TGluZSArIGluc2lkZS5sZW5ndGggLSAxLCBpbnNpZGUubGVuZ3RoID09IDEgPyBzdGFydENoICsgaW5zaWRlWzBdLmxlbmd0aCA6IGluc2lkZVtpbnNpZGUubGVuZ3RoIC0gMV0ubGVuZ3RoKSxcbiAgICAgICAgICAgIG1hdGNoXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoc2VhcmNoUmVnZXhwRm9yd2FyZE11bHRpbGluZSwgXCJzZWFyY2hSZWdleHBGb3J3YXJkTXVsdGlsaW5lXCIpO1xuICAgIGZ1bmN0aW9uIGxhc3RNYXRjaEluKHN0cmluZywgcmVnZXhwLCBlbmRNYXJnaW4pIHtcbiAgICAgIHZhciBtYXRjaCwgZnJvbSA9IDA7XG4gICAgICB3aGlsZSAoZnJvbSA8PSBzdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgIHJlZ2V4cC5sYXN0SW5kZXggPSBmcm9tO1xuICAgICAgICB2YXIgbmV3TWF0Y2ggPSByZWdleHAuZXhlYyhzdHJpbmcpO1xuICAgICAgICBpZiAoIW5ld01hdGNoKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB2YXIgZW5kID0gbmV3TWF0Y2guaW5kZXggKyBuZXdNYXRjaFswXS5sZW5ndGg7XG4gICAgICAgIGlmIChlbmQgPiBzdHJpbmcubGVuZ3RoIC0gZW5kTWFyZ2luKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAoIW1hdGNoIHx8IGVuZCA+IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKVxuICAgICAgICAgIG1hdGNoID0gbmV3TWF0Y2g7XG4gICAgICAgIGZyb20gPSBuZXdNYXRjaC5pbmRleCArIDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxuICAgIF9fbmFtZShsYXN0TWF0Y2hJbiwgXCJsYXN0TWF0Y2hJblwiKTtcbiAgICBmdW5jdGlvbiBzZWFyY2hSZWdleHBCYWNrd2FyZChkb2MsIHJlZ2V4cCwgc3RhcnQpIHtcbiAgICAgIHJlZ2V4cCA9IGVuc3VyZUZsYWdzKHJlZ2V4cCwgXCJnXCIpO1xuICAgICAgZm9yICh2YXIgbGluZSA9IHN0YXJ0LmxpbmUsIGNoID0gc3RhcnQuY2gsIGZpcnN0ID0gZG9jLmZpcnN0TGluZSgpOyBsaW5lID49IGZpcnN0OyBsaW5lLS0sIGNoID0gLTEpIHtcbiAgICAgICAgdmFyIHN0cmluZyA9IGRvYy5nZXRMaW5lKGxpbmUpO1xuICAgICAgICB2YXIgbWF0Y2ggPSBsYXN0TWF0Y2hJbihzdHJpbmcsIHJlZ2V4cCwgY2ggPCAwID8gMCA6IHN0cmluZy5sZW5ndGggLSBjaCk7XG4gICAgICAgIGlmIChtYXRjaClcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZnJvbTogUG9zKGxpbmUsIG1hdGNoLmluZGV4KSxcbiAgICAgICAgICAgIHRvOiBQb3MobGluZSwgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpLFxuICAgICAgICAgICAgbWF0Y2hcbiAgICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoc2VhcmNoUmVnZXhwQmFja3dhcmQsIFwic2VhcmNoUmVnZXhwQmFja3dhcmRcIik7XG4gICAgZnVuY3Rpb24gc2VhcmNoUmVnZXhwQmFja3dhcmRNdWx0aWxpbmUoZG9jLCByZWdleHAsIHN0YXJ0KSB7XG4gICAgICBpZiAoIW1heWJlTXVsdGlsaW5lKHJlZ2V4cCkpXG4gICAgICAgIHJldHVybiBzZWFyY2hSZWdleHBCYWNrd2FyZChkb2MsIHJlZ2V4cCwgc3RhcnQpO1xuICAgICAgcmVnZXhwID0gZW5zdXJlRmxhZ3MocmVnZXhwLCBcImdtXCIpO1xuICAgICAgdmFyIHN0cmluZywgY2h1bmtTaXplID0gMSwgZW5kTWFyZ2luID0gZG9jLmdldExpbmUoc3RhcnQubGluZSkubGVuZ3RoIC0gc3RhcnQuY2g7XG4gICAgICBmb3IgKHZhciBsaW5lID0gc3RhcnQubGluZSwgZmlyc3QgPSBkb2MuZmlyc3RMaW5lKCk7IGxpbmUgPj0gZmlyc3Q7ICkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNodW5rU2l6ZSAmJiBsaW5lID49IGZpcnN0OyBpKyspIHtcbiAgICAgICAgICB2YXIgY3VyTGluZSA9IGRvYy5nZXRMaW5lKGxpbmUtLSk7XG4gICAgICAgICAgc3RyaW5nID0gc3RyaW5nID09IG51bGwgPyBjdXJMaW5lIDogY3VyTGluZSArIFwiXFxuXCIgKyBzdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgY2h1bmtTaXplICo9IDI7XG4gICAgICAgIHZhciBtYXRjaCA9IGxhc3RNYXRjaEluKHN0cmluZywgcmVnZXhwLCBlbmRNYXJnaW4pO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICB2YXIgYmVmb3JlID0gc3RyaW5nLnNsaWNlKDAsIG1hdGNoLmluZGV4KS5zcGxpdChcIlxcblwiKSwgaW5zaWRlID0gbWF0Y2hbMF0uc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgdmFyIHN0YXJ0TGluZSA9IGxpbmUgKyBiZWZvcmUubGVuZ3RoLCBzdGFydENoID0gYmVmb3JlW2JlZm9yZS5sZW5ndGggLSAxXS5sZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZyb206IFBvcyhzdGFydExpbmUsIHN0YXJ0Q2gpLFxuICAgICAgICAgICAgdG86IFBvcyhzdGFydExpbmUgKyBpbnNpZGUubGVuZ3RoIC0gMSwgaW5zaWRlLmxlbmd0aCA9PSAxID8gc3RhcnRDaCArIGluc2lkZVswXS5sZW5ndGggOiBpbnNpZGVbaW5zaWRlLmxlbmd0aCAtIDFdLmxlbmd0aCksXG4gICAgICAgICAgICBtYXRjaFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKHNlYXJjaFJlZ2V4cEJhY2t3YXJkTXVsdGlsaW5lLCBcInNlYXJjaFJlZ2V4cEJhY2t3YXJkTXVsdGlsaW5lXCIpO1xuICAgIHZhciBkb0ZvbGQsIG5vRm9sZDtcbiAgICBpZiAoU3RyaW5nLnByb3RvdHlwZS5ub3JtYWxpemUpIHtcbiAgICAgIGRvRm9sZCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIubm9ybWFsaXplKFwiTkZEXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9LCBcImRvRm9sZFwiKTtcbiAgICAgIG5vRm9sZCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIubm9ybWFsaXplKFwiTkZEXCIpO1xuICAgICAgfSwgXCJub0ZvbGRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvRm9sZCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgIH0sIFwiZG9Gb2xkXCIpO1xuICAgICAgbm9Gb2xkID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgIH0sIFwibm9Gb2xkXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGp1c3RQb3Mob3JpZywgZm9sZGVkLCBwb3MsIGZvbGRGdW5jKSB7XG4gICAgICBpZiAob3JpZy5sZW5ndGggPT0gZm9sZGVkLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgIGZvciAodmFyIG1pbiA9IDAsIG1heCA9IHBvcyArIE1hdGgubWF4KDAsIG9yaWcubGVuZ3RoIC0gZm9sZGVkLmxlbmd0aCk7IDsgKSB7XG4gICAgICAgIGlmIChtaW4gPT0gbWF4KVxuICAgICAgICAgIHJldHVybiBtaW47XG4gICAgICAgIHZhciBtaWQgPSBtaW4gKyBtYXggPj4gMTtcbiAgICAgICAgdmFyIGxlbiA9IGZvbGRGdW5jKG9yaWcuc2xpY2UoMCwgbWlkKSkubGVuZ3RoO1xuICAgICAgICBpZiAobGVuID09IHBvcylcbiAgICAgICAgICByZXR1cm4gbWlkO1xuICAgICAgICBlbHNlIGlmIChsZW4gPiBwb3MpXG4gICAgICAgICAgbWF4ID0gbWlkO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgbWluID0gbWlkICsgMTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKGFkanVzdFBvcywgXCJhZGp1c3RQb3NcIik7XG4gICAgZnVuY3Rpb24gc2VhcmNoU3RyaW5nRm9yd2FyZChkb2MsIHF1ZXJ5LCBzdGFydCwgY2FzZUZvbGQpIHtcbiAgICAgIGlmICghcXVlcnkubGVuZ3RoKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBmb2xkID0gY2FzZUZvbGQgPyBkb0ZvbGQgOiBub0ZvbGQ7XG4gICAgICB2YXIgbGluZXMgPSBmb2xkKHF1ZXJ5KS5zcGxpdCgvXFxyfFxcblxccj8vKTtcbiAgICAgIHNlYXJjaDpcbiAgICAgICAgZm9yICh2YXIgbGluZSA9IHN0YXJ0LmxpbmUsIGNoID0gc3RhcnQuY2gsIGxhc3QgPSBkb2MubGFzdExpbmUoKSArIDEgLSBsaW5lcy5sZW5ndGg7IGxpbmUgPD0gbGFzdDsgbGluZSsrLCBjaCA9IDApIHtcbiAgICAgICAgICB2YXIgb3JpZyA9IGRvYy5nZXRMaW5lKGxpbmUpLnNsaWNlKGNoKSwgc3RyaW5nID0gZm9sZChvcmlnKTtcbiAgICAgICAgICBpZiAobGluZXMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIHZhciBmb3VuZCA9IHN0cmluZy5pbmRleE9mKGxpbmVzWzBdKTtcbiAgICAgICAgICAgIGlmIChmb3VuZCA9PSAtMSlcbiAgICAgICAgICAgICAgY29udGludWUgc2VhcmNoO1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gYWRqdXN0UG9zKG9yaWcsIHN0cmluZywgZm91bmQsIGZvbGQpICsgY2g7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBmcm9tOiBQb3MobGluZSwgYWRqdXN0UG9zKG9yaWcsIHN0cmluZywgZm91bmQsIGZvbGQpICsgY2gpLFxuICAgICAgICAgICAgICB0bzogUG9zKGxpbmUsIGFkanVzdFBvcyhvcmlnLCBzdHJpbmcsIGZvdW5kICsgbGluZXNbMF0ubGVuZ3RoLCBmb2xkKSArIGNoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGN1dEZyb20gPSBzdHJpbmcubGVuZ3RoIC0gbGluZXNbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHN0cmluZy5zbGljZShjdXRGcm9tKSAhPSBsaW5lc1swXSlcbiAgICAgICAgICAgICAgY29udGludWUgc2VhcmNoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsaW5lcy5sZW5ndGggLSAxOyBpKyspXG4gICAgICAgICAgICAgIGlmIChmb2xkKGRvYy5nZXRMaW5lKGxpbmUgKyBpKSkgIT0gbGluZXNbaV0pXG4gICAgICAgICAgICAgICAgY29udGludWUgc2VhcmNoO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGRvYy5nZXRMaW5lKGxpbmUgKyBsaW5lcy5sZW5ndGggLSAxKSwgZW5kU3RyaW5nID0gZm9sZChlbmQpLCBsYXN0TGluZSA9IGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKGVuZFN0cmluZy5zbGljZSgwLCBsYXN0TGluZS5sZW5ndGgpICE9IGxhc3RMaW5lKVxuICAgICAgICAgICAgICBjb250aW51ZSBzZWFyY2g7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBmcm9tOiBQb3MobGluZSwgYWRqdXN0UG9zKG9yaWcsIHN0cmluZywgY3V0RnJvbSwgZm9sZCkgKyBjaCksXG4gICAgICAgICAgICAgIHRvOiBQb3MobGluZSArIGxpbmVzLmxlbmd0aCAtIDEsIGFkanVzdFBvcyhlbmQsIGVuZFN0cmluZywgbGFzdExpbmUubGVuZ3RoLCBmb2xkKSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShzZWFyY2hTdHJpbmdGb3J3YXJkLCBcInNlYXJjaFN0cmluZ0ZvcndhcmRcIik7XG4gICAgZnVuY3Rpb24gc2VhcmNoU3RyaW5nQmFja3dhcmQoZG9jLCBxdWVyeSwgc3RhcnQsIGNhc2VGb2xkKSB7XG4gICAgICBpZiAoIXF1ZXJ5Lmxlbmd0aClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgZm9sZCA9IGNhc2VGb2xkID8gZG9Gb2xkIDogbm9Gb2xkO1xuICAgICAgdmFyIGxpbmVzID0gZm9sZChxdWVyeSkuc3BsaXQoL1xccnxcXG5cXHI/Lyk7XG4gICAgICBzZWFyY2g6XG4gICAgICAgIGZvciAodmFyIGxpbmUgPSBzdGFydC5saW5lLCBjaCA9IHN0YXJ0LmNoLCBmaXJzdCA9IGRvYy5maXJzdExpbmUoKSAtIDEgKyBsaW5lcy5sZW5ndGg7IGxpbmUgPj0gZmlyc3Q7IGxpbmUtLSwgY2ggPSAtMSkge1xuICAgICAgICAgIHZhciBvcmlnID0gZG9jLmdldExpbmUobGluZSk7XG4gICAgICAgICAgaWYgKGNoID4gLTEpXG4gICAgICAgICAgICBvcmlnID0gb3JpZy5zbGljZSgwLCBjaCk7XG4gICAgICAgICAgdmFyIHN0cmluZyA9IGZvbGQob3JpZyk7XG4gICAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICB2YXIgZm91bmQgPSBzdHJpbmcubGFzdEluZGV4T2YobGluZXNbMF0pO1xuICAgICAgICAgICAgaWYgKGZvdW5kID09IC0xKVxuICAgICAgICAgICAgICBjb250aW51ZSBzZWFyY2g7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBmcm9tOiBQb3MobGluZSwgYWRqdXN0UG9zKG9yaWcsIHN0cmluZywgZm91bmQsIGZvbGQpKSxcbiAgICAgICAgICAgICAgdG86IFBvcyhsaW5lLCBhZGp1c3RQb3Mob3JpZywgc3RyaW5nLCBmb3VuZCArIGxpbmVzWzBdLmxlbmd0aCwgZm9sZCkpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbGFzdExpbmUgPSBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChzdHJpbmcuc2xpY2UoMCwgbGFzdExpbmUubGVuZ3RoKSAhPSBsYXN0TGluZSlcbiAgICAgICAgICAgICAgY29udGludWUgc2VhcmNoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDEsIHN0YXJ0ID0gbGluZSAtIGxpbmVzLmxlbmd0aCArIDE7IGkgPCBsaW5lcy5sZW5ndGggLSAxOyBpKyspXG4gICAgICAgICAgICAgIGlmIChmb2xkKGRvYy5nZXRMaW5lKHN0YXJ0ICsgaSkpICE9IGxpbmVzW2ldKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlIHNlYXJjaDtcbiAgICAgICAgICAgIHZhciB0b3AgPSBkb2MuZ2V0TGluZShsaW5lICsgMSAtIGxpbmVzLmxlbmd0aCksIHRvcFN0cmluZyA9IGZvbGQodG9wKTtcbiAgICAgICAgICAgIGlmICh0b3BTdHJpbmcuc2xpY2UodG9wU3RyaW5nLmxlbmd0aCAtIGxpbmVzWzBdLmxlbmd0aCkgIT0gbGluZXNbMF0pXG4gICAgICAgICAgICAgIGNvbnRpbnVlIHNlYXJjaDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGZyb206IFBvcyhsaW5lICsgMSAtIGxpbmVzLmxlbmd0aCwgYWRqdXN0UG9zKHRvcCwgdG9wU3RyaW5nLCB0b3AubGVuZ3RoIC0gbGluZXNbMF0ubGVuZ3RoLCBmb2xkKSksXG4gICAgICAgICAgICAgIHRvOiBQb3MobGluZSwgYWRqdXN0UG9zKG9yaWcsIHN0cmluZywgbGFzdExpbmUubGVuZ3RoLCBmb2xkKSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShzZWFyY2hTdHJpbmdCYWNrd2FyZCwgXCJzZWFyY2hTdHJpbmdCYWNrd2FyZFwiKTtcbiAgICBmdW5jdGlvbiBTZWFyY2hDdXJzb3IoZG9jLCBxdWVyeSwgcG9zLCBvcHRpb25zKSB7XG4gICAgICB0aGlzLmF0T2NjdXJyZW5jZSA9IGZhbHNlO1xuICAgICAgdGhpcy5hZnRlckVtcHR5TWF0Y2ggPSBmYWxzZTtcbiAgICAgIHRoaXMuZG9jID0gZG9jO1xuICAgICAgcG9zID0gcG9zID8gZG9jLmNsaXBQb3MocG9zKSA6IFBvcygwLCAwKTtcbiAgICAgIHRoaXMucG9zID0geyBmcm9tOiBwb3MsIHRvOiBwb3MgfTtcbiAgICAgIHZhciBjYXNlRm9sZDtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGNhc2VGb2xkID0gb3B0aW9ucy5jYXNlRm9sZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhc2VGb2xkID0gb3B0aW9ucztcbiAgICAgICAgb3B0aW9ucyA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHF1ZXJ5ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKGNhc2VGb2xkID09IG51bGwpXG4gICAgICAgICAgY2FzZUZvbGQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tYXRjaGVzID0gZnVuY3Rpb24ocmV2ZXJzZSwgcG9zMikge1xuICAgICAgICAgIHJldHVybiAocmV2ZXJzZSA/IHNlYXJjaFN0cmluZ0JhY2t3YXJkIDogc2VhcmNoU3RyaW5nRm9yd2FyZCkoZG9jLCBxdWVyeSwgcG9zMiwgY2FzZUZvbGQpO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVlcnkgPSBlbnN1cmVGbGFncyhxdWVyeSwgXCJnbVwiKTtcbiAgICAgICAgaWYgKCFvcHRpb25zIHx8IG9wdGlvbnMubXVsdGlsaW5lICE9PSBmYWxzZSlcbiAgICAgICAgICB0aGlzLm1hdGNoZXMgPSBmdW5jdGlvbihyZXZlcnNlLCBwb3MyKSB7XG4gICAgICAgICAgICByZXR1cm4gKHJldmVyc2UgPyBzZWFyY2hSZWdleHBCYWNrd2FyZE11bHRpbGluZSA6IHNlYXJjaFJlZ2V4cEZvcndhcmRNdWx0aWxpbmUpKGRvYywgcXVlcnksIHBvczIpO1xuICAgICAgICAgIH07XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aGlzLm1hdGNoZXMgPSBmdW5jdGlvbihyZXZlcnNlLCBwb3MyKSB7XG4gICAgICAgICAgICByZXR1cm4gKHJldmVyc2UgPyBzZWFyY2hSZWdleHBCYWNrd2FyZCA6IHNlYXJjaFJlZ2V4cEZvcndhcmQpKGRvYywgcXVlcnksIHBvczIpO1xuICAgICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShTZWFyY2hDdXJzb3IsIFwiU2VhcmNoQ3Vyc29yXCIpO1xuICAgIFNlYXJjaEN1cnNvci5wcm90b3R5cGUgPSB7XG4gICAgICBmaW5kTmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmQoZmFsc2UpO1xuICAgICAgfSxcbiAgICAgIGZpbmRQcmV2aW91czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmQodHJ1ZSk7XG4gICAgICB9LFxuICAgICAgZmluZDogZnVuY3Rpb24ocmV2ZXJzZSkge1xuICAgICAgICB2YXIgaGVhZCA9IHRoaXMuZG9jLmNsaXBQb3MocmV2ZXJzZSA/IHRoaXMucG9zLmZyb20gOiB0aGlzLnBvcy50byk7XG4gICAgICAgIGlmICh0aGlzLmFmdGVyRW1wdHlNYXRjaCAmJiB0aGlzLmF0T2NjdXJyZW5jZSkge1xuICAgICAgICAgIGhlYWQgPSBQb3MoaGVhZC5saW5lLCBoZWFkLmNoKTtcbiAgICAgICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICAgICAgaGVhZC5jaC0tO1xuICAgICAgICAgICAgaWYgKGhlYWQuY2ggPCAwKSB7XG4gICAgICAgICAgICAgIGhlYWQubGluZS0tO1xuICAgICAgICAgICAgICBoZWFkLmNoID0gKHRoaXMuZG9jLmdldExpbmUoaGVhZC5saW5lKSB8fCBcIlwiKS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhlYWQuY2grKztcbiAgICAgICAgICAgIGlmIChoZWFkLmNoID4gKHRoaXMuZG9jLmdldExpbmUoaGVhZC5saW5lKSB8fCBcIlwiKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgaGVhZC5jaCA9IDA7XG4gICAgICAgICAgICAgIGhlYWQubGluZSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoQ29kZU1pcnJvci5jbXBQb3MoaGVhZCwgdGhpcy5kb2MuY2xpcFBvcyhoZWFkKSkgIT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXRPY2N1cnJlbmNlID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLm1hdGNoZXMocmV2ZXJzZSwgaGVhZCk7XG4gICAgICAgIHRoaXMuYWZ0ZXJFbXB0eU1hdGNoID0gcmVzdWx0ICYmIENvZGVNaXJyb3IuY21wUG9zKHJlc3VsdC5mcm9tLCByZXN1bHQudG8pID09IDA7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICB0aGlzLnBvcyA9IHJlc3VsdDtcbiAgICAgICAgICB0aGlzLmF0T2NjdXJyZW5jZSA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucG9zLm1hdGNoIHx8IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGVuZCA9IFBvcyhyZXZlcnNlID8gdGhpcy5kb2MuZmlyc3RMaW5lKCkgOiB0aGlzLmRvYy5sYXN0TGluZSgpICsgMSwgMCk7XG4gICAgICAgICAgdGhpcy5wb3MgPSB7IGZyb206IGVuZCwgdG86IGVuZCB9O1xuICAgICAgICAgIHJldHVybiB0aGlzLmF0T2NjdXJyZW5jZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZnJvbTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmF0T2NjdXJyZW5jZSlcbiAgICAgICAgICByZXR1cm4gdGhpcy5wb3MuZnJvbTtcbiAgICAgIH0sXG4gICAgICB0bzogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmF0T2NjdXJyZW5jZSlcbiAgICAgICAgICByZXR1cm4gdGhpcy5wb3MudG87XG4gICAgICB9LFxuICAgICAgcmVwbGFjZTogZnVuY3Rpb24obmV3VGV4dCwgb3JpZ2luKSB7XG4gICAgICAgIGlmICghdGhpcy5hdE9jY3VycmVuY2UpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgbGluZXMgPSBDb2RlTWlycm9yLnNwbGl0TGluZXMobmV3VGV4dCk7XG4gICAgICAgIHRoaXMuZG9jLnJlcGxhY2VSYW5nZShsaW5lcywgdGhpcy5wb3MuZnJvbSwgdGhpcy5wb3MudG8sIG9yaWdpbik7XG4gICAgICAgIHRoaXMucG9zLnRvID0gUG9zKHRoaXMucG9zLmZyb20ubGluZSArIGxpbmVzLmxlbmd0aCAtIDEsIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLmxlbmd0aCArIChsaW5lcy5sZW5ndGggPT0gMSA/IHRoaXMucG9zLmZyb20uY2ggOiAwKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBDb2RlTWlycm9yLmRlZmluZUV4dGVuc2lvbihcImdldFNlYXJjaEN1cnNvclwiLCBmdW5jdGlvbihxdWVyeSwgcG9zLCBjYXNlRm9sZCkge1xuICAgICAgcmV0dXJuIG5ldyBTZWFyY2hDdXJzb3IodGhpcy5kb2MsIHF1ZXJ5LCBwb3MsIGNhc2VGb2xkKTtcbiAgICB9KTtcbiAgICBDb2RlTWlycm9yLmRlZmluZURvY0V4dGVuc2lvbihcImdldFNlYXJjaEN1cnNvclwiLCBmdW5jdGlvbihxdWVyeSwgcG9zLCBjYXNlRm9sZCkge1xuICAgICAgcmV0dXJuIG5ldyBTZWFyY2hDdXJzb3IodGhpcywgcXVlcnksIHBvcywgY2FzZUZvbGQpO1xuICAgIH0pO1xuICAgIENvZGVNaXJyb3IuZGVmaW5lRXh0ZW5zaW9uKFwic2VsZWN0TWF0Y2hlc1wiLCBmdW5jdGlvbihxdWVyeSwgY2FzZUZvbGQpIHtcbiAgICAgIHZhciByYW5nZXMgPSBbXTtcbiAgICAgIHZhciBjdXIgPSB0aGlzLmdldFNlYXJjaEN1cnNvcihxdWVyeSwgdGhpcy5nZXRDdXJzb3IoXCJmcm9tXCIpLCBjYXNlRm9sZCk7XG4gICAgICB3aGlsZSAoY3VyLmZpbmROZXh0KCkpIHtcbiAgICAgICAgaWYgKENvZGVNaXJyb3IuY21wUG9zKGN1ci50bygpLCB0aGlzLmdldEN1cnNvcihcInRvXCIpKSA+IDApXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIHJhbmdlcy5wdXNoKHsgYW5jaG9yOiBjdXIuZnJvbSgpLCBoZWFkOiBjdXIudG8oKSB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChyYW5nZXMubGVuZ3RoKVxuICAgICAgICB0aGlzLnNldFNlbGVjdGlvbnMocmFuZ2VzLCAwKTtcbiAgICB9KTtcbiAgfSk7XG59KSgpO1xudmFyIHNlYXJjaGN1cnNvciA9IHNlYXJjaGN1cnNvciQyLmV4cG9ydHM7XG52YXIgc2VhcmNoY3Vyc29yJDEgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gX21lcmdlTmFtZXNwYWNlcyh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106IFwiTW9kdWxlXCIsXG4gIFwiZGVmYXVsdFwiOiBzZWFyY2hjdXJzb3Jcbn0sIFtzZWFyY2hjdXJzb3IkMi5leHBvcnRzXSkpO1xuZXhwb3J0IHsgc2VhcmNoY3Vyc29yJDIgYXMgYSwgc2VhcmNoY3Vyc29yJDEgYXMgcyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///26105\n')},13571:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "s": () => (/* binding */ sublime$1)\n/* harmony export */ });\n/* harmony import */ var _codemirror_es_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97480);\n/* harmony import */ var _searchcursor_es_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(26105);\n/* harmony import */ var _matchbrackets_es_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(54980);\nvar __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, "name", { value, configurable: true });\n\n\n\nfunction _mergeNamespaces(n, m) {\n  m.forEach(function(e) {\n    e && typeof e !== "string" && !Array.isArray(e) && Object.keys(e).forEach(function(k) {\n      if (k !== "default" && !(k in n)) {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function() {\n            return e[k];\n          }\n        });\n      }\n    });\n  });\n  return Object.freeze(n);\n}\n__name(_mergeNamespaces, "_mergeNamespaces");\nvar sublime$2 = { exports: {} };\n(function(module, exports) {\n  (function(mod) {\n    mod(_codemirror_es_js__WEBPACK_IMPORTED_MODULE_0__.a.exports, _searchcursor_es_js__WEBPACK_IMPORTED_MODULE_1__.a.exports, _matchbrackets_es_js__WEBPACK_IMPORTED_MODULE_2__.a.exports);\n  })(function(CodeMirror) {\n    var cmds = CodeMirror.commands;\n    var Pos = CodeMirror.Pos;\n    function findPosSubword(doc, start, dir) {\n      if (dir < 0 && start.ch == 0)\n        return doc.clipPos(Pos(start.line - 1));\n      var line = doc.getLine(start.line);\n      if (dir > 0 && start.ch >= line.length)\n        return doc.clipPos(Pos(start.line + 1, 0));\n      var state = "start", type, startPos = start.ch;\n      for (var pos = startPos, e = dir < 0 ? 0 : line.length, i = 0; pos != e; pos += dir, i++) {\n        var next = line.charAt(dir < 0 ? pos - 1 : pos);\n        var cat = next != "_" && CodeMirror.isWordChar(next) ? "w" : "o";\n        if (cat == "w" && next.toUpperCase() == next)\n          cat = "W";\n        if (state == "start") {\n          if (cat != "o") {\n            state = "in";\n            type = cat;\n          } else\n            startPos = pos + dir;\n        } else if (state == "in") {\n          if (type != cat) {\n            if (type == "w" && cat == "W" && dir < 0)\n              pos--;\n            if (type == "W" && cat == "w" && dir > 0) {\n              if (pos == startPos + 1) {\n                type = "w";\n                continue;\n              } else\n                pos--;\n            }\n            break;\n          }\n        }\n      }\n      return Pos(start.line, pos);\n    }\n    __name(findPosSubword, "findPosSubword");\n    function moveSubword(cm, dir) {\n      cm.extendSelectionsBy(function(range) {\n        if (cm.display.shift || cm.doc.extend || range.empty())\n          return findPosSubword(cm.doc, range.head, dir);\n        else\n          return dir < 0 ? range.from() : range.to();\n      });\n    }\n    __name(moveSubword, "moveSubword");\n    cmds.goSubwordLeft = function(cm) {\n      moveSubword(cm, -1);\n    };\n    cmds.goSubwordRight = function(cm) {\n      moveSubword(cm, 1);\n    };\n    cmds.scrollLineUp = function(cm) {\n      var info = cm.getScrollInfo();\n      if (!cm.somethingSelected()) {\n        var visibleBottomLine = cm.lineAtHeight(info.top + info.clientHeight, "local");\n        if (cm.getCursor().line >= visibleBottomLine)\n          cm.execCommand("goLineUp");\n      }\n      cm.scrollTo(null, info.top - cm.defaultTextHeight());\n    };\n    cmds.scrollLineDown = function(cm) {\n      var info = cm.getScrollInfo();\n      if (!cm.somethingSelected()) {\n        var visibleTopLine = cm.lineAtHeight(info.top, "local") + 1;\n        if (cm.getCursor().line <= visibleTopLine)\n          cm.execCommand("goLineDown");\n      }\n      cm.scrollTo(null, info.top + cm.defaultTextHeight());\n    };\n    cmds.splitSelectionByLine = function(cm) {\n      var ranges = cm.listSelections(), lineRanges = [];\n      for (var i = 0; i < ranges.length; i++) {\n        var from = ranges[i].from(), to = ranges[i].to();\n        for (var line = from.line; line <= to.line; ++line)\n          if (!(to.line > from.line && line == to.line && to.ch == 0))\n            lineRanges.push({\n              anchor: line == from.line ? from : Pos(line, 0),\n              head: line == to.line ? to : Pos(line)\n            });\n      }\n      cm.setSelections(lineRanges, 0);\n    };\n    cmds.singleSelectionTop = function(cm) {\n      var range = cm.listSelections()[0];\n      cm.setSelection(range.anchor, range.head, { scroll: false });\n    };\n    cmds.selectLine = function(cm) {\n      var ranges = cm.listSelections(), extended = [];\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n        extended.push({\n          anchor: Pos(range.from().line, 0),\n          head: Pos(range.to().line + 1, 0)\n        });\n      }\n      cm.setSelections(extended);\n    };\n    function insertLine(cm, above) {\n      if (cm.isReadOnly())\n        return CodeMirror.Pass;\n      cm.operation(function() {\n        var len = cm.listSelections().length, newSelection = [], last = -1;\n        for (var i = 0; i < len; i++) {\n          var head = cm.listSelections()[i].head;\n          if (head.line <= last)\n            continue;\n          var at = Pos(head.line + (above ? 0 : 1), 0);\n          cm.replaceRange("\\n", at, null, "+insertLine");\n          cm.indentLine(at.line, null, true);\n          newSelection.push({ head: at, anchor: at });\n          last = head.line + 1;\n        }\n        cm.setSelections(newSelection);\n      });\n      cm.execCommand("indentAuto");\n    }\n    __name(insertLine, "insertLine");\n    cmds.insertLineAfter = function(cm) {\n      return insertLine(cm, false);\n    };\n    cmds.insertLineBefore = function(cm) {\n      return insertLine(cm, true);\n    };\n    function wordAt(cm, pos) {\n      var start = pos.ch, end = start, line = cm.getLine(pos.line);\n      while (start && CodeMirror.isWordChar(line.charAt(start - 1)))\n        --start;\n      while (end < line.length && CodeMirror.isWordChar(line.charAt(end)))\n        ++end;\n      return { from: Pos(pos.line, start), to: Pos(pos.line, end), word: line.slice(start, end) };\n    }\n    __name(wordAt, "wordAt");\n    cmds.selectNextOccurrence = function(cm) {\n      var from = cm.getCursor("from"), to = cm.getCursor("to");\n      var fullWord = cm.state.sublimeFindFullWord == cm.doc.sel;\n      if (CodeMirror.cmpPos(from, to) == 0) {\n        var word = wordAt(cm, from);\n        if (!word.word)\n          return;\n        cm.setSelection(word.from, word.to);\n        fullWord = true;\n      } else {\n        var text = cm.getRange(from, to);\n        var query = fullWord ? new RegExp("\\\\b" + text + "\\\\b") : text;\n        var cur = cm.getSearchCursor(query, to);\n        var found = cur.findNext();\n        if (!found) {\n          cur = cm.getSearchCursor(query, Pos(cm.firstLine(), 0));\n          found = cur.findNext();\n        }\n        if (!found || isSelectedRange(cm.listSelections(), cur.from(), cur.to()))\n          return;\n        cm.addSelection(cur.from(), cur.to());\n      }\n      if (fullWord)\n        cm.state.sublimeFindFullWord = cm.doc.sel;\n    };\n    cmds.skipAndSelectNextOccurrence = function(cm) {\n      var prevAnchor = cm.getCursor("anchor"), prevHead = cm.getCursor("head");\n      cmds.selectNextOccurrence(cm);\n      if (CodeMirror.cmpPos(prevAnchor, prevHead) != 0) {\n        cm.doc.setSelections(cm.doc.listSelections().filter(function(sel) {\n          return sel.anchor != prevAnchor || sel.head != prevHead;\n        }));\n      }\n    };\n    function addCursorToSelection(cm, dir) {\n      var ranges = cm.listSelections(), newRanges = [];\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n        var newAnchor = cm.findPosV(range.anchor, dir, "line", range.anchor.goalColumn);\n        var newHead = cm.findPosV(range.head, dir, "line", range.head.goalColumn);\n        newAnchor.goalColumn = range.anchor.goalColumn != null ? range.anchor.goalColumn : cm.cursorCoords(range.anchor, "div").left;\n        newHead.goalColumn = range.head.goalColumn != null ? range.head.goalColumn : cm.cursorCoords(range.head, "div").left;\n        var newRange = { anchor: newAnchor, head: newHead };\n        newRanges.push(range);\n        newRanges.push(newRange);\n      }\n      cm.setSelections(newRanges);\n    }\n    __name(addCursorToSelection, "addCursorToSelection");\n    cmds.addCursorToPrevLine = function(cm) {\n      addCursorToSelection(cm, -1);\n    };\n    cmds.addCursorToNextLine = function(cm) {\n      addCursorToSelection(cm, 1);\n    };\n    function isSelectedRange(ranges, from, to) {\n      for (var i = 0; i < ranges.length; i++)\n        if (CodeMirror.cmpPos(ranges[i].from(), from) == 0 && CodeMirror.cmpPos(ranges[i].to(), to) == 0)\n          return true;\n      return false;\n    }\n    __name(isSelectedRange, "isSelectedRange");\n    var mirror = "(){}[]";\n    function selectBetweenBrackets(cm) {\n      var ranges = cm.listSelections(), newRanges = [];\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i], pos = range.head, opening = cm.scanForBracket(pos, -1);\n        if (!opening)\n          return false;\n        for (; ; ) {\n          var closing = cm.scanForBracket(pos, 1);\n          if (!closing)\n            return false;\n          if (closing.ch == mirror.charAt(mirror.indexOf(opening.ch) + 1)) {\n            var startPos = Pos(opening.pos.line, opening.pos.ch + 1);\n            if (CodeMirror.cmpPos(startPos, range.from()) == 0 && CodeMirror.cmpPos(closing.pos, range.to()) == 0) {\n              opening = cm.scanForBracket(opening.pos, -1);\n              if (!opening)\n                return false;\n            } else {\n              newRanges.push({ anchor: startPos, head: closing.pos });\n              break;\n            }\n          }\n          pos = Pos(closing.pos.line, closing.pos.ch + 1);\n        }\n      }\n      cm.setSelections(newRanges);\n      return true;\n    }\n    __name(selectBetweenBrackets, "selectBetweenBrackets");\n    cmds.selectScope = function(cm) {\n      selectBetweenBrackets(cm) || cm.execCommand("selectAll");\n    };\n    cmds.selectBetweenBrackets = function(cm) {\n      if (!selectBetweenBrackets(cm))\n        return CodeMirror.Pass;\n    };\n    function puncType(type) {\n      return !type ? null : /\\bpunctuation\\b/.test(type) ? type : void 0;\n    }\n    __name(puncType, "puncType");\n    cmds.goToBracket = function(cm) {\n      cm.extendSelectionsBy(function(range) {\n        var next = cm.scanForBracket(range.head, 1, puncType(cm.getTokenTypeAt(range.head)));\n        if (next && CodeMirror.cmpPos(next.pos, range.head) != 0)\n          return next.pos;\n        var prev = cm.scanForBracket(range.head, -1, puncType(cm.getTokenTypeAt(Pos(range.head.line, range.head.ch + 1))));\n        return prev && Pos(prev.pos.line, prev.pos.ch + 1) || range.head;\n      });\n    };\n    cmds.swapLineUp = function(cm) {\n      if (cm.isReadOnly())\n        return CodeMirror.Pass;\n      var ranges = cm.listSelections(), linesToMove = [], at = cm.firstLine() - 1, newSels = [];\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i], from = range.from().line - 1, to = range.to().line;\n        newSels.push({\n          anchor: Pos(range.anchor.line - 1, range.anchor.ch),\n          head: Pos(range.head.line - 1, range.head.ch)\n        });\n        if (range.to().ch == 0 && !range.empty())\n          --to;\n        if (from > at)\n          linesToMove.push(from, to);\n        else if (linesToMove.length)\n          linesToMove[linesToMove.length - 1] = to;\n        at = to;\n      }\n      cm.operation(function() {\n        for (var i2 = 0; i2 < linesToMove.length; i2 += 2) {\n          var from2 = linesToMove[i2], to2 = linesToMove[i2 + 1];\n          var line = cm.getLine(from2);\n          cm.replaceRange("", Pos(from2, 0), Pos(from2 + 1, 0), "+swapLine");\n          if (to2 > cm.lastLine())\n            cm.replaceRange("\\n" + line, Pos(cm.lastLine()), null, "+swapLine");\n          else\n            cm.replaceRange(line + "\\n", Pos(to2, 0), null, "+swapLine");\n        }\n        cm.setSelections(newSels);\n        cm.scrollIntoView();\n      });\n    };\n    cmds.swapLineDown = function(cm) {\n      if (cm.isReadOnly())\n        return CodeMirror.Pass;\n      var ranges = cm.listSelections(), linesToMove = [], at = cm.lastLine() + 1;\n      for (var i = ranges.length - 1; i >= 0; i--) {\n        var range = ranges[i], from = range.to().line + 1, to = range.from().line;\n        if (range.to().ch == 0 && !range.empty())\n          from--;\n        if (from < at)\n          linesToMove.push(from, to);\n        else if (linesToMove.length)\n          linesToMove[linesToMove.length - 1] = to;\n        at = to;\n      }\n      cm.operation(function() {\n        for (var i2 = linesToMove.length - 2; i2 >= 0; i2 -= 2) {\n          var from2 = linesToMove[i2], to2 = linesToMove[i2 + 1];\n          var line = cm.getLine(from2);\n          if (from2 == cm.lastLine())\n            cm.replaceRange("", Pos(from2 - 1), Pos(from2), "+swapLine");\n          else\n            cm.replaceRange("", Pos(from2, 0), Pos(from2 + 1, 0), "+swapLine");\n          cm.replaceRange(line + "\\n", Pos(to2, 0), null, "+swapLine");\n        }\n        cm.scrollIntoView();\n      });\n    };\n    cmds.toggleCommentIndented = function(cm) {\n      cm.toggleComment({ indent: true });\n    };\n    cmds.joinLines = function(cm) {\n      var ranges = cm.listSelections(), joined = [];\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i], from = range.from();\n        var start = from.line, end = range.to().line;\n        while (i < ranges.length - 1 && ranges[i + 1].from().line == end)\n          end = ranges[++i].to().line;\n        joined.push({ start, end, anchor: !range.empty() && from });\n      }\n      cm.operation(function() {\n        var offset = 0, ranges2 = [];\n        for (var i2 = 0; i2 < joined.length; i2++) {\n          var obj = joined[i2];\n          var anchor = obj.anchor && Pos(obj.anchor.line - offset, obj.anchor.ch), head;\n          for (var line = obj.start; line <= obj.end; line++) {\n            var actual = line - offset;\n            if (line == obj.end)\n              head = Pos(actual, cm.getLine(actual).length + 1);\n            if (actual < cm.lastLine()) {\n              cm.replaceRange(" ", Pos(actual), Pos(actual + 1, /^\\s*/.exec(cm.getLine(actual + 1))[0].length));\n              ++offset;\n            }\n          }\n          ranges2.push({ anchor: anchor || head, head });\n        }\n        cm.setSelections(ranges2, 0);\n      });\n    };\n    cmds.duplicateLine = function(cm) {\n      cm.operation(function() {\n        var rangeCount = cm.listSelections().length;\n        for (var i = 0; i < rangeCount; i++) {\n          var range = cm.listSelections()[i];\n          if (range.empty())\n            cm.replaceRange(cm.getLine(range.head.line) + "\\n", Pos(range.head.line, 0));\n          else\n            cm.replaceRange(cm.getRange(range.from(), range.to()), range.from());\n        }\n        cm.scrollIntoView();\n      });\n    };\n    function sortLines(cm, caseSensitive, direction) {\n      if (cm.isReadOnly())\n        return CodeMirror.Pass;\n      var ranges = cm.listSelections(), toSort = [], selected;\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n        if (range.empty())\n          continue;\n        var from = range.from().line, to = range.to().line;\n        while (i < ranges.length - 1 && ranges[i + 1].from().line == to)\n          to = ranges[++i].to().line;\n        if (!ranges[i].to().ch)\n          to--;\n        toSort.push(from, to);\n      }\n      if (toSort.length)\n        selected = true;\n      else\n        toSort.push(cm.firstLine(), cm.lastLine());\n      cm.operation(function() {\n        var ranges2 = [];\n        for (var i2 = 0; i2 < toSort.length; i2 += 2) {\n          var from2 = toSort[i2], to2 = toSort[i2 + 1];\n          var start = Pos(from2, 0), end = Pos(to2);\n          var lines = cm.getRange(start, end, false);\n          if (caseSensitive)\n            lines.sort(function(a, b) {\n              return a < b ? -direction : a == b ? 0 : direction;\n            });\n          else\n            lines.sort(function(a, b) {\n              var au = a.toUpperCase(), bu = b.toUpperCase();\n              if (au != bu) {\n                a = au;\n                b = bu;\n              }\n              return a < b ? -direction : a == b ? 0 : direction;\n            });\n          cm.replaceRange(lines, start, end);\n          if (selected)\n            ranges2.push({ anchor: start, head: Pos(to2 + 1, 0) });\n        }\n        if (selected)\n          cm.setSelections(ranges2, 0);\n      });\n    }\n    __name(sortLines, "sortLines");\n    cmds.sortLines = function(cm) {\n      sortLines(cm, true, 1);\n    };\n    cmds.reverseSortLines = function(cm) {\n      sortLines(cm, true, -1);\n    };\n    cmds.sortLinesInsensitive = function(cm) {\n      sortLines(cm, false, 1);\n    };\n    cmds.reverseSortLinesInsensitive = function(cm) {\n      sortLines(cm, false, -1);\n    };\n    cmds.nextBookmark = function(cm) {\n      var marks = cm.state.sublimeBookmarks;\n      if (marks)\n        while (marks.length) {\n          var current = marks.shift();\n          var found = current.find();\n          if (found) {\n            marks.push(current);\n            return cm.setSelection(found.from, found.to);\n          }\n        }\n    };\n    cmds.prevBookmark = function(cm) {\n      var marks = cm.state.sublimeBookmarks;\n      if (marks)\n        while (marks.length) {\n          marks.unshift(marks.pop());\n          var found = marks[marks.length - 1].find();\n          if (!found)\n            marks.pop();\n          else\n            return cm.setSelection(found.from, found.to);\n        }\n    };\n    cmds.toggleBookmark = function(cm) {\n      var ranges = cm.listSelections();\n      var marks = cm.state.sublimeBookmarks || (cm.state.sublimeBookmarks = []);\n      for (var i = 0; i < ranges.length; i++) {\n        var from = ranges[i].from(), to = ranges[i].to();\n        var found = ranges[i].empty() ? cm.findMarksAt(from) : cm.findMarks(from, to);\n        for (var j = 0; j < found.length; j++) {\n          if (found[j].sublimeBookmark) {\n            found[j].clear();\n            for (var k = 0; k < marks.length; k++)\n              if (marks[k] == found[j])\n                marks.splice(k--, 1);\n            break;\n          }\n        }\n        if (j == found.length)\n          marks.push(cm.markText(from, to, { sublimeBookmark: true, clearWhenEmpty: false }));\n      }\n    };\n    cmds.clearBookmarks = function(cm) {\n      var marks = cm.state.sublimeBookmarks;\n      if (marks)\n        for (var i = 0; i < marks.length; i++)\n          marks[i].clear();\n      marks.length = 0;\n    };\n    cmds.selectBookmarks = function(cm) {\n      var marks = cm.state.sublimeBookmarks, ranges = [];\n      if (marks)\n        for (var i = 0; i < marks.length; i++) {\n          var found = marks[i].find();\n          if (!found)\n            marks.splice(i--, 0);\n          else\n            ranges.push({ anchor: found.from, head: found.to });\n        }\n      if (ranges.length)\n        cm.setSelections(ranges, 0);\n    };\n    function modifyWordOrSelection(cm, mod) {\n      cm.operation(function() {\n        var ranges = cm.listSelections(), indices = [], replacements = [];\n        for (var i = 0; i < ranges.length; i++) {\n          var range = ranges[i];\n          if (range.empty()) {\n            indices.push(i);\n            replacements.push("");\n          } else\n            replacements.push(mod(cm.getRange(range.from(), range.to())));\n        }\n        cm.replaceSelections(replacements, "around", "case");\n        for (var i = indices.length - 1, at; i >= 0; i--) {\n          var range = ranges[indices[i]];\n          if (at && CodeMirror.cmpPos(range.head, at) > 0)\n            continue;\n          var word = wordAt(cm, range.head);\n          at = word.from;\n          cm.replaceRange(mod(word.word), word.from, word.to);\n        }\n      });\n    }\n    __name(modifyWordOrSelection, "modifyWordOrSelection");\n    cmds.smartBackspace = function(cm) {\n      if (cm.somethingSelected())\n        return CodeMirror.Pass;\n      cm.operation(function() {\n        var cursors = cm.listSelections();\n        var indentUnit = cm.getOption("indentUnit");\n        for (var i = cursors.length - 1; i >= 0; i--) {\n          var cursor = cursors[i].head;\n          var toStartOfLine = cm.getRange({ line: cursor.line, ch: 0 }, cursor);\n          var column = CodeMirror.countColumn(toStartOfLine, null, cm.getOption("tabSize"));\n          var deletePos = cm.findPosH(cursor, -1, "char", false);\n          if (toStartOfLine && !/\\S/.test(toStartOfLine) && column % indentUnit == 0) {\n            var prevIndent = new Pos(cursor.line, CodeMirror.findColumn(toStartOfLine, column - indentUnit, indentUnit));\n            if (prevIndent.ch != cursor.ch)\n              deletePos = prevIndent;\n          }\n          cm.replaceRange("", deletePos, cursor, "+delete");\n        }\n      });\n    };\n    cmds.delLineRight = function(cm) {\n      cm.operation(function() {\n        var ranges = cm.listSelections();\n        for (var i = ranges.length - 1; i >= 0; i--)\n          cm.replaceRange("", ranges[i].anchor, Pos(ranges[i].to().line), "+delete");\n        cm.scrollIntoView();\n      });\n    };\n    cmds.upcaseAtCursor = function(cm) {\n      modifyWordOrSelection(cm, function(str) {\n        return str.toUpperCase();\n      });\n    };\n    cmds.downcaseAtCursor = function(cm) {\n      modifyWordOrSelection(cm, function(str) {\n        return str.toLowerCase();\n      });\n    };\n    cmds.setSublimeMark = function(cm) {\n      if (cm.state.sublimeMark)\n        cm.state.sublimeMark.clear();\n      cm.state.sublimeMark = cm.setBookmark(cm.getCursor());\n    };\n    cmds.selectToSublimeMark = function(cm) {\n      var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n      if (found)\n        cm.setSelection(cm.getCursor(), found);\n    };\n    cmds.deleteToSublimeMark = function(cm) {\n      var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n      if (found) {\n        var from = cm.getCursor(), to = found;\n        if (CodeMirror.cmpPos(from, to) > 0) {\n          var tmp = to;\n          to = from;\n          from = tmp;\n        }\n        cm.state.sublimeKilled = cm.getRange(from, to);\n        cm.replaceRange("", from, to);\n      }\n    };\n    cmds.swapWithSublimeMark = function(cm) {\n      var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n      if (found) {\n        cm.state.sublimeMark.clear();\n        cm.state.sublimeMark = cm.setBookmark(cm.getCursor());\n        cm.setCursor(found);\n      }\n    };\n    cmds.sublimeYank = function(cm) {\n      if (cm.state.sublimeKilled != null)\n        cm.replaceSelection(cm.state.sublimeKilled, null, "paste");\n    };\n    cmds.showInCenter = function(cm) {\n      var pos = cm.cursorCoords(null, "local");\n      cm.scrollTo(null, (pos.top + pos.bottom) / 2 - cm.getScrollInfo().clientHeight / 2);\n    };\n    function getTarget(cm) {\n      var from = cm.getCursor("from"), to = cm.getCursor("to");\n      if (CodeMirror.cmpPos(from, to) == 0) {\n        var word = wordAt(cm, from);\n        if (!word.word)\n          return;\n        from = word.from;\n        to = word.to;\n      }\n      return { from, to, query: cm.getRange(from, to), word };\n    }\n    __name(getTarget, "getTarget");\n    function findAndGoTo(cm, forward) {\n      var target = getTarget(cm);\n      if (!target)\n        return;\n      var query = target.query;\n      var cur = cm.getSearchCursor(query, forward ? target.to : target.from);\n      if (forward ? cur.findNext() : cur.findPrevious()) {\n        cm.setSelection(cur.from(), cur.to());\n      } else {\n        cur = cm.getSearchCursor(query, forward ? Pos(cm.firstLine(), 0) : cm.clipPos(Pos(cm.lastLine())));\n        if (forward ? cur.findNext() : cur.findPrevious())\n          cm.setSelection(cur.from(), cur.to());\n        else if (target.word)\n          cm.setSelection(target.from, target.to);\n      }\n    }\n    __name(findAndGoTo, "findAndGoTo");\n    cmds.findUnder = function(cm) {\n      findAndGoTo(cm, true);\n    };\n    cmds.findUnderPrevious = function(cm) {\n      findAndGoTo(cm, false);\n    };\n    cmds.findAllUnder = function(cm) {\n      var target = getTarget(cm);\n      if (!target)\n        return;\n      var cur = cm.getSearchCursor(target.query);\n      var matches = [];\n      var primaryIndex = -1;\n      while (cur.findNext()) {\n        matches.push({ anchor: cur.from(), head: cur.to() });\n        if (cur.from().line <= target.from.line && cur.from().ch <= target.from.ch)\n          primaryIndex++;\n      }\n      cm.setSelections(matches, primaryIndex);\n    };\n    var keyMap = CodeMirror.keyMap;\n    keyMap.macSublime = {\n      "Cmd-Left": "goLineStartSmart",\n      "Shift-Tab": "indentLess",\n      "Shift-Ctrl-K": "deleteLine",\n      "Alt-Q": "wrapLines",\n      "Ctrl-Left": "goSubwordLeft",\n      "Ctrl-Right": "goSubwordRight",\n      "Ctrl-Alt-Up": "scrollLineUp",\n      "Ctrl-Alt-Down": "scrollLineDown",\n      "Cmd-L": "selectLine",\n      "Shift-Cmd-L": "splitSelectionByLine",\n      "Esc": "singleSelectionTop",\n      "Cmd-Enter": "insertLineAfter",\n      "Shift-Cmd-Enter": "insertLineBefore",\n      "Cmd-D": "selectNextOccurrence",\n      "Shift-Cmd-Space": "selectScope",\n      "Shift-Cmd-M": "selectBetweenBrackets",\n      "Cmd-M": "goToBracket",\n      "Cmd-Ctrl-Up": "swapLineUp",\n      "Cmd-Ctrl-Down": "swapLineDown",\n      "Cmd-/": "toggleCommentIndented",\n      "Cmd-J": "joinLines",\n      "Shift-Cmd-D": "duplicateLine",\n      "F5": "sortLines",\n      "Shift-F5": "reverseSortLines",\n      "Cmd-F5": "sortLinesInsensitive",\n      "Shift-Cmd-F5": "reverseSortLinesInsensitive",\n      "F2": "nextBookmark",\n      "Shift-F2": "prevBookmark",\n      "Cmd-F2": "toggleBookmark",\n      "Shift-Cmd-F2": "clearBookmarks",\n      "Alt-F2": "selectBookmarks",\n      "Backspace": "smartBackspace",\n      "Cmd-K Cmd-D": "skipAndSelectNextOccurrence",\n      "Cmd-K Cmd-K": "delLineRight",\n      "Cmd-K Cmd-U": "upcaseAtCursor",\n      "Cmd-K Cmd-L": "downcaseAtCursor",\n      "Cmd-K Cmd-Space": "setSublimeMark",\n      "Cmd-K Cmd-A": "selectToSublimeMark",\n      "Cmd-K Cmd-W": "deleteToSublimeMark",\n      "Cmd-K Cmd-X": "swapWithSublimeMark",\n      "Cmd-K Cmd-Y": "sublimeYank",\n      "Cmd-K Cmd-C": "showInCenter",\n      "Cmd-K Cmd-G": "clearBookmarks",\n      "Cmd-K Cmd-Backspace": "delLineLeft",\n      "Cmd-K Cmd-1": "foldAll",\n      "Cmd-K Cmd-0": "unfoldAll",\n      "Cmd-K Cmd-J": "unfoldAll",\n      "Ctrl-Shift-Up": "addCursorToPrevLine",\n      "Ctrl-Shift-Down": "addCursorToNextLine",\n      "Cmd-F3": "findUnder",\n      "Shift-Cmd-F3": "findUnderPrevious",\n      "Alt-F3": "findAllUnder",\n      "Shift-Cmd-[": "fold",\n      "Shift-Cmd-]": "unfold",\n      "Cmd-I": "findIncremental",\n      "Shift-Cmd-I": "findIncrementalReverse",\n      "Cmd-H": "replace",\n      "F3": "findNext",\n      "Shift-F3": "findPrev",\n      "fallthrough": "macDefault"\n    };\n    CodeMirror.normalizeKeyMap(keyMap.macSublime);\n    keyMap.pcSublime = {\n      "Shift-Tab": "indentLess",\n      "Shift-Ctrl-K": "deleteLine",\n      "Alt-Q": "wrapLines",\n      "Ctrl-T": "transposeChars",\n      "Alt-Left": "goSubwordLeft",\n      "Alt-Right": "goSubwordRight",\n      "Ctrl-Up": "scrollLineUp",\n      "Ctrl-Down": "scrollLineDown",\n      "Ctrl-L": "selectLine",\n      "Shift-Ctrl-L": "splitSelectionByLine",\n      "Esc": "singleSelectionTop",\n      "Ctrl-Enter": "insertLineAfter",\n      "Shift-Ctrl-Enter": "insertLineBefore",\n      "Ctrl-D": "selectNextOccurrence",\n      "Shift-Ctrl-Space": "selectScope",\n      "Shift-Ctrl-M": "selectBetweenBrackets",\n      "Ctrl-M": "goToBracket",\n      "Shift-Ctrl-Up": "swapLineUp",\n      "Shift-Ctrl-Down": "swapLineDown",\n      "Ctrl-/": "toggleCommentIndented",\n      "Ctrl-J": "joinLines",\n      "Shift-Ctrl-D": "duplicateLine",\n      "F9": "sortLines",\n      "Shift-F9": "reverseSortLines",\n      "Ctrl-F9": "sortLinesInsensitive",\n      "Shift-Ctrl-F9": "reverseSortLinesInsensitive",\n      "F2": "nextBookmark",\n      "Shift-F2": "prevBookmark",\n      "Ctrl-F2": "toggleBookmark",\n      "Shift-Ctrl-F2": "clearBookmarks",\n      "Alt-F2": "selectBookmarks",\n      "Backspace": "smartBackspace",\n      "Ctrl-K Ctrl-D": "skipAndSelectNextOccurrence",\n      "Ctrl-K Ctrl-K": "delLineRight",\n      "Ctrl-K Ctrl-U": "upcaseAtCursor",\n      "Ctrl-K Ctrl-L": "downcaseAtCursor",\n      "Ctrl-K Ctrl-Space": "setSublimeMark",\n      "Ctrl-K Ctrl-A": "selectToSublimeMark",\n      "Ctrl-K Ctrl-W": "deleteToSublimeMark",\n      "Ctrl-K Ctrl-X": "swapWithSublimeMark",\n      "Ctrl-K Ctrl-Y": "sublimeYank",\n      "Ctrl-K Ctrl-C": "showInCenter",\n      "Ctrl-K Ctrl-G": "clearBookmarks",\n      "Ctrl-K Ctrl-Backspace": "delLineLeft",\n      "Ctrl-K Ctrl-1": "foldAll",\n      "Ctrl-K Ctrl-0": "unfoldAll",\n      "Ctrl-K Ctrl-J": "unfoldAll",\n      "Ctrl-Alt-Up": "addCursorToPrevLine",\n      "Ctrl-Alt-Down": "addCursorToNextLine",\n      "Ctrl-F3": "findUnder",\n      "Shift-Ctrl-F3": "findUnderPrevious",\n      "Alt-F3": "findAllUnder",\n      "Shift-Ctrl-[": "fold",\n      "Shift-Ctrl-]": "unfold",\n      "Ctrl-I": "findIncremental",\n      "Shift-Ctrl-I": "findIncrementalReverse",\n      "Ctrl-H": "replace",\n      "F3": "findNext",\n      "Shift-F3": "findPrev",\n      "fallthrough": "pcDefault"\n    };\n    CodeMirror.normalizeKeyMap(keyMap.pcSublime);\n    var mac = keyMap.default == keyMap.macDefault;\n    keyMap.sublime = mac ? keyMap.macSublime : keyMap.pcSublime;\n  });\n})();\nvar sublime = sublime$2.exports;\nvar sublime$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  [Symbol.toStringTag]: "Module",\n  "default": sublime\n}, [sublime$2.exports]));\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0NBQW9DO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ3lCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2FjaGlxbC1kZW1vLy4vbm9kZV9tb2R1bGVzL0BncmFwaGlxbC9yZWFjdC9kaXN0L3N1YmxpbWUuZXMuanM/OGQyNiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fbmFtZSA9ICh0YXJnZXQsIHZhbHVlKSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIm5hbWVcIiwgeyB2YWx1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuaW1wb3J0IHsgYSBhcyBjb2RlbWlycm9yIH0gZnJvbSBcIi4vY29kZW1pcnJvci5lcy5qc1wiO1xuaW1wb3J0IHsgYSBhcyBzZWFyY2hjdXJzb3IgfSBmcm9tIFwiLi9zZWFyY2hjdXJzb3IuZXMuanNcIjtcbmltcG9ydCB7IGEgYXMgbWF0Y2hicmFja2V0cyB9IGZyb20gXCIuL21hdGNoYnJhY2tldHMuZXMuanNcIjtcbmZ1bmN0aW9uIF9tZXJnZU5hbWVzcGFjZXMobiwgbSkge1xuICBtLmZvckVhY2goZnVuY3Rpb24oZSkge1xuICAgIGUgJiYgdHlwZW9mIGUgIT09IFwic3RyaW5nXCIgJiYgIUFycmF5LmlzQXJyYXkoZSkgJiYgT2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgIShrIGluIG4pKSB7XG4gICAgICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGssIGQuZ2V0ID8gZCA6IHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZVtrXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUobik7XG59XG5fX25hbWUoX21lcmdlTmFtZXNwYWNlcywgXCJfbWVyZ2VOYW1lc3BhY2VzXCIpO1xudmFyIHN1YmxpbWUkMiA9IHsgZXhwb3J0czoge30gfTtcbihmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcbiAgKGZ1bmN0aW9uKG1vZCkge1xuICAgIG1vZChjb2RlbWlycm9yLmV4cG9ydHMsIHNlYXJjaGN1cnNvci5leHBvcnRzLCBtYXRjaGJyYWNrZXRzLmV4cG9ydHMpO1xuICB9KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG4gICAgdmFyIGNtZHMgPSBDb2RlTWlycm9yLmNvbW1hbmRzO1xuICAgIHZhciBQb3MgPSBDb2RlTWlycm9yLlBvcztcbiAgICBmdW5jdGlvbiBmaW5kUG9zU3Vid29yZChkb2MsIHN0YXJ0LCBkaXIpIHtcbiAgICAgIGlmIChkaXIgPCAwICYmIHN0YXJ0LmNoID09IDApXG4gICAgICAgIHJldHVybiBkb2MuY2xpcFBvcyhQb3Moc3RhcnQubGluZSAtIDEpKTtcbiAgICAgIHZhciBsaW5lID0gZG9jLmdldExpbmUoc3RhcnQubGluZSk7XG4gICAgICBpZiAoZGlyID4gMCAmJiBzdGFydC5jaCA+PSBsaW5lLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGRvYy5jbGlwUG9zKFBvcyhzdGFydC5saW5lICsgMSwgMCkpO1xuICAgICAgdmFyIHN0YXRlID0gXCJzdGFydFwiLCB0eXBlLCBzdGFydFBvcyA9IHN0YXJ0LmNoO1xuICAgICAgZm9yICh2YXIgcG9zID0gc3RhcnRQb3MsIGUgPSBkaXIgPCAwID8gMCA6IGxpbmUubGVuZ3RoLCBpID0gMDsgcG9zICE9IGU7IHBvcyArPSBkaXIsIGkrKykge1xuICAgICAgICB2YXIgbmV4dCA9IGxpbmUuY2hhckF0KGRpciA8IDAgPyBwb3MgLSAxIDogcG9zKTtcbiAgICAgICAgdmFyIGNhdCA9IG5leHQgIT0gXCJfXCIgJiYgQ29kZU1pcnJvci5pc1dvcmRDaGFyKG5leHQpID8gXCJ3XCIgOiBcIm9cIjtcbiAgICAgICAgaWYgKGNhdCA9PSBcIndcIiAmJiBuZXh0LnRvVXBwZXJDYXNlKCkgPT0gbmV4dClcbiAgICAgICAgICBjYXQgPSBcIldcIjtcbiAgICAgICAgaWYgKHN0YXRlID09IFwic3RhcnRcIikge1xuICAgICAgICAgIGlmIChjYXQgIT0gXCJvXCIpIHtcbiAgICAgICAgICAgIHN0YXRlID0gXCJpblwiO1xuICAgICAgICAgICAgdHlwZSA9IGNhdDtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIHN0YXJ0UG9zID0gcG9zICsgZGlyO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09IFwiaW5cIikge1xuICAgICAgICAgIGlmICh0eXBlICE9IGNhdCkge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT0gXCJ3XCIgJiYgY2F0ID09IFwiV1wiICYmIGRpciA8IDApXG4gICAgICAgICAgICAgIHBvcy0tO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT0gXCJXXCIgJiYgY2F0ID09IFwid1wiICYmIGRpciA+IDApIHtcbiAgICAgICAgICAgICAgaWYgKHBvcyA9PSBzdGFydFBvcyArIDEpIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gXCJ3XCI7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIHBvcy0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gUG9zKHN0YXJ0LmxpbmUsIHBvcyk7XG4gICAgfVxuICAgIF9fbmFtZShmaW5kUG9zU3Vid29yZCwgXCJmaW5kUG9zU3Vid29yZFwiKTtcbiAgICBmdW5jdGlvbiBtb3ZlU3Vid29yZChjbSwgZGlyKSB7XG4gICAgICBjbS5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgICAgaWYgKGNtLmRpc3BsYXkuc2hpZnQgfHwgY20uZG9jLmV4dGVuZCB8fCByYW5nZS5lbXB0eSgpKVxuICAgICAgICAgIHJldHVybiBmaW5kUG9zU3Vid29yZChjbS5kb2MsIHJhbmdlLmhlYWQsIGRpcik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXR1cm4gZGlyIDwgMCA/IHJhbmdlLmZyb20oKSA6IHJhbmdlLnRvKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgX19uYW1lKG1vdmVTdWJ3b3JkLCBcIm1vdmVTdWJ3b3JkXCIpO1xuICAgIGNtZHMuZ29TdWJ3b3JkTGVmdCA9IGZ1bmN0aW9uKGNtKSB7XG4gICAgICBtb3ZlU3Vid29yZChjbSwgLTEpO1xuICAgIH07XG4gICAgY21kcy5nb1N1YndvcmRSaWdodCA9IGZ1bmN0aW9uKGNtKSB7XG4gICAgICBtb3ZlU3Vid29yZChjbSwgMSk7XG4gICAgfTtcbiAgICBjbWRzLnNjcm9sbExpbmVVcCA9IGZ1bmN0aW9uKGNtKSB7XG4gICAgICB2YXIgaW5mbyA9IGNtLmdldFNjcm9sbEluZm8oKTtcbiAgICAgIGlmICghY20uc29tZXRoaW5nU2VsZWN0ZWQoKSkge1xuICAgICAgICB2YXIgdmlzaWJsZUJvdHRvbUxpbmUgPSBjbS5saW5lQXRIZWlnaHQoaW5mby50b3AgKyBpbmZvLmNsaWVudEhlaWdodCwgXCJsb2NhbFwiKTtcbiAgICAgICAgaWYgKGNtLmdldEN1cnNvcigpLmxpbmUgPj0gdmlzaWJsZUJvdHRvbUxpbmUpXG4gICAgICAgICAgY20uZXhlY0NvbW1hbmQoXCJnb0xpbmVVcFwiKTtcbiAgICAgIH1cbiAgICAgIGNtLnNjcm9sbFRvKG51bGwsIGluZm8udG9wIC0gY20uZGVmYXVsdFRleHRIZWlnaHQoKSk7XG4gICAgfTtcbiAgICBjbWRzLnNjcm9sbExpbmVEb3duID0gZnVuY3Rpb24oY20pIHtcbiAgICAgIHZhciBpbmZvID0gY20uZ2V0U2Nyb2xsSW5mbygpO1xuICAgICAgaWYgKCFjbS5zb21ldGhpbmdTZWxlY3RlZCgpKSB7XG4gICAgICAgIHZhciB2aXNpYmxlVG9wTGluZSA9IGNtLmxpbmVBdEhlaWdodChpbmZvLnRvcCwgXCJsb2NhbFwiKSArIDE7XG4gICAgICAgIGlmIChjbS5nZXRDdXJzb3IoKS5saW5lIDw9IHZpc2libGVUb3BMaW5lKVxuICAgICAgICAgIGNtLmV4ZWNDb21tYW5kKFwiZ29MaW5lRG93blwiKTtcbiAgICAgIH1cbiAgICAgIGNtLnNjcm9sbFRvKG51bGwsIGluZm8udG9wICsgY20uZGVmYXVsdFRleHRIZWlnaHQoKSk7XG4gICAgfTtcbiAgICBjbWRzLnNwbGl0U2VsZWN0aW9uQnlMaW5lID0gZnVuY3Rpb24oY20pIHtcbiAgICAgIHZhciByYW5nZXMgPSBjbS5saXN0U2VsZWN0aW9ucygpLCBsaW5lUmFuZ2VzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZnJvbSA9IHJhbmdlc1tpXS5mcm9tKCksIHRvID0gcmFuZ2VzW2ldLnRvKCk7XG4gICAgICAgIGZvciAodmFyIGxpbmUgPSBmcm9tLmxpbmU7IGxpbmUgPD0gdG8ubGluZTsgKytsaW5lKVxuICAgICAgICAgIGlmICghKHRvLmxpbmUgPiBmcm9tLmxpbmUgJiYgbGluZSA9PSB0by5saW5lICYmIHRvLmNoID09IDApKVxuICAgICAgICAgICAgbGluZVJhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgYW5jaG9yOiBsaW5lID09IGZyb20ubGluZSA/IGZyb20gOiBQb3MobGluZSwgMCksXG4gICAgICAgICAgICAgIGhlYWQ6IGxpbmUgPT0gdG8ubGluZSA/IHRvIDogUG9zKGxpbmUpXG4gICAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNtLnNldFNlbGVjdGlvbnMobGluZVJhbmdlcywgMCk7XG4gICAgfTtcbiAgICBjbWRzLnNpbmdsZVNlbGVjdGlvblRvcCA9IGZ1bmN0aW9uKGNtKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBjbS5saXN0U2VsZWN0aW9ucygpWzBdO1xuICAgICAgY20uc2V0U2VsZWN0aW9uKHJhbmdlLmFuY2hvciwgcmFuZ2UuaGVhZCwgeyBzY3JvbGw6IGZhbHNlIH0pO1xuICAgIH07XG4gICAgY21kcy5zZWxlY3RMaW5lID0gZnVuY3Rpb24oY20pIHtcbiAgICAgIHZhciByYW5nZXMgPSBjbS5saXN0U2VsZWN0aW9ucygpLCBleHRlbmRlZCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJhbmdlID0gcmFuZ2VzW2ldO1xuICAgICAgICBleHRlbmRlZC5wdXNoKHtcbiAgICAgICAgICBhbmNob3I6IFBvcyhyYW5nZS5mcm9tKCkubGluZSwgMCksXG4gICAgICAgICAgaGVhZDogUG9zKHJhbmdlLnRvKCkubGluZSArIDEsIDApXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY20uc2V0U2VsZWN0aW9ucyhleHRlbmRlZCk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBpbnNlcnRMaW5lKGNtLCBhYm92ZSkge1xuICAgICAgaWYgKGNtLmlzUmVhZE9ubHkoKSlcbiAgICAgICAgcmV0dXJuIENvZGVNaXJyb3IuUGFzcztcbiAgICAgIGNtLm9wZXJhdGlvbihmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxlbiA9IGNtLmxpc3RTZWxlY3Rpb25zKCkubGVuZ3RoLCBuZXdTZWxlY3Rpb24gPSBbXSwgbGFzdCA9IC0xO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgdmFyIGhlYWQgPSBjbS5saXN0U2VsZWN0aW9ucygpW2ldLmhlYWQ7XG4gICAgICAgICAgaWYgKGhlYWQubGluZSA8PSBsYXN0KVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgdmFyIGF0ID0gUG9zKGhlYWQubGluZSArIChhYm92ZSA/IDAgOiAxKSwgMCk7XG4gICAgICAgICAgY20ucmVwbGFjZVJhbmdlKFwiXFxuXCIsIGF0LCBudWxsLCBcIitpbnNlcnRMaW5lXCIpO1xuICAgICAgICAgIGNtLmluZGVudExpbmUoYXQubGluZSwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgbmV3U2VsZWN0aW9uLnB1c2goeyBoZWFkOiBhdCwgYW5jaG9yOiBhdCB9KTtcbiAgICAgICAgICBsYXN0ID0gaGVhZC5saW5lICsgMTtcbiAgICAgICAgfVxuICAgICAgICBjbS5zZXRTZWxlY3Rpb25zKG5ld1NlbGVjdGlvbik7XG4gICAgICB9KTtcbiAgICAgIGNtLmV4ZWNDb21tYW5kKFwiaW5kZW50QXV0b1wiKTtcbiAgICB9XG4gICAgX19uYW1lKGluc2VydExpbmUsIFwiaW5zZXJ0TGluZVwiKTtcbiAgICBjbWRzLmluc2VydExpbmVBZnRlciA9IGZ1bmN0aW9uKGNtKSB7XG4gICAgICByZXR1cm4gaW5zZXJ0TGluZShjbSwgZmFsc2UpO1xuICAgIH07XG4gICAgY21kcy5pbnNlcnRMaW5lQmVmb3JlID0gZnVuY3Rpb24oY20pIHtcbiAgICAgIHJldHVybiBpbnNlcnRMaW5lKGNtLCB0cnVlKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHdvcmRBdChjbSwgcG9zKSB7XG4gICAgICB2YXIgc3RhcnQgPSBwb3MuY2gsIGVuZCA9IHN0YXJ0LCBsaW5lID0gY20uZ2V0TGluZShwb3MubGluZSk7XG4gICAgICB3aGlsZSAoc3RhcnQgJiYgQ29kZU1pcnJvci5pc1dvcmRDaGFyKGxpbmUuY2hhckF0KHN0YXJ0IC0gMSkpKVxuICAgICAgICAtLXN0YXJ0O1xuICAgICAgd2hpbGUgKGVuZCA8IGxpbmUubGVuZ3RoICYmIENvZGVNaXJyb3IuaXNXb3JkQ2hhcihsaW5lLmNoYXJBdChlbmQpKSlcbiAgICAgICAgKytlbmQ7XG4gICAgICByZXR1cm4geyBmcm9tOiBQb3MocG9zLmxpbmUsIHN0YXJ0KSwgdG86IFBvcyhwb3MubGluZSwgZW5kKSwgd29yZDogbGluZS5zbGljZShzdGFydCwgZW5kKSB9O1xuICAgIH1cbiAgICBfX25hbWUod29yZEF0LCBcIndvcmRBdFwiKTtcbiAgICBjbWRzLnNlbGVjdE5leHRPY2N1cnJlbmNlID0gZnVuY3Rpb24oY20pIHtcbiAgICAgIHZhciBmcm9tID0gY20uZ2V0Q3Vyc29yKFwiZnJvbVwiKSwgdG8gPSBjbS5nZXRDdXJzb3IoXCJ0b1wiKTtcbiAgICAgIHZhciBmdWxsV29yZCA9IGNtLnN0YXRlLnN1YmxpbWVGaW5kRnVsbFdvcmQgPT0gY20uZG9jLnNlbDtcbiAgICAgIGlmIChDb2RlTWlycm9yLmNtcFBvcyhmcm9tLCB0bykgPT0gMCkge1xuICAgICAgICB2YXIgd29yZCA9IHdvcmRBdChjbSwgZnJvbSk7XG4gICAgICAgIGlmICghd29yZC53b3JkKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY20uc2V0U2VsZWN0aW9uKHdvcmQuZnJvbSwgd29yZC50byk7XG4gICAgICAgIGZ1bGxXb3JkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0ZXh0ID0gY20uZ2V0UmFuZ2UoZnJvbSwgdG8pO1xuICAgICAgICB2YXIgcXVlcnkgPSBmdWxsV29yZCA/IG5ldyBSZWdFeHAoXCJcXFxcYlwiICsgdGV4dCArIFwiXFxcXGJcIikgOiB0ZXh0O1xuICAgICAgICB2YXIgY3VyID0gY20uZ2V0U2VhcmNoQ3Vyc29yKHF1ZXJ5LCB0byk7XG4gICAgICAgIHZhciBmb3VuZCA9IGN1ci5maW5kTmV4dCgpO1xuICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgY3VyID0gY20uZ2V0U2VhcmNoQ3Vyc29yKHF1ZXJ5LCBQb3MoY20uZmlyc3RMaW5lKCksIDApKTtcbiAgICAgICAgICBmb3VuZCA9IGN1ci5maW5kTmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZm91bmQgfHwgaXNTZWxlY3RlZFJhbmdlKGNtLmxpc3RTZWxlY3Rpb25zKCksIGN1ci5mcm9tKCksIGN1ci50bygpKSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNtLmFkZFNlbGVjdGlvbihjdXIuZnJvbSgpLCBjdXIudG8oKSk7XG4gICAgICB9XG4gICAgICBpZiAoZnVsbFdvcmQpXG4gICAgICAgIGNtLnN0YXRlLnN1YmxpbWVGaW5kRnVsbFdvcmQgPSBjbS5kb2Muc2VsO1xuICAgIH07XG4gICAgY21kcy5za2lwQW5kU2VsZWN0TmV4dE9jY3VycmVuY2UgPSBmdW5jdGlvbihjbSkge1xuICAgICAgdmFyIHByZXZBbmNob3IgPSBjbS5nZXRDdXJzb3IoXCJhbmNob3JcIiksIHByZXZIZWFkID0gY20uZ2V0Q3Vyc29yKFwiaGVhZFwiKTtcbiAgICAgIGNtZHMuc2VsZWN0TmV4dE9jY3VycmVuY2UoY20pO1xuICAgICAgaWYgKENvZGVNaXJyb3IuY21wUG9zKHByZXZBbmNob3IsIHByZXZIZWFkKSAhPSAwKSB7XG4gICAgICAgIGNtLmRvYy5zZXRTZWxlY3Rpb25zKGNtLmRvYy5saXN0U2VsZWN0aW9ucygpLmZpbHRlcihmdW5jdGlvbihzZWwpIHtcbiAgICAgICAgICByZXR1cm4gc2VsLmFuY2hvciAhPSBwcmV2QW5jaG9yIHx8IHNlbC5oZWFkICE9IHByZXZIZWFkO1xuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBhZGRDdXJzb3JUb1NlbGVjdGlvbihjbSwgZGlyKSB7XG4gICAgICB2YXIgcmFuZ2VzID0gY20ubGlzdFNlbGVjdGlvbnMoKSwgbmV3UmFuZ2VzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcmFuZ2UgPSByYW5nZXNbaV07XG4gICAgICAgIHZhciBuZXdBbmNob3IgPSBjbS5maW5kUG9zVihyYW5nZS5hbmNob3IsIGRpciwgXCJsaW5lXCIsIHJhbmdlLmFuY2hvci5nb2FsQ29sdW1uKTtcbiAgICAgICAgdmFyIG5ld0hlYWQgPSBjbS5maW5kUG9zVihyYW5nZS5oZWFkLCBkaXIsIFwibGluZVwiLCByYW5nZS5oZWFkLmdvYWxDb2x1bW4pO1xuICAgICAgICBuZXdBbmNob3IuZ29hbENvbHVtbiA9IHJhbmdlLmFuY2hvci5nb2FsQ29sdW1uICE9IG51bGwgPyByYW5nZS5hbmNob3IuZ29hbENvbHVtbiA6IGNtLmN1cnNvckNvb3JkcyhyYW5nZS5hbmNob3IsIFwiZGl2XCIpLmxlZnQ7XG4gICAgICAgIG5ld0hlYWQuZ29hbENvbHVtbiA9IHJhbmdlLmhlYWQuZ29hbENvbHVtbiAhPSBudWxsID8gcmFuZ2UuaGVhZC5nb2FsQ29sdW1uIDogY20uY3Vyc29yQ29vcmRzKHJhbmdlLmhlYWQsIFwiZGl2XCIpLmxlZnQ7XG4gICAgICAgIHZhciBuZXdSYW5nZSA9IHsgYW5jaG9yOiBuZXdBbmNob3IsIGhlYWQ6IG5ld0hlYWQgfTtcbiAgICAgICAgbmV3UmFuZ2VzLnB1c2gocmFuZ2UpO1xuICAgICAgICBuZXdSYW5nZXMucHVzaChuZXdSYW5nZSk7XG4gICAgICB9XG4gICAgICBjbS5zZXRTZWxlY3Rpb25zKG5ld1Jhbmdlcyk7XG4gICAgfVxuICAgIF9fbmFtZShhZGRDdXJzb3JUb1NlbGVjdGlvbiwgXCJhZGRDdXJzb3JUb1NlbGVjdGlvblwiKTtcbiAgICBjbWRzLmFkZEN1cnNvclRvUHJldkxpbmUgPSBmdW5jdGlvbihjbSkge1xuICAgICAgYWRkQ3Vyc29yVG9TZWxlY3Rpb24oY20sIC0xKTtcbiAgICB9O1xuICAgIGNtZHMuYWRkQ3Vyc29yVG9OZXh0TGluZSA9IGZ1bmN0aW9uKGNtKSB7XG4gICAgICBhZGRDdXJzb3JUb1NlbGVjdGlvbihjbSwgMSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBpc1NlbGVjdGVkUmFuZ2UocmFuZ2VzLCBmcm9tLCB0bykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmIChDb2RlTWlycm9yLmNtcFBvcyhyYW5nZXNbaV0uZnJvbSgpLCBmcm9tKSA9PSAwICYmIENvZGVNaXJyb3IuY21wUG9zKHJhbmdlc1tpXS50bygpLCB0bykgPT0gMClcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgX19uYW1lKGlzU2VsZWN0ZWRSYW5nZSwgXCJpc1NlbGVjdGVkUmFuZ2VcIik7XG4gICAgdmFyIG1pcnJvciA9IFwiKCl7fVtdXCI7XG4gICAgZnVuY3Rpb24gc2VsZWN0QmV0d2VlbkJyYWNrZXRzKGNtKSB7XG4gICAgICB2YXIgcmFuZ2VzID0gY20ubGlzdFNlbGVjdGlvbnMoKSwgbmV3UmFuZ2VzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcmFuZ2UgPSByYW5nZXNbaV0sIHBvcyA9IHJhbmdlLmhlYWQsIG9wZW5pbmcgPSBjbS5zY2FuRm9yQnJhY2tldChwb3MsIC0xKTtcbiAgICAgICAgaWYgKCFvcGVuaW5nKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yICg7IDsgKSB7XG4gICAgICAgICAgdmFyIGNsb3NpbmcgPSBjbS5zY2FuRm9yQnJhY2tldChwb3MsIDEpO1xuICAgICAgICAgIGlmICghY2xvc2luZylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICBpZiAoY2xvc2luZy5jaCA9PSBtaXJyb3IuY2hhckF0KG1pcnJvci5pbmRleE9mKG9wZW5pbmcuY2gpICsgMSkpIHtcbiAgICAgICAgICAgIHZhciBzdGFydFBvcyA9IFBvcyhvcGVuaW5nLnBvcy5saW5lLCBvcGVuaW5nLnBvcy5jaCArIDEpO1xuICAgICAgICAgICAgaWYgKENvZGVNaXJyb3IuY21wUG9zKHN0YXJ0UG9zLCByYW5nZS5mcm9tKCkpID09IDAgJiYgQ29kZU1pcnJvci5jbXBQb3MoY2xvc2luZy5wb3MsIHJhbmdlLnRvKCkpID09IDApIHtcbiAgICAgICAgICAgICAgb3BlbmluZyA9IGNtLnNjYW5Gb3JCcmFja2V0KG9wZW5pbmcucG9zLCAtMSk7XG4gICAgICAgICAgICAgIGlmICghb3BlbmluZylcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdSYW5nZXMucHVzaCh7IGFuY2hvcjogc3RhcnRQb3MsIGhlYWQ6IGNsb3NpbmcucG9zIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcG9zID0gUG9zKGNsb3NpbmcucG9zLmxpbmUsIGNsb3NpbmcucG9zLmNoICsgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNtLnNldFNlbGVjdGlvbnMobmV3UmFuZ2VzKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBfX25hbWUoc2VsZWN0QmV0d2VlbkJyYWNrZXRzLCBcInNlbGVjdEJldHdlZW5CcmFja2V0c1wiKTtcbiAgICBjbWRzLnNlbGVjdFNjb3BlID0gZnVuY3Rpb24oY20pIHtcbiAgICAgIHNlbGVjdEJldHdlZW5CcmFja2V0cyhjbSkgfHwgY20uZXhlY0NvbW1hbmQoXCJzZWxlY3RBbGxcIik7XG4gICAgfTtcbiAgICBjbWRzLnNlbGVjdEJldHdlZW5CcmFja2V0cyA9IGZ1bmN0aW9uKGNtKSB7XG4gICAgICBpZiAoIXNlbGVjdEJldHdlZW5CcmFja2V0cyhjbSkpXG4gICAgICAgIHJldHVybiBDb2RlTWlycm9yLlBhc3M7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBwdW5jVHlwZSh0eXBlKSB7XG4gICAgICByZXR1cm4gIXR5cGUgPyBudWxsIDogL1xcYnB1bmN0dWF0aW9uXFxiLy50ZXN0KHR5cGUpID8gdHlwZSA6IHZvaWQgMDtcbiAgICB9XG4gICAgX19uYW1lKHB1bmNUeXBlLCBcInB1bmNUeXBlXCIpO1xuICAgIGNtZHMuZ29Ub0JyYWNrZXQgPSBmdW5jdGlvbihjbSkge1xuICAgICAgY20uZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgIHZhciBuZXh0ID0gY20uc2NhbkZvckJyYWNrZXQocmFuZ2UuaGVhZCwgMSwgcHVuY1R5cGUoY20uZ2V0VG9rZW5UeXBlQXQocmFuZ2UuaGVhZCkpKTtcbiAgICAgICAgaWYgKG5leHQgJiYgQ29kZU1pcnJvci5jbXBQb3MobmV4dC5wb3MsIHJhbmdlLmhlYWQpICE9IDApXG4gICAgICAgICAgcmV0dXJuIG5leHQucG9zO1xuICAgICAgICB2YXIgcHJldiA9IGNtLnNjYW5Gb3JCcmFja2V0KHJhbmdlLmhlYWQsIC0xLCBwdW5jVHlwZShjbS5nZXRUb2tlblR5cGVBdChQb3MocmFuZ2UuaGVhZC5saW5lLCByYW5nZS5oZWFkLmNoICsgMSkpKSk7XG4gICAgICAgIHJldHVybiBwcmV2ICYmIFBvcyhwcmV2LnBvcy5saW5lLCBwcmV2LnBvcy5jaCArIDEpIHx8IHJhbmdlLmhlYWQ7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNtZHMuc3dhcExpbmVVcCA9IGZ1bmN0aW9uKGNtKSB7XG4gICAgICBpZiAoY20uaXNSZWFkT25seSgpKVxuICAgICAgICByZXR1cm4gQ29kZU1pcnJvci5QYXNzO1xuICAgICAgdmFyIHJhbmdlcyA9IGNtLmxpc3RTZWxlY3Rpb25zKCksIGxpbmVzVG9Nb3ZlID0gW10sIGF0ID0gY20uZmlyc3RMaW5lKCkgLSAxLCBuZXdTZWxzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcmFuZ2UgPSByYW5nZXNbaV0sIGZyb20gPSByYW5nZS5mcm9tKCkubGluZSAtIDEsIHRvID0gcmFuZ2UudG8oKS5saW5lO1xuICAgICAgICBuZXdTZWxzLnB1c2goe1xuICAgICAgICAgIGFuY2hvcjogUG9zKHJhbmdlLmFuY2hvci5saW5lIC0gMSwgcmFuZ2UuYW5jaG9yLmNoKSxcbiAgICAgICAgICBoZWFkOiBQb3MocmFuZ2UuaGVhZC5saW5lIC0gMSwgcmFuZ2UuaGVhZC5jaClcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyYW5nZS50bygpLmNoID09IDAgJiYgIXJhbmdlLmVtcHR5KCkpXG4gICAgICAgICAgLS10bztcbiAgICAgICAgaWYgKGZyb20gPiBhdClcbiAgICAgICAgICBsaW5lc1RvTW92ZS5wdXNoKGZyb20sIHRvKTtcbiAgICAgICAgZWxzZSBpZiAobGluZXNUb01vdmUubGVuZ3RoKVxuICAgICAgICAgIGxpbmVzVG9Nb3ZlW2xpbmVzVG9Nb3ZlLmxlbmd0aCAtIDFdID0gdG87XG4gICAgICAgIGF0ID0gdG87XG4gICAgICB9XG4gICAgICBjbS5vcGVyYXRpb24oZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBsaW5lc1RvTW92ZS5sZW5ndGg7IGkyICs9IDIpIHtcbiAgICAgICAgICB2YXIgZnJvbTIgPSBsaW5lc1RvTW92ZVtpMl0sIHRvMiA9IGxpbmVzVG9Nb3ZlW2kyICsgMV07XG4gICAgICAgICAgdmFyIGxpbmUgPSBjbS5nZXRMaW5lKGZyb20yKTtcbiAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2UoXCJcIiwgUG9zKGZyb20yLCAwKSwgUG9zKGZyb20yICsgMSwgMCksIFwiK3N3YXBMaW5lXCIpO1xuICAgICAgICAgIGlmICh0bzIgPiBjbS5sYXN0TGluZSgpKVxuICAgICAgICAgICAgY20ucmVwbGFjZVJhbmdlKFwiXFxuXCIgKyBsaW5lLCBQb3MoY20ubGFzdExpbmUoKSksIG51bGwsIFwiK3N3YXBMaW5lXCIpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNtLnJlcGxhY2VSYW5nZShsaW5lICsgXCJcXG5cIiwgUG9zKHRvMiwgMCksIG51bGwsIFwiK3N3YXBMaW5lXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNtLnNldFNlbGVjdGlvbnMobmV3U2Vscyk7XG4gICAgICAgIGNtLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNtZHMuc3dhcExpbmVEb3duID0gZnVuY3Rpb24oY20pIHtcbiAgICAgIGlmIChjbS5pc1JlYWRPbmx5KCkpXG4gICAgICAgIHJldHVybiBDb2RlTWlycm9yLlBhc3M7XG4gICAgICB2YXIgcmFuZ2VzID0gY20ubGlzdFNlbGVjdGlvbnMoKSwgbGluZXNUb01vdmUgPSBbXSwgYXQgPSBjbS5sYXN0TGluZSgpICsgMTtcbiAgICAgIGZvciAodmFyIGkgPSByYW5nZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIHJhbmdlID0gcmFuZ2VzW2ldLCBmcm9tID0gcmFuZ2UudG8oKS5saW5lICsgMSwgdG8gPSByYW5nZS5mcm9tKCkubGluZTtcbiAgICAgICAgaWYgKHJhbmdlLnRvKCkuY2ggPT0gMCAmJiAhcmFuZ2UuZW1wdHkoKSlcbiAgICAgICAgICBmcm9tLS07XG4gICAgICAgIGlmIChmcm9tIDwgYXQpXG4gICAgICAgICAgbGluZXNUb01vdmUucHVzaChmcm9tLCB0byk7XG4gICAgICAgIGVsc2UgaWYgKGxpbmVzVG9Nb3ZlLmxlbmd0aClcbiAgICAgICAgICBsaW5lc1RvTW92ZVtsaW5lc1RvTW92ZS5sZW5ndGggLSAxXSA9IHRvO1xuICAgICAgICBhdCA9IHRvO1xuICAgICAgfVxuICAgICAgY20ub3BlcmF0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBpMiA9IGxpbmVzVG9Nb3ZlLmxlbmd0aCAtIDI7IGkyID49IDA7IGkyIC09IDIpIHtcbiAgICAgICAgICB2YXIgZnJvbTIgPSBsaW5lc1RvTW92ZVtpMl0sIHRvMiA9IGxpbmVzVG9Nb3ZlW2kyICsgMV07XG4gICAgICAgICAgdmFyIGxpbmUgPSBjbS5nZXRMaW5lKGZyb20yKTtcbiAgICAgICAgICBpZiAoZnJvbTIgPT0gY20ubGFzdExpbmUoKSlcbiAgICAgICAgICAgIGNtLnJlcGxhY2VSYW5nZShcIlwiLCBQb3MoZnJvbTIgLSAxKSwgUG9zKGZyb20yKSwgXCIrc3dhcExpbmVcIik7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgY20ucmVwbGFjZVJhbmdlKFwiXCIsIFBvcyhmcm9tMiwgMCksIFBvcyhmcm9tMiArIDEsIDApLCBcIitzd2FwTGluZVwiKTtcbiAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2UobGluZSArIFwiXFxuXCIsIFBvcyh0bzIsIDApLCBudWxsLCBcIitzd2FwTGluZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjbS5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjbWRzLnRvZ2dsZUNvbW1lbnRJbmRlbnRlZCA9IGZ1bmN0aW9uKGNtKSB7XG4gICAgICBjbS50b2dnbGVDb21tZW50KHsgaW5kZW50OiB0cnVlIH0pO1xuICAgIH07XG4gICAgY21kcy5qb2luTGluZXMgPSBmdW5jdGlvbihjbSkge1xuICAgICAgdmFyIHJhbmdlcyA9IGNtLmxpc3RTZWxlY3Rpb25zKCksIGpvaW5lZCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJhbmdlID0gcmFuZ2VzW2ldLCBmcm9tID0gcmFuZ2UuZnJvbSgpO1xuICAgICAgICB2YXIgc3RhcnQgPSBmcm9tLmxpbmUsIGVuZCA9IHJhbmdlLnRvKCkubGluZTtcbiAgICAgICAgd2hpbGUgKGkgPCByYW5nZXMubGVuZ3RoIC0gMSAmJiByYW5nZXNbaSArIDFdLmZyb20oKS5saW5lID09IGVuZClcbiAgICAgICAgICBlbmQgPSByYW5nZXNbKytpXS50bygpLmxpbmU7XG4gICAgICAgIGpvaW5lZC5wdXNoKHsgc3RhcnQsIGVuZCwgYW5jaG9yOiAhcmFuZ2UuZW1wdHkoKSAmJiBmcm9tIH0pO1xuICAgICAgfVxuICAgICAgY20ub3BlcmF0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gMCwgcmFuZ2VzMiA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgam9pbmVkLmxlbmd0aDsgaTIrKykge1xuICAgICAgICAgIHZhciBvYmogPSBqb2luZWRbaTJdO1xuICAgICAgICAgIHZhciBhbmNob3IgPSBvYmouYW5jaG9yICYmIFBvcyhvYmouYW5jaG9yLmxpbmUgLSBvZmZzZXQsIG9iai5hbmNob3IuY2gpLCBoZWFkO1xuICAgICAgICAgIGZvciAodmFyIGxpbmUgPSBvYmouc3RhcnQ7IGxpbmUgPD0gb2JqLmVuZDsgbGluZSsrKSB7XG4gICAgICAgICAgICB2YXIgYWN0dWFsID0gbGluZSAtIG9mZnNldDtcbiAgICAgICAgICAgIGlmIChsaW5lID09IG9iai5lbmQpXG4gICAgICAgICAgICAgIGhlYWQgPSBQb3MoYWN0dWFsLCBjbS5nZXRMaW5lKGFjdHVhbCkubGVuZ3RoICsgMSk7XG4gICAgICAgICAgICBpZiAoYWN0dWFsIDwgY20ubGFzdExpbmUoKSkge1xuICAgICAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2UoXCIgXCIsIFBvcyhhY3R1YWwpLCBQb3MoYWN0dWFsICsgMSwgL15cXHMqLy5leGVjKGNtLmdldExpbmUoYWN0dWFsICsgMSkpWzBdLmxlbmd0aCkpO1xuICAgICAgICAgICAgICArK29mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmFuZ2VzMi5wdXNoKHsgYW5jaG9yOiBhbmNob3IgfHwgaGVhZCwgaGVhZCB9KTtcbiAgICAgICAgfVxuICAgICAgICBjbS5zZXRTZWxlY3Rpb25zKHJhbmdlczIsIDApO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjbWRzLmR1cGxpY2F0ZUxpbmUgPSBmdW5jdGlvbihjbSkge1xuICAgICAgY20ub3BlcmF0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmFuZ2VDb3VudCA9IGNtLmxpc3RTZWxlY3Rpb25zKCkubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlQ291bnQ7IGkrKykge1xuICAgICAgICAgIHZhciByYW5nZSA9IGNtLmxpc3RTZWxlY3Rpb25zKClbaV07XG4gICAgICAgICAgaWYgKHJhbmdlLmVtcHR5KCkpXG4gICAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2UoY20uZ2V0TGluZShyYW5nZS5oZWFkLmxpbmUpICsgXCJcXG5cIiwgUG9zKHJhbmdlLmhlYWQubGluZSwgMCkpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNtLnJlcGxhY2VSYW5nZShjbS5nZXRSYW5nZShyYW5nZS5mcm9tKCksIHJhbmdlLnRvKCkpLCByYW5nZS5mcm9tKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNtLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHNvcnRMaW5lcyhjbSwgY2FzZVNlbnNpdGl2ZSwgZGlyZWN0aW9uKSB7XG4gICAgICBpZiAoY20uaXNSZWFkT25seSgpKVxuICAgICAgICByZXR1cm4gQ29kZU1pcnJvci5QYXNzO1xuICAgICAgdmFyIHJhbmdlcyA9IGNtLmxpc3RTZWxlY3Rpb25zKCksIHRvU29ydCA9IFtdLCBzZWxlY3RlZDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgICAgaWYgKHJhbmdlLmVtcHR5KCkpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIHZhciBmcm9tID0gcmFuZ2UuZnJvbSgpLmxpbmUsIHRvID0gcmFuZ2UudG8oKS5saW5lO1xuICAgICAgICB3aGlsZSAoaSA8IHJhbmdlcy5sZW5ndGggLSAxICYmIHJhbmdlc1tpICsgMV0uZnJvbSgpLmxpbmUgPT0gdG8pXG4gICAgICAgICAgdG8gPSByYW5nZXNbKytpXS50bygpLmxpbmU7XG4gICAgICAgIGlmICghcmFuZ2VzW2ldLnRvKCkuY2gpXG4gICAgICAgICAgdG8tLTtcbiAgICAgICAgdG9Tb3J0LnB1c2goZnJvbSwgdG8pO1xuICAgICAgfVxuICAgICAgaWYgKHRvU29ydC5sZW5ndGgpXG4gICAgICAgIHNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIGVsc2VcbiAgICAgICAgdG9Tb3J0LnB1c2goY20uZmlyc3RMaW5lKCksIGNtLmxhc3RMaW5lKCkpO1xuICAgICAgY20ub3BlcmF0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmFuZ2VzMiA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgdG9Tb3J0Lmxlbmd0aDsgaTIgKz0gMikge1xuICAgICAgICAgIHZhciBmcm9tMiA9IHRvU29ydFtpMl0sIHRvMiA9IHRvU29ydFtpMiArIDFdO1xuICAgICAgICAgIHZhciBzdGFydCA9IFBvcyhmcm9tMiwgMCksIGVuZCA9IFBvcyh0bzIpO1xuICAgICAgICAgIHZhciBsaW5lcyA9IGNtLmdldFJhbmdlKHN0YXJ0LCBlbmQsIGZhbHNlKTtcbiAgICAgICAgICBpZiAoY2FzZVNlbnNpdGl2ZSlcbiAgICAgICAgICAgIGxpbmVzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgICByZXR1cm4gYSA8IGIgPyAtZGlyZWN0aW9uIDogYSA9PSBiID8gMCA6IGRpcmVjdGlvbjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxpbmVzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgICB2YXIgYXUgPSBhLnRvVXBwZXJDYXNlKCksIGJ1ID0gYi50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICBpZiAoYXUgIT0gYnUpIHtcbiAgICAgICAgICAgICAgICBhID0gYXU7XG4gICAgICAgICAgICAgICAgYiA9IGJ1O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBhIDwgYiA/IC1kaXJlY3Rpb24gOiBhID09IGIgPyAwIDogZGlyZWN0aW9uO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgY20ucmVwbGFjZVJhbmdlKGxpbmVzLCBzdGFydCwgZW5kKTtcbiAgICAgICAgICBpZiAoc2VsZWN0ZWQpXG4gICAgICAgICAgICByYW5nZXMyLnB1c2goeyBhbmNob3I6IHN0YXJ0LCBoZWFkOiBQb3ModG8yICsgMSwgMCkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGVjdGVkKVxuICAgICAgICAgIGNtLnNldFNlbGVjdGlvbnMocmFuZ2VzMiwgMCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgX19uYW1lKHNvcnRMaW5lcywgXCJzb3J0TGluZXNcIik7XG4gICAgY21kcy5zb3J0TGluZXMgPSBmdW5jdGlvbihjbSkge1xuICAgICAgc29ydExpbmVzKGNtLCB0cnVlLCAxKTtcbiAgICB9O1xuICAgIGNtZHMucmV2ZXJzZVNvcnRMaW5lcyA9IGZ1bmN0aW9uKGNtKSB7XG4gICAgICBzb3J0TGluZXMoY20sIHRydWUsIC0xKTtcbiAgICB9O1xuICAgIGNtZHMuc29ydExpbmVzSW5zZW5zaXRpdmUgPSBmdW5jdGlvbihjbSkge1xuICAgICAgc29ydExpbmVzKGNtLCBmYWxzZSwgMSk7XG4gICAgfTtcbiAgICBjbWRzLnJldmVyc2VTb3J0TGluZXNJbnNlbnNpdGl2ZSA9IGZ1bmN0aW9uKGNtKSB7XG4gICAgICBzb3J0TGluZXMoY20sIGZhbHNlLCAtMSk7XG4gICAgfTtcbiAgICBjbWRzLm5leHRCb29rbWFyayA9IGZ1bmN0aW9uKGNtKSB7XG4gICAgICB2YXIgbWFya3MgPSBjbS5zdGF0ZS5zdWJsaW1lQm9va21hcmtzO1xuICAgICAgaWYgKG1hcmtzKVxuICAgICAgICB3aGlsZSAobWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnQgPSBtYXJrcy5zaGlmdCgpO1xuICAgICAgICAgIHZhciBmb3VuZCA9IGN1cnJlbnQuZmluZCgpO1xuICAgICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgICAgbWFya3MucHVzaChjdXJyZW50KTtcbiAgICAgICAgICAgIHJldHVybiBjbS5zZXRTZWxlY3Rpb24oZm91bmQuZnJvbSwgZm91bmQudG8pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgY21kcy5wcmV2Qm9va21hcmsgPSBmdW5jdGlvbihjbSkge1xuICAgICAgdmFyIG1hcmtzID0gY20uc3RhdGUuc3VibGltZUJvb2ttYXJrcztcbiAgICAgIGlmIChtYXJrcylcbiAgICAgICAgd2hpbGUgKG1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgIG1hcmtzLnVuc2hpZnQobWFya3MucG9wKCkpO1xuICAgICAgICAgIHZhciBmb3VuZCA9IG1hcmtzW21hcmtzLmxlbmd0aCAtIDFdLmZpbmQoKTtcbiAgICAgICAgICBpZiAoIWZvdW5kKVxuICAgICAgICAgICAgbWFya3MucG9wKCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGNtLnNldFNlbGVjdGlvbihmb3VuZC5mcm9tLCBmb3VuZC50byk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNtZHMudG9nZ2xlQm9va21hcmsgPSBmdW5jdGlvbihjbSkge1xuICAgICAgdmFyIHJhbmdlcyA9IGNtLmxpc3RTZWxlY3Rpb25zKCk7XG4gICAgICB2YXIgbWFya3MgPSBjbS5zdGF0ZS5zdWJsaW1lQm9va21hcmtzIHx8IChjbS5zdGF0ZS5zdWJsaW1lQm9va21hcmtzID0gW10pO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGZyb20gPSByYW5nZXNbaV0uZnJvbSgpLCB0byA9IHJhbmdlc1tpXS50bygpO1xuICAgICAgICB2YXIgZm91bmQgPSByYW5nZXNbaV0uZW1wdHkoKSA/IGNtLmZpbmRNYXJrc0F0KGZyb20pIDogY20uZmluZE1hcmtzKGZyb20sIHRvKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBmb3VuZC5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGlmIChmb3VuZFtqXS5zdWJsaW1lQm9va21hcmspIHtcbiAgICAgICAgICAgIGZvdW5kW2pdLmNsZWFyKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IG1hcmtzLmxlbmd0aDsgaysrKVxuICAgICAgICAgICAgICBpZiAobWFya3Nba10gPT0gZm91bmRbal0pXG4gICAgICAgICAgICAgICAgbWFya3Muc3BsaWNlKGstLSwgMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGogPT0gZm91bmQubGVuZ3RoKVxuICAgICAgICAgIG1hcmtzLnB1c2goY20ubWFya1RleHQoZnJvbSwgdG8sIHsgc3VibGltZUJvb2ttYXJrOiB0cnVlLCBjbGVhcldoZW5FbXB0eTogZmFsc2UgfSkpO1xuICAgICAgfVxuICAgIH07XG4gICAgY21kcy5jbGVhckJvb2ttYXJrcyA9IGZ1bmN0aW9uKGNtKSB7XG4gICAgICB2YXIgbWFya3MgPSBjbS5zdGF0ZS5zdWJsaW1lQm9va21hcmtzO1xuICAgICAgaWYgKG1hcmtzKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgIG1hcmtzW2ldLmNsZWFyKCk7XG4gICAgICBtYXJrcy5sZW5ndGggPSAwO1xuICAgIH07XG4gICAgY21kcy5zZWxlY3RCb29rbWFya3MgPSBmdW5jdGlvbihjbSkge1xuICAgICAgdmFyIG1hcmtzID0gY20uc3RhdGUuc3VibGltZUJvb2ttYXJrcywgcmFuZ2VzID0gW107XG4gICAgICBpZiAobWFya3MpXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZm91bmQgPSBtYXJrc1tpXS5maW5kKCk7XG4gICAgICAgICAgaWYgKCFmb3VuZClcbiAgICAgICAgICAgIG1hcmtzLnNwbGljZShpLS0sIDApO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKHsgYW5jaG9yOiBmb3VuZC5mcm9tLCBoZWFkOiBmb3VuZC50byB9KTtcbiAgICAgICAgfVxuICAgICAgaWYgKHJhbmdlcy5sZW5ndGgpXG4gICAgICAgIGNtLnNldFNlbGVjdGlvbnMocmFuZ2VzLCAwKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIG1vZGlmeVdvcmRPclNlbGVjdGlvbihjbSwgbW9kKSB7XG4gICAgICBjbS5vcGVyYXRpb24oZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByYW5nZXMgPSBjbS5saXN0U2VsZWN0aW9ucygpLCBpbmRpY2VzID0gW10sIHJlcGxhY2VtZW50cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciByYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgICAgICBpZiAocmFuZ2UuZW1wdHkoKSkge1xuICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGkpO1xuICAgICAgICAgICAgcmVwbGFjZW1lbnRzLnB1c2goXCJcIik7XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICByZXBsYWNlbWVudHMucHVzaChtb2QoY20uZ2V0UmFuZ2UocmFuZ2UuZnJvbSgpLCByYW5nZS50bygpKSkpO1xuICAgICAgICB9XG4gICAgICAgIGNtLnJlcGxhY2VTZWxlY3Rpb25zKHJlcGxhY2VtZW50cywgXCJhcm91bmRcIiwgXCJjYXNlXCIpO1xuICAgICAgICBmb3IgKHZhciBpID0gaW5kaWNlcy5sZW5ndGggLSAxLCBhdDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB2YXIgcmFuZ2UgPSByYW5nZXNbaW5kaWNlc1tpXV07XG4gICAgICAgICAgaWYgKGF0ICYmIENvZGVNaXJyb3IuY21wUG9zKHJhbmdlLmhlYWQsIGF0KSA+IDApXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB2YXIgd29yZCA9IHdvcmRBdChjbSwgcmFuZ2UuaGVhZCk7XG4gICAgICAgICAgYXQgPSB3b3JkLmZyb207XG4gICAgICAgICAgY20ucmVwbGFjZVJhbmdlKG1vZCh3b3JkLndvcmQpLCB3b3JkLmZyb20sIHdvcmQudG8pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgX19uYW1lKG1vZGlmeVdvcmRPclNlbGVjdGlvbiwgXCJtb2RpZnlXb3JkT3JTZWxlY3Rpb25cIik7XG4gICAgY21kcy5zbWFydEJhY2tzcGFjZSA9IGZ1bmN0aW9uKGNtKSB7XG4gICAgICBpZiAoY20uc29tZXRoaW5nU2VsZWN0ZWQoKSlcbiAgICAgICAgcmV0dXJuIENvZGVNaXJyb3IuUGFzcztcbiAgICAgIGNtLm9wZXJhdGlvbihmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGN1cnNvcnMgPSBjbS5saXN0U2VsZWN0aW9ucygpO1xuICAgICAgICB2YXIgaW5kZW50VW5pdCA9IGNtLmdldE9wdGlvbihcImluZGVudFVuaXRcIik7XG4gICAgICAgIGZvciAodmFyIGkgPSBjdXJzb3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdmFyIGN1cnNvciA9IGN1cnNvcnNbaV0uaGVhZDtcbiAgICAgICAgICB2YXIgdG9TdGFydE9mTGluZSA9IGNtLmdldFJhbmdlKHsgbGluZTogY3Vyc29yLmxpbmUsIGNoOiAwIH0sIGN1cnNvcik7XG4gICAgICAgICAgdmFyIGNvbHVtbiA9IENvZGVNaXJyb3IuY291bnRDb2x1bW4odG9TdGFydE9mTGluZSwgbnVsbCwgY20uZ2V0T3B0aW9uKFwidGFiU2l6ZVwiKSk7XG4gICAgICAgICAgdmFyIGRlbGV0ZVBvcyA9IGNtLmZpbmRQb3NIKGN1cnNvciwgLTEsIFwiY2hhclwiLCBmYWxzZSk7XG4gICAgICAgICAgaWYgKHRvU3RhcnRPZkxpbmUgJiYgIS9cXFMvLnRlc3QodG9TdGFydE9mTGluZSkgJiYgY29sdW1uICUgaW5kZW50VW5pdCA9PSAwKSB7XG4gICAgICAgICAgICB2YXIgcHJldkluZGVudCA9IG5ldyBQb3MoY3Vyc29yLmxpbmUsIENvZGVNaXJyb3IuZmluZENvbHVtbih0b1N0YXJ0T2ZMaW5lLCBjb2x1bW4gLSBpbmRlbnRVbml0LCBpbmRlbnRVbml0KSk7XG4gICAgICAgICAgICBpZiAocHJldkluZGVudC5jaCAhPSBjdXJzb3IuY2gpXG4gICAgICAgICAgICAgIGRlbGV0ZVBvcyA9IHByZXZJbmRlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNtLnJlcGxhY2VSYW5nZShcIlwiLCBkZWxldGVQb3MsIGN1cnNvciwgXCIrZGVsZXRlXCIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNtZHMuZGVsTGluZVJpZ2h0ID0gZnVuY3Rpb24oY20pIHtcbiAgICAgIGNtLm9wZXJhdGlvbihmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJhbmdlcyA9IGNtLmxpc3RTZWxlY3Rpb25zKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSByYW5nZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgY20ucmVwbGFjZVJhbmdlKFwiXCIsIHJhbmdlc1tpXS5hbmNob3IsIFBvcyhyYW5nZXNbaV0udG8oKS5saW5lKSwgXCIrZGVsZXRlXCIpO1xuICAgICAgICBjbS5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjbWRzLnVwY2FzZUF0Q3Vyc29yID0gZnVuY3Rpb24oY20pIHtcbiAgICAgIG1vZGlmeVdvcmRPclNlbGVjdGlvbihjbSwgZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIudG9VcHBlckNhc2UoKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY21kcy5kb3duY2FzZUF0Q3Vyc29yID0gZnVuY3Rpb24oY20pIHtcbiAgICAgIG1vZGlmeVdvcmRPclNlbGVjdGlvbihjbSwgZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY21kcy5zZXRTdWJsaW1lTWFyayA9IGZ1bmN0aW9uKGNtKSB7XG4gICAgICBpZiAoY20uc3RhdGUuc3VibGltZU1hcmspXG4gICAgICAgIGNtLnN0YXRlLnN1YmxpbWVNYXJrLmNsZWFyKCk7XG4gICAgICBjbS5zdGF0ZS5zdWJsaW1lTWFyayA9IGNtLnNldEJvb2ttYXJrKGNtLmdldEN1cnNvcigpKTtcbiAgICB9O1xuICAgIGNtZHMuc2VsZWN0VG9TdWJsaW1lTWFyayA9IGZ1bmN0aW9uKGNtKSB7XG4gICAgICB2YXIgZm91bmQgPSBjbS5zdGF0ZS5zdWJsaW1lTWFyayAmJiBjbS5zdGF0ZS5zdWJsaW1lTWFyay5maW5kKCk7XG4gICAgICBpZiAoZm91bmQpXG4gICAgICAgIGNtLnNldFNlbGVjdGlvbihjbS5nZXRDdXJzb3IoKSwgZm91bmQpO1xuICAgIH07XG4gICAgY21kcy5kZWxldGVUb1N1YmxpbWVNYXJrID0gZnVuY3Rpb24oY20pIHtcbiAgICAgIHZhciBmb3VuZCA9IGNtLnN0YXRlLnN1YmxpbWVNYXJrICYmIGNtLnN0YXRlLnN1YmxpbWVNYXJrLmZpbmQoKTtcbiAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICB2YXIgZnJvbSA9IGNtLmdldEN1cnNvcigpLCB0byA9IGZvdW5kO1xuICAgICAgICBpZiAoQ29kZU1pcnJvci5jbXBQb3MoZnJvbSwgdG8pID4gMCkge1xuICAgICAgICAgIHZhciB0bXAgPSB0bztcbiAgICAgICAgICB0byA9IGZyb207XG4gICAgICAgICAgZnJvbSA9IHRtcDtcbiAgICAgICAgfVxuICAgICAgICBjbS5zdGF0ZS5zdWJsaW1lS2lsbGVkID0gY20uZ2V0UmFuZ2UoZnJvbSwgdG8pO1xuICAgICAgICBjbS5yZXBsYWNlUmFuZ2UoXCJcIiwgZnJvbSwgdG8pO1xuICAgICAgfVxuICAgIH07XG4gICAgY21kcy5zd2FwV2l0aFN1YmxpbWVNYXJrID0gZnVuY3Rpb24oY20pIHtcbiAgICAgIHZhciBmb3VuZCA9IGNtLnN0YXRlLnN1YmxpbWVNYXJrICYmIGNtLnN0YXRlLnN1YmxpbWVNYXJrLmZpbmQoKTtcbiAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICBjbS5zdGF0ZS5zdWJsaW1lTWFyay5jbGVhcigpO1xuICAgICAgICBjbS5zdGF0ZS5zdWJsaW1lTWFyayA9IGNtLnNldEJvb2ttYXJrKGNtLmdldEN1cnNvcigpKTtcbiAgICAgICAgY20uc2V0Q3Vyc29yKGZvdW5kKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNtZHMuc3VibGltZVlhbmsgPSBmdW5jdGlvbihjbSkge1xuICAgICAgaWYgKGNtLnN0YXRlLnN1YmxpbWVLaWxsZWQgIT0gbnVsbClcbiAgICAgICAgY20ucmVwbGFjZVNlbGVjdGlvbihjbS5zdGF0ZS5zdWJsaW1lS2lsbGVkLCBudWxsLCBcInBhc3RlXCIpO1xuICAgIH07XG4gICAgY21kcy5zaG93SW5DZW50ZXIgPSBmdW5jdGlvbihjbSkge1xuICAgICAgdmFyIHBvcyA9IGNtLmN1cnNvckNvb3JkcyhudWxsLCBcImxvY2FsXCIpO1xuICAgICAgY20uc2Nyb2xsVG8obnVsbCwgKHBvcy50b3AgKyBwb3MuYm90dG9tKSAvIDIgLSBjbS5nZXRTY3JvbGxJbmZvKCkuY2xpZW50SGVpZ2h0IC8gMik7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBnZXRUYXJnZXQoY20pIHtcbiAgICAgIHZhciBmcm9tID0gY20uZ2V0Q3Vyc29yKFwiZnJvbVwiKSwgdG8gPSBjbS5nZXRDdXJzb3IoXCJ0b1wiKTtcbiAgICAgIGlmIChDb2RlTWlycm9yLmNtcFBvcyhmcm9tLCB0bykgPT0gMCkge1xuICAgICAgICB2YXIgd29yZCA9IHdvcmRBdChjbSwgZnJvbSk7XG4gICAgICAgIGlmICghd29yZC53b3JkKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZnJvbSA9IHdvcmQuZnJvbTtcbiAgICAgICAgdG8gPSB3b3JkLnRvO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgZnJvbSwgdG8sIHF1ZXJ5OiBjbS5nZXRSYW5nZShmcm9tLCB0byksIHdvcmQgfTtcbiAgICB9XG4gICAgX19uYW1lKGdldFRhcmdldCwgXCJnZXRUYXJnZXRcIik7XG4gICAgZnVuY3Rpb24gZmluZEFuZEdvVG8oY20sIGZvcndhcmQpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBnZXRUYXJnZXQoY20pO1xuICAgICAgaWYgKCF0YXJnZXQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHZhciBxdWVyeSA9IHRhcmdldC5xdWVyeTtcbiAgICAgIHZhciBjdXIgPSBjbS5nZXRTZWFyY2hDdXJzb3IocXVlcnksIGZvcndhcmQgPyB0YXJnZXQudG8gOiB0YXJnZXQuZnJvbSk7XG4gICAgICBpZiAoZm9yd2FyZCA/IGN1ci5maW5kTmV4dCgpIDogY3VyLmZpbmRQcmV2aW91cygpKSB7XG4gICAgICAgIGNtLnNldFNlbGVjdGlvbihjdXIuZnJvbSgpLCBjdXIudG8oKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXIgPSBjbS5nZXRTZWFyY2hDdXJzb3IocXVlcnksIGZvcndhcmQgPyBQb3MoY20uZmlyc3RMaW5lKCksIDApIDogY20uY2xpcFBvcyhQb3MoY20ubGFzdExpbmUoKSkpKTtcbiAgICAgICAgaWYgKGZvcndhcmQgPyBjdXIuZmluZE5leHQoKSA6IGN1ci5maW5kUHJldmlvdXMoKSlcbiAgICAgICAgICBjbS5zZXRTZWxlY3Rpb24oY3VyLmZyb20oKSwgY3VyLnRvKCkpO1xuICAgICAgICBlbHNlIGlmICh0YXJnZXQud29yZClcbiAgICAgICAgICBjbS5zZXRTZWxlY3Rpb24odGFyZ2V0LmZyb20sIHRhcmdldC50byk7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShmaW5kQW5kR29UbywgXCJmaW5kQW5kR29Ub1wiKTtcbiAgICBjbWRzLmZpbmRVbmRlciA9IGZ1bmN0aW9uKGNtKSB7XG4gICAgICBmaW5kQW5kR29UbyhjbSwgdHJ1ZSk7XG4gICAgfTtcbiAgICBjbWRzLmZpbmRVbmRlclByZXZpb3VzID0gZnVuY3Rpb24oY20pIHtcbiAgICAgIGZpbmRBbmRHb1RvKGNtLCBmYWxzZSk7XG4gICAgfTtcbiAgICBjbWRzLmZpbmRBbGxVbmRlciA9IGZ1bmN0aW9uKGNtKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KGNtKTtcbiAgICAgIGlmICghdGFyZ2V0KVxuICAgICAgICByZXR1cm47XG4gICAgICB2YXIgY3VyID0gY20uZ2V0U2VhcmNoQ3Vyc29yKHRhcmdldC5xdWVyeSk7XG4gICAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuICAgICAgdmFyIHByaW1hcnlJbmRleCA9IC0xO1xuICAgICAgd2hpbGUgKGN1ci5maW5kTmV4dCgpKSB7XG4gICAgICAgIG1hdGNoZXMucHVzaCh7IGFuY2hvcjogY3VyLmZyb20oKSwgaGVhZDogY3VyLnRvKCkgfSk7XG4gICAgICAgIGlmIChjdXIuZnJvbSgpLmxpbmUgPD0gdGFyZ2V0LmZyb20ubGluZSAmJiBjdXIuZnJvbSgpLmNoIDw9IHRhcmdldC5mcm9tLmNoKVxuICAgICAgICAgIHByaW1hcnlJbmRleCsrO1xuICAgICAgfVxuICAgICAgY20uc2V0U2VsZWN0aW9ucyhtYXRjaGVzLCBwcmltYXJ5SW5kZXgpO1xuICAgIH07XG4gICAgdmFyIGtleU1hcCA9IENvZGVNaXJyb3Iua2V5TWFwO1xuICAgIGtleU1hcC5tYWNTdWJsaW1lID0ge1xuICAgICAgXCJDbWQtTGVmdFwiOiBcImdvTGluZVN0YXJ0U21hcnRcIixcbiAgICAgIFwiU2hpZnQtVGFiXCI6IFwiaW5kZW50TGVzc1wiLFxuICAgICAgXCJTaGlmdC1DdHJsLUtcIjogXCJkZWxldGVMaW5lXCIsXG4gICAgICBcIkFsdC1RXCI6IFwid3JhcExpbmVzXCIsXG4gICAgICBcIkN0cmwtTGVmdFwiOiBcImdvU3Vid29yZExlZnRcIixcbiAgICAgIFwiQ3RybC1SaWdodFwiOiBcImdvU3Vid29yZFJpZ2h0XCIsXG4gICAgICBcIkN0cmwtQWx0LVVwXCI6IFwic2Nyb2xsTGluZVVwXCIsXG4gICAgICBcIkN0cmwtQWx0LURvd25cIjogXCJzY3JvbGxMaW5lRG93blwiLFxuICAgICAgXCJDbWQtTFwiOiBcInNlbGVjdExpbmVcIixcbiAgICAgIFwiU2hpZnQtQ21kLUxcIjogXCJzcGxpdFNlbGVjdGlvbkJ5TGluZVwiLFxuICAgICAgXCJFc2NcIjogXCJzaW5nbGVTZWxlY3Rpb25Ub3BcIixcbiAgICAgIFwiQ21kLUVudGVyXCI6IFwiaW5zZXJ0TGluZUFmdGVyXCIsXG4gICAgICBcIlNoaWZ0LUNtZC1FbnRlclwiOiBcImluc2VydExpbmVCZWZvcmVcIixcbiAgICAgIFwiQ21kLURcIjogXCJzZWxlY3ROZXh0T2NjdXJyZW5jZVwiLFxuICAgICAgXCJTaGlmdC1DbWQtU3BhY2VcIjogXCJzZWxlY3RTY29wZVwiLFxuICAgICAgXCJTaGlmdC1DbWQtTVwiOiBcInNlbGVjdEJldHdlZW5CcmFja2V0c1wiLFxuICAgICAgXCJDbWQtTVwiOiBcImdvVG9CcmFja2V0XCIsXG4gICAgICBcIkNtZC1DdHJsLVVwXCI6IFwic3dhcExpbmVVcFwiLFxuICAgICAgXCJDbWQtQ3RybC1Eb3duXCI6IFwic3dhcExpbmVEb3duXCIsXG4gICAgICBcIkNtZC0vXCI6IFwidG9nZ2xlQ29tbWVudEluZGVudGVkXCIsXG4gICAgICBcIkNtZC1KXCI6IFwiam9pbkxpbmVzXCIsXG4gICAgICBcIlNoaWZ0LUNtZC1EXCI6IFwiZHVwbGljYXRlTGluZVwiLFxuICAgICAgXCJGNVwiOiBcInNvcnRMaW5lc1wiLFxuICAgICAgXCJTaGlmdC1GNVwiOiBcInJldmVyc2VTb3J0TGluZXNcIixcbiAgICAgIFwiQ21kLUY1XCI6IFwic29ydExpbmVzSW5zZW5zaXRpdmVcIixcbiAgICAgIFwiU2hpZnQtQ21kLUY1XCI6IFwicmV2ZXJzZVNvcnRMaW5lc0luc2Vuc2l0aXZlXCIsXG4gICAgICBcIkYyXCI6IFwibmV4dEJvb2ttYXJrXCIsXG4gICAgICBcIlNoaWZ0LUYyXCI6IFwicHJldkJvb2ttYXJrXCIsXG4gICAgICBcIkNtZC1GMlwiOiBcInRvZ2dsZUJvb2ttYXJrXCIsXG4gICAgICBcIlNoaWZ0LUNtZC1GMlwiOiBcImNsZWFyQm9va21hcmtzXCIsXG4gICAgICBcIkFsdC1GMlwiOiBcInNlbGVjdEJvb2ttYXJrc1wiLFxuICAgICAgXCJCYWNrc3BhY2VcIjogXCJzbWFydEJhY2tzcGFjZVwiLFxuICAgICAgXCJDbWQtSyBDbWQtRFwiOiBcInNraXBBbmRTZWxlY3ROZXh0T2NjdXJyZW5jZVwiLFxuICAgICAgXCJDbWQtSyBDbWQtS1wiOiBcImRlbExpbmVSaWdodFwiLFxuICAgICAgXCJDbWQtSyBDbWQtVVwiOiBcInVwY2FzZUF0Q3Vyc29yXCIsXG4gICAgICBcIkNtZC1LIENtZC1MXCI6IFwiZG93bmNhc2VBdEN1cnNvclwiLFxuICAgICAgXCJDbWQtSyBDbWQtU3BhY2VcIjogXCJzZXRTdWJsaW1lTWFya1wiLFxuICAgICAgXCJDbWQtSyBDbWQtQVwiOiBcInNlbGVjdFRvU3VibGltZU1hcmtcIixcbiAgICAgIFwiQ21kLUsgQ21kLVdcIjogXCJkZWxldGVUb1N1YmxpbWVNYXJrXCIsXG4gICAgICBcIkNtZC1LIENtZC1YXCI6IFwic3dhcFdpdGhTdWJsaW1lTWFya1wiLFxuICAgICAgXCJDbWQtSyBDbWQtWVwiOiBcInN1YmxpbWVZYW5rXCIsXG4gICAgICBcIkNtZC1LIENtZC1DXCI6IFwic2hvd0luQ2VudGVyXCIsXG4gICAgICBcIkNtZC1LIENtZC1HXCI6IFwiY2xlYXJCb29rbWFya3NcIixcbiAgICAgIFwiQ21kLUsgQ21kLUJhY2tzcGFjZVwiOiBcImRlbExpbmVMZWZ0XCIsXG4gICAgICBcIkNtZC1LIENtZC0xXCI6IFwiZm9sZEFsbFwiLFxuICAgICAgXCJDbWQtSyBDbWQtMFwiOiBcInVuZm9sZEFsbFwiLFxuICAgICAgXCJDbWQtSyBDbWQtSlwiOiBcInVuZm9sZEFsbFwiLFxuICAgICAgXCJDdHJsLVNoaWZ0LVVwXCI6IFwiYWRkQ3Vyc29yVG9QcmV2TGluZVwiLFxuICAgICAgXCJDdHJsLVNoaWZ0LURvd25cIjogXCJhZGRDdXJzb3JUb05leHRMaW5lXCIsXG4gICAgICBcIkNtZC1GM1wiOiBcImZpbmRVbmRlclwiLFxuICAgICAgXCJTaGlmdC1DbWQtRjNcIjogXCJmaW5kVW5kZXJQcmV2aW91c1wiLFxuICAgICAgXCJBbHQtRjNcIjogXCJmaW5kQWxsVW5kZXJcIixcbiAgICAgIFwiU2hpZnQtQ21kLVtcIjogXCJmb2xkXCIsXG4gICAgICBcIlNoaWZ0LUNtZC1dXCI6IFwidW5mb2xkXCIsXG4gICAgICBcIkNtZC1JXCI6IFwiZmluZEluY3JlbWVudGFsXCIsXG4gICAgICBcIlNoaWZ0LUNtZC1JXCI6IFwiZmluZEluY3JlbWVudGFsUmV2ZXJzZVwiLFxuICAgICAgXCJDbWQtSFwiOiBcInJlcGxhY2VcIixcbiAgICAgIFwiRjNcIjogXCJmaW5kTmV4dFwiLFxuICAgICAgXCJTaGlmdC1GM1wiOiBcImZpbmRQcmV2XCIsXG4gICAgICBcImZhbGx0aHJvdWdoXCI6IFwibWFjRGVmYXVsdFwiXG4gICAgfTtcbiAgICBDb2RlTWlycm9yLm5vcm1hbGl6ZUtleU1hcChrZXlNYXAubWFjU3VibGltZSk7XG4gICAga2V5TWFwLnBjU3VibGltZSA9IHtcbiAgICAgIFwiU2hpZnQtVGFiXCI6IFwiaW5kZW50TGVzc1wiLFxuICAgICAgXCJTaGlmdC1DdHJsLUtcIjogXCJkZWxldGVMaW5lXCIsXG4gICAgICBcIkFsdC1RXCI6IFwid3JhcExpbmVzXCIsXG4gICAgICBcIkN0cmwtVFwiOiBcInRyYW5zcG9zZUNoYXJzXCIsXG4gICAgICBcIkFsdC1MZWZ0XCI6IFwiZ29TdWJ3b3JkTGVmdFwiLFxuICAgICAgXCJBbHQtUmlnaHRcIjogXCJnb1N1YndvcmRSaWdodFwiLFxuICAgICAgXCJDdHJsLVVwXCI6IFwic2Nyb2xsTGluZVVwXCIsXG4gICAgICBcIkN0cmwtRG93blwiOiBcInNjcm9sbExpbmVEb3duXCIsXG4gICAgICBcIkN0cmwtTFwiOiBcInNlbGVjdExpbmVcIixcbiAgICAgIFwiU2hpZnQtQ3RybC1MXCI6IFwic3BsaXRTZWxlY3Rpb25CeUxpbmVcIixcbiAgICAgIFwiRXNjXCI6IFwic2luZ2xlU2VsZWN0aW9uVG9wXCIsXG4gICAgICBcIkN0cmwtRW50ZXJcIjogXCJpbnNlcnRMaW5lQWZ0ZXJcIixcbiAgICAgIFwiU2hpZnQtQ3RybC1FbnRlclwiOiBcImluc2VydExpbmVCZWZvcmVcIixcbiAgICAgIFwiQ3RybC1EXCI6IFwic2VsZWN0TmV4dE9jY3VycmVuY2VcIixcbiAgICAgIFwiU2hpZnQtQ3RybC1TcGFjZVwiOiBcInNlbGVjdFNjb3BlXCIsXG4gICAgICBcIlNoaWZ0LUN0cmwtTVwiOiBcInNlbGVjdEJldHdlZW5CcmFja2V0c1wiLFxuICAgICAgXCJDdHJsLU1cIjogXCJnb1RvQnJhY2tldFwiLFxuICAgICAgXCJTaGlmdC1DdHJsLVVwXCI6IFwic3dhcExpbmVVcFwiLFxuICAgICAgXCJTaGlmdC1DdHJsLURvd25cIjogXCJzd2FwTGluZURvd25cIixcbiAgICAgIFwiQ3RybC0vXCI6IFwidG9nZ2xlQ29tbWVudEluZGVudGVkXCIsXG4gICAgICBcIkN0cmwtSlwiOiBcImpvaW5MaW5lc1wiLFxuICAgICAgXCJTaGlmdC1DdHJsLURcIjogXCJkdXBsaWNhdGVMaW5lXCIsXG4gICAgICBcIkY5XCI6IFwic29ydExpbmVzXCIsXG4gICAgICBcIlNoaWZ0LUY5XCI6IFwicmV2ZXJzZVNvcnRMaW5lc1wiLFxuICAgICAgXCJDdHJsLUY5XCI6IFwic29ydExpbmVzSW5zZW5zaXRpdmVcIixcbiAgICAgIFwiU2hpZnQtQ3RybC1GOVwiOiBcInJldmVyc2VTb3J0TGluZXNJbnNlbnNpdGl2ZVwiLFxuICAgICAgXCJGMlwiOiBcIm5leHRCb29rbWFya1wiLFxuICAgICAgXCJTaGlmdC1GMlwiOiBcInByZXZCb29rbWFya1wiLFxuICAgICAgXCJDdHJsLUYyXCI6IFwidG9nZ2xlQm9va21hcmtcIixcbiAgICAgIFwiU2hpZnQtQ3RybC1GMlwiOiBcImNsZWFyQm9va21hcmtzXCIsXG4gICAgICBcIkFsdC1GMlwiOiBcInNlbGVjdEJvb2ttYXJrc1wiLFxuICAgICAgXCJCYWNrc3BhY2VcIjogXCJzbWFydEJhY2tzcGFjZVwiLFxuICAgICAgXCJDdHJsLUsgQ3RybC1EXCI6IFwic2tpcEFuZFNlbGVjdE5leHRPY2N1cnJlbmNlXCIsXG4gICAgICBcIkN0cmwtSyBDdHJsLUtcIjogXCJkZWxMaW5lUmlnaHRcIixcbiAgICAgIFwiQ3RybC1LIEN0cmwtVVwiOiBcInVwY2FzZUF0Q3Vyc29yXCIsXG4gICAgICBcIkN0cmwtSyBDdHJsLUxcIjogXCJkb3duY2FzZUF0Q3Vyc29yXCIsXG4gICAgICBcIkN0cmwtSyBDdHJsLVNwYWNlXCI6IFwic2V0U3VibGltZU1hcmtcIixcbiAgICAgIFwiQ3RybC1LIEN0cmwtQVwiOiBcInNlbGVjdFRvU3VibGltZU1hcmtcIixcbiAgICAgIFwiQ3RybC1LIEN0cmwtV1wiOiBcImRlbGV0ZVRvU3VibGltZU1hcmtcIixcbiAgICAgIFwiQ3RybC1LIEN0cmwtWFwiOiBcInN3YXBXaXRoU3VibGltZU1hcmtcIixcbiAgICAgIFwiQ3RybC1LIEN0cmwtWVwiOiBcInN1YmxpbWVZYW5rXCIsXG4gICAgICBcIkN0cmwtSyBDdHJsLUNcIjogXCJzaG93SW5DZW50ZXJcIixcbiAgICAgIFwiQ3RybC1LIEN0cmwtR1wiOiBcImNsZWFyQm9va21hcmtzXCIsXG4gICAgICBcIkN0cmwtSyBDdHJsLUJhY2tzcGFjZVwiOiBcImRlbExpbmVMZWZ0XCIsXG4gICAgICBcIkN0cmwtSyBDdHJsLTFcIjogXCJmb2xkQWxsXCIsXG4gICAgICBcIkN0cmwtSyBDdHJsLTBcIjogXCJ1bmZvbGRBbGxcIixcbiAgICAgIFwiQ3RybC1LIEN0cmwtSlwiOiBcInVuZm9sZEFsbFwiLFxuICAgICAgXCJDdHJsLUFsdC1VcFwiOiBcImFkZEN1cnNvclRvUHJldkxpbmVcIixcbiAgICAgIFwiQ3RybC1BbHQtRG93blwiOiBcImFkZEN1cnNvclRvTmV4dExpbmVcIixcbiAgICAgIFwiQ3RybC1GM1wiOiBcImZpbmRVbmRlclwiLFxuICAgICAgXCJTaGlmdC1DdHJsLUYzXCI6IFwiZmluZFVuZGVyUHJldmlvdXNcIixcbiAgICAgIFwiQWx0LUYzXCI6IFwiZmluZEFsbFVuZGVyXCIsXG4gICAgICBcIlNoaWZ0LUN0cmwtW1wiOiBcImZvbGRcIixcbiAgICAgIFwiU2hpZnQtQ3RybC1dXCI6IFwidW5mb2xkXCIsXG4gICAgICBcIkN0cmwtSVwiOiBcImZpbmRJbmNyZW1lbnRhbFwiLFxuICAgICAgXCJTaGlmdC1DdHJsLUlcIjogXCJmaW5kSW5jcmVtZW50YWxSZXZlcnNlXCIsXG4gICAgICBcIkN0cmwtSFwiOiBcInJlcGxhY2VcIixcbiAgICAgIFwiRjNcIjogXCJmaW5kTmV4dFwiLFxuICAgICAgXCJTaGlmdC1GM1wiOiBcImZpbmRQcmV2XCIsXG4gICAgICBcImZhbGx0aHJvdWdoXCI6IFwicGNEZWZhdWx0XCJcbiAgICB9O1xuICAgIENvZGVNaXJyb3Iubm9ybWFsaXplS2V5TWFwKGtleU1hcC5wY1N1YmxpbWUpO1xuICAgIHZhciBtYWMgPSBrZXlNYXAuZGVmYXVsdCA9PSBrZXlNYXAubWFjRGVmYXVsdDtcbiAgICBrZXlNYXAuc3VibGltZSA9IG1hYyA/IGtleU1hcC5tYWNTdWJsaW1lIDoga2V5TWFwLnBjU3VibGltZTtcbiAgfSk7XG59KSgpO1xudmFyIHN1YmxpbWUgPSBzdWJsaW1lJDIuZXhwb3J0cztcbnZhciBzdWJsaW1lJDEgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gX21lcmdlTmFtZXNwYWNlcyh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106IFwiTW9kdWxlXCIsXG4gIFwiZGVmYXVsdFwiOiBzdWJsaW1lXG59LCBbc3VibGltZSQyLmV4cG9ydHNdKSk7XG5leHBvcnQgeyBzdWJsaW1lJDEgYXMgcyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///13571\n')}}]);