"use strict";(self.webpackChunkcachiql_demo=self.webpackChunkcachiql_demo||[]).push([[584],{92584:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "S": () => (/* binding */ SchemaMetaFieldDef),\n/* harmony export */   "T": () => (/* binding */ TypeMetaFieldDef),\n/* harmony export */   "a": () => (/* binding */ TypeNameMetaFieldDef)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, "name", { value, configurable: true });\nconst MAX_ARRAY_LENGTH = 10;\nconst MAX_RECURSIVE_DEPTH = 2;\nfunction inspect(value) {\n  return formatValue(value, []);\n}\n__name(inspect, "inspect");\nfunction formatValue(value, seenValues) {\n  switch (typeof value) {\n    case "string":\n      return JSON.stringify(value);\n    case "function":\n      return value.name ? `[function ${value.name}]` : "[function]";\n    case "object":\n      return formatObjectValue(value, seenValues);\n    default:\n      return String(value);\n  }\n}\n__name(formatValue, "formatValue");\nfunction formatObjectValue(value, previouslySeenValues) {\n  if (value === null) {\n    return "null";\n  }\n  if (previouslySeenValues.includes(value)) {\n    return "[Circular]";\n  }\n  const seenValues = [...previouslySeenValues, value];\n  if (isJSONable(value)) {\n    const jsonValue = value.toJSON();\n    if (jsonValue !== value) {\n      return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);\n    }\n  } else if (Array.isArray(value)) {\n    return formatArray(value, seenValues);\n  }\n  return formatObject(value, seenValues);\n}\n__name(formatObjectValue, "formatObjectValue");\nfunction isJSONable(value) {\n  return typeof value.toJSON === "function";\n}\n__name(isJSONable, "isJSONable");\nfunction formatObject(object, seenValues) {\n  const entries = Object.entries(object);\n  if (entries.length === 0) {\n    return "{}";\n  }\n  if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n    return "[" + getObjectTag(object) + "]";\n  }\n  const properties = entries.map(([key, value]) => key + ": " + formatValue(value, seenValues));\n  return "{ " + properties.join(", ") + " }";\n}\n__name(formatObject, "formatObject");\nfunction formatArray(array, seenValues) {\n  if (array.length === 0) {\n    return "[]";\n  }\n  if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n    return "[Array]";\n  }\n  const len = Math.min(MAX_ARRAY_LENGTH, array.length);\n  const remaining = array.length - len;\n  const items = [];\n  for (let i = 0; i < len; ++i) {\n    items.push(formatValue(array[i], seenValues));\n  }\n  if (remaining === 1) {\n    items.push("... 1 more item");\n  } else if (remaining > 1) {\n    items.push(`... ${remaining} more items`);\n  }\n  return "[" + items.join(", ") + "]";\n}\n__name(formatArray, "formatArray");\nfunction getObjectTag(object) {\n  const tag = Object.prototype.toString.call(object).replace(/^\\[object /, "").replace(/]$/, "");\n  if (tag === "Object" && typeof object.constructor === "function") {\n    const name = object.constructor.name;\n    if (typeof name === "string" && name !== "") {\n      return name;\n    }\n  }\n  return tag;\n}\n__name(getObjectTag, "getObjectTag");\nfunction invariant(condition, message) {\n  const booleanCondition = Boolean(condition);\n  if (!booleanCondition) {\n    throw new Error(message != null ? message : "Unexpected invariant triggered.");\n  }\n}\n__name(invariant, "invariant");\nlet DirectiveLocation;\n(function(DirectiveLocation2) {\n  DirectiveLocation2["QUERY"] = "QUERY";\n  DirectiveLocation2["MUTATION"] = "MUTATION";\n  DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";\n  DirectiveLocation2["FIELD"] = "FIELD";\n  DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";\n  DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";\n  DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";\n  DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";\n  DirectiveLocation2["SCHEMA"] = "SCHEMA";\n  DirectiveLocation2["SCALAR"] = "SCALAR";\n  DirectiveLocation2["OBJECT"] = "OBJECT";\n  DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";\n  DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";\n  DirectiveLocation2["INTERFACE"] = "INTERFACE";\n  DirectiveLocation2["UNION"] = "UNION";\n  DirectiveLocation2["ENUM"] = "ENUM";\n  DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";\n  DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";\n  DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";\n})(DirectiveLocation || (DirectiveLocation = {}));\nfunction isWhiteSpace(code) {\n  return code === 9 || code === 32;\n}\n__name(isWhiteSpace, "isWhiteSpace");\nfunction isDigit$1(code) {\n  return code >= 48 && code <= 57;\n}\n__name(isDigit$1, "isDigit$1");\nfunction isLetter(code) {\n  return code >= 97 && code <= 122 || code >= 65 && code <= 90;\n}\n__name(isLetter, "isLetter");\nfunction isNameStart(code) {\n  return isLetter(code) || code === 95;\n}\n__name(isNameStart, "isNameStart");\nfunction isNameContinue(code) {\n  return isLetter(code) || isDigit$1(code) || code === 95;\n}\n__name(isNameContinue, "isNameContinue");\nfunction printBlockString(value, options) {\n  const escapedValue = value.replace(/"""/g, \'\\\\"""\');\n  const lines = escapedValue.split(/\\r\\n|[\\n\\r]/g);\n  const isSingleLine = lines.length === 1;\n  const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line) => line.length === 0 || isWhiteSpace(line.charCodeAt(0)));\n  const hasTrailingTripleQuotes = escapedValue.endsWith(\'\\\\"""\');\n  const hasTrailingQuote = value.endsWith(\'"\') && !hasTrailingTripleQuotes;\n  const hasTrailingSlash = value.endsWith("\\\\");\n  const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;\n  const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);\n  let result = "";\n  const skipLeadingNewLine = isSingleLine && isWhiteSpace(value.charCodeAt(0));\n  if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {\n    result += "\\n";\n  }\n  result += escapedValue;\n  if (printAsMultipleLines || forceTrailingNewline) {\n    result += "\\n";\n  }\n  return \'"""\' + result + \'"""\';\n}\n__name(printBlockString, "printBlockString");\nfunction printString(str) {\n  return `"${str.replace(escapedRegExp, escapedReplacer)}"`;\n}\n__name(printString, "printString");\nconst escapedRegExp = /[\\x00-\\x1f\\x22\\x5c\\x7f-\\x9f]/g;\nfunction escapedReplacer(str) {\n  return escapeSequences[str.charCodeAt(0)];\n}\n__name(escapedReplacer, "escapedReplacer");\nconst escapeSequences = [\n  "\\\\u0000",\n  "\\\\u0001",\n  "\\\\u0002",\n  "\\\\u0003",\n  "\\\\u0004",\n  "\\\\u0005",\n  "\\\\u0006",\n  "\\\\u0007",\n  "\\\\b",\n  "\\\\t",\n  "\\\\n",\n  "\\\\u000B",\n  "\\\\f",\n  "\\\\r",\n  "\\\\u000E",\n  "\\\\u000F",\n  "\\\\u0010",\n  "\\\\u0011",\n  "\\\\u0012",\n  "\\\\u0013",\n  "\\\\u0014",\n  "\\\\u0015",\n  "\\\\u0016",\n  "\\\\u0017",\n  "\\\\u0018",\n  "\\\\u0019",\n  "\\\\u001A",\n  "\\\\u001B",\n  "\\\\u001C",\n  "\\\\u001D",\n  "\\\\u001E",\n  "\\\\u001F",\n  "",\n  "",\n  \'\\\\"\',\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "\\\\\\\\",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "",\n  "\\\\u007F",\n  "\\\\u0080",\n  "\\\\u0081",\n  "\\\\u0082",\n  "\\\\u0083",\n  "\\\\u0084",\n  "\\\\u0085",\n  "\\\\u0086",\n  "\\\\u0087",\n  "\\\\u0088",\n  "\\\\u0089",\n  "\\\\u008A",\n  "\\\\u008B",\n  "\\\\u008C",\n  "\\\\u008D",\n  "\\\\u008E",\n  "\\\\u008F",\n  "\\\\u0090",\n  "\\\\u0091",\n  "\\\\u0092",\n  "\\\\u0093",\n  "\\\\u0094",\n  "\\\\u0095",\n  "\\\\u0096",\n  "\\\\u0097",\n  "\\\\u0098",\n  "\\\\u0099",\n  "\\\\u009A",\n  "\\\\u009B",\n  "\\\\u009C",\n  "\\\\u009D",\n  "\\\\u009E",\n  "\\\\u009F"\n];\nfunction devAssert(condition, message) {\n  const booleanCondition = Boolean(condition);\n  if (!booleanCondition) {\n    throw new Error(message);\n  }\n}\n__name(devAssert, "devAssert");\nconst QueryDocumentKeys = {\n  Name: [],\n  Document: ["definitions"],\n  OperationDefinition: [\n    "name",\n    "variableDefinitions",\n    "directives",\n    "selectionSet"\n  ],\n  VariableDefinition: ["variable", "type", "defaultValue", "directives"],\n  Variable: ["name"],\n  SelectionSet: ["selections"],\n  Field: ["alias", "name", "arguments", "directives", "selectionSet"],\n  Argument: ["name", "value"],\n  FragmentSpread: ["name", "directives"],\n  InlineFragment: ["typeCondition", "directives", "selectionSet"],\n  FragmentDefinition: [\n    "name",\n    "variableDefinitions",\n    "typeCondition",\n    "directives",\n    "selectionSet"\n  ],\n  IntValue: [],\n  FloatValue: [],\n  StringValue: [],\n  BooleanValue: [],\n  NullValue: [],\n  EnumValue: [],\n  ListValue: ["values"],\n  ObjectValue: ["fields"],\n  ObjectField: ["name", "value"],\n  Directive: ["name", "arguments"],\n  NamedType: ["name"],\n  ListType: ["type"],\n  NonNullType: ["type"],\n  SchemaDefinition: ["description", "directives", "operationTypes"],\n  OperationTypeDefinition: ["type"],\n  ScalarTypeDefinition: ["description", "name", "directives"],\n  ObjectTypeDefinition: [\n    "description",\n    "name",\n    "interfaces",\n    "directives",\n    "fields"\n  ],\n  FieldDefinition: ["description", "name", "arguments", "type", "directives"],\n  InputValueDefinition: [\n    "description",\n    "name",\n    "type",\n    "defaultValue",\n    "directives"\n  ],\n  InterfaceTypeDefinition: [\n    "description",\n    "name",\n    "interfaces",\n    "directives",\n    "fields"\n  ],\n  UnionTypeDefinition: ["description", "name", "directives", "types"],\n  EnumTypeDefinition: ["description", "name", "directives", "values"],\n  EnumValueDefinition: ["description", "name", "directives"],\n  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],\n  DirectiveDefinition: ["description", "name", "arguments", "locations"],\n  SchemaExtension: ["directives", "operationTypes"],\n  ScalarTypeExtension: ["name", "directives"],\n  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],\n  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],\n  UnionTypeExtension: ["name", "directives", "types"],\n  EnumTypeExtension: ["name", "directives", "values"],\n  InputObjectTypeExtension: ["name", "directives", "fields"]\n};\nconst kindValues = new Set(Object.keys(QueryDocumentKeys));\nfunction isNode(maybeNode) {\n  const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;\n  return typeof maybeKind === "string" && kindValues.has(maybeKind);\n}\n__name(isNode, "isNode");\nlet OperationTypeNode;\n(function(OperationTypeNode2) {\n  OperationTypeNode2["QUERY"] = "query";\n  OperationTypeNode2["MUTATION"] = "mutation";\n  OperationTypeNode2["SUBSCRIPTION"] = "subscription";\n})(OperationTypeNode || (OperationTypeNode = {}));\nlet Kind;\n(function(Kind2) {\n  Kind2["NAME"] = "Name";\n  Kind2["DOCUMENT"] = "Document";\n  Kind2["OPERATION_DEFINITION"] = "OperationDefinition";\n  Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";\n  Kind2["SELECTION_SET"] = "SelectionSet";\n  Kind2["FIELD"] = "Field";\n  Kind2["ARGUMENT"] = "Argument";\n  Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";\n  Kind2["INLINE_FRAGMENT"] = "InlineFragment";\n  Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";\n  Kind2["VARIABLE"] = "Variable";\n  Kind2["INT"] = "IntValue";\n  Kind2["FLOAT"] = "FloatValue";\n  Kind2["STRING"] = "StringValue";\n  Kind2["BOOLEAN"] = "BooleanValue";\n  Kind2["NULL"] = "NullValue";\n  Kind2["ENUM"] = "EnumValue";\n  Kind2["LIST"] = "ListValue";\n  Kind2["OBJECT"] = "ObjectValue";\n  Kind2["OBJECT_FIELD"] = "ObjectField";\n  Kind2["DIRECTIVE"] = "Directive";\n  Kind2["NAMED_TYPE"] = "NamedType";\n  Kind2["LIST_TYPE"] = "ListType";\n  Kind2["NON_NULL_TYPE"] = "NonNullType";\n  Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";\n  Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";\n  Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";\n  Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";\n  Kind2["FIELD_DEFINITION"] = "FieldDefinition";\n  Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";\n  Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";\n  Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";\n  Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";\n  Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";\n  Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";\n  Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";\n  Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";\n  Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";\n  Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";\n  Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";\n  Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";\n  Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";\n  Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";\n})(Kind || (Kind = {}));\nconst BREAK = Object.freeze({});\nfunction visit(root, visitor, visitorKeys = QueryDocumentKeys) {\n  const enterLeaveMap = /* @__PURE__ */ new Map();\n  for (const kind of Object.values(Kind)) {\n    enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));\n  }\n  let stack = void 0;\n  let inArray = Array.isArray(root);\n  let keys = [root];\n  let index = -1;\n  let edits = [];\n  let node = root;\n  let key = void 0;\n  let parent = void 0;\n  const path = [];\n  const ancestors = [];\n  do {\n    index++;\n    const isLeaving = index === keys.length;\n    const isEdited = isLeaving && edits.length !== 0;\n    if (isLeaving) {\n      key = ancestors.length === 0 ? void 0 : path[path.length - 1];\n      node = parent;\n      parent = ancestors.pop();\n      if (isEdited) {\n        if (inArray) {\n          node = node.slice();\n          let editOffset = 0;\n          for (const [editKey, editValue] of edits) {\n            const arrayKey = editKey - editOffset;\n            if (editValue === null) {\n              node.splice(arrayKey, 1);\n              editOffset++;\n            } else {\n              node[arrayKey] = editValue;\n            }\n          }\n        } else {\n          node = Object.defineProperties({}, Object.getOwnPropertyDescriptors(node));\n          for (const [editKey, editValue] of edits) {\n            node[editKey] = editValue;\n          }\n        }\n      }\n      index = stack.index;\n      keys = stack.keys;\n      edits = stack.edits;\n      inArray = stack.inArray;\n      stack = stack.prev;\n    } else if (parent) {\n      key = inArray ? index : keys[index];\n      node = parent[key];\n      if (node === null || node === void 0) {\n        continue;\n      }\n      path.push(key);\n    }\n    let result;\n    if (!Array.isArray(node)) {\n      var _enterLeaveMap$get, _enterLeaveMap$get2;\n      isNode(node) || devAssert(false, `Invalid AST Node: ${inspect(node)}.`);\n      const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;\n      result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key, parent, path, ancestors);\n      if (result === BREAK) {\n        break;\n      }\n      if (result === false) {\n        if (!isLeaving) {\n          path.pop();\n          continue;\n        }\n      } else if (result !== void 0) {\n        edits.push([key, result]);\n        if (!isLeaving) {\n          if (isNode(result)) {\n            node = result;\n          } else {\n            path.pop();\n            continue;\n          }\n        }\n      }\n    }\n    if (result === void 0 && isEdited) {\n      edits.push([key, node]);\n    }\n    if (isLeaving) {\n      path.pop();\n    } else {\n      var _node$kind;\n      stack = {\n        inArray,\n        index,\n        keys,\n        edits,\n        prev: stack\n      };\n      inArray = Array.isArray(node);\n      keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];\n      index = -1;\n      edits = [];\n      if (parent) {\n        ancestors.push(parent);\n      }\n      parent = node;\n    }\n  } while (stack !== void 0);\n  if (edits.length !== 0) {\n    return edits[edits.length - 1][1];\n  }\n  return root;\n}\n__name(visit, "visit");\nfunction getEnterLeaveForKind(visitor, kind) {\n  const kindVisitor = visitor[kind];\n  if (typeof kindVisitor === "object") {\n    return kindVisitor;\n  } else if (typeof kindVisitor === "function") {\n    return {\n      enter: kindVisitor,\n      leave: void 0\n    };\n  }\n  return {\n    enter: visitor.enter,\n    leave: visitor.leave\n  };\n}\n__name(getEnterLeaveForKind, "getEnterLeaveForKind");\nfunction print(ast) {\n  return visit(ast, printDocASTReducer);\n}\n__name(print, "print");\nconst MAX_LINE_LENGTH = 80;\nconst printDocASTReducer = {\n  Name: {\n    leave: (node) => node.value\n  },\n  Variable: {\n    leave: (node) => "$" + node.name\n  },\n  Document: {\n    leave: (node) => join(node.definitions, "\\n\\n")\n  },\n  OperationDefinition: {\n    leave(node) {\n      const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");\n      const prefix = join([\n        node.operation,\n        join([node.name, varDefs]),\n        join(node.directives, " ")\n      ], " ");\n      return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;\n    }\n  },\n  VariableDefinition: {\n    leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap(" = ", defaultValue) + wrap(" ", join(directives, " "))\n  },\n  SelectionSet: {\n    leave: ({ selections }) => block(selections)\n  },\n  Field: {\n    leave({ alias, name, arguments: args, directives, selectionSet }) {\n      const prefix = wrap("", alias, ": ") + name;\n      let argsLine = prefix + wrap("(", join(args, ", "), ")");\n      if (argsLine.length > MAX_LINE_LENGTH) {\n        argsLine = prefix + wrap("(\\n", indent(join(args, "\\n")), "\\n)");\n      }\n      return join([argsLine, join(directives, " "), selectionSet], " ");\n    }\n  },\n  Argument: {\n    leave: ({ name, value }) => name + ": " + value\n  },\n  FragmentSpread: {\n    leave: ({ name, directives }) => "..." + name + wrap(" ", join(directives, " "))\n  },\n  InlineFragment: {\n    leave: ({ typeCondition, directives, selectionSet }) => join([\n      "...",\n      wrap("on ", typeCondition),\n      join(directives, " "),\n      selectionSet\n    ], " ")\n  },\n  FragmentDefinition: {\n    leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => `fragment ${name}${wrap("(", join(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap("", join(directives, " "), " ")}` + selectionSet\n  },\n  IntValue: {\n    leave: ({ value }) => value\n  },\n  FloatValue: {\n    leave: ({ value }) => value\n  },\n  StringValue: {\n    leave: ({ value, block: isBlockString }) => isBlockString ? printBlockString(value) : printString(value)\n  },\n  BooleanValue: {\n    leave: ({ value }) => value ? "true" : "false"\n  },\n  NullValue: {\n    leave: () => "null"\n  },\n  EnumValue: {\n    leave: ({ value }) => value\n  },\n  ListValue: {\n    leave: ({ values }) => "[" + join(values, ", ") + "]"\n  },\n  ObjectValue: {\n    leave: ({ fields }) => "{" + join(fields, ", ") + "}"\n  },\n  ObjectField: {\n    leave: ({ name, value }) => name + ": " + value\n  },\n  Directive: {\n    leave: ({ name, arguments: args }) => "@" + name + wrap("(", join(args, ", "), ")")\n  },\n  NamedType: {\n    leave: ({ name }) => name\n  },\n  ListType: {\n    leave: ({ type }) => "[" + type + "]"\n  },\n  NonNullType: {\n    leave: ({ type }) => type + "!"\n  },\n  SchemaDefinition: {\n    leave: ({ description, directives, operationTypes }) => wrap("", description, "\\n") + join(["schema", join(directives, " "), block(operationTypes)], " ")\n  },\n  OperationTypeDefinition: {\n    leave: ({ operation, type }) => operation + ": " + type\n  },\n  ScalarTypeDefinition: {\n    leave: ({ description, name, directives }) => wrap("", description, "\\n") + join(["scalar", name, join(directives, " ")], " ")\n  },\n  ObjectTypeDefinition: {\n    leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\\n") + join([\n      "type",\n      name,\n      wrap("implements ", join(interfaces, " & ")),\n      join(directives, " "),\n      block(fields)\n    ], " ")\n  },\n  FieldDefinition: {\n    leave: ({ description, name, arguments: args, type, directives }) => wrap("", description, "\\n") + name + (hasMultilineItems(args) ? wrap("(\\n", indent(join(args, "\\n")), "\\n)") : wrap("(", join(args, ", "), ")")) + ": " + type + wrap(" ", join(directives, " "))\n  },\n  InputValueDefinition: {\n    leave: ({ description, name, type, defaultValue, directives }) => wrap("", description, "\\n") + join([name + ": " + type, wrap("= ", defaultValue), join(directives, " ")], " ")\n  },\n  InterfaceTypeDefinition: {\n    leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\\n") + join([\n      "interface",\n      name,\n      wrap("implements ", join(interfaces, " & ")),\n      join(directives, " "),\n      block(fields)\n    ], " ")\n  },\n  UnionTypeDefinition: {\n    leave: ({ description, name, directives, types }) => wrap("", description, "\\n") + join(["union", name, join(directives, " "), wrap("= ", join(types, " | "))], " ")\n  },\n  EnumTypeDefinition: {\n    leave: ({ description, name, directives, values }) => wrap("", description, "\\n") + join(["enum", name, join(directives, " "), block(values)], " ")\n  },\n  EnumValueDefinition: {\n    leave: ({ description, name, directives }) => wrap("", description, "\\n") + join([name, join(directives, " ")], " ")\n  },\n  InputObjectTypeDefinition: {\n    leave: ({ description, name, directives, fields }) => wrap("", description, "\\n") + join(["input", name, join(directives, " "), block(fields)], " ")\n  },\n  DirectiveDefinition: {\n    leave: ({ description, name, arguments: args, repeatable, locations }) => wrap("", description, "\\n") + "directive @" + name + (hasMultilineItems(args) ? wrap("(\\n", indent(join(args, "\\n")), "\\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")\n  },\n  SchemaExtension: {\n    leave: ({ directives, operationTypes }) => join(["extend schema", join(directives, " "), block(operationTypes)], " ")\n  },\n  ScalarTypeExtension: {\n    leave: ({ name, directives }) => join(["extend scalar", name, join(directives, " ")], " ")\n  },\n  ObjectTypeExtension: {\n    leave: ({ name, interfaces, directives, fields }) => join([\n      "extend type",\n      name,\n      wrap("implements ", join(interfaces, " & ")),\n      join(directives, " "),\n      block(fields)\n    ], " ")\n  },\n  InterfaceTypeExtension: {\n    leave: ({ name, interfaces, directives, fields }) => join([\n      "extend interface",\n      name,\n      wrap("implements ", join(interfaces, " & ")),\n      join(directives, " "),\n      block(fields)\n    ], " ")\n  },\n  UnionTypeExtension: {\n    leave: ({ name, directives, types }) => join([\n      "extend union",\n      name,\n      join(directives, " "),\n      wrap("= ", join(types, " | "))\n    ], " ")\n  },\n  EnumTypeExtension: {\n    leave: ({ name, directives, values }) => join(["extend enum", name, join(directives, " "), block(values)], " ")\n  },\n  InputObjectTypeExtension: {\n    leave: ({ name, directives, fields }) => join(["extend input", name, join(directives, " "), block(fields)], " ")\n  }\n};\nfunction join(maybeArray, separator = "") {\n  var _maybeArray$filter$jo;\n  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x) => x).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";\n}\n__name(join, "join");\nfunction block(array) {\n  return wrap("{\\n", indent(join(array, "\\n")), "\\n}");\n}\n__name(block, "block");\nfunction wrap(start, maybeString, end = "") {\n  return maybeString != null && maybeString !== "" ? start + maybeString + end : "";\n}\n__name(wrap, "wrap");\nfunction indent(str) {\n  return wrap("  ", str.replace(/\\n/g, "\\n  "));\n}\n__name(indent, "indent");\nfunction hasMultilineItems(maybeArray) {\n  var _maybeArray$some;\n  return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;\n}\n__name(hasMultilineItems, "hasMultilineItems");\nfunction isIterableObject(maybeIterable) {\n  return typeof maybeIterable === "object" && typeof (maybeIterable === null || maybeIterable === void 0 ? void 0 : maybeIterable[Symbol.iterator]) === "function";\n}\n__name(isIterableObject, "isIterableObject");\nfunction isObjectLike(value) {\n  return typeof value == "object" && value !== null;\n}\n__name(isObjectLike, "isObjectLike");\nconst MAX_SUGGESTIONS = 5;\nfunction didYouMean(firstArg, secondArg) {\n  const [subMessage, suggestionsArg] = secondArg ? [firstArg, secondArg] : [void 0, firstArg];\n  let message = " Did you mean ";\n  if (subMessage) {\n    message += subMessage + " ";\n  }\n  const suggestions = suggestionsArg.map((x) => `"${x}"`);\n  switch (suggestions.length) {\n    case 0:\n      return "";\n    case 1:\n      return message + suggestions[0] + "?";\n    case 2:\n      return message + suggestions[0] + " or " + suggestions[1] + "?";\n  }\n  const selected = suggestions.slice(0, MAX_SUGGESTIONS);\n  const lastItem = selected.pop();\n  return message + selected.join(", ") + ", or " + lastItem + "?";\n}\n__name(didYouMean, "didYouMean");\nfunction identityFunc(x) {\n  return x;\n}\n__name(identityFunc, "identityFunc");\nconst instanceOf = /* @__PURE__ */ __name(function instanceOf2(value, constructor) {\n  return value instanceof constructor;\n}, "instanceOf");\nfunction keyMap(list, keyFn) {\n  const result = /* @__PURE__ */ Object.create(null);\n  for (const item of list) {\n    result[keyFn(item)] = item;\n  }\n  return result;\n}\n__name(keyMap, "keyMap");\nfunction keyValMap(list, keyFn, valFn) {\n  const result = /* @__PURE__ */ Object.create(null);\n  for (const item of list) {\n    result[keyFn(item)] = valFn(item);\n  }\n  return result;\n}\n__name(keyValMap, "keyValMap");\nfunction mapValue(map, fn) {\n  const result = /* @__PURE__ */ Object.create(null);\n  for (const key of Object.keys(map)) {\n    result[key] = fn(map[key], key);\n  }\n  return result;\n}\n__name(mapValue, "mapValue");\nfunction naturalCompare(aStr, bStr) {\n  let aIndex = 0;\n  let bIndex = 0;\n  while (aIndex < aStr.length && bIndex < bStr.length) {\n    let aChar = aStr.charCodeAt(aIndex);\n    let bChar = bStr.charCodeAt(bIndex);\n    if (isDigit(aChar) && isDigit(bChar)) {\n      let aNum = 0;\n      do {\n        ++aIndex;\n        aNum = aNum * 10 + aChar - DIGIT_0;\n        aChar = aStr.charCodeAt(aIndex);\n      } while (isDigit(aChar) && aNum > 0);\n      let bNum = 0;\n      do {\n        ++bIndex;\n        bNum = bNum * 10 + bChar - DIGIT_0;\n        bChar = bStr.charCodeAt(bIndex);\n      } while (isDigit(bChar) && bNum > 0);\n      if (aNum < bNum) {\n        return -1;\n      }\n      if (aNum > bNum) {\n        return 1;\n      }\n    } else {\n      if (aChar < bChar) {\n        return -1;\n      }\n      if (aChar > bChar) {\n        return 1;\n      }\n      ++aIndex;\n      ++bIndex;\n    }\n  }\n  return aStr.length - bStr.length;\n}\n__name(naturalCompare, "naturalCompare");\nconst DIGIT_0 = 48;\nconst DIGIT_9 = 57;\nfunction isDigit(code) {\n  return !isNaN(code) && DIGIT_0 <= code && code <= DIGIT_9;\n}\n__name(isDigit, "isDigit");\nfunction suggestionList(input, options) {\n  const optionsByDistance = /* @__PURE__ */ Object.create(null);\n  const lexicalDistance = new LexicalDistance(input);\n  const threshold = Math.floor(input.length * 0.4) + 1;\n  for (const option of options) {\n    const distance = lexicalDistance.measure(option, threshold);\n    if (distance !== void 0) {\n      optionsByDistance[option] = distance;\n    }\n  }\n  return Object.keys(optionsByDistance).sort((a, b) => {\n    const distanceDiff = optionsByDistance[a] - optionsByDistance[b];\n    return distanceDiff !== 0 ? distanceDiff : naturalCompare(a, b);\n  });\n}\n__name(suggestionList, "suggestionList");\nclass LexicalDistance {\n  constructor(input) {\n    this._input = input;\n    this._inputLowerCase = input.toLowerCase();\n    this._inputArray = stringToArray(this._inputLowerCase);\n    this._rows = [\n      new Array(input.length + 1).fill(0),\n      new Array(input.length + 1).fill(0),\n      new Array(input.length + 1).fill(0)\n    ];\n  }\n  measure(option, threshold) {\n    if (this._input === option) {\n      return 0;\n    }\n    const optionLowerCase = option.toLowerCase();\n    if (this._inputLowerCase === optionLowerCase) {\n      return 1;\n    }\n    let a = stringToArray(optionLowerCase);\n    let b = this._inputArray;\n    if (a.length < b.length) {\n      const tmp = a;\n      a = b;\n      b = tmp;\n    }\n    const aLength = a.length;\n    const bLength = b.length;\n    if (aLength - bLength > threshold) {\n      return void 0;\n    }\n    const rows = this._rows;\n    for (let j = 0; j <= bLength; j++) {\n      rows[0][j] = j;\n    }\n    for (let i = 1; i <= aLength; i++) {\n      const upRow = rows[(i - 1) % 3];\n      const currentRow = rows[i % 3];\n      let smallestCell = currentRow[0] = i;\n      for (let j = 1; j <= bLength; j++) {\n        const cost = a[i - 1] === b[j - 1] ? 0 : 1;\n        let currentCell = Math.min(upRow[j] + 1, currentRow[j - 1] + 1, upRow[j - 1] + cost);\n        if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {\n          const doubleDiagonalCell = rows[(i - 2) % 3][j - 2];\n          currentCell = Math.min(currentCell, doubleDiagonalCell + 1);\n        }\n        if (currentCell < smallestCell) {\n          smallestCell = currentCell;\n        }\n        currentRow[j] = currentCell;\n      }\n      if (smallestCell > threshold) {\n        return void 0;\n      }\n    }\n    const distance = rows[aLength % 3][bLength];\n    return distance <= threshold ? distance : void 0;\n  }\n}\n__name(LexicalDistance, "LexicalDistance");\nfunction stringToArray(str) {\n  const strLength = str.length;\n  const array = new Array(strLength);\n  for (let i = 0; i < strLength; ++i) {\n    array[i] = str.charCodeAt(i);\n  }\n  return array;\n}\n__name(stringToArray, "stringToArray");\nfunction toObjMap(obj) {\n  if (obj == null) {\n    return /* @__PURE__ */ Object.create(null);\n  }\n  if (Object.getPrototypeOf(obj) === null) {\n    return obj;\n  }\n  const map = /* @__PURE__ */ Object.create(null);\n  for (const [key, value] of Object.entries(obj)) {\n    map[key] = value;\n  }\n  return map;\n}\n__name(toObjMap, "toObjMap");\nconst LineRegExp = /\\r\\n|[\\n\\r]/g;\nfunction getLocation(source, position) {\n  let lastLineStart = 0;\n  let line = 1;\n  for (const match of source.body.matchAll(LineRegExp)) {\n    typeof match.index === "number" || invariant(false);\n    if (match.index >= position) {\n      break;\n    }\n    lastLineStart = match.index + match[0].length;\n    line += 1;\n  }\n  return {\n    line,\n    column: position + 1 - lastLineStart\n  };\n}\n__name(getLocation, "getLocation");\nfunction printLocation(location) {\n  return printSourceLocation(location.source, getLocation(location.source, location.start));\n}\n__name(printLocation, "printLocation");\nfunction printSourceLocation(source, sourceLocation) {\n  const firstLineColumnOffset = source.locationOffset.column - 1;\n  const body = "".padStart(firstLineColumnOffset) + source.body;\n  const lineIndex = sourceLocation.line - 1;\n  const lineOffset = source.locationOffset.line - 1;\n  const lineNum = sourceLocation.line + lineOffset;\n  const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;\n  const columnNum = sourceLocation.column + columnOffset;\n  const locationStr = `${source.name}:${lineNum}:${columnNum}\n`;\n  const lines = body.split(/\\r\\n|[\\n\\r]/g);\n  const locationLine = lines[lineIndex];\n  if (locationLine.length > 120) {\n    const subLineIndex = Math.floor(columnNum / 80);\n    const subLineColumnNum = columnNum % 80;\n    const subLines = [];\n    for (let i = 0; i < locationLine.length; i += 80) {\n      subLines.push(locationLine.slice(i, i + 80));\n    }\n    return locationStr + printPrefixedLines([\n      [`${lineNum} |`, subLines[0]],\n      ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),\n      ["|", "^".padStart(subLineColumnNum)],\n      ["|", subLines[subLineIndex + 1]]\n    ]);\n  }\n  return locationStr + printPrefixedLines([\n    [`${lineNum - 1} |`, lines[lineIndex - 1]],\n    [`${lineNum} |`, locationLine],\n    ["|", "^".padStart(columnNum)],\n    [`${lineNum + 1} |`, lines[lineIndex + 1]]\n  ]);\n}\n__name(printSourceLocation, "printSourceLocation");\nfunction printPrefixedLines(lines) {\n  const existingLines = lines.filter(([_, line]) => line !== void 0);\n  const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));\n  return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join("\\n");\n}\n__name(printPrefixedLines, "printPrefixedLines");\nfunction toNormalizedOptions(args) {\n  const firstArg = args[0];\n  if (firstArg == null || "kind" in firstArg || "length" in firstArg) {\n    return {\n      nodes: firstArg,\n      source: args[1],\n      positions: args[2],\n      path: args[3],\n      originalError: args[4],\n      extensions: args[5]\n    };\n  }\n  return firstArg;\n}\n__name(toNormalizedOptions, "toNormalizedOptions");\nclass GraphQLError extends Error {\n  constructor(message, ...rawArgs) {\n    var _this$nodes, _nodeLocations$, _ref;\n    const { nodes, source, positions, path, originalError, extensions } = toNormalizedOptions(rawArgs);\n    super(message);\n    this.name = "GraphQLError";\n    this.path = path !== null && path !== void 0 ? path : void 0;\n    this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;\n    this.nodes = undefinedIfEmpty(Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0);\n    const nodeLocations = undefinedIfEmpty((_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node) => node.loc).filter((loc) => loc != null));\n    this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;\n    this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);\n    this.locations = positions && source ? positions.map((pos) => getLocation(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => getLocation(loc.source, loc.start));\n    const originalExtensions = isObjectLike(originalError === null || originalError === void 0 ? void 0 : originalError.extensions) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;\n    this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ Object.create(null);\n    Object.defineProperties(this, {\n      message: {\n        writable: true,\n        enumerable: true\n      },\n      name: {\n        enumerable: false\n      },\n      nodes: {\n        enumerable: false\n      },\n      source: {\n        enumerable: false\n      },\n      positions: {\n        enumerable: false\n      },\n      originalError: {\n        enumerable: false\n      }\n    });\n    if (originalError !== null && originalError !== void 0 && originalError.stack) {\n      Object.defineProperty(this, "stack", {\n        value: originalError.stack,\n        writable: true,\n        configurable: true\n      });\n    } else if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, GraphQLError);\n    } else {\n      Object.defineProperty(this, "stack", {\n        value: Error().stack,\n        writable: true,\n        configurable: true\n      });\n    }\n  }\n  get [Symbol.toStringTag]() {\n    return "GraphQLError";\n  }\n  toString() {\n    let output = this.message;\n    if (this.nodes) {\n      for (const node of this.nodes) {\n        if (node.loc) {\n          output += "\\n\\n" + printLocation(node.loc);\n        }\n      }\n    } else if (this.source && this.locations) {\n      for (const location of this.locations) {\n        output += "\\n\\n" + printSourceLocation(this.source, location);\n      }\n    }\n    return output;\n  }\n  toJSON() {\n    const formattedError = {\n      message: this.message\n    };\n    if (this.locations != null) {\n      formattedError.locations = this.locations;\n    }\n    if (this.path != null) {\n      formattedError.path = this.path;\n    }\n    if (this.extensions != null && Object.keys(this.extensions).length > 0) {\n      formattedError.extensions = this.extensions;\n    }\n    return formattedError;\n  }\n}\n__name(GraphQLError, "GraphQLError");\nfunction undefinedIfEmpty(array) {\n  return array === void 0 || array.length === 0 ? void 0 : array;\n}\n__name(undefinedIfEmpty, "undefinedIfEmpty");\nfunction valueFromASTUntyped(valueNode, variables) {\n  switch (valueNode.kind) {\n    case Kind.NULL:\n      return null;\n    case Kind.INT:\n      return parseInt(valueNode.value, 10);\n    case Kind.FLOAT:\n      return parseFloat(valueNode.value);\n    case Kind.STRING:\n    case Kind.ENUM:\n    case Kind.BOOLEAN:\n      return valueNode.value;\n    case Kind.LIST:\n      return valueNode.values.map((node) => valueFromASTUntyped(node, variables));\n    case Kind.OBJECT:\n      return keyValMap(valueNode.fields, (field) => field.name.value, (field) => valueFromASTUntyped(field.value, variables));\n    case Kind.VARIABLE:\n      return variables === null || variables === void 0 ? void 0 : variables[valueNode.name.value];\n  }\n}\n__name(valueFromASTUntyped, "valueFromASTUntyped");\nfunction assertName(name) {\n  name != null || devAssert(false, "Must provide name.");\n  typeof name === "string" || devAssert(false, "Expected name to be a string.");\n  if (name.length === 0) {\n    throw new GraphQLError("Expected name to be a non-empty string.");\n  }\n  for (let i = 1; i < name.length; ++i) {\n    if (!isNameContinue(name.charCodeAt(i))) {\n      throw new GraphQLError(`Names must only contain [_a-zA-Z0-9] but "${name}" does not.`);\n    }\n  }\n  if (!isNameStart(name.charCodeAt(0))) {\n    throw new GraphQLError(`Names must start with [_a-zA-Z] but "${name}" does not.`);\n  }\n  return name;\n}\n__name(assertName, "assertName");\nfunction assertEnumValueName(name) {\n  if (name === "true" || name === "false" || name === "null") {\n    throw new GraphQLError(`Enum values cannot be named: ${name}`);\n  }\n  return assertName(name);\n}\n__name(assertEnumValueName, "assertEnumValueName");\nfunction isType(type) {\n  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type) || isListType(type) || isNonNullType(type);\n}\n__name(isType, "isType");\nfunction isScalarType(type) {\n  return instanceOf(type, GraphQLScalarType);\n}\n__name(isScalarType, "isScalarType");\nfunction isObjectType(type) {\n  return instanceOf(type, GraphQLObjectType);\n}\n__name(isObjectType, "isObjectType");\nfunction isInterfaceType(type) {\n  return instanceOf(type, GraphQLInterfaceType);\n}\n__name(isInterfaceType, "isInterfaceType");\nfunction isUnionType(type) {\n  return instanceOf(type, GraphQLUnionType);\n}\n__name(isUnionType, "isUnionType");\nfunction isEnumType(type) {\n  return instanceOf(type, GraphQLEnumType);\n}\n__name(isEnumType, "isEnumType");\nfunction isInputObjectType(type) {\n  return instanceOf(type, GraphQLInputObjectType);\n}\n__name(isInputObjectType, "isInputObjectType");\nfunction isListType(type) {\n  return instanceOf(type, GraphQLList);\n}\n__name(isListType, "isListType");\nfunction isNonNullType(type) {\n  return instanceOf(type, GraphQLNonNull);\n}\n__name(isNonNullType, "isNonNullType");\nfunction isLeafType(type) {\n  return isScalarType(type) || isEnumType(type);\n}\n__name(isLeafType, "isLeafType");\nfunction isAbstractType(type) {\n  return isInterfaceType(type) || isUnionType(type);\n}\n__name(isAbstractType, "isAbstractType");\nclass GraphQLList {\n  constructor(ofType) {\n    isType(ofType) || devAssert(false, `Expected ${inspect(ofType)} to be a GraphQL type.`);\n    this.ofType = ofType;\n  }\n  get [Symbol.toStringTag]() {\n    return "GraphQLList";\n  }\n  toString() {\n    return "[" + String(this.ofType) + "]";\n  }\n  toJSON() {\n    return this.toString();\n  }\n}\n__name(GraphQLList, "GraphQLList");\nclass GraphQLNonNull {\n  constructor(ofType) {\n    isNullableType(ofType) || devAssert(false, `Expected ${inspect(ofType)} to be a GraphQL nullable type.`);\n    this.ofType = ofType;\n  }\n  get [Symbol.toStringTag]() {\n    return "GraphQLNonNull";\n  }\n  toString() {\n    return String(this.ofType) + "!";\n  }\n  toJSON() {\n    return this.toString();\n  }\n}\n__name(GraphQLNonNull, "GraphQLNonNull");\nfunction isNullableType(type) {\n  return isType(type) && !isNonNullType(type);\n}\n__name(isNullableType, "isNullableType");\nfunction resolveReadonlyArrayThunk(thunk) {\n  return typeof thunk === "function" ? thunk() : thunk;\n}\n__name(resolveReadonlyArrayThunk, "resolveReadonlyArrayThunk");\nfunction resolveObjMapThunk(thunk) {\n  return typeof thunk === "function" ? thunk() : thunk;\n}\n__name(resolveObjMapThunk, "resolveObjMapThunk");\nclass GraphQLScalarType {\n  constructor(config) {\n    var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;\n    const parseValue = (_config$parseValue = config.parseValue) !== null && _config$parseValue !== void 0 ? _config$parseValue : identityFunc;\n    this.name = assertName(config.name);\n    this.description = config.description;\n    this.specifiedByURL = config.specifiedByURL;\n    this.serialize = (_config$serialize = config.serialize) !== null && _config$serialize !== void 0 ? _config$serialize : identityFunc;\n    this.parseValue = parseValue;\n    this.parseLiteral = (_config$parseLiteral = config.parseLiteral) !== null && _config$parseLiteral !== void 0 ? _config$parseLiteral : (node, variables) => parseValue(valueFromASTUntyped(node, variables));\n    this.extensions = toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];\n    config.specifiedByURL == null || typeof config.specifiedByURL === "string" || devAssert(false, `${this.name} must provide "specifiedByURL" as a string, but got: ${inspect(config.specifiedByURL)}.`);\n    config.serialize == null || typeof config.serialize === "function" || devAssert(false, `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`);\n    if (config.parseLiteral) {\n      typeof config.parseValue === "function" && typeof config.parseLiteral === "function" || devAssert(false, `${this.name} must provide both "parseValue" and "parseLiteral" functions.`);\n    }\n  }\n  get [Symbol.toStringTag]() {\n    return "GraphQLScalarType";\n  }\n  toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      specifiedByURL: this.specifiedByURL,\n      serialize: this.serialize,\n      parseValue: this.parseValue,\n      parseLiteral: this.parseLiteral,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes\n    };\n  }\n  toString() {\n    return this.name;\n  }\n  toJSON() {\n    return this.toString();\n  }\n}\n__name(GraphQLScalarType, "GraphQLScalarType");\nclass GraphQLObjectType {\n  constructor(config) {\n    var _config$extensionASTN2;\n    this.name = assertName(config.name);\n    this.description = config.description;\n    this.isTypeOf = config.isTypeOf;\n    this.extensions = toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = (_config$extensionASTN2 = config.extensionASTNodes) !== null && _config$extensionASTN2 !== void 0 ? _config$extensionASTN2 : [];\n    this._fields = () => defineFieldMap(config);\n    this._interfaces = () => defineInterfaces(config);\n    config.isTypeOf == null || typeof config.isTypeOf === "function" || devAssert(false, `${this.name} must provide "isTypeOf" as a function, but got: ${inspect(config.isTypeOf)}.`);\n  }\n  get [Symbol.toStringTag]() {\n    return "GraphQLObjectType";\n  }\n  getFields() {\n    if (typeof this._fields === "function") {\n      this._fields = this._fields();\n    }\n    return this._fields;\n  }\n  getInterfaces() {\n    if (typeof this._interfaces === "function") {\n      this._interfaces = this._interfaces();\n    }\n    return this._interfaces;\n  }\n  toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      interfaces: this.getInterfaces(),\n      fields: fieldsToFieldsConfig(this.getFields()),\n      isTypeOf: this.isTypeOf,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes\n    };\n  }\n  toString() {\n    return this.name;\n  }\n  toJSON() {\n    return this.toString();\n  }\n}\n__name(GraphQLObjectType, "GraphQLObjectType");\nfunction defineInterfaces(config) {\n  var _config$interfaces;\n  const interfaces = resolveReadonlyArrayThunk((_config$interfaces = config.interfaces) !== null && _config$interfaces !== void 0 ? _config$interfaces : []);\n  Array.isArray(interfaces) || devAssert(false, `${config.name} interfaces must be an Array or a function which returns an Array.`);\n  return interfaces;\n}\n__name(defineInterfaces, "defineInterfaces");\nfunction defineFieldMap(config) {\n  const fieldMap = resolveObjMapThunk(config.fields);\n  isPlainObj(fieldMap) || devAssert(false, `${config.name} fields must be an object with field names as keys or a function which returns such an object.`);\n  return mapValue(fieldMap, (fieldConfig, fieldName) => {\n    var _fieldConfig$args;\n    isPlainObj(fieldConfig) || devAssert(false, `${config.name}.${fieldName} field config must be an object.`);\n    fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || devAssert(false, `${config.name}.${fieldName} field resolver must be a function if provided, but got: ${inspect(fieldConfig.resolve)}.`);\n    const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== void 0 ? _fieldConfig$args : {};\n    isPlainObj(argsConfig) || devAssert(false, `${config.name}.${fieldName} args must be an object with argument names as keys.`);\n    return {\n      name: assertName(fieldName),\n      description: fieldConfig.description,\n      type: fieldConfig.type,\n      args: defineArguments(argsConfig),\n      resolve: fieldConfig.resolve,\n      subscribe: fieldConfig.subscribe,\n      deprecationReason: fieldConfig.deprecationReason,\n      extensions: toObjMap(fieldConfig.extensions),\n      astNode: fieldConfig.astNode\n    };\n  });\n}\n__name(defineFieldMap, "defineFieldMap");\nfunction defineArguments(config) {\n  return Object.entries(config).map(([argName, argConfig]) => ({\n    name: assertName(argName),\n    description: argConfig.description,\n    type: argConfig.type,\n    defaultValue: argConfig.defaultValue,\n    deprecationReason: argConfig.deprecationReason,\n    extensions: toObjMap(argConfig.extensions),\n    astNode: argConfig.astNode\n  }));\n}\n__name(defineArguments, "defineArguments");\nfunction isPlainObj(obj) {\n  return isObjectLike(obj) && !Array.isArray(obj);\n}\n__name(isPlainObj, "isPlainObj");\nfunction fieldsToFieldsConfig(fields) {\n  return mapValue(fields, (field) => ({\n    description: field.description,\n    type: field.type,\n    args: argsToArgsConfig(field.args),\n    resolve: field.resolve,\n    subscribe: field.subscribe,\n    deprecationReason: field.deprecationReason,\n    extensions: field.extensions,\n    astNode: field.astNode\n  }));\n}\n__name(fieldsToFieldsConfig, "fieldsToFieldsConfig");\nfunction argsToArgsConfig(args) {\n  return keyValMap(args, (arg) => arg.name, (arg) => ({\n    description: arg.description,\n    type: arg.type,\n    defaultValue: arg.defaultValue,\n    deprecationReason: arg.deprecationReason,\n    extensions: arg.extensions,\n    astNode: arg.astNode\n  }));\n}\n__name(argsToArgsConfig, "argsToArgsConfig");\nclass GraphQLInterfaceType {\n  constructor(config) {\n    var _config$extensionASTN3;\n    this.name = assertName(config.name);\n    this.description = config.description;\n    this.resolveType = config.resolveType;\n    this.extensions = toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = (_config$extensionASTN3 = config.extensionASTNodes) !== null && _config$extensionASTN3 !== void 0 ? _config$extensionASTN3 : [];\n    this._fields = defineFieldMap.bind(void 0, config);\n    this._interfaces = defineInterfaces.bind(void 0, config);\n    config.resolveType == null || typeof config.resolveType === "function" || devAssert(false, `${this.name} must provide "resolveType" as a function, but got: ${inspect(config.resolveType)}.`);\n  }\n  get [Symbol.toStringTag]() {\n    return "GraphQLInterfaceType";\n  }\n  getFields() {\n    if (typeof this._fields === "function") {\n      this._fields = this._fields();\n    }\n    return this._fields;\n  }\n  getInterfaces() {\n    if (typeof this._interfaces === "function") {\n      this._interfaces = this._interfaces();\n    }\n    return this._interfaces;\n  }\n  toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      interfaces: this.getInterfaces(),\n      fields: fieldsToFieldsConfig(this.getFields()),\n      resolveType: this.resolveType,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes\n    };\n  }\n  toString() {\n    return this.name;\n  }\n  toJSON() {\n    return this.toString();\n  }\n}\n__name(GraphQLInterfaceType, "GraphQLInterfaceType");\nclass GraphQLUnionType {\n  constructor(config) {\n    var _config$extensionASTN4;\n    this.name = assertName(config.name);\n    this.description = config.description;\n    this.resolveType = config.resolveType;\n    this.extensions = toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = (_config$extensionASTN4 = config.extensionASTNodes) !== null && _config$extensionASTN4 !== void 0 ? _config$extensionASTN4 : [];\n    this._types = defineTypes.bind(void 0, config);\n    config.resolveType == null || typeof config.resolveType === "function" || devAssert(false, `${this.name} must provide "resolveType" as a function, but got: ${inspect(config.resolveType)}.`);\n  }\n  get [Symbol.toStringTag]() {\n    return "GraphQLUnionType";\n  }\n  getTypes() {\n    if (typeof this._types === "function") {\n      this._types = this._types();\n    }\n    return this._types;\n  }\n  toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      types: this.getTypes(),\n      resolveType: this.resolveType,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes\n    };\n  }\n  toString() {\n    return this.name;\n  }\n  toJSON() {\n    return this.toString();\n  }\n}\n__name(GraphQLUnionType, "GraphQLUnionType");\nfunction defineTypes(config) {\n  const types = resolveReadonlyArrayThunk(config.types);\n  Array.isArray(types) || devAssert(false, `Must provide Array of types or a function which returns such an array for Union ${config.name}.`);\n  return types;\n}\n__name(defineTypes, "defineTypes");\nclass GraphQLEnumType {\n  constructor(config) {\n    var _config$extensionASTN5;\n    this.name = assertName(config.name);\n    this.description = config.description;\n    this.extensions = toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = (_config$extensionASTN5 = config.extensionASTNodes) !== null && _config$extensionASTN5 !== void 0 ? _config$extensionASTN5 : [];\n    this._values = defineEnumValues(this.name, config.values);\n    this._valueLookup = new Map(this._values.map((enumValue) => [enumValue.value, enumValue]));\n    this._nameLookup = keyMap(this._values, (value) => value.name);\n  }\n  get [Symbol.toStringTag]() {\n    return "GraphQLEnumType";\n  }\n  getValues() {\n    return this._values;\n  }\n  getValue(name) {\n    return this._nameLookup[name];\n  }\n  serialize(outputValue) {\n    const enumValue = this._valueLookup.get(outputValue);\n    if (enumValue === void 0) {\n      throw new GraphQLError(`Enum "${this.name}" cannot represent value: ${inspect(outputValue)}`);\n    }\n    return enumValue.name;\n  }\n  parseValue(inputValue) {\n    if (typeof inputValue !== "string") {\n      const valueStr = inspect(inputValue);\n      throw new GraphQLError(`Enum "${this.name}" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr));\n    }\n    const enumValue = this.getValue(inputValue);\n    if (enumValue == null) {\n      throw new GraphQLError(`Value "${inputValue}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, inputValue));\n    }\n    return enumValue.value;\n  }\n  parseLiteral(valueNode, _variables) {\n    if (valueNode.kind !== Kind.ENUM) {\n      const valueStr = print(valueNode);\n      throw new GraphQLError(`Enum "${this.name}" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr), {\n        nodes: valueNode\n      });\n    }\n    const enumValue = this.getValue(valueNode.value);\n    if (enumValue == null) {\n      const valueStr = print(valueNode);\n      throw new GraphQLError(`Value "${valueStr}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, valueStr), {\n        nodes: valueNode\n      });\n    }\n    return enumValue.value;\n  }\n  toConfig() {\n    const values = keyValMap(this.getValues(), (value) => value.name, (value) => ({\n      description: value.description,\n      value: value.value,\n      deprecationReason: value.deprecationReason,\n      extensions: value.extensions,\n      astNode: value.astNode\n    }));\n    return {\n      name: this.name,\n      description: this.description,\n      values,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes\n    };\n  }\n  toString() {\n    return this.name;\n  }\n  toJSON() {\n    return this.toString();\n  }\n}\n__name(GraphQLEnumType, "GraphQLEnumType");\nfunction didYouMeanEnumValue(enumType, unknownValueStr) {\n  const allNames = enumType.getValues().map((value) => value.name);\n  const suggestedValues = suggestionList(unknownValueStr, allNames);\n  return didYouMean("the enum value", suggestedValues);\n}\n__name(didYouMeanEnumValue, "didYouMeanEnumValue");\nfunction defineEnumValues(typeName, valueMap) {\n  isPlainObj(valueMap) || devAssert(false, `${typeName} values must be an object with value names as keys.`);\n  return Object.entries(valueMap).map(([valueName, valueConfig]) => {\n    isPlainObj(valueConfig) || devAssert(false, `${typeName}.${valueName} must refer to an object with a "value" key representing an internal value but got: ${inspect(valueConfig)}.`);\n    return {\n      name: assertEnumValueName(valueName),\n      description: valueConfig.description,\n      value: valueConfig.value !== void 0 ? valueConfig.value : valueName,\n      deprecationReason: valueConfig.deprecationReason,\n      extensions: toObjMap(valueConfig.extensions),\n      astNode: valueConfig.astNode\n    };\n  });\n}\n__name(defineEnumValues, "defineEnumValues");\nclass GraphQLInputObjectType {\n  constructor(config) {\n    var _config$extensionASTN6;\n    this.name = assertName(config.name);\n    this.description = config.description;\n    this.extensions = toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = (_config$extensionASTN6 = config.extensionASTNodes) !== null && _config$extensionASTN6 !== void 0 ? _config$extensionASTN6 : [];\n    this._fields = defineInputFieldMap.bind(void 0, config);\n  }\n  get [Symbol.toStringTag]() {\n    return "GraphQLInputObjectType";\n  }\n  getFields() {\n    if (typeof this._fields === "function") {\n      this._fields = this._fields();\n    }\n    return this._fields;\n  }\n  toConfig() {\n    const fields = mapValue(this.getFields(), (field) => ({\n      description: field.description,\n      type: field.type,\n      defaultValue: field.defaultValue,\n      deprecationReason: field.deprecationReason,\n      extensions: field.extensions,\n      astNode: field.astNode\n    }));\n    return {\n      name: this.name,\n      description: this.description,\n      fields,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes\n    };\n  }\n  toString() {\n    return this.name;\n  }\n  toJSON() {\n    return this.toString();\n  }\n}\n__name(GraphQLInputObjectType, "GraphQLInputObjectType");\nfunction defineInputFieldMap(config) {\n  const fieldMap = resolveObjMapThunk(config.fields);\n  isPlainObj(fieldMap) || devAssert(false, `${config.name} fields must be an object with field names as keys or a function which returns such an object.`);\n  return mapValue(fieldMap, (fieldConfig, fieldName) => {\n    !("resolve" in fieldConfig) || devAssert(false, `${config.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`);\n    return {\n      name: assertName(fieldName),\n      description: fieldConfig.description,\n      type: fieldConfig.type,\n      defaultValue: fieldConfig.defaultValue,\n      deprecationReason: fieldConfig.deprecationReason,\n      extensions: toObjMap(fieldConfig.extensions),\n      astNode: fieldConfig.astNode\n    };\n  });\n}\n__name(defineInputFieldMap, "defineInputFieldMap");\nconst GRAPHQL_MAX_INT = 2147483647;\nconst GRAPHQL_MIN_INT = -2147483648;\nconst GraphQLInt = new GraphQLScalarType({\n  name: "Int",\n  description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",\n  serialize(outputValue) {\n    const coercedValue = serializeObject(outputValue);\n    if (typeof coercedValue === "boolean") {\n      return coercedValue ? 1 : 0;\n    }\n    let num = coercedValue;\n    if (typeof coercedValue === "string" && coercedValue !== "") {\n      num = Number(coercedValue);\n    }\n    if (typeof num !== "number" || !Number.isInteger(num)) {\n      throw new GraphQLError(`Int cannot represent non-integer value: ${inspect(coercedValue)}`);\n    }\n    if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {\n      throw new GraphQLError("Int cannot represent non 32-bit signed integer value: " + inspect(coercedValue));\n    }\n    return num;\n  },\n  parseValue(inputValue) {\n    if (typeof inputValue !== "number" || !Number.isInteger(inputValue)) {\n      throw new GraphQLError(`Int cannot represent non-integer value: ${inspect(inputValue)}`);\n    }\n    if (inputValue > GRAPHQL_MAX_INT || inputValue < GRAPHQL_MIN_INT) {\n      throw new GraphQLError(`Int cannot represent non 32-bit signed integer value: ${inputValue}`);\n    }\n    return inputValue;\n  },\n  parseLiteral(valueNode) {\n    if (valueNode.kind !== Kind.INT) {\n      throw new GraphQLError(`Int cannot represent non-integer value: ${print(valueNode)}`, {\n        nodes: valueNode\n      });\n    }\n    const num = parseInt(valueNode.value, 10);\n    if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {\n      throw new GraphQLError(`Int cannot represent non 32-bit signed integer value: ${valueNode.value}`, {\n        nodes: valueNode\n      });\n    }\n    return num;\n  }\n});\nconst GraphQLFloat = new GraphQLScalarType({\n  name: "Float",\n  description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",\n  serialize(outputValue) {\n    const coercedValue = serializeObject(outputValue);\n    if (typeof coercedValue === "boolean") {\n      return coercedValue ? 1 : 0;\n    }\n    let num = coercedValue;\n    if (typeof coercedValue === "string" && coercedValue !== "") {\n      num = Number(coercedValue);\n    }\n    if (typeof num !== "number" || !Number.isFinite(num)) {\n      throw new GraphQLError(`Float cannot represent non numeric value: ${inspect(coercedValue)}`);\n    }\n    return num;\n  },\n  parseValue(inputValue) {\n    if (typeof inputValue !== "number" || !Number.isFinite(inputValue)) {\n      throw new GraphQLError(`Float cannot represent non numeric value: ${inspect(inputValue)}`);\n    }\n    return inputValue;\n  },\n  parseLiteral(valueNode) {\n    if (valueNode.kind !== Kind.FLOAT && valueNode.kind !== Kind.INT) {\n      throw new GraphQLError(`Float cannot represent non numeric value: ${print(valueNode)}`, valueNode);\n    }\n    return parseFloat(valueNode.value);\n  }\n});\nconst GraphQLString = new GraphQLScalarType({\n  name: "String",\n  description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",\n  serialize(outputValue) {\n    const coercedValue = serializeObject(outputValue);\n    if (typeof coercedValue === "string") {\n      return coercedValue;\n    }\n    if (typeof coercedValue === "boolean") {\n      return coercedValue ? "true" : "false";\n    }\n    if (typeof coercedValue === "number" && Number.isFinite(coercedValue)) {\n      return coercedValue.toString();\n    }\n    throw new GraphQLError(`String cannot represent value: ${inspect(outputValue)}`);\n  },\n  parseValue(inputValue) {\n    if (typeof inputValue !== "string") {\n      throw new GraphQLError(`String cannot represent a non string value: ${inspect(inputValue)}`);\n    }\n    return inputValue;\n  },\n  parseLiteral(valueNode) {\n    if (valueNode.kind !== Kind.STRING) {\n      throw new GraphQLError(`String cannot represent a non string value: ${print(valueNode)}`, {\n        nodes: valueNode\n      });\n    }\n    return valueNode.value;\n  }\n});\nconst GraphQLBoolean = new GraphQLScalarType({\n  name: "Boolean",\n  description: "The `Boolean` scalar type represents `true` or `false`.",\n  serialize(outputValue) {\n    const coercedValue = serializeObject(outputValue);\n    if (typeof coercedValue === "boolean") {\n      return coercedValue;\n    }\n    if (Number.isFinite(coercedValue)) {\n      return coercedValue !== 0;\n    }\n    throw new GraphQLError(`Boolean cannot represent a non boolean value: ${inspect(coercedValue)}`);\n  },\n  parseValue(inputValue) {\n    if (typeof inputValue !== "boolean") {\n      throw new GraphQLError(`Boolean cannot represent a non boolean value: ${inspect(inputValue)}`);\n    }\n    return inputValue;\n  },\n  parseLiteral(valueNode) {\n    if (valueNode.kind !== Kind.BOOLEAN) {\n      throw new GraphQLError(`Boolean cannot represent a non boolean value: ${print(valueNode)}`, {\n        nodes: valueNode\n      });\n    }\n    return valueNode.value;\n  }\n});\nconst GraphQLID = new GraphQLScalarType({\n  name: "ID",\n  description: \'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.\',\n  serialize(outputValue) {\n    const coercedValue = serializeObject(outputValue);\n    if (typeof coercedValue === "string") {\n      return coercedValue;\n    }\n    if (Number.isInteger(coercedValue)) {\n      return String(coercedValue);\n    }\n    throw new GraphQLError(`ID cannot represent value: ${inspect(outputValue)}`);\n  },\n  parseValue(inputValue) {\n    if (typeof inputValue === "string") {\n      return inputValue;\n    }\n    if (typeof inputValue === "number" && Number.isInteger(inputValue)) {\n      return inputValue.toString();\n    }\n    throw new GraphQLError(`ID cannot represent value: ${inspect(inputValue)}`);\n  },\n  parseLiteral(valueNode) {\n    if (valueNode.kind !== Kind.STRING && valueNode.kind !== Kind.INT) {\n      throw new GraphQLError("ID cannot represent a non-string and non-integer value: " + print(valueNode), {\n        nodes: valueNode\n      });\n    }\n    return valueNode.value;\n  }\n});\nObject.freeze([\n  GraphQLString,\n  GraphQLInt,\n  GraphQLFloat,\n  GraphQLBoolean,\n  GraphQLID\n]);\nfunction serializeObject(outputValue) {\n  if (isObjectLike(outputValue)) {\n    if (typeof outputValue.valueOf === "function") {\n      const valueOfResult = outputValue.valueOf();\n      if (!isObjectLike(valueOfResult)) {\n        return valueOfResult;\n      }\n    }\n    if (typeof outputValue.toJSON === "function") {\n      return outputValue.toJSON();\n    }\n  }\n  return outputValue;\n}\n__name(serializeObject, "serializeObject");\nfunction astFromValue(value, type) {\n  if (isNonNullType(type)) {\n    const astValue = astFromValue(value, type.ofType);\n    if ((astValue === null || astValue === void 0 ? void 0 : astValue.kind) === Kind.NULL) {\n      return null;\n    }\n    return astValue;\n  }\n  if (value === null) {\n    return {\n      kind: Kind.NULL\n    };\n  }\n  if (value === void 0) {\n    return null;\n  }\n  if (isListType(type)) {\n    const itemType = type.ofType;\n    if (isIterableObject(value)) {\n      const valuesNodes = [];\n      for (const item of value) {\n        const itemNode = astFromValue(item, itemType);\n        if (itemNode != null) {\n          valuesNodes.push(itemNode);\n        }\n      }\n      return {\n        kind: Kind.LIST,\n        values: valuesNodes\n      };\n    }\n    return astFromValue(value, itemType);\n  }\n  if (isInputObjectType(type)) {\n    if (!isObjectLike(value)) {\n      return null;\n    }\n    const fieldNodes = [];\n    for (const field of Object.values(type.getFields())) {\n      const fieldValue = astFromValue(value[field.name], field.type);\n      if (fieldValue) {\n        fieldNodes.push({\n          kind: Kind.OBJECT_FIELD,\n          name: {\n            kind: Kind.NAME,\n            value: field.name\n          },\n          value: fieldValue\n        });\n      }\n    }\n    return {\n      kind: Kind.OBJECT,\n      fields: fieldNodes\n    };\n  }\n  if (isLeafType(type)) {\n    const serialized = type.serialize(value);\n    if (serialized == null) {\n      return null;\n    }\n    if (typeof serialized === "boolean") {\n      return {\n        kind: Kind.BOOLEAN,\n        value: serialized\n      };\n    }\n    if (typeof serialized === "number" && Number.isFinite(serialized)) {\n      const stringNum = String(serialized);\n      return integerStringRegExp.test(stringNum) ? {\n        kind: Kind.INT,\n        value: stringNum\n      } : {\n        kind: Kind.FLOAT,\n        value: stringNum\n      };\n    }\n    if (typeof serialized === "string") {\n      if (isEnumType(type)) {\n        return {\n          kind: Kind.ENUM,\n          value: serialized\n        };\n      }\n      if (type === GraphQLID && integerStringRegExp.test(serialized)) {\n        return {\n          kind: Kind.INT,\n          value: serialized\n        };\n      }\n      return {\n        kind: Kind.STRING,\n        value: serialized\n      };\n    }\n    throw new TypeError(`Cannot convert value to AST: ${inspect(serialized)}.`);\n  }\n  invariant(false, "Unexpected input type: " + inspect(type));\n}\n__name(astFromValue, "astFromValue");\nconst integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;\nconst __Schema = new GraphQLObjectType({\n  name: "__Schema",\n  description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",\n  fields: () => ({\n    description: {\n      type: GraphQLString,\n      resolve: (schema) => schema.description\n    },\n    types: {\n      description: "A list of all types supported by this server.",\n      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Type))),\n      resolve(schema) {\n        return Object.values(schema.getTypeMap());\n      }\n    },\n    queryType: {\n      description: "The type that query operations will be rooted at.",\n      type: new GraphQLNonNull(__Type),\n      resolve: (schema) => schema.getQueryType()\n    },\n    mutationType: {\n      description: "If this server supports mutation, the type that mutation operations will be rooted at.",\n      type: __Type,\n      resolve: (schema) => schema.getMutationType()\n    },\n    subscriptionType: {\n      description: "If this server support subscription, the type that subscription operations will be rooted at.",\n      type: __Type,\n      resolve: (schema) => schema.getSubscriptionType()\n    },\n    directives: {\n      description: "A list of all directives supported by this server.",\n      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Directive))),\n      resolve: (schema) => schema.getDirectives()\n    }\n  })\n});\nconst __Directive = new GraphQLObjectType({\n  name: "__Directive",\n  description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\\n\\nIn some cases, you need to provide options to alter GraphQL\'s execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",\n  fields: () => ({\n    name: {\n      type: new GraphQLNonNull(GraphQLString),\n      resolve: (directive) => directive.name\n    },\n    description: {\n      type: GraphQLString,\n      resolve: (directive) => directive.description\n    },\n    isRepeatable: {\n      type: new GraphQLNonNull(GraphQLBoolean),\n      resolve: (directive) => directive.isRepeatable\n    },\n    locations: {\n      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__DirectiveLocation))),\n      resolve: (directive) => directive.locations\n    },\n    args: {\n      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__InputValue))),\n      args: {\n        includeDeprecated: {\n          type: GraphQLBoolean,\n          defaultValue: false\n        }\n      },\n      resolve(field, { includeDeprecated }) {\n        return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);\n      }\n    }\n  })\n});\nconst __DirectiveLocation = new GraphQLEnumType({\n  name: "__DirectiveLocation",\n  description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",\n  values: {\n    QUERY: {\n      value: DirectiveLocation.QUERY,\n      description: "Location adjacent to a query operation."\n    },\n    MUTATION: {\n      value: DirectiveLocation.MUTATION,\n      description: "Location adjacent to a mutation operation."\n    },\n    SUBSCRIPTION: {\n      value: DirectiveLocation.SUBSCRIPTION,\n      description: "Location adjacent to a subscription operation."\n    },\n    FIELD: {\n      value: DirectiveLocation.FIELD,\n      description: "Location adjacent to a field."\n    },\n    FRAGMENT_DEFINITION: {\n      value: DirectiveLocation.FRAGMENT_DEFINITION,\n      description: "Location adjacent to a fragment definition."\n    },\n    FRAGMENT_SPREAD: {\n      value: DirectiveLocation.FRAGMENT_SPREAD,\n      description: "Location adjacent to a fragment spread."\n    },\n    INLINE_FRAGMENT: {\n      value: DirectiveLocation.INLINE_FRAGMENT,\n      description: "Location adjacent to an inline fragment."\n    },\n    VARIABLE_DEFINITION: {\n      value: DirectiveLocation.VARIABLE_DEFINITION,\n      description: "Location adjacent to a variable definition."\n    },\n    SCHEMA: {\n      value: DirectiveLocation.SCHEMA,\n      description: "Location adjacent to a schema definition."\n    },\n    SCALAR: {\n      value: DirectiveLocation.SCALAR,\n      description: "Location adjacent to a scalar definition."\n    },\n    OBJECT: {\n      value: DirectiveLocation.OBJECT,\n      description: "Location adjacent to an object type definition."\n    },\n    FIELD_DEFINITION: {\n      value: DirectiveLocation.FIELD_DEFINITION,\n      description: "Location adjacent to a field definition."\n    },\n    ARGUMENT_DEFINITION: {\n      value: DirectiveLocation.ARGUMENT_DEFINITION,\n      description: "Location adjacent to an argument definition."\n    },\n    INTERFACE: {\n      value: DirectiveLocation.INTERFACE,\n      description: "Location adjacent to an interface definition."\n    },\n    UNION: {\n      value: DirectiveLocation.UNION,\n      description: "Location adjacent to a union definition."\n    },\n    ENUM: {\n      value: DirectiveLocation.ENUM,\n      description: "Location adjacent to an enum definition."\n    },\n    ENUM_VALUE: {\n      value: DirectiveLocation.ENUM_VALUE,\n      description: "Location adjacent to an enum value definition."\n    },\n    INPUT_OBJECT: {\n      value: DirectiveLocation.INPUT_OBJECT,\n      description: "Location adjacent to an input object type definition."\n    },\n    INPUT_FIELD_DEFINITION: {\n      value: DirectiveLocation.INPUT_FIELD_DEFINITION,\n      description: "Location adjacent to an input object field definition."\n    }\n  }\n});\nconst __Type = new GraphQLObjectType({\n  name: "__Type",\n  description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\\n\\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",\n  fields: () => ({\n    kind: {\n      type: new GraphQLNonNull(__TypeKind),\n      resolve(type) {\n        if (isScalarType(type)) {\n          return TypeKind.SCALAR;\n        }\n        if (isObjectType(type)) {\n          return TypeKind.OBJECT;\n        }\n        if (isInterfaceType(type)) {\n          return TypeKind.INTERFACE;\n        }\n        if (isUnionType(type)) {\n          return TypeKind.UNION;\n        }\n        if (isEnumType(type)) {\n          return TypeKind.ENUM;\n        }\n        if (isInputObjectType(type)) {\n          return TypeKind.INPUT_OBJECT;\n        }\n        if (isListType(type)) {\n          return TypeKind.LIST;\n        }\n        if (isNonNullType(type)) {\n          return TypeKind.NON_NULL;\n        }\n        invariant(false, `Unexpected type: "${inspect(type)}".`);\n      }\n    },\n    name: {\n      type: GraphQLString,\n      resolve: (type) => "name" in type ? type.name : void 0\n    },\n    description: {\n      type: GraphQLString,\n      resolve: (type) => "description" in type ? type.description : void 0\n    },\n    specifiedByURL: {\n      type: GraphQLString,\n      resolve: (obj) => "specifiedByURL" in obj ? obj.specifiedByURL : void 0\n    },\n    fields: {\n      type: new GraphQLList(new GraphQLNonNull(__Field)),\n      args: {\n        includeDeprecated: {\n          type: GraphQLBoolean,\n          defaultValue: false\n        }\n      },\n      resolve(type, { includeDeprecated }) {\n        if (isObjectType(type) || isInterfaceType(type)) {\n          const fields = Object.values(type.getFields());\n          return includeDeprecated ? fields : fields.filter((field) => field.deprecationReason == null);\n        }\n      }\n    },\n    interfaces: {\n      type: new GraphQLList(new GraphQLNonNull(__Type)),\n      resolve(type) {\n        if (isObjectType(type) || isInterfaceType(type)) {\n          return type.getInterfaces();\n        }\n      }\n    },\n    possibleTypes: {\n      type: new GraphQLList(new GraphQLNonNull(__Type)),\n      resolve(type, _args, _context, { schema }) {\n        if (isAbstractType(type)) {\n          return schema.getPossibleTypes(type);\n        }\n      }\n    },\n    enumValues: {\n      type: new GraphQLList(new GraphQLNonNull(__EnumValue)),\n      args: {\n        includeDeprecated: {\n          type: GraphQLBoolean,\n          defaultValue: false\n        }\n      },\n      resolve(type, { includeDeprecated }) {\n        if (isEnumType(type)) {\n          const values = type.getValues();\n          return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);\n        }\n      }\n    },\n    inputFields: {\n      type: new GraphQLList(new GraphQLNonNull(__InputValue)),\n      args: {\n        includeDeprecated: {\n          type: GraphQLBoolean,\n          defaultValue: false\n        }\n      },\n      resolve(type, { includeDeprecated }) {\n        if (isInputObjectType(type)) {\n          const values = Object.values(type.getFields());\n          return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);\n        }\n      }\n    },\n    ofType: {\n      type: __Type,\n      resolve: (type) => "ofType" in type ? type.ofType : void 0\n    }\n  })\n});\nconst __Field = new GraphQLObjectType({\n  name: "__Field",\n  description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",\n  fields: () => ({\n    name: {\n      type: new GraphQLNonNull(GraphQLString),\n      resolve: (field) => field.name\n    },\n    description: {\n      type: GraphQLString,\n      resolve: (field) => field.description\n    },\n    args: {\n      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__InputValue))),\n      args: {\n        includeDeprecated: {\n          type: GraphQLBoolean,\n          defaultValue: false\n        }\n      },\n      resolve(field, { includeDeprecated }) {\n        return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);\n      }\n    },\n    type: {\n      type: new GraphQLNonNull(__Type),\n      resolve: (field) => field.type\n    },\n    isDeprecated: {\n      type: new GraphQLNonNull(GraphQLBoolean),\n      resolve: (field) => field.deprecationReason != null\n    },\n    deprecationReason: {\n      type: GraphQLString,\n      resolve: (field) => field.deprecationReason\n    }\n  })\n});\nconst __InputValue = new GraphQLObjectType({\n  name: "__InputValue",\n  description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",\n  fields: () => ({\n    name: {\n      type: new GraphQLNonNull(GraphQLString),\n      resolve: (inputValue) => inputValue.name\n    },\n    description: {\n      type: GraphQLString,\n      resolve: (inputValue) => inputValue.description\n    },\n    type: {\n      type: new GraphQLNonNull(__Type),\n      resolve: (inputValue) => inputValue.type\n    },\n    defaultValue: {\n      type: GraphQLString,\n      description: "A GraphQL-formatted string representing the default value for this input value.",\n      resolve(inputValue) {\n        const { type, defaultValue } = inputValue;\n        const valueAST = astFromValue(defaultValue, type);\n        return valueAST ? print(valueAST) : null;\n      }\n    },\n    isDeprecated: {\n      type: new GraphQLNonNull(GraphQLBoolean),\n      resolve: (field) => field.deprecationReason != null\n    },\n    deprecationReason: {\n      type: GraphQLString,\n      resolve: (obj) => obj.deprecationReason\n    }\n  })\n});\nconst __EnumValue = new GraphQLObjectType({\n  name: "__EnumValue",\n  description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",\n  fields: () => ({\n    name: {\n      type: new GraphQLNonNull(GraphQLString),\n      resolve: (enumValue) => enumValue.name\n    },\n    description: {\n      type: GraphQLString,\n      resolve: (enumValue) => enumValue.description\n    },\n    isDeprecated: {\n      type: new GraphQLNonNull(GraphQLBoolean),\n      resolve: (enumValue) => enumValue.deprecationReason != null\n    },\n    deprecationReason: {\n      type: GraphQLString,\n      resolve: (enumValue) => enumValue.deprecationReason\n    }\n  })\n});\nlet TypeKind;\n(function(TypeKind2) {\n  TypeKind2["SCALAR"] = "SCALAR";\n  TypeKind2["OBJECT"] = "OBJECT";\n  TypeKind2["INTERFACE"] = "INTERFACE";\n  TypeKind2["UNION"] = "UNION";\n  TypeKind2["ENUM"] = "ENUM";\n  TypeKind2["INPUT_OBJECT"] = "INPUT_OBJECT";\n  TypeKind2["LIST"] = "LIST";\n  TypeKind2["NON_NULL"] = "NON_NULL";\n})(TypeKind || (TypeKind = {}));\nconst __TypeKind = new GraphQLEnumType({\n  name: "__TypeKind",\n  description: "An enum describing what kind of type a given `__Type` is.",\n  values: {\n    SCALAR: {\n      value: TypeKind.SCALAR,\n      description: "Indicates this type is a scalar."\n    },\n    OBJECT: {\n      value: TypeKind.OBJECT,\n      description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."\n    },\n    INTERFACE: {\n      value: TypeKind.INTERFACE,\n      description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."\n    },\n    UNION: {\n      value: TypeKind.UNION,\n      description: "Indicates this type is a union. `possibleTypes` is a valid field."\n    },\n    ENUM: {\n      value: TypeKind.ENUM,\n      description: "Indicates this type is an enum. `enumValues` is a valid field."\n    },\n    INPUT_OBJECT: {\n      value: TypeKind.INPUT_OBJECT,\n      description: "Indicates this type is an input object. `inputFields` is a valid field."\n    },\n    LIST: {\n      value: TypeKind.LIST,\n      description: "Indicates this type is a list. `ofType` is a valid field."\n    },\n    NON_NULL: {\n      value: TypeKind.NON_NULL,\n      description: "Indicates this type is a non-null. `ofType` is a valid field."\n    }\n  }\n});\nconst SchemaMetaFieldDef = {\n  name: "__schema",\n  type: new GraphQLNonNull(__Schema),\n  description: "Access the current type schema of this server.",\n  args: [],\n  resolve: (_source, _args, _context, { schema }) => schema,\n  deprecationReason: void 0,\n  extensions: /* @__PURE__ */ Object.create(null),\n  astNode: void 0\n};\nconst TypeMetaFieldDef = {\n  name: "__type",\n  type: __Type,\n  description: "Request the type information of a single type.",\n  args: [\n    {\n      name: "name",\n      description: void 0,\n      type: new GraphQLNonNull(GraphQLString),\n      defaultValue: void 0,\n      deprecationReason: void 0,\n      extensions: /* @__PURE__ */ Object.create(null),\n      astNode: void 0\n    }\n  ],\n  resolve: (_source, { name }, _context, { schema }) => schema.getType(name),\n  deprecationReason: void 0,\n  extensions: /* @__PURE__ */ Object.create(null),\n  astNode: void 0\n};\nconst TypeNameMetaFieldDef = {\n  name: "__typename",\n  type: new GraphQLNonNull(GraphQLString),\n  description: "The name of the current Object type at runtime.",\n  args: [],\n  resolve: (_source, _args, _context, { parentType }) => parentType.name,\n  deprecationReason: void 0,\n  extensions: /* @__PURE__ */ Object.create(null),\n  astNode: void 0\n};\nObject.freeze([\n  __Schema,\n  __Directive,\n  __DirectiveLocation,\n  __Type,\n  __Field,\n  __InputValue,\n  __EnumValue,\n  __TypeKind\n]);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTI1ODQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBLDREQUE0RCwyQkFBMkI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxXQUFXO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtCQUErQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixzQkFBc0IsV0FBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOENBQThDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw0Q0FBNEM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4Q0FBOEM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQkFBb0I7QUFDckIsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxjQUFjO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxjQUFjLDBDQUEwQztBQUN4RCxHQUFHO0FBQ0g7QUFDQSxjQUFjLFlBQVk7QUFDMUIsR0FBRztBQUNIO0FBQ0EsWUFBWSx3REFBd0Q7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxjQUFjLGFBQWE7QUFDM0IsR0FBRztBQUNIO0FBQ0EsY0FBYyxrQkFBa0I7QUFDaEMsR0FBRztBQUNIO0FBQ0EsY0FBYyx5Q0FBeUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGNBQWMsb0VBQW9FLGlCQUFpQixLQUFLLEVBQUUsaURBQWlELEtBQUssZUFBZSxFQUFFLHFDQUFxQztBQUN0TixHQUFHO0FBQ0g7QUFDQSxjQUFjLE9BQU87QUFDckIsR0FBRztBQUNIO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLEdBQUc7QUFDSDtBQUNBLGNBQWMsNkJBQTZCO0FBQzNDLEdBQUc7QUFDSDtBQUNBLGNBQWMsT0FBTztBQUNyQixHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGNBQWMsT0FBTztBQUNyQixHQUFHO0FBQ0g7QUFDQSxjQUFjLFFBQVE7QUFDdEIsR0FBRztBQUNIO0FBQ0EsY0FBYyxRQUFRLE9BQU8sMkJBQTJCO0FBQ3hELEdBQUc7QUFDSDtBQUNBLGNBQWMsYUFBYTtBQUMzQixHQUFHO0FBQ0g7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQyxHQUFHO0FBQ0g7QUFDQSxjQUFjLE1BQU07QUFDcEIsR0FBRztBQUNIO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCLEdBQUc7QUFDSDtBQUNBLGNBQWMsTUFBTTtBQUNwQixHQUFHO0FBQ0g7QUFDQSxjQUFjLHlDQUF5QztBQUN2RCxHQUFHO0FBQ0g7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQixHQUFHO0FBQ0g7QUFDQSxjQUFjLCtCQUErQjtBQUM3QyxHQUFHO0FBQ0g7QUFDQSxjQUFjLG1EQUFtRDtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxjQUFjLHNEQUFzRDtBQUNwRSxHQUFHO0FBQ0g7QUFDQSxjQUFjLG1EQUFtRDtBQUNqRSxHQUFHO0FBQ0g7QUFDQSxjQUFjLG1EQUFtRDtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxjQUFjLHNDQUFzQztBQUNwRCxHQUFHO0FBQ0g7QUFDQSxjQUFjLHVDQUF1QztBQUNyRCxHQUFHO0FBQ0g7QUFDQSxjQUFjLCtCQUErQjtBQUM3QyxHQUFHO0FBQ0g7QUFDQSxjQUFjLHVDQUF1QztBQUNyRCxHQUFHO0FBQ0g7QUFDQSxjQUFjLDJEQUEyRDtBQUN6RSxHQUFHO0FBQ0g7QUFDQSxjQUFjLDRCQUE0QjtBQUMxQyxHQUFHO0FBQ0g7QUFDQSxjQUFjLGtCQUFrQjtBQUNoQyxHQUFHO0FBQ0g7QUFDQSxjQUFjLHNDQUFzQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxjQUFjLHNDQUFzQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxjQUFjLHlCQUF5QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsY0FBYywwQkFBMEI7QUFDeEMsR0FBRztBQUNIO0FBQ0EsY0FBYywwQkFBMEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQ0FBb0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELEVBQUU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFlBQVksR0FBRyxRQUFRLEdBQUc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGFBQWE7QUFDckIsUUFBUSxTQUFTO0FBQ2pCO0FBQ0EsUUFBUSxhQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNERBQTREO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0EsMEVBQTBFLEtBQUs7QUFDL0U7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLEtBQUs7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELEtBQUs7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxpQkFBaUI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGlCQUFpQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHLFdBQVcsc0RBQXNELCtCQUErQjtBQUN0TSw4RkFBOEYsV0FBVztBQUN6RztBQUNBLGtIQUFrSCxXQUFXO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLFdBQVcsa0RBQWtELHlCQUF5QjtBQUNsTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsYUFBYTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGFBQWE7QUFDM0Q7QUFDQTtBQUNBLG1EQUFtRCxZQUFZLEdBQUcsV0FBVztBQUM3RSxvR0FBb0csWUFBWSxHQUFHLFdBQVcsMERBQTBELDZCQUE2QjtBQUNyTjtBQUNBLGtEQUFrRCxZQUFZLEdBQUcsV0FBVztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0csV0FBVyxxREFBcUQsNEJBQTRCO0FBQzlMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHLFdBQVcscURBQXFELDRCQUE0QjtBQUM5TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhIQUE4SCxZQUFZO0FBQzFJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxVQUFVLDRCQUE0QixxQkFBcUI7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFVBQVUsdUNBQXVDLFNBQVM7QUFDaEc7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFdBQVcsdUJBQXVCLFVBQVU7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFVBQVUscUNBQXFDLFNBQVM7QUFDOUY7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUyx1QkFBdUIsVUFBVTtBQUNqRjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsVUFBVTtBQUN4RDtBQUNBLG1EQUFtRCxTQUFTLEdBQUcsV0FBVyxxRkFBcUYscUJBQXFCO0FBQ3BMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxhQUFhO0FBQzNEO0FBQ0EsdURBQXVELFlBQVksR0FBRyxXQUFXO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLHNCQUFzQjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx3RUFBd0Usb0JBQW9CO0FBQzVGO0FBQ0E7QUFDQSxzRkFBc0YsV0FBVztBQUNqRztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx3RUFBd0UsaUJBQWlCO0FBQ3pGO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRixnQkFBZ0I7QUFDdEc7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLHNCQUFzQjtBQUNoRztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwwRUFBMEUsb0JBQW9CO0FBQzlGO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDBFQUEwRSxpQkFBaUI7QUFDM0Y7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQscUJBQXFCO0FBQ2xGLEdBQUc7QUFDSDtBQUNBO0FBQ0EsNEVBQTRFLG9CQUFvQjtBQUNoRztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw0RUFBNEUsaUJBQWlCO0FBQzdGO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLHNCQUFzQjtBQUNsRyxHQUFHO0FBQ0g7QUFDQTtBQUNBLDhFQUE4RSxvQkFBb0I7QUFDbEc7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsOEVBQThFLGlCQUFpQjtBQUMvRjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGdMQUFnTDtBQUNoTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELHFCQUFxQjtBQUM5RSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsb0JBQW9CO0FBQzdFLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELG9CQUFvQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixNQUFNLGNBQWMsUUFBUTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsWUFBWTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3FGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2FjaGlxbC1kZW1vLy4vbm9kZV9tb2R1bGVzL0BncmFwaGlxbC9yZWFjdC9kaXN0L2ludHJvc3BlY3Rpb24uZXMuanM/ZWMyOCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fbmFtZSA9ICh0YXJnZXQsIHZhbHVlKSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIm5hbWVcIiwgeyB2YWx1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuY29uc3QgTUFYX0FSUkFZX0xFTkdUSCA9IDEwO1xuY29uc3QgTUFYX1JFQ1VSU0lWRV9ERVBUSCA9IDI7XG5mdW5jdGlvbiBpbnNwZWN0KHZhbHVlKSB7XG4gIHJldHVybiBmb3JtYXRWYWx1ZSh2YWx1ZSwgW10pO1xufVxuX19uYW1lKGluc3BlY3QsIFwiaW5zcGVjdFwiKTtcbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKHZhbHVlLCBzZWVuVmFsdWVzKSB7XG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgIHJldHVybiB2YWx1ZS5uYW1lID8gYFtmdW5jdGlvbiAke3ZhbHVlLm5hbWV9XWAgOiBcIltmdW5jdGlvbl1cIjtcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICByZXR1cm4gZm9ybWF0T2JqZWN0VmFsdWUodmFsdWUsIHNlZW5WYWx1ZXMpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgfVxufVxuX19uYW1lKGZvcm1hdFZhbHVlLCBcImZvcm1hdFZhbHVlXCIpO1xuZnVuY3Rpb24gZm9ybWF0T2JqZWN0VmFsdWUodmFsdWUsIHByZXZpb3VzbHlTZWVuVmFsdWVzKSB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBcIm51bGxcIjtcbiAgfVxuICBpZiAocHJldmlvdXNseVNlZW5WYWx1ZXMuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgcmV0dXJuIFwiW0NpcmN1bGFyXVwiO1xuICB9XG4gIGNvbnN0IHNlZW5WYWx1ZXMgPSBbLi4ucHJldmlvdXNseVNlZW5WYWx1ZXMsIHZhbHVlXTtcbiAgaWYgKGlzSlNPTmFibGUodmFsdWUpKSB7XG4gICAgY29uc3QganNvblZhbHVlID0gdmFsdWUudG9KU09OKCk7XG4gICAgaWYgKGpzb25WYWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YganNvblZhbHVlID09PSBcInN0cmluZ1wiID8ganNvblZhbHVlIDogZm9ybWF0VmFsdWUoanNvblZhbHVlLCBzZWVuVmFsdWVzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZm9ybWF0QXJyYXkodmFsdWUsIHNlZW5WYWx1ZXMpO1xuICB9XG4gIHJldHVybiBmb3JtYXRPYmplY3QodmFsdWUsIHNlZW5WYWx1ZXMpO1xufVxuX19uYW1lKGZvcm1hdE9iamVjdFZhbHVlLCBcImZvcm1hdE9iamVjdFZhbHVlXCIpO1xuZnVuY3Rpb24gaXNKU09OYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gXCJmdW5jdGlvblwiO1xufVxuX19uYW1lKGlzSlNPTmFibGUsIFwiaXNKU09OYWJsZVwiKTtcbmZ1bmN0aW9uIGZvcm1hdE9iamVjdChvYmplY3QsIHNlZW5WYWx1ZXMpIHtcbiAgY29uc3QgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKG9iamVjdCk7XG4gIGlmIChlbnRyaWVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBcInt9XCI7XG4gIH1cbiAgaWYgKHNlZW5WYWx1ZXMubGVuZ3RoID4gTUFYX1JFQ1VSU0lWRV9ERVBUSCkge1xuICAgIHJldHVybiBcIltcIiArIGdldE9iamVjdFRhZyhvYmplY3QpICsgXCJdXCI7XG4gIH1cbiAgY29uc3QgcHJvcGVydGllcyA9IGVudHJpZXMubWFwKChba2V5LCB2YWx1ZV0pID0+IGtleSArIFwiOiBcIiArIGZvcm1hdFZhbHVlKHZhbHVlLCBzZWVuVmFsdWVzKSk7XG4gIHJldHVybiBcInsgXCIgKyBwcm9wZXJ0aWVzLmpvaW4oXCIsIFwiKSArIFwiIH1cIjtcbn1cbl9fbmFtZShmb3JtYXRPYmplY3QsIFwiZm9ybWF0T2JqZWN0XCIpO1xuZnVuY3Rpb24gZm9ybWF0QXJyYXkoYXJyYXksIHNlZW5WYWx1ZXMpIHtcbiAgaWYgKGFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBcIltdXCI7XG4gIH1cbiAgaWYgKHNlZW5WYWx1ZXMubGVuZ3RoID4gTUFYX1JFQ1VSU0lWRV9ERVBUSCkge1xuICAgIHJldHVybiBcIltBcnJheV1cIjtcbiAgfVxuICBjb25zdCBsZW4gPSBNYXRoLm1pbihNQVhfQVJSQVlfTEVOR1RILCBhcnJheS5sZW5ndGgpO1xuICBjb25zdCByZW1haW5pbmcgPSBhcnJheS5sZW5ndGggLSBsZW47XG4gIGNvbnN0IGl0ZW1zID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpdGVtcy5wdXNoKGZvcm1hdFZhbHVlKGFycmF5W2ldLCBzZWVuVmFsdWVzKSk7XG4gIH1cbiAgaWYgKHJlbWFpbmluZyA9PT0gMSkge1xuICAgIGl0ZW1zLnB1c2goXCIuLi4gMSBtb3JlIGl0ZW1cIik7XG4gIH0gZWxzZSBpZiAocmVtYWluaW5nID4gMSkge1xuICAgIGl0ZW1zLnB1c2goYC4uLiAke3JlbWFpbmluZ30gbW9yZSBpdGVtc2ApO1xuICB9XG4gIHJldHVybiBcIltcIiArIGl0ZW1zLmpvaW4oXCIsIFwiKSArIFwiXVwiO1xufVxuX19uYW1lKGZvcm1hdEFycmF5LCBcImZvcm1hdEFycmF5XCIpO1xuZnVuY3Rpb24gZ2V0T2JqZWN0VGFnKG9iamVjdCkge1xuICBjb25zdCB0YWcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KS5yZXBsYWNlKC9eXFxbb2JqZWN0IC8sIFwiXCIpLnJlcGxhY2UoL10kLywgXCJcIik7XG4gIGlmICh0YWcgPT09IFwiT2JqZWN0XCIgJiYgdHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uc3QgbmFtZSA9IG9iamVjdC5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIiAmJiBuYW1lICE9PSBcIlwiKSB7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhZztcbn1cbl9fbmFtZShnZXRPYmplY3RUYWcsIFwiZ2V0T2JqZWN0VGFnXCIpO1xuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBjb25zdCBib29sZWFuQ29uZGl0aW9uID0gQm9vbGVhbihjb25kaXRpb24pO1xuICBpZiAoIWJvb2xlYW5Db25kaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSAhPSBudWxsID8gbWVzc2FnZSA6IFwiVW5leHBlY3RlZCBpbnZhcmlhbnQgdHJpZ2dlcmVkLlwiKTtcbiAgfVxufVxuX19uYW1lKGludmFyaWFudCwgXCJpbnZhcmlhbnRcIik7XG5sZXQgRGlyZWN0aXZlTG9jYXRpb247XG4oZnVuY3Rpb24oRGlyZWN0aXZlTG9jYXRpb24yKSB7XG4gIERpcmVjdGl2ZUxvY2F0aW9uMltcIlFVRVJZXCJdID0gXCJRVUVSWVwiO1xuICBEaXJlY3RpdmVMb2NhdGlvbjJbXCJNVVRBVElPTlwiXSA9IFwiTVVUQVRJT05cIjtcbiAgRGlyZWN0aXZlTG9jYXRpb24yW1wiU1VCU0NSSVBUSU9OXCJdID0gXCJTVUJTQ1JJUFRJT05cIjtcbiAgRGlyZWN0aXZlTG9jYXRpb24yW1wiRklFTERcIl0gPSBcIkZJRUxEXCI7XG4gIERpcmVjdGl2ZUxvY2F0aW9uMltcIkZSQUdNRU5UX0RFRklOSVRJT05cIl0gPSBcIkZSQUdNRU5UX0RFRklOSVRJT05cIjtcbiAgRGlyZWN0aXZlTG9jYXRpb24yW1wiRlJBR01FTlRfU1BSRUFEXCJdID0gXCJGUkFHTUVOVF9TUFJFQURcIjtcbiAgRGlyZWN0aXZlTG9jYXRpb24yW1wiSU5MSU5FX0ZSQUdNRU5UXCJdID0gXCJJTkxJTkVfRlJBR01FTlRcIjtcbiAgRGlyZWN0aXZlTG9jYXRpb24yW1wiVkFSSUFCTEVfREVGSU5JVElPTlwiXSA9IFwiVkFSSUFCTEVfREVGSU5JVElPTlwiO1xuICBEaXJlY3RpdmVMb2NhdGlvbjJbXCJTQ0hFTUFcIl0gPSBcIlNDSEVNQVwiO1xuICBEaXJlY3RpdmVMb2NhdGlvbjJbXCJTQ0FMQVJcIl0gPSBcIlNDQUxBUlwiO1xuICBEaXJlY3RpdmVMb2NhdGlvbjJbXCJPQkpFQ1RcIl0gPSBcIk9CSkVDVFwiO1xuICBEaXJlY3RpdmVMb2NhdGlvbjJbXCJGSUVMRF9ERUZJTklUSU9OXCJdID0gXCJGSUVMRF9ERUZJTklUSU9OXCI7XG4gIERpcmVjdGl2ZUxvY2F0aW9uMltcIkFSR1VNRU5UX0RFRklOSVRJT05cIl0gPSBcIkFSR1VNRU5UX0RFRklOSVRJT05cIjtcbiAgRGlyZWN0aXZlTG9jYXRpb24yW1wiSU5URVJGQUNFXCJdID0gXCJJTlRFUkZBQ0VcIjtcbiAgRGlyZWN0aXZlTG9jYXRpb24yW1wiVU5JT05cIl0gPSBcIlVOSU9OXCI7XG4gIERpcmVjdGl2ZUxvY2F0aW9uMltcIkVOVU1cIl0gPSBcIkVOVU1cIjtcbiAgRGlyZWN0aXZlTG9jYXRpb24yW1wiRU5VTV9WQUxVRVwiXSA9IFwiRU5VTV9WQUxVRVwiO1xuICBEaXJlY3RpdmVMb2NhdGlvbjJbXCJJTlBVVF9PQkpFQ1RcIl0gPSBcIklOUFVUX09CSkVDVFwiO1xuICBEaXJlY3RpdmVMb2NhdGlvbjJbXCJJTlBVVF9GSUVMRF9ERUZJTklUSU9OXCJdID0gXCJJTlBVVF9GSUVMRF9ERUZJTklUSU9OXCI7XG59KShEaXJlY3RpdmVMb2NhdGlvbiB8fCAoRGlyZWN0aXZlTG9jYXRpb24gPSB7fSkpO1xuZnVuY3Rpb24gaXNXaGl0ZVNwYWNlKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPT09IDkgfHwgY29kZSA9PT0gMzI7XG59XG5fX25hbWUoaXNXaGl0ZVNwYWNlLCBcImlzV2hpdGVTcGFjZVwiKTtcbmZ1bmN0aW9uIGlzRGlnaXQkMShjb2RlKSB7XG4gIHJldHVybiBjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTc7XG59XG5fX25hbWUoaXNEaWdpdCQxLCBcImlzRGlnaXQkMVwiKTtcbmZ1bmN0aW9uIGlzTGV0dGVyKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPj0gOTcgJiYgY29kZSA8PSAxMjIgfHwgY29kZSA+PSA2NSAmJiBjb2RlIDw9IDkwO1xufVxuX19uYW1lKGlzTGV0dGVyLCBcImlzTGV0dGVyXCIpO1xuZnVuY3Rpb24gaXNOYW1lU3RhcnQoY29kZSkge1xuICByZXR1cm4gaXNMZXR0ZXIoY29kZSkgfHwgY29kZSA9PT0gOTU7XG59XG5fX25hbWUoaXNOYW1lU3RhcnQsIFwiaXNOYW1lU3RhcnRcIik7XG5mdW5jdGlvbiBpc05hbWVDb250aW51ZShjb2RlKSB7XG4gIHJldHVybiBpc0xldHRlcihjb2RlKSB8fCBpc0RpZ2l0JDEoY29kZSkgfHwgY29kZSA9PT0gOTU7XG59XG5fX25hbWUoaXNOYW1lQ29udGludWUsIFwiaXNOYW1lQ29udGludWVcIik7XG5mdW5jdGlvbiBwcmludEJsb2NrU3RyaW5nKHZhbHVlLCBvcHRpb25zKSB7XG4gIGNvbnN0IGVzY2FwZWRWYWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1wiXCJcIi9nLCAnXFxcXFwiXCJcIicpO1xuICBjb25zdCBsaW5lcyA9IGVzY2FwZWRWYWx1ZS5zcGxpdCgvXFxyXFxufFtcXG5cXHJdL2cpO1xuICBjb25zdCBpc1NpbmdsZUxpbmUgPSBsaW5lcy5sZW5ndGggPT09IDE7XG4gIGNvbnN0IGZvcmNlTGVhZGluZ05ld0xpbmUgPSBsaW5lcy5sZW5ndGggPiAxICYmIGxpbmVzLnNsaWNlKDEpLmV2ZXJ5KChsaW5lKSA9PiBsaW5lLmxlbmd0aCA9PT0gMCB8fCBpc1doaXRlU3BhY2UobGluZS5jaGFyQ29kZUF0KDApKSk7XG4gIGNvbnN0IGhhc1RyYWlsaW5nVHJpcGxlUXVvdGVzID0gZXNjYXBlZFZhbHVlLmVuZHNXaXRoKCdcXFxcXCJcIlwiJyk7XG4gIGNvbnN0IGhhc1RyYWlsaW5nUXVvdGUgPSB2YWx1ZS5lbmRzV2l0aCgnXCInKSAmJiAhaGFzVHJhaWxpbmdUcmlwbGVRdW90ZXM7XG4gIGNvbnN0IGhhc1RyYWlsaW5nU2xhc2ggPSB2YWx1ZS5lbmRzV2l0aChcIlxcXFxcIik7XG4gIGNvbnN0IGZvcmNlVHJhaWxpbmdOZXdsaW5lID0gaGFzVHJhaWxpbmdRdW90ZSB8fCBoYXNUcmFpbGluZ1NsYXNoO1xuICBjb25zdCBwcmludEFzTXVsdGlwbGVMaW5lcyA9ICEob3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgJiYgb3B0aW9ucy5taW5pbWl6ZSkgJiYgKCFpc1NpbmdsZUxpbmUgfHwgdmFsdWUubGVuZ3RoID4gNzAgfHwgZm9yY2VUcmFpbGluZ05ld2xpbmUgfHwgZm9yY2VMZWFkaW5nTmV3TGluZSB8fCBoYXNUcmFpbGluZ1RyaXBsZVF1b3Rlcyk7XG4gIGxldCByZXN1bHQgPSBcIlwiO1xuICBjb25zdCBza2lwTGVhZGluZ05ld0xpbmUgPSBpc1NpbmdsZUxpbmUgJiYgaXNXaGl0ZVNwYWNlKHZhbHVlLmNoYXJDb2RlQXQoMCkpO1xuICBpZiAocHJpbnRBc011bHRpcGxlTGluZXMgJiYgIXNraXBMZWFkaW5nTmV3TGluZSB8fCBmb3JjZUxlYWRpbmdOZXdMaW5lKSB7XG4gICAgcmVzdWx0ICs9IFwiXFxuXCI7XG4gIH1cbiAgcmVzdWx0ICs9IGVzY2FwZWRWYWx1ZTtcbiAgaWYgKHByaW50QXNNdWx0aXBsZUxpbmVzIHx8IGZvcmNlVHJhaWxpbmdOZXdsaW5lKSB7XG4gICAgcmVzdWx0ICs9IFwiXFxuXCI7XG4gIH1cbiAgcmV0dXJuICdcIlwiXCInICsgcmVzdWx0ICsgJ1wiXCJcIic7XG59XG5fX25hbWUocHJpbnRCbG9ja1N0cmluZywgXCJwcmludEJsb2NrU3RyaW5nXCIpO1xuZnVuY3Rpb24gcHJpbnRTdHJpbmcoc3RyKSB7XG4gIHJldHVybiBgXCIke3N0ci5yZXBsYWNlKGVzY2FwZWRSZWdFeHAsIGVzY2FwZWRSZXBsYWNlcil9XCJgO1xufVxuX19uYW1lKHByaW50U3RyaW5nLCBcInByaW50U3RyaW5nXCIpO1xuY29uc3QgZXNjYXBlZFJlZ0V4cCA9IC9bXFx4MDAtXFx4MWZcXHgyMlxceDVjXFx4N2YtXFx4OWZdL2c7XG5mdW5jdGlvbiBlc2NhcGVkUmVwbGFjZXIoc3RyKSB7XG4gIHJldHVybiBlc2NhcGVTZXF1ZW5jZXNbc3RyLmNoYXJDb2RlQXQoMCldO1xufVxuX19uYW1lKGVzY2FwZWRSZXBsYWNlciwgXCJlc2NhcGVkUmVwbGFjZXJcIik7XG5jb25zdCBlc2NhcGVTZXF1ZW5jZXMgPSBbXG4gIFwiXFxcXHUwMDAwXCIsXG4gIFwiXFxcXHUwMDAxXCIsXG4gIFwiXFxcXHUwMDAyXCIsXG4gIFwiXFxcXHUwMDAzXCIsXG4gIFwiXFxcXHUwMDA0XCIsXG4gIFwiXFxcXHUwMDA1XCIsXG4gIFwiXFxcXHUwMDA2XCIsXG4gIFwiXFxcXHUwMDA3XCIsXG4gIFwiXFxcXGJcIixcbiAgXCJcXFxcdFwiLFxuICBcIlxcXFxuXCIsXG4gIFwiXFxcXHUwMDBCXCIsXG4gIFwiXFxcXGZcIixcbiAgXCJcXFxcclwiLFxuICBcIlxcXFx1MDAwRVwiLFxuICBcIlxcXFx1MDAwRlwiLFxuICBcIlxcXFx1MDAxMFwiLFxuICBcIlxcXFx1MDAxMVwiLFxuICBcIlxcXFx1MDAxMlwiLFxuICBcIlxcXFx1MDAxM1wiLFxuICBcIlxcXFx1MDAxNFwiLFxuICBcIlxcXFx1MDAxNVwiLFxuICBcIlxcXFx1MDAxNlwiLFxuICBcIlxcXFx1MDAxN1wiLFxuICBcIlxcXFx1MDAxOFwiLFxuICBcIlxcXFx1MDAxOVwiLFxuICBcIlxcXFx1MDAxQVwiLFxuICBcIlxcXFx1MDAxQlwiLFxuICBcIlxcXFx1MDAxQ1wiLFxuICBcIlxcXFx1MDAxRFwiLFxuICBcIlxcXFx1MDAxRVwiLFxuICBcIlxcXFx1MDAxRlwiLFxuICBcIlwiLFxuICBcIlwiLFxuICAnXFxcXFwiJyxcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcIixcbiAgXCJcXFxcXFxcXFwiLFxuICBcIlwiLFxuICBcIlwiLFxuICBcIlwiLFxuICBcIlwiLFxuICBcIlwiLFxuICBcIlwiLFxuICBcIlwiLFxuICBcIlwiLFxuICBcIlwiLFxuICBcIlwiLFxuICBcIlwiLFxuICBcIlwiLFxuICBcIlwiLFxuICBcIlwiLFxuICBcIlwiLFxuICBcIlwiLFxuICBcIlwiLFxuICBcIlwiLFxuICBcIlwiLFxuICBcIlwiLFxuICBcIlwiLFxuICBcIlwiLFxuICBcIlwiLFxuICBcIlwiLFxuICBcIlwiLFxuICBcIlwiLFxuICBcIlwiLFxuICBcIlwiLFxuICBcIlwiLFxuICBcIlwiLFxuICBcIlwiLFxuICBcIlwiLFxuICBcIlwiLFxuICBcIlwiLFxuICBcIlxcXFx1MDA3RlwiLFxuICBcIlxcXFx1MDA4MFwiLFxuICBcIlxcXFx1MDA4MVwiLFxuICBcIlxcXFx1MDA4MlwiLFxuICBcIlxcXFx1MDA4M1wiLFxuICBcIlxcXFx1MDA4NFwiLFxuICBcIlxcXFx1MDA4NVwiLFxuICBcIlxcXFx1MDA4NlwiLFxuICBcIlxcXFx1MDA4N1wiLFxuICBcIlxcXFx1MDA4OFwiLFxuICBcIlxcXFx1MDA4OVwiLFxuICBcIlxcXFx1MDA4QVwiLFxuICBcIlxcXFx1MDA4QlwiLFxuICBcIlxcXFx1MDA4Q1wiLFxuICBcIlxcXFx1MDA4RFwiLFxuICBcIlxcXFx1MDA4RVwiLFxuICBcIlxcXFx1MDA4RlwiLFxuICBcIlxcXFx1MDA5MFwiLFxuICBcIlxcXFx1MDA5MVwiLFxuICBcIlxcXFx1MDA5MlwiLFxuICBcIlxcXFx1MDA5M1wiLFxuICBcIlxcXFx1MDA5NFwiLFxuICBcIlxcXFx1MDA5NVwiLFxuICBcIlxcXFx1MDA5NlwiLFxuICBcIlxcXFx1MDA5N1wiLFxuICBcIlxcXFx1MDA5OFwiLFxuICBcIlxcXFx1MDA5OVwiLFxuICBcIlxcXFx1MDA5QVwiLFxuICBcIlxcXFx1MDA5QlwiLFxuICBcIlxcXFx1MDA5Q1wiLFxuICBcIlxcXFx1MDA5RFwiLFxuICBcIlxcXFx1MDA5RVwiLFxuICBcIlxcXFx1MDA5RlwiXG5dO1xuZnVuY3Rpb24gZGV2QXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBjb25zdCBib29sZWFuQ29uZGl0aW9uID0gQm9vbGVhbihjb25kaXRpb24pO1xuICBpZiAoIWJvb2xlYW5Db25kaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbn1cbl9fbmFtZShkZXZBc3NlcnQsIFwiZGV2QXNzZXJ0XCIpO1xuY29uc3QgUXVlcnlEb2N1bWVudEtleXMgPSB7XG4gIE5hbWU6IFtdLFxuICBEb2N1bWVudDogW1wiZGVmaW5pdGlvbnNcIl0sXG4gIE9wZXJhdGlvbkRlZmluaXRpb246IFtcbiAgICBcIm5hbWVcIixcbiAgICBcInZhcmlhYmxlRGVmaW5pdGlvbnNcIixcbiAgICBcImRpcmVjdGl2ZXNcIixcbiAgICBcInNlbGVjdGlvblNldFwiXG4gIF0sXG4gIFZhcmlhYmxlRGVmaW5pdGlvbjogW1widmFyaWFibGVcIiwgXCJ0eXBlXCIsIFwiZGVmYXVsdFZhbHVlXCIsIFwiZGlyZWN0aXZlc1wiXSxcbiAgVmFyaWFibGU6IFtcIm5hbWVcIl0sXG4gIFNlbGVjdGlvblNldDogW1wic2VsZWN0aW9uc1wiXSxcbiAgRmllbGQ6IFtcImFsaWFzXCIsIFwibmFtZVwiLCBcImFyZ3VtZW50c1wiLCBcImRpcmVjdGl2ZXNcIiwgXCJzZWxlY3Rpb25TZXRcIl0sXG4gIEFyZ3VtZW50OiBbXCJuYW1lXCIsIFwidmFsdWVcIl0sXG4gIEZyYWdtZW50U3ByZWFkOiBbXCJuYW1lXCIsIFwiZGlyZWN0aXZlc1wiXSxcbiAgSW5saW5lRnJhZ21lbnQ6IFtcInR5cGVDb25kaXRpb25cIiwgXCJkaXJlY3RpdmVzXCIsIFwic2VsZWN0aW9uU2V0XCJdLFxuICBGcmFnbWVudERlZmluaXRpb246IFtcbiAgICBcIm5hbWVcIixcbiAgICBcInZhcmlhYmxlRGVmaW5pdGlvbnNcIixcbiAgICBcInR5cGVDb25kaXRpb25cIixcbiAgICBcImRpcmVjdGl2ZXNcIixcbiAgICBcInNlbGVjdGlvblNldFwiXG4gIF0sXG4gIEludFZhbHVlOiBbXSxcbiAgRmxvYXRWYWx1ZTogW10sXG4gIFN0cmluZ1ZhbHVlOiBbXSxcbiAgQm9vbGVhblZhbHVlOiBbXSxcbiAgTnVsbFZhbHVlOiBbXSxcbiAgRW51bVZhbHVlOiBbXSxcbiAgTGlzdFZhbHVlOiBbXCJ2YWx1ZXNcIl0sXG4gIE9iamVjdFZhbHVlOiBbXCJmaWVsZHNcIl0sXG4gIE9iamVjdEZpZWxkOiBbXCJuYW1lXCIsIFwidmFsdWVcIl0sXG4gIERpcmVjdGl2ZTogW1wibmFtZVwiLCBcImFyZ3VtZW50c1wiXSxcbiAgTmFtZWRUeXBlOiBbXCJuYW1lXCJdLFxuICBMaXN0VHlwZTogW1widHlwZVwiXSxcbiAgTm9uTnVsbFR5cGU6IFtcInR5cGVcIl0sXG4gIFNjaGVtYURlZmluaXRpb246IFtcImRlc2NyaXB0aW9uXCIsIFwiZGlyZWN0aXZlc1wiLCBcIm9wZXJhdGlvblR5cGVzXCJdLFxuICBPcGVyYXRpb25UeXBlRGVmaW5pdGlvbjogW1widHlwZVwiXSxcbiAgU2NhbGFyVHlwZURlZmluaXRpb246IFtcImRlc2NyaXB0aW9uXCIsIFwibmFtZVwiLCBcImRpcmVjdGl2ZXNcIl0sXG4gIE9iamVjdFR5cGVEZWZpbml0aW9uOiBbXG4gICAgXCJkZXNjcmlwdGlvblwiLFxuICAgIFwibmFtZVwiLFxuICAgIFwiaW50ZXJmYWNlc1wiLFxuICAgIFwiZGlyZWN0aXZlc1wiLFxuICAgIFwiZmllbGRzXCJcbiAgXSxcbiAgRmllbGREZWZpbml0aW9uOiBbXCJkZXNjcmlwdGlvblwiLCBcIm5hbWVcIiwgXCJhcmd1bWVudHNcIiwgXCJ0eXBlXCIsIFwiZGlyZWN0aXZlc1wiXSxcbiAgSW5wdXRWYWx1ZURlZmluaXRpb246IFtcbiAgICBcImRlc2NyaXB0aW9uXCIsXG4gICAgXCJuYW1lXCIsXG4gICAgXCJ0eXBlXCIsXG4gICAgXCJkZWZhdWx0VmFsdWVcIixcbiAgICBcImRpcmVjdGl2ZXNcIlxuICBdLFxuICBJbnRlcmZhY2VUeXBlRGVmaW5pdGlvbjogW1xuICAgIFwiZGVzY3JpcHRpb25cIixcbiAgICBcIm5hbWVcIixcbiAgICBcImludGVyZmFjZXNcIixcbiAgICBcImRpcmVjdGl2ZXNcIixcbiAgICBcImZpZWxkc1wiXG4gIF0sXG4gIFVuaW9uVHlwZURlZmluaXRpb246IFtcImRlc2NyaXB0aW9uXCIsIFwibmFtZVwiLCBcImRpcmVjdGl2ZXNcIiwgXCJ0eXBlc1wiXSxcbiAgRW51bVR5cGVEZWZpbml0aW9uOiBbXCJkZXNjcmlwdGlvblwiLCBcIm5hbWVcIiwgXCJkaXJlY3RpdmVzXCIsIFwidmFsdWVzXCJdLFxuICBFbnVtVmFsdWVEZWZpbml0aW9uOiBbXCJkZXNjcmlwdGlvblwiLCBcIm5hbWVcIiwgXCJkaXJlY3RpdmVzXCJdLFxuICBJbnB1dE9iamVjdFR5cGVEZWZpbml0aW9uOiBbXCJkZXNjcmlwdGlvblwiLCBcIm5hbWVcIiwgXCJkaXJlY3RpdmVzXCIsIFwiZmllbGRzXCJdLFxuICBEaXJlY3RpdmVEZWZpbml0aW9uOiBbXCJkZXNjcmlwdGlvblwiLCBcIm5hbWVcIiwgXCJhcmd1bWVudHNcIiwgXCJsb2NhdGlvbnNcIl0sXG4gIFNjaGVtYUV4dGVuc2lvbjogW1wiZGlyZWN0aXZlc1wiLCBcIm9wZXJhdGlvblR5cGVzXCJdLFxuICBTY2FsYXJUeXBlRXh0ZW5zaW9uOiBbXCJuYW1lXCIsIFwiZGlyZWN0aXZlc1wiXSxcbiAgT2JqZWN0VHlwZUV4dGVuc2lvbjogW1wibmFtZVwiLCBcImludGVyZmFjZXNcIiwgXCJkaXJlY3RpdmVzXCIsIFwiZmllbGRzXCJdLFxuICBJbnRlcmZhY2VUeXBlRXh0ZW5zaW9uOiBbXCJuYW1lXCIsIFwiaW50ZXJmYWNlc1wiLCBcImRpcmVjdGl2ZXNcIiwgXCJmaWVsZHNcIl0sXG4gIFVuaW9uVHlwZUV4dGVuc2lvbjogW1wibmFtZVwiLCBcImRpcmVjdGl2ZXNcIiwgXCJ0eXBlc1wiXSxcbiAgRW51bVR5cGVFeHRlbnNpb246IFtcIm5hbWVcIiwgXCJkaXJlY3RpdmVzXCIsIFwidmFsdWVzXCJdLFxuICBJbnB1dE9iamVjdFR5cGVFeHRlbnNpb246IFtcIm5hbWVcIiwgXCJkaXJlY3RpdmVzXCIsIFwiZmllbGRzXCJdXG59O1xuY29uc3Qga2luZFZhbHVlcyA9IG5ldyBTZXQoT2JqZWN0LmtleXMoUXVlcnlEb2N1bWVudEtleXMpKTtcbmZ1bmN0aW9uIGlzTm9kZShtYXliZU5vZGUpIHtcbiAgY29uc3QgbWF5YmVLaW5kID0gbWF5YmVOb2RlID09PSBudWxsIHx8IG1heWJlTm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWF5YmVOb2RlLmtpbmQ7XG4gIHJldHVybiB0eXBlb2YgbWF5YmVLaW5kID09PSBcInN0cmluZ1wiICYmIGtpbmRWYWx1ZXMuaGFzKG1heWJlS2luZCk7XG59XG5fX25hbWUoaXNOb2RlLCBcImlzTm9kZVwiKTtcbmxldCBPcGVyYXRpb25UeXBlTm9kZTtcbihmdW5jdGlvbihPcGVyYXRpb25UeXBlTm9kZTIpIHtcbiAgT3BlcmF0aW9uVHlwZU5vZGUyW1wiUVVFUllcIl0gPSBcInF1ZXJ5XCI7XG4gIE9wZXJhdGlvblR5cGVOb2RlMltcIk1VVEFUSU9OXCJdID0gXCJtdXRhdGlvblwiO1xuICBPcGVyYXRpb25UeXBlTm9kZTJbXCJTVUJTQ1JJUFRJT05cIl0gPSBcInN1YnNjcmlwdGlvblwiO1xufSkoT3BlcmF0aW9uVHlwZU5vZGUgfHwgKE9wZXJhdGlvblR5cGVOb2RlID0ge30pKTtcbmxldCBLaW5kO1xuKGZ1bmN0aW9uKEtpbmQyKSB7XG4gIEtpbmQyW1wiTkFNRVwiXSA9IFwiTmFtZVwiO1xuICBLaW5kMltcIkRPQ1VNRU5UXCJdID0gXCJEb2N1bWVudFwiO1xuICBLaW5kMltcIk9QRVJBVElPTl9ERUZJTklUSU9OXCJdID0gXCJPcGVyYXRpb25EZWZpbml0aW9uXCI7XG4gIEtpbmQyW1wiVkFSSUFCTEVfREVGSU5JVElPTlwiXSA9IFwiVmFyaWFibGVEZWZpbml0aW9uXCI7XG4gIEtpbmQyW1wiU0VMRUNUSU9OX1NFVFwiXSA9IFwiU2VsZWN0aW9uU2V0XCI7XG4gIEtpbmQyW1wiRklFTERcIl0gPSBcIkZpZWxkXCI7XG4gIEtpbmQyW1wiQVJHVU1FTlRcIl0gPSBcIkFyZ3VtZW50XCI7XG4gIEtpbmQyW1wiRlJBR01FTlRfU1BSRUFEXCJdID0gXCJGcmFnbWVudFNwcmVhZFwiO1xuICBLaW5kMltcIklOTElORV9GUkFHTUVOVFwiXSA9IFwiSW5saW5lRnJhZ21lbnRcIjtcbiAgS2luZDJbXCJGUkFHTUVOVF9ERUZJTklUSU9OXCJdID0gXCJGcmFnbWVudERlZmluaXRpb25cIjtcbiAgS2luZDJbXCJWQVJJQUJMRVwiXSA9IFwiVmFyaWFibGVcIjtcbiAgS2luZDJbXCJJTlRcIl0gPSBcIkludFZhbHVlXCI7XG4gIEtpbmQyW1wiRkxPQVRcIl0gPSBcIkZsb2F0VmFsdWVcIjtcbiAgS2luZDJbXCJTVFJJTkdcIl0gPSBcIlN0cmluZ1ZhbHVlXCI7XG4gIEtpbmQyW1wiQk9PTEVBTlwiXSA9IFwiQm9vbGVhblZhbHVlXCI7XG4gIEtpbmQyW1wiTlVMTFwiXSA9IFwiTnVsbFZhbHVlXCI7XG4gIEtpbmQyW1wiRU5VTVwiXSA9IFwiRW51bVZhbHVlXCI7XG4gIEtpbmQyW1wiTElTVFwiXSA9IFwiTGlzdFZhbHVlXCI7XG4gIEtpbmQyW1wiT0JKRUNUXCJdID0gXCJPYmplY3RWYWx1ZVwiO1xuICBLaW5kMltcIk9CSkVDVF9GSUVMRFwiXSA9IFwiT2JqZWN0RmllbGRcIjtcbiAgS2luZDJbXCJESVJFQ1RJVkVcIl0gPSBcIkRpcmVjdGl2ZVwiO1xuICBLaW5kMltcIk5BTUVEX1RZUEVcIl0gPSBcIk5hbWVkVHlwZVwiO1xuICBLaW5kMltcIkxJU1RfVFlQRVwiXSA9IFwiTGlzdFR5cGVcIjtcbiAgS2luZDJbXCJOT05fTlVMTF9UWVBFXCJdID0gXCJOb25OdWxsVHlwZVwiO1xuICBLaW5kMltcIlNDSEVNQV9ERUZJTklUSU9OXCJdID0gXCJTY2hlbWFEZWZpbml0aW9uXCI7XG4gIEtpbmQyW1wiT1BFUkFUSU9OX1RZUEVfREVGSU5JVElPTlwiXSA9IFwiT3BlcmF0aW9uVHlwZURlZmluaXRpb25cIjtcbiAgS2luZDJbXCJTQ0FMQVJfVFlQRV9ERUZJTklUSU9OXCJdID0gXCJTY2FsYXJUeXBlRGVmaW5pdGlvblwiO1xuICBLaW5kMltcIk9CSkVDVF9UWVBFX0RFRklOSVRJT05cIl0gPSBcIk9iamVjdFR5cGVEZWZpbml0aW9uXCI7XG4gIEtpbmQyW1wiRklFTERfREVGSU5JVElPTlwiXSA9IFwiRmllbGREZWZpbml0aW9uXCI7XG4gIEtpbmQyW1wiSU5QVVRfVkFMVUVfREVGSU5JVElPTlwiXSA9IFwiSW5wdXRWYWx1ZURlZmluaXRpb25cIjtcbiAgS2luZDJbXCJJTlRFUkZBQ0VfVFlQRV9ERUZJTklUSU9OXCJdID0gXCJJbnRlcmZhY2VUeXBlRGVmaW5pdGlvblwiO1xuICBLaW5kMltcIlVOSU9OX1RZUEVfREVGSU5JVElPTlwiXSA9IFwiVW5pb25UeXBlRGVmaW5pdGlvblwiO1xuICBLaW5kMltcIkVOVU1fVFlQRV9ERUZJTklUSU9OXCJdID0gXCJFbnVtVHlwZURlZmluaXRpb25cIjtcbiAgS2luZDJbXCJFTlVNX1ZBTFVFX0RFRklOSVRJT05cIl0gPSBcIkVudW1WYWx1ZURlZmluaXRpb25cIjtcbiAgS2luZDJbXCJJTlBVVF9PQkpFQ1RfVFlQRV9ERUZJTklUSU9OXCJdID0gXCJJbnB1dE9iamVjdFR5cGVEZWZpbml0aW9uXCI7XG4gIEtpbmQyW1wiRElSRUNUSVZFX0RFRklOSVRJT05cIl0gPSBcIkRpcmVjdGl2ZURlZmluaXRpb25cIjtcbiAgS2luZDJbXCJTQ0hFTUFfRVhURU5TSU9OXCJdID0gXCJTY2hlbWFFeHRlbnNpb25cIjtcbiAgS2luZDJbXCJTQ0FMQVJfVFlQRV9FWFRFTlNJT05cIl0gPSBcIlNjYWxhclR5cGVFeHRlbnNpb25cIjtcbiAgS2luZDJbXCJPQkpFQ1RfVFlQRV9FWFRFTlNJT05cIl0gPSBcIk9iamVjdFR5cGVFeHRlbnNpb25cIjtcbiAgS2luZDJbXCJJTlRFUkZBQ0VfVFlQRV9FWFRFTlNJT05cIl0gPSBcIkludGVyZmFjZVR5cGVFeHRlbnNpb25cIjtcbiAgS2luZDJbXCJVTklPTl9UWVBFX0VYVEVOU0lPTlwiXSA9IFwiVW5pb25UeXBlRXh0ZW5zaW9uXCI7XG4gIEtpbmQyW1wiRU5VTV9UWVBFX0VYVEVOU0lPTlwiXSA9IFwiRW51bVR5cGVFeHRlbnNpb25cIjtcbiAgS2luZDJbXCJJTlBVVF9PQkpFQ1RfVFlQRV9FWFRFTlNJT05cIl0gPSBcIklucHV0T2JqZWN0VHlwZUV4dGVuc2lvblwiO1xufSkoS2luZCB8fCAoS2luZCA9IHt9KSk7XG5jb25zdCBCUkVBSyA9IE9iamVjdC5mcmVlemUoe30pO1xuZnVuY3Rpb24gdmlzaXQocm9vdCwgdmlzaXRvciwgdmlzaXRvcktleXMgPSBRdWVyeURvY3VtZW50S2V5cykge1xuICBjb25zdCBlbnRlckxlYXZlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZm9yIChjb25zdCBraW5kIG9mIE9iamVjdC52YWx1ZXMoS2luZCkpIHtcbiAgICBlbnRlckxlYXZlTWFwLnNldChraW5kLCBnZXRFbnRlckxlYXZlRm9yS2luZCh2aXNpdG9yLCBraW5kKSk7XG4gIH1cbiAgbGV0IHN0YWNrID0gdm9pZCAwO1xuICBsZXQgaW5BcnJheSA9IEFycmF5LmlzQXJyYXkocm9vdCk7XG4gIGxldCBrZXlzID0gW3Jvb3RdO1xuICBsZXQgaW5kZXggPSAtMTtcbiAgbGV0IGVkaXRzID0gW107XG4gIGxldCBub2RlID0gcm9vdDtcbiAgbGV0IGtleSA9IHZvaWQgMDtcbiAgbGV0IHBhcmVudCA9IHZvaWQgMDtcbiAgY29uc3QgcGF0aCA9IFtdO1xuICBjb25zdCBhbmNlc3RvcnMgPSBbXTtcbiAgZG8ge1xuICAgIGluZGV4Kys7XG4gICAgY29uc3QgaXNMZWF2aW5nID0gaW5kZXggPT09IGtleXMubGVuZ3RoO1xuICAgIGNvbnN0IGlzRWRpdGVkID0gaXNMZWF2aW5nICYmIGVkaXRzLmxlbmd0aCAhPT0gMDtcbiAgICBpZiAoaXNMZWF2aW5nKSB7XG4gICAgICBrZXkgPSBhbmNlc3RvcnMubGVuZ3RoID09PSAwID8gdm9pZCAwIDogcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgIHBhcmVudCA9IGFuY2VzdG9ycy5wb3AoKTtcbiAgICAgIGlmIChpc0VkaXRlZCkge1xuICAgICAgICBpZiAoaW5BcnJheSkge1xuICAgICAgICAgIG5vZGUgPSBub2RlLnNsaWNlKCk7XG4gICAgICAgICAgbGV0IGVkaXRPZmZzZXQgPSAwO1xuICAgICAgICAgIGZvciAoY29uc3QgW2VkaXRLZXksIGVkaXRWYWx1ZV0gb2YgZWRpdHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGFycmF5S2V5ID0gZWRpdEtleSAtIGVkaXRPZmZzZXQ7XG4gICAgICAgICAgICBpZiAoZWRpdFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIG5vZGUuc3BsaWNlKGFycmF5S2V5LCAxKTtcbiAgICAgICAgICAgICAgZWRpdE9mZnNldCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbm9kZVthcnJheUtleV0gPSBlZGl0VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh7fSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMobm9kZSkpO1xuICAgICAgICAgIGZvciAoY29uc3QgW2VkaXRLZXksIGVkaXRWYWx1ZV0gb2YgZWRpdHMpIHtcbiAgICAgICAgICAgIG5vZGVbZWRpdEtleV0gPSBlZGl0VmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpbmRleCA9IHN0YWNrLmluZGV4O1xuICAgICAga2V5cyA9IHN0YWNrLmtleXM7XG4gICAgICBlZGl0cyA9IHN0YWNrLmVkaXRzO1xuICAgICAgaW5BcnJheSA9IHN0YWNrLmluQXJyYXk7XG4gICAgICBzdGFjayA9IHN0YWNrLnByZXY7XG4gICAgfSBlbHNlIGlmIChwYXJlbnQpIHtcbiAgICAgIGtleSA9IGluQXJyYXkgPyBpbmRleCA6IGtleXNbaW5kZXhdO1xuICAgICAgbm9kZSA9IHBhcmVudFtrZXldO1xuICAgICAgaWYgKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcGF0aC5wdXNoKGtleSk7XG4gICAgfVxuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgICB2YXIgX2VudGVyTGVhdmVNYXAkZ2V0LCBfZW50ZXJMZWF2ZU1hcCRnZXQyO1xuICAgICAgaXNOb2RlKG5vZGUpIHx8IGRldkFzc2VydChmYWxzZSwgYEludmFsaWQgQVNUIE5vZGU6ICR7aW5zcGVjdChub2RlKX0uYCk7XG4gICAgICBjb25zdCB2aXNpdEZuID0gaXNMZWF2aW5nID8gKF9lbnRlckxlYXZlTWFwJGdldCA9IGVudGVyTGVhdmVNYXAuZ2V0KG5vZGUua2luZCkpID09PSBudWxsIHx8IF9lbnRlckxlYXZlTWFwJGdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2VudGVyTGVhdmVNYXAkZ2V0LmxlYXZlIDogKF9lbnRlckxlYXZlTWFwJGdldDIgPSBlbnRlckxlYXZlTWFwLmdldChub2RlLmtpbmQpKSA9PT0gbnVsbCB8fCBfZW50ZXJMZWF2ZU1hcCRnZXQyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZW50ZXJMZWF2ZU1hcCRnZXQyLmVudGVyO1xuICAgICAgcmVzdWx0ID0gdmlzaXRGbiA9PT0gbnVsbCB8fCB2aXNpdEZuID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aXNpdEZuLmNhbGwodmlzaXRvciwgbm9kZSwga2V5LCBwYXJlbnQsIHBhdGgsIGFuY2VzdG9ycyk7XG4gICAgICBpZiAocmVzdWx0ID09PSBCUkVBSykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgIGlmICghaXNMZWF2aW5nKSB7XG4gICAgICAgICAgcGF0aC5wb3AoKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyZXN1bHQgIT09IHZvaWQgMCkge1xuICAgICAgICBlZGl0cy5wdXNoKFtrZXksIHJlc3VsdF0pO1xuICAgICAgICBpZiAoIWlzTGVhdmluZykge1xuICAgICAgICAgIGlmIChpc05vZGUocmVzdWx0KSkge1xuICAgICAgICAgICAgbm9kZSA9IHJlc3VsdDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF0aC5wb3AoKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVzdWx0ID09PSB2b2lkIDAgJiYgaXNFZGl0ZWQpIHtcbiAgICAgIGVkaXRzLnB1c2goW2tleSwgbm9kZV0pO1xuICAgIH1cbiAgICBpZiAoaXNMZWF2aW5nKSB7XG4gICAgICBwYXRoLnBvcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX25vZGUka2luZDtcbiAgICAgIHN0YWNrID0ge1xuICAgICAgICBpbkFycmF5LFxuICAgICAgICBpbmRleCxcbiAgICAgICAga2V5cyxcbiAgICAgICAgZWRpdHMsXG4gICAgICAgIHByZXY6IHN0YWNrXG4gICAgICB9O1xuICAgICAgaW5BcnJheSA9IEFycmF5LmlzQXJyYXkobm9kZSk7XG4gICAgICBrZXlzID0gaW5BcnJheSA/IG5vZGUgOiAoX25vZGUka2luZCA9IHZpc2l0b3JLZXlzW25vZGUua2luZF0pICE9PSBudWxsICYmIF9ub2RlJGtpbmQgIT09IHZvaWQgMCA/IF9ub2RlJGtpbmQgOiBbXTtcbiAgICAgIGluZGV4ID0gLTE7XG4gICAgICBlZGl0cyA9IFtdO1xuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICBhbmNlc3RvcnMucHVzaChwYXJlbnQpO1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gbm9kZTtcbiAgICB9XG4gIH0gd2hpbGUgKHN0YWNrICE9PSB2b2lkIDApO1xuICBpZiAoZWRpdHMubGVuZ3RoICE9PSAwKSB7XG4gICAgcmV0dXJuIGVkaXRzW2VkaXRzLmxlbmd0aCAtIDFdWzFdO1xuICB9XG4gIHJldHVybiByb290O1xufVxuX19uYW1lKHZpc2l0LCBcInZpc2l0XCIpO1xuZnVuY3Rpb24gZ2V0RW50ZXJMZWF2ZUZvcktpbmQodmlzaXRvciwga2luZCkge1xuICBjb25zdCBraW5kVmlzaXRvciA9IHZpc2l0b3Jba2luZF07XG4gIGlmICh0eXBlb2Yga2luZFZpc2l0b3IgPT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4ga2luZFZpc2l0b3I7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGtpbmRWaXNpdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZW50ZXI6IGtpbmRWaXNpdG9yLFxuICAgICAgbGVhdmU6IHZvaWQgMFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBlbnRlcjogdmlzaXRvci5lbnRlcixcbiAgICBsZWF2ZTogdmlzaXRvci5sZWF2ZVxuICB9O1xufVxuX19uYW1lKGdldEVudGVyTGVhdmVGb3JLaW5kLCBcImdldEVudGVyTGVhdmVGb3JLaW5kXCIpO1xuZnVuY3Rpb24gcHJpbnQoYXN0KSB7XG4gIHJldHVybiB2aXNpdChhc3QsIHByaW50RG9jQVNUUmVkdWNlcik7XG59XG5fX25hbWUocHJpbnQsIFwicHJpbnRcIik7XG5jb25zdCBNQVhfTElORV9MRU5HVEggPSA4MDtcbmNvbnN0IHByaW50RG9jQVNUUmVkdWNlciA9IHtcbiAgTmFtZToge1xuICAgIGxlYXZlOiAobm9kZSkgPT4gbm9kZS52YWx1ZVxuICB9LFxuICBWYXJpYWJsZToge1xuICAgIGxlYXZlOiAobm9kZSkgPT4gXCIkXCIgKyBub2RlLm5hbWVcbiAgfSxcbiAgRG9jdW1lbnQ6IHtcbiAgICBsZWF2ZTogKG5vZGUpID0+IGpvaW4obm9kZS5kZWZpbml0aW9ucywgXCJcXG5cXG5cIilcbiAgfSxcbiAgT3BlcmF0aW9uRGVmaW5pdGlvbjoge1xuICAgIGxlYXZlKG5vZGUpIHtcbiAgICAgIGNvbnN0IHZhckRlZnMgPSB3cmFwKFwiKFwiLCBqb2luKG5vZGUudmFyaWFibGVEZWZpbml0aW9ucywgXCIsIFwiKSwgXCIpXCIpO1xuICAgICAgY29uc3QgcHJlZml4ID0gam9pbihbXG4gICAgICAgIG5vZGUub3BlcmF0aW9uLFxuICAgICAgICBqb2luKFtub2RlLm5hbWUsIHZhckRlZnNdKSxcbiAgICAgICAgam9pbihub2RlLmRpcmVjdGl2ZXMsIFwiIFwiKVxuICAgICAgXSwgXCIgXCIpO1xuICAgICAgcmV0dXJuIChwcmVmaXggPT09IFwicXVlcnlcIiA/IFwiXCIgOiBwcmVmaXggKyBcIiBcIikgKyBub2RlLnNlbGVjdGlvblNldDtcbiAgICB9XG4gIH0sXG4gIFZhcmlhYmxlRGVmaW5pdGlvbjoge1xuICAgIGxlYXZlOiAoeyB2YXJpYWJsZSwgdHlwZSwgZGVmYXVsdFZhbHVlLCBkaXJlY3RpdmVzIH0pID0+IHZhcmlhYmxlICsgXCI6IFwiICsgdHlwZSArIHdyYXAoXCIgPSBcIiwgZGVmYXVsdFZhbHVlKSArIHdyYXAoXCIgXCIsIGpvaW4oZGlyZWN0aXZlcywgXCIgXCIpKVxuICB9LFxuICBTZWxlY3Rpb25TZXQ6IHtcbiAgICBsZWF2ZTogKHsgc2VsZWN0aW9ucyB9KSA9PiBibG9jayhzZWxlY3Rpb25zKVxuICB9LFxuICBGaWVsZDoge1xuICAgIGxlYXZlKHsgYWxpYXMsIG5hbWUsIGFyZ3VtZW50czogYXJncywgZGlyZWN0aXZlcywgc2VsZWN0aW9uU2V0IH0pIHtcbiAgICAgIGNvbnN0IHByZWZpeCA9IHdyYXAoXCJcIiwgYWxpYXMsIFwiOiBcIikgKyBuYW1lO1xuICAgICAgbGV0IGFyZ3NMaW5lID0gcHJlZml4ICsgd3JhcChcIihcIiwgam9pbihhcmdzLCBcIiwgXCIpLCBcIilcIik7XG4gICAgICBpZiAoYXJnc0xpbmUubGVuZ3RoID4gTUFYX0xJTkVfTEVOR1RIKSB7XG4gICAgICAgIGFyZ3NMaW5lID0gcHJlZml4ICsgd3JhcChcIihcXG5cIiwgaW5kZW50KGpvaW4oYXJncywgXCJcXG5cIikpLCBcIlxcbilcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gam9pbihbYXJnc0xpbmUsIGpvaW4oZGlyZWN0aXZlcywgXCIgXCIpLCBzZWxlY3Rpb25TZXRdLCBcIiBcIik7XG4gICAgfVxuICB9LFxuICBBcmd1bWVudDoge1xuICAgIGxlYXZlOiAoeyBuYW1lLCB2YWx1ZSB9KSA9PiBuYW1lICsgXCI6IFwiICsgdmFsdWVcbiAgfSxcbiAgRnJhZ21lbnRTcHJlYWQ6IHtcbiAgICBsZWF2ZTogKHsgbmFtZSwgZGlyZWN0aXZlcyB9KSA9PiBcIi4uLlwiICsgbmFtZSArIHdyYXAoXCIgXCIsIGpvaW4oZGlyZWN0aXZlcywgXCIgXCIpKVxuICB9LFxuICBJbmxpbmVGcmFnbWVudDoge1xuICAgIGxlYXZlOiAoeyB0eXBlQ29uZGl0aW9uLCBkaXJlY3RpdmVzLCBzZWxlY3Rpb25TZXQgfSkgPT4gam9pbihbXG4gICAgICBcIi4uLlwiLFxuICAgICAgd3JhcChcIm9uIFwiLCB0eXBlQ29uZGl0aW9uKSxcbiAgICAgIGpvaW4oZGlyZWN0aXZlcywgXCIgXCIpLFxuICAgICAgc2VsZWN0aW9uU2V0XG4gICAgXSwgXCIgXCIpXG4gIH0sXG4gIEZyYWdtZW50RGVmaW5pdGlvbjoge1xuICAgIGxlYXZlOiAoeyBuYW1lLCB0eXBlQ29uZGl0aW9uLCB2YXJpYWJsZURlZmluaXRpb25zLCBkaXJlY3RpdmVzLCBzZWxlY3Rpb25TZXQgfSkgPT4gYGZyYWdtZW50ICR7bmFtZX0ke3dyYXAoXCIoXCIsIGpvaW4odmFyaWFibGVEZWZpbml0aW9ucywgXCIsIFwiKSwgXCIpXCIpfSBvbiAke3R5cGVDb25kaXRpb259ICR7d3JhcChcIlwiLCBqb2luKGRpcmVjdGl2ZXMsIFwiIFwiKSwgXCIgXCIpfWAgKyBzZWxlY3Rpb25TZXRcbiAgfSxcbiAgSW50VmFsdWU6IHtcbiAgICBsZWF2ZTogKHsgdmFsdWUgfSkgPT4gdmFsdWVcbiAgfSxcbiAgRmxvYXRWYWx1ZToge1xuICAgIGxlYXZlOiAoeyB2YWx1ZSB9KSA9PiB2YWx1ZVxuICB9LFxuICBTdHJpbmdWYWx1ZToge1xuICAgIGxlYXZlOiAoeyB2YWx1ZSwgYmxvY2s6IGlzQmxvY2tTdHJpbmcgfSkgPT4gaXNCbG9ja1N0cmluZyA/IHByaW50QmxvY2tTdHJpbmcodmFsdWUpIDogcHJpbnRTdHJpbmcodmFsdWUpXG4gIH0sXG4gIEJvb2xlYW5WYWx1ZToge1xuICAgIGxlYXZlOiAoeyB2YWx1ZSB9KSA9PiB2YWx1ZSA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiXG4gIH0sXG4gIE51bGxWYWx1ZToge1xuICAgIGxlYXZlOiAoKSA9PiBcIm51bGxcIlxuICB9LFxuICBFbnVtVmFsdWU6IHtcbiAgICBsZWF2ZTogKHsgdmFsdWUgfSkgPT4gdmFsdWVcbiAgfSxcbiAgTGlzdFZhbHVlOiB7XG4gICAgbGVhdmU6ICh7IHZhbHVlcyB9KSA9PiBcIltcIiArIGpvaW4odmFsdWVzLCBcIiwgXCIpICsgXCJdXCJcbiAgfSxcbiAgT2JqZWN0VmFsdWU6IHtcbiAgICBsZWF2ZTogKHsgZmllbGRzIH0pID0+IFwie1wiICsgam9pbihmaWVsZHMsIFwiLCBcIikgKyBcIn1cIlxuICB9LFxuICBPYmplY3RGaWVsZDoge1xuICAgIGxlYXZlOiAoeyBuYW1lLCB2YWx1ZSB9KSA9PiBuYW1lICsgXCI6IFwiICsgdmFsdWVcbiAgfSxcbiAgRGlyZWN0aXZlOiB7XG4gICAgbGVhdmU6ICh7IG5hbWUsIGFyZ3VtZW50czogYXJncyB9KSA9PiBcIkBcIiArIG5hbWUgKyB3cmFwKFwiKFwiLCBqb2luKGFyZ3MsIFwiLCBcIiksIFwiKVwiKVxuICB9LFxuICBOYW1lZFR5cGU6IHtcbiAgICBsZWF2ZTogKHsgbmFtZSB9KSA9PiBuYW1lXG4gIH0sXG4gIExpc3RUeXBlOiB7XG4gICAgbGVhdmU6ICh7IHR5cGUgfSkgPT4gXCJbXCIgKyB0eXBlICsgXCJdXCJcbiAgfSxcbiAgTm9uTnVsbFR5cGU6IHtcbiAgICBsZWF2ZTogKHsgdHlwZSB9KSA9PiB0eXBlICsgXCIhXCJcbiAgfSxcbiAgU2NoZW1hRGVmaW5pdGlvbjoge1xuICAgIGxlYXZlOiAoeyBkZXNjcmlwdGlvbiwgZGlyZWN0aXZlcywgb3BlcmF0aW9uVHlwZXMgfSkgPT4gd3JhcChcIlwiLCBkZXNjcmlwdGlvbiwgXCJcXG5cIikgKyBqb2luKFtcInNjaGVtYVwiLCBqb2luKGRpcmVjdGl2ZXMsIFwiIFwiKSwgYmxvY2sob3BlcmF0aW9uVHlwZXMpXSwgXCIgXCIpXG4gIH0sXG4gIE9wZXJhdGlvblR5cGVEZWZpbml0aW9uOiB7XG4gICAgbGVhdmU6ICh7IG9wZXJhdGlvbiwgdHlwZSB9KSA9PiBvcGVyYXRpb24gKyBcIjogXCIgKyB0eXBlXG4gIH0sXG4gIFNjYWxhclR5cGVEZWZpbml0aW9uOiB7XG4gICAgbGVhdmU6ICh7IGRlc2NyaXB0aW9uLCBuYW1lLCBkaXJlY3RpdmVzIH0pID0+IHdyYXAoXCJcIiwgZGVzY3JpcHRpb24sIFwiXFxuXCIpICsgam9pbihbXCJzY2FsYXJcIiwgbmFtZSwgam9pbihkaXJlY3RpdmVzLCBcIiBcIildLCBcIiBcIilcbiAgfSxcbiAgT2JqZWN0VHlwZURlZmluaXRpb246IHtcbiAgICBsZWF2ZTogKHsgZGVzY3JpcHRpb24sIG5hbWUsIGludGVyZmFjZXMsIGRpcmVjdGl2ZXMsIGZpZWxkcyB9KSA9PiB3cmFwKFwiXCIsIGRlc2NyaXB0aW9uLCBcIlxcblwiKSArIGpvaW4oW1xuICAgICAgXCJ0eXBlXCIsXG4gICAgICBuYW1lLFxuICAgICAgd3JhcChcImltcGxlbWVudHMgXCIsIGpvaW4oaW50ZXJmYWNlcywgXCIgJiBcIikpLFxuICAgICAgam9pbihkaXJlY3RpdmVzLCBcIiBcIiksXG4gICAgICBibG9jayhmaWVsZHMpXG4gICAgXSwgXCIgXCIpXG4gIH0sXG4gIEZpZWxkRGVmaW5pdGlvbjoge1xuICAgIGxlYXZlOiAoeyBkZXNjcmlwdGlvbiwgbmFtZSwgYXJndW1lbnRzOiBhcmdzLCB0eXBlLCBkaXJlY3RpdmVzIH0pID0+IHdyYXAoXCJcIiwgZGVzY3JpcHRpb24sIFwiXFxuXCIpICsgbmFtZSArIChoYXNNdWx0aWxpbmVJdGVtcyhhcmdzKSA/IHdyYXAoXCIoXFxuXCIsIGluZGVudChqb2luKGFyZ3MsIFwiXFxuXCIpKSwgXCJcXG4pXCIpIDogd3JhcChcIihcIiwgam9pbihhcmdzLCBcIiwgXCIpLCBcIilcIikpICsgXCI6IFwiICsgdHlwZSArIHdyYXAoXCIgXCIsIGpvaW4oZGlyZWN0aXZlcywgXCIgXCIpKVxuICB9LFxuICBJbnB1dFZhbHVlRGVmaW5pdGlvbjoge1xuICAgIGxlYXZlOiAoeyBkZXNjcmlwdGlvbiwgbmFtZSwgdHlwZSwgZGVmYXVsdFZhbHVlLCBkaXJlY3RpdmVzIH0pID0+IHdyYXAoXCJcIiwgZGVzY3JpcHRpb24sIFwiXFxuXCIpICsgam9pbihbbmFtZSArIFwiOiBcIiArIHR5cGUsIHdyYXAoXCI9IFwiLCBkZWZhdWx0VmFsdWUpLCBqb2luKGRpcmVjdGl2ZXMsIFwiIFwiKV0sIFwiIFwiKVxuICB9LFxuICBJbnRlcmZhY2VUeXBlRGVmaW5pdGlvbjoge1xuICAgIGxlYXZlOiAoeyBkZXNjcmlwdGlvbiwgbmFtZSwgaW50ZXJmYWNlcywgZGlyZWN0aXZlcywgZmllbGRzIH0pID0+IHdyYXAoXCJcIiwgZGVzY3JpcHRpb24sIFwiXFxuXCIpICsgam9pbihbXG4gICAgICBcImludGVyZmFjZVwiLFxuICAgICAgbmFtZSxcbiAgICAgIHdyYXAoXCJpbXBsZW1lbnRzIFwiLCBqb2luKGludGVyZmFjZXMsIFwiICYgXCIpKSxcbiAgICAgIGpvaW4oZGlyZWN0aXZlcywgXCIgXCIpLFxuICAgICAgYmxvY2soZmllbGRzKVxuICAgIF0sIFwiIFwiKVxuICB9LFxuICBVbmlvblR5cGVEZWZpbml0aW9uOiB7XG4gICAgbGVhdmU6ICh7IGRlc2NyaXB0aW9uLCBuYW1lLCBkaXJlY3RpdmVzLCB0eXBlcyB9KSA9PiB3cmFwKFwiXCIsIGRlc2NyaXB0aW9uLCBcIlxcblwiKSArIGpvaW4oW1widW5pb25cIiwgbmFtZSwgam9pbihkaXJlY3RpdmVzLCBcIiBcIiksIHdyYXAoXCI9IFwiLCBqb2luKHR5cGVzLCBcIiB8IFwiKSldLCBcIiBcIilcbiAgfSxcbiAgRW51bVR5cGVEZWZpbml0aW9uOiB7XG4gICAgbGVhdmU6ICh7IGRlc2NyaXB0aW9uLCBuYW1lLCBkaXJlY3RpdmVzLCB2YWx1ZXMgfSkgPT4gd3JhcChcIlwiLCBkZXNjcmlwdGlvbiwgXCJcXG5cIikgKyBqb2luKFtcImVudW1cIiwgbmFtZSwgam9pbihkaXJlY3RpdmVzLCBcIiBcIiksIGJsb2NrKHZhbHVlcyldLCBcIiBcIilcbiAgfSxcbiAgRW51bVZhbHVlRGVmaW5pdGlvbjoge1xuICAgIGxlYXZlOiAoeyBkZXNjcmlwdGlvbiwgbmFtZSwgZGlyZWN0aXZlcyB9KSA9PiB3cmFwKFwiXCIsIGRlc2NyaXB0aW9uLCBcIlxcblwiKSArIGpvaW4oW25hbWUsIGpvaW4oZGlyZWN0aXZlcywgXCIgXCIpXSwgXCIgXCIpXG4gIH0sXG4gIElucHV0T2JqZWN0VHlwZURlZmluaXRpb246IHtcbiAgICBsZWF2ZTogKHsgZGVzY3JpcHRpb24sIG5hbWUsIGRpcmVjdGl2ZXMsIGZpZWxkcyB9KSA9PiB3cmFwKFwiXCIsIGRlc2NyaXB0aW9uLCBcIlxcblwiKSArIGpvaW4oW1wiaW5wdXRcIiwgbmFtZSwgam9pbihkaXJlY3RpdmVzLCBcIiBcIiksIGJsb2NrKGZpZWxkcyldLCBcIiBcIilcbiAgfSxcbiAgRGlyZWN0aXZlRGVmaW5pdGlvbjoge1xuICAgIGxlYXZlOiAoeyBkZXNjcmlwdGlvbiwgbmFtZSwgYXJndW1lbnRzOiBhcmdzLCByZXBlYXRhYmxlLCBsb2NhdGlvbnMgfSkgPT4gd3JhcChcIlwiLCBkZXNjcmlwdGlvbiwgXCJcXG5cIikgKyBcImRpcmVjdGl2ZSBAXCIgKyBuYW1lICsgKGhhc011bHRpbGluZUl0ZW1zKGFyZ3MpID8gd3JhcChcIihcXG5cIiwgaW5kZW50KGpvaW4oYXJncywgXCJcXG5cIikpLCBcIlxcbilcIikgOiB3cmFwKFwiKFwiLCBqb2luKGFyZ3MsIFwiLCBcIiksIFwiKVwiKSkgKyAocmVwZWF0YWJsZSA/IFwiIHJlcGVhdGFibGVcIiA6IFwiXCIpICsgXCIgb24gXCIgKyBqb2luKGxvY2F0aW9ucywgXCIgfCBcIilcbiAgfSxcbiAgU2NoZW1hRXh0ZW5zaW9uOiB7XG4gICAgbGVhdmU6ICh7IGRpcmVjdGl2ZXMsIG9wZXJhdGlvblR5cGVzIH0pID0+IGpvaW4oW1wiZXh0ZW5kIHNjaGVtYVwiLCBqb2luKGRpcmVjdGl2ZXMsIFwiIFwiKSwgYmxvY2sob3BlcmF0aW9uVHlwZXMpXSwgXCIgXCIpXG4gIH0sXG4gIFNjYWxhclR5cGVFeHRlbnNpb246IHtcbiAgICBsZWF2ZTogKHsgbmFtZSwgZGlyZWN0aXZlcyB9KSA9PiBqb2luKFtcImV4dGVuZCBzY2FsYXJcIiwgbmFtZSwgam9pbihkaXJlY3RpdmVzLCBcIiBcIildLCBcIiBcIilcbiAgfSxcbiAgT2JqZWN0VHlwZUV4dGVuc2lvbjoge1xuICAgIGxlYXZlOiAoeyBuYW1lLCBpbnRlcmZhY2VzLCBkaXJlY3RpdmVzLCBmaWVsZHMgfSkgPT4gam9pbihbXG4gICAgICBcImV4dGVuZCB0eXBlXCIsXG4gICAgICBuYW1lLFxuICAgICAgd3JhcChcImltcGxlbWVudHMgXCIsIGpvaW4oaW50ZXJmYWNlcywgXCIgJiBcIikpLFxuICAgICAgam9pbihkaXJlY3RpdmVzLCBcIiBcIiksXG4gICAgICBibG9jayhmaWVsZHMpXG4gICAgXSwgXCIgXCIpXG4gIH0sXG4gIEludGVyZmFjZVR5cGVFeHRlbnNpb246IHtcbiAgICBsZWF2ZTogKHsgbmFtZSwgaW50ZXJmYWNlcywgZGlyZWN0aXZlcywgZmllbGRzIH0pID0+IGpvaW4oW1xuICAgICAgXCJleHRlbmQgaW50ZXJmYWNlXCIsXG4gICAgICBuYW1lLFxuICAgICAgd3JhcChcImltcGxlbWVudHMgXCIsIGpvaW4oaW50ZXJmYWNlcywgXCIgJiBcIikpLFxuICAgICAgam9pbihkaXJlY3RpdmVzLCBcIiBcIiksXG4gICAgICBibG9jayhmaWVsZHMpXG4gICAgXSwgXCIgXCIpXG4gIH0sXG4gIFVuaW9uVHlwZUV4dGVuc2lvbjoge1xuICAgIGxlYXZlOiAoeyBuYW1lLCBkaXJlY3RpdmVzLCB0eXBlcyB9KSA9PiBqb2luKFtcbiAgICAgIFwiZXh0ZW5kIHVuaW9uXCIsXG4gICAgICBuYW1lLFxuICAgICAgam9pbihkaXJlY3RpdmVzLCBcIiBcIiksXG4gICAgICB3cmFwKFwiPSBcIiwgam9pbih0eXBlcywgXCIgfCBcIikpXG4gICAgXSwgXCIgXCIpXG4gIH0sXG4gIEVudW1UeXBlRXh0ZW5zaW9uOiB7XG4gICAgbGVhdmU6ICh7IG5hbWUsIGRpcmVjdGl2ZXMsIHZhbHVlcyB9KSA9PiBqb2luKFtcImV4dGVuZCBlbnVtXCIsIG5hbWUsIGpvaW4oZGlyZWN0aXZlcywgXCIgXCIpLCBibG9jayh2YWx1ZXMpXSwgXCIgXCIpXG4gIH0sXG4gIElucHV0T2JqZWN0VHlwZUV4dGVuc2lvbjoge1xuICAgIGxlYXZlOiAoeyBuYW1lLCBkaXJlY3RpdmVzLCBmaWVsZHMgfSkgPT4gam9pbihbXCJleHRlbmQgaW5wdXRcIiwgbmFtZSwgam9pbihkaXJlY3RpdmVzLCBcIiBcIiksIGJsb2NrKGZpZWxkcyldLCBcIiBcIilcbiAgfVxufTtcbmZ1bmN0aW9uIGpvaW4obWF5YmVBcnJheSwgc2VwYXJhdG9yID0gXCJcIikge1xuICB2YXIgX21heWJlQXJyYXkkZmlsdGVyJGpvO1xuICByZXR1cm4gKF9tYXliZUFycmF5JGZpbHRlciRqbyA9IG1heWJlQXJyYXkgPT09IG51bGwgfHwgbWF5YmVBcnJheSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWF5YmVBcnJheS5maWx0ZXIoKHgpID0+IHgpLmpvaW4oc2VwYXJhdG9yKSkgIT09IG51bGwgJiYgX21heWJlQXJyYXkkZmlsdGVyJGpvICE9PSB2b2lkIDAgPyBfbWF5YmVBcnJheSRmaWx0ZXIkam8gOiBcIlwiO1xufVxuX19uYW1lKGpvaW4sIFwiam9pblwiKTtcbmZ1bmN0aW9uIGJsb2NrKGFycmF5KSB7XG4gIHJldHVybiB3cmFwKFwie1xcblwiLCBpbmRlbnQoam9pbihhcnJheSwgXCJcXG5cIikpLCBcIlxcbn1cIik7XG59XG5fX25hbWUoYmxvY2ssIFwiYmxvY2tcIik7XG5mdW5jdGlvbiB3cmFwKHN0YXJ0LCBtYXliZVN0cmluZywgZW5kID0gXCJcIikge1xuICByZXR1cm4gbWF5YmVTdHJpbmcgIT0gbnVsbCAmJiBtYXliZVN0cmluZyAhPT0gXCJcIiA/IHN0YXJ0ICsgbWF5YmVTdHJpbmcgKyBlbmQgOiBcIlwiO1xufVxuX19uYW1lKHdyYXAsIFwid3JhcFwiKTtcbmZ1bmN0aW9uIGluZGVudChzdHIpIHtcbiAgcmV0dXJuIHdyYXAoXCIgIFwiLCBzdHIucmVwbGFjZSgvXFxuL2csIFwiXFxuICBcIikpO1xufVxuX19uYW1lKGluZGVudCwgXCJpbmRlbnRcIik7XG5mdW5jdGlvbiBoYXNNdWx0aWxpbmVJdGVtcyhtYXliZUFycmF5KSB7XG4gIHZhciBfbWF5YmVBcnJheSRzb21lO1xuICByZXR1cm4gKF9tYXliZUFycmF5JHNvbWUgPSBtYXliZUFycmF5ID09PSBudWxsIHx8IG1heWJlQXJyYXkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1heWJlQXJyYXkuc29tZSgoc3RyKSA9PiBzdHIuaW5jbHVkZXMoXCJcXG5cIikpKSAhPT0gbnVsbCAmJiBfbWF5YmVBcnJheSRzb21lICE9PSB2b2lkIDAgPyBfbWF5YmVBcnJheSRzb21lIDogZmFsc2U7XG59XG5fX25hbWUoaGFzTXVsdGlsaW5lSXRlbXMsIFwiaGFzTXVsdGlsaW5lSXRlbXNcIik7XG5mdW5jdGlvbiBpc0l0ZXJhYmxlT2JqZWN0KG1heWJlSXRlcmFibGUpIHtcbiAgcmV0dXJuIHR5cGVvZiBtYXliZUl0ZXJhYmxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCBtYXliZUl0ZXJhYmxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXliZUl0ZXJhYmxlW1N5bWJvbC5pdGVyYXRvcl0pID09PSBcImZ1bmN0aW9uXCI7XG59XG5fX25hbWUoaXNJdGVyYWJsZU9iamVjdCwgXCJpc0l0ZXJhYmxlT2JqZWN0XCIpO1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cbl9fbmFtZShpc09iamVjdExpa2UsIFwiaXNPYmplY3RMaWtlXCIpO1xuY29uc3QgTUFYX1NVR0dFU1RJT05TID0gNTtcbmZ1bmN0aW9uIGRpZFlvdU1lYW4oZmlyc3RBcmcsIHNlY29uZEFyZykge1xuICBjb25zdCBbc3ViTWVzc2FnZSwgc3VnZ2VzdGlvbnNBcmddID0gc2Vjb25kQXJnID8gW2ZpcnN0QXJnLCBzZWNvbmRBcmddIDogW3ZvaWQgMCwgZmlyc3RBcmddO1xuICBsZXQgbWVzc2FnZSA9IFwiIERpZCB5b3UgbWVhbiBcIjtcbiAgaWYgKHN1Yk1lc3NhZ2UpIHtcbiAgICBtZXNzYWdlICs9IHN1Yk1lc3NhZ2UgKyBcIiBcIjtcbiAgfVxuICBjb25zdCBzdWdnZXN0aW9ucyA9IHN1Z2dlc3Rpb25zQXJnLm1hcCgoeCkgPT4gYFwiJHt4fVwiYCk7XG4gIHN3aXRjaCAoc3VnZ2VzdGlvbnMubGVuZ3RoKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIG1lc3NhZ2UgKyBzdWdnZXN0aW9uc1swXSArIFwiP1wiO1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBtZXNzYWdlICsgc3VnZ2VzdGlvbnNbMF0gKyBcIiBvciBcIiArIHN1Z2dlc3Rpb25zWzFdICsgXCI/XCI7XG4gIH1cbiAgY29uc3Qgc2VsZWN0ZWQgPSBzdWdnZXN0aW9ucy5zbGljZSgwLCBNQVhfU1VHR0VTVElPTlMpO1xuICBjb25zdCBsYXN0SXRlbSA9IHNlbGVjdGVkLnBvcCgpO1xuICByZXR1cm4gbWVzc2FnZSArIHNlbGVjdGVkLmpvaW4oXCIsIFwiKSArIFwiLCBvciBcIiArIGxhc3RJdGVtICsgXCI/XCI7XG59XG5fX25hbWUoZGlkWW91TWVhbiwgXCJkaWRZb3VNZWFuXCIpO1xuZnVuY3Rpb24gaWRlbnRpdHlGdW5jKHgpIHtcbiAgcmV0dXJuIHg7XG59XG5fX25hbWUoaWRlbnRpdHlGdW5jLCBcImlkZW50aXR5RnVuY1wiKTtcbmNvbnN0IGluc3RhbmNlT2YgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uIGluc3RhbmNlT2YyKHZhbHVlLCBjb25zdHJ1Y3Rvcikge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBjb25zdHJ1Y3Rvcjtcbn0sIFwiaW5zdGFuY2VPZlwiKTtcbmZ1bmN0aW9uIGtleU1hcChsaXN0LCBrZXlGbikge1xuICBjb25zdCByZXN1bHQgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZm9yIChjb25zdCBpdGVtIG9mIGxpc3QpIHtcbiAgICByZXN1bHRba2V5Rm4oaXRlbSldID0gaXRlbTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuX19uYW1lKGtleU1hcCwgXCJrZXlNYXBcIik7XG5mdW5jdGlvbiBrZXlWYWxNYXAobGlzdCwga2V5Rm4sIHZhbEZuKSB7XG4gIGNvbnN0IHJlc3VsdCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBmb3IgKGNvbnN0IGl0ZW0gb2YgbGlzdCkge1xuICAgIHJlc3VsdFtrZXlGbihpdGVtKV0gPSB2YWxGbihpdGVtKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuX19uYW1lKGtleVZhbE1hcCwgXCJrZXlWYWxNYXBcIik7XG5mdW5jdGlvbiBtYXBWYWx1ZShtYXAsIGZuKSB7XG4gIGNvbnN0IHJlc3VsdCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhtYXApKSB7XG4gICAgcmVzdWx0W2tleV0gPSBmbihtYXBba2V5XSwga2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuX19uYW1lKG1hcFZhbHVlLCBcIm1hcFZhbHVlXCIpO1xuZnVuY3Rpb24gbmF0dXJhbENvbXBhcmUoYVN0ciwgYlN0cikge1xuICBsZXQgYUluZGV4ID0gMDtcbiAgbGV0IGJJbmRleCA9IDA7XG4gIHdoaWxlIChhSW5kZXggPCBhU3RyLmxlbmd0aCAmJiBiSW5kZXggPCBiU3RyLmxlbmd0aCkge1xuICAgIGxldCBhQ2hhciA9IGFTdHIuY2hhckNvZGVBdChhSW5kZXgpO1xuICAgIGxldCBiQ2hhciA9IGJTdHIuY2hhckNvZGVBdChiSW5kZXgpO1xuICAgIGlmIChpc0RpZ2l0KGFDaGFyKSAmJiBpc0RpZ2l0KGJDaGFyKSkge1xuICAgICAgbGV0IGFOdW0gPSAwO1xuICAgICAgZG8ge1xuICAgICAgICArK2FJbmRleDtcbiAgICAgICAgYU51bSA9IGFOdW0gKiAxMCArIGFDaGFyIC0gRElHSVRfMDtcbiAgICAgICAgYUNoYXIgPSBhU3RyLmNoYXJDb2RlQXQoYUluZGV4KTtcbiAgICAgIH0gd2hpbGUgKGlzRGlnaXQoYUNoYXIpICYmIGFOdW0gPiAwKTtcbiAgICAgIGxldCBiTnVtID0gMDtcbiAgICAgIGRvIHtcbiAgICAgICAgKytiSW5kZXg7XG4gICAgICAgIGJOdW0gPSBiTnVtICogMTAgKyBiQ2hhciAtIERJR0lUXzA7XG4gICAgICAgIGJDaGFyID0gYlN0ci5jaGFyQ29kZUF0KGJJbmRleCk7XG4gICAgICB9IHdoaWxlIChpc0RpZ2l0KGJDaGFyKSAmJiBiTnVtID4gMCk7XG4gICAgICBpZiAoYU51bSA8IGJOdW0pIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgaWYgKGFOdW0gPiBiTnVtKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYUNoYXIgPCBiQ2hhcikge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBpZiAoYUNoYXIgPiBiQ2hhcikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgICsrYUluZGV4O1xuICAgICAgKytiSW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiBhU3RyLmxlbmd0aCAtIGJTdHIubGVuZ3RoO1xufVxuX19uYW1lKG5hdHVyYWxDb21wYXJlLCBcIm5hdHVyYWxDb21wYXJlXCIpO1xuY29uc3QgRElHSVRfMCA9IDQ4O1xuY29uc3QgRElHSVRfOSA9IDU3O1xuZnVuY3Rpb24gaXNEaWdpdChjb2RlKSB7XG4gIHJldHVybiAhaXNOYU4oY29kZSkgJiYgRElHSVRfMCA8PSBjb2RlICYmIGNvZGUgPD0gRElHSVRfOTtcbn1cbl9fbmFtZShpc0RpZ2l0LCBcImlzRGlnaXRcIik7XG5mdW5jdGlvbiBzdWdnZXN0aW9uTGlzdChpbnB1dCwgb3B0aW9ucykge1xuICBjb25zdCBvcHRpb25zQnlEaXN0YW5jZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb25zdCBsZXhpY2FsRGlzdGFuY2UgPSBuZXcgTGV4aWNhbERpc3RhbmNlKGlucHV0KTtcbiAgY29uc3QgdGhyZXNob2xkID0gTWF0aC5mbG9vcihpbnB1dC5sZW5ndGggKiAwLjQpICsgMTtcbiAgZm9yIChjb25zdCBvcHRpb24gb2Ygb3B0aW9ucykge1xuICAgIGNvbnN0IGRpc3RhbmNlID0gbGV4aWNhbERpc3RhbmNlLm1lYXN1cmUob3B0aW9uLCB0aHJlc2hvbGQpO1xuICAgIGlmIChkaXN0YW5jZSAhPT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zQnlEaXN0YW5jZVtvcHRpb25dID0gZGlzdGFuY2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBPYmplY3Qua2V5cyhvcHRpb25zQnlEaXN0YW5jZSkuc29ydCgoYSwgYikgPT4ge1xuICAgIGNvbnN0IGRpc3RhbmNlRGlmZiA9IG9wdGlvbnNCeURpc3RhbmNlW2FdIC0gb3B0aW9uc0J5RGlzdGFuY2VbYl07XG4gICAgcmV0dXJuIGRpc3RhbmNlRGlmZiAhPT0gMCA/IGRpc3RhbmNlRGlmZiA6IG5hdHVyYWxDb21wYXJlKGEsIGIpO1xuICB9KTtcbn1cbl9fbmFtZShzdWdnZXN0aW9uTGlzdCwgXCJzdWdnZXN0aW9uTGlzdFwiKTtcbmNsYXNzIExleGljYWxEaXN0YW5jZSB7XG4gIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcbiAgICB0aGlzLl9pbnB1dExvd2VyQ2FzZSA9IGlucHV0LnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5faW5wdXRBcnJheSA9IHN0cmluZ1RvQXJyYXkodGhpcy5faW5wdXRMb3dlckNhc2UpO1xuICAgIHRoaXMuX3Jvd3MgPSBbXG4gICAgICBuZXcgQXJyYXkoaW5wdXQubGVuZ3RoICsgMSkuZmlsbCgwKSxcbiAgICAgIG5ldyBBcnJheShpbnB1dC5sZW5ndGggKyAxKS5maWxsKDApLFxuICAgICAgbmV3IEFycmF5KGlucHV0Lmxlbmd0aCArIDEpLmZpbGwoMClcbiAgICBdO1xuICB9XG4gIG1lYXN1cmUob3B0aW9uLCB0aHJlc2hvbGQpIHtcbiAgICBpZiAodGhpcy5faW5wdXQgPT09IG9wdGlvbikge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNvbnN0IG9wdGlvbkxvd2VyQ2FzZSA9IG9wdGlvbi50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICh0aGlzLl9pbnB1dExvd2VyQ2FzZSA9PT0gb3B0aW9uTG93ZXJDYXNlKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgbGV0IGEgPSBzdHJpbmdUb0FycmF5KG9wdGlvbkxvd2VyQ2FzZSk7XG4gICAgbGV0IGIgPSB0aGlzLl9pbnB1dEFycmF5O1xuICAgIGlmIChhLmxlbmd0aCA8IGIubGVuZ3RoKSB7XG4gICAgICBjb25zdCB0bXAgPSBhO1xuICAgICAgYSA9IGI7XG4gICAgICBiID0gdG1wO1xuICAgIH1cbiAgICBjb25zdCBhTGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgY29uc3QgYkxlbmd0aCA9IGIubGVuZ3RoO1xuICAgIGlmIChhTGVuZ3RoIC0gYkxlbmd0aCA+IHRocmVzaG9sZCkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgY29uc3Qgcm93cyA9IHRoaXMuX3Jvd3M7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPD0gYkxlbmd0aDsgaisrKSB7XG4gICAgICByb3dzWzBdW2pdID0gajtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gYUxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB1cFJvdyA9IHJvd3NbKGkgLSAxKSAlIDNdO1xuICAgICAgY29uc3QgY3VycmVudFJvdyA9IHJvd3NbaSAlIDNdO1xuICAgICAgbGV0IHNtYWxsZXN0Q2VsbCA9IGN1cnJlbnRSb3dbMF0gPSBpO1xuICAgICAgZm9yIChsZXQgaiA9IDE7IGogPD0gYkxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNvbnN0IGNvc3QgPSBhW2kgLSAxXSA9PT0gYltqIC0gMV0gPyAwIDogMTtcbiAgICAgICAgbGV0IGN1cnJlbnRDZWxsID0gTWF0aC5taW4odXBSb3dbal0gKyAxLCBjdXJyZW50Um93W2ogLSAxXSArIDEsIHVwUm93W2ogLSAxXSArIGNvc3QpO1xuICAgICAgICBpZiAoaSA+IDEgJiYgaiA+IDEgJiYgYVtpIC0gMV0gPT09IGJbaiAtIDJdICYmIGFbaSAtIDJdID09PSBiW2ogLSAxXSkge1xuICAgICAgICAgIGNvbnN0IGRvdWJsZURpYWdvbmFsQ2VsbCA9IHJvd3NbKGkgLSAyKSAlIDNdW2ogLSAyXTtcbiAgICAgICAgICBjdXJyZW50Q2VsbCA9IE1hdGgubWluKGN1cnJlbnRDZWxsLCBkb3VibGVEaWFnb25hbENlbGwgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudENlbGwgPCBzbWFsbGVzdENlbGwpIHtcbiAgICAgICAgICBzbWFsbGVzdENlbGwgPSBjdXJyZW50Q2VsbDtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50Um93W2pdID0gY3VycmVudENlbGw7XG4gICAgICB9XG4gICAgICBpZiAoc21hbGxlc3RDZWxsID4gdGhyZXNob2xkKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGRpc3RhbmNlID0gcm93c1thTGVuZ3RoICUgM11bYkxlbmd0aF07XG4gICAgcmV0dXJuIGRpc3RhbmNlIDw9IHRocmVzaG9sZCA/IGRpc3RhbmNlIDogdm9pZCAwO1xuICB9XG59XG5fX25hbWUoTGV4aWNhbERpc3RhbmNlLCBcIkxleGljYWxEaXN0YW5jZVwiKTtcbmZ1bmN0aW9uIHN0cmluZ1RvQXJyYXkoc3RyKSB7XG4gIGNvbnN0IHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gIGNvbnN0IGFycmF5ID0gbmV3IEFycmF5KHN0ckxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyTGVuZ3RoOyArK2kpIHtcbiAgICBhcnJheVtpXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cbl9fbmFtZShzdHJpbmdUb0FycmF5LCBcInN0cmluZ1RvQXJyYXlcIik7XG5mdW5jdGlvbiB0b09iak1hcChvYmopIHtcbiAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gIGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgY29uc3QgbWFwID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9iaikpIHtcbiAgICBtYXBba2V5XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBtYXA7XG59XG5fX25hbWUodG9PYmpNYXAsIFwidG9PYmpNYXBcIik7XG5jb25zdCBMaW5lUmVnRXhwID0gL1xcclxcbnxbXFxuXFxyXS9nO1xuZnVuY3Rpb24gZ2V0TG9jYXRpb24oc291cmNlLCBwb3NpdGlvbikge1xuICBsZXQgbGFzdExpbmVTdGFydCA9IDA7XG4gIGxldCBsaW5lID0gMTtcbiAgZm9yIChjb25zdCBtYXRjaCBvZiBzb3VyY2UuYm9keS5tYXRjaEFsbChMaW5lUmVnRXhwKSkge1xuICAgIHR5cGVvZiBtYXRjaC5pbmRleCA9PT0gXCJudW1iZXJcIiB8fCBpbnZhcmlhbnQoZmFsc2UpO1xuICAgIGlmIChtYXRjaC5pbmRleCA+PSBwb3NpdGlvbikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGxhc3RMaW5lU3RhcnQgPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICBsaW5lICs9IDE7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBsaW5lLFxuICAgIGNvbHVtbjogcG9zaXRpb24gKyAxIC0gbGFzdExpbmVTdGFydFxuICB9O1xufVxuX19uYW1lKGdldExvY2F0aW9uLCBcImdldExvY2F0aW9uXCIpO1xuZnVuY3Rpb24gcHJpbnRMb2NhdGlvbihsb2NhdGlvbikge1xuICByZXR1cm4gcHJpbnRTb3VyY2VMb2NhdGlvbihsb2NhdGlvbi5zb3VyY2UsIGdldExvY2F0aW9uKGxvY2F0aW9uLnNvdXJjZSwgbG9jYXRpb24uc3RhcnQpKTtcbn1cbl9fbmFtZShwcmludExvY2F0aW9uLCBcInByaW50TG9jYXRpb25cIik7XG5mdW5jdGlvbiBwcmludFNvdXJjZUxvY2F0aW9uKHNvdXJjZSwgc291cmNlTG9jYXRpb24pIHtcbiAgY29uc3QgZmlyc3RMaW5lQ29sdW1uT2Zmc2V0ID0gc291cmNlLmxvY2F0aW9uT2Zmc2V0LmNvbHVtbiAtIDE7XG4gIGNvbnN0IGJvZHkgPSBcIlwiLnBhZFN0YXJ0KGZpcnN0TGluZUNvbHVtbk9mZnNldCkgKyBzb3VyY2UuYm9keTtcbiAgY29uc3QgbGluZUluZGV4ID0gc291cmNlTG9jYXRpb24ubGluZSAtIDE7XG4gIGNvbnN0IGxpbmVPZmZzZXQgPSBzb3VyY2UubG9jYXRpb25PZmZzZXQubGluZSAtIDE7XG4gIGNvbnN0IGxpbmVOdW0gPSBzb3VyY2VMb2NhdGlvbi5saW5lICsgbGluZU9mZnNldDtcbiAgY29uc3QgY29sdW1uT2Zmc2V0ID0gc291cmNlTG9jYXRpb24ubGluZSA9PT0gMSA/IGZpcnN0TGluZUNvbHVtbk9mZnNldCA6IDA7XG4gIGNvbnN0IGNvbHVtbk51bSA9IHNvdXJjZUxvY2F0aW9uLmNvbHVtbiArIGNvbHVtbk9mZnNldDtcbiAgY29uc3QgbG9jYXRpb25TdHIgPSBgJHtzb3VyY2UubmFtZX06JHtsaW5lTnVtfToke2NvbHVtbk51bX1cbmA7XG4gIGNvbnN0IGxpbmVzID0gYm9keS5zcGxpdCgvXFxyXFxufFtcXG5cXHJdL2cpO1xuICBjb25zdCBsb2NhdGlvbkxpbmUgPSBsaW5lc1tsaW5lSW5kZXhdO1xuICBpZiAobG9jYXRpb25MaW5lLmxlbmd0aCA+IDEyMCkge1xuICAgIGNvbnN0IHN1YkxpbmVJbmRleCA9IE1hdGguZmxvb3IoY29sdW1uTnVtIC8gODApO1xuICAgIGNvbnN0IHN1YkxpbmVDb2x1bW5OdW0gPSBjb2x1bW5OdW0gJSA4MDtcbiAgICBjb25zdCBzdWJMaW5lcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYXRpb25MaW5lLmxlbmd0aDsgaSArPSA4MCkge1xuICAgICAgc3ViTGluZXMucHVzaChsb2NhdGlvbkxpbmUuc2xpY2UoaSwgaSArIDgwKSk7XG4gICAgfVxuICAgIHJldHVybiBsb2NhdGlvblN0ciArIHByaW50UHJlZml4ZWRMaW5lcyhbXG4gICAgICBbYCR7bGluZU51bX0gfGAsIHN1YkxpbmVzWzBdXSxcbiAgICAgIC4uLnN1YkxpbmVzLnNsaWNlKDEsIHN1YkxpbmVJbmRleCArIDEpLm1hcCgoc3ViTGluZSkgPT4gW1wifFwiLCBzdWJMaW5lXSksXG4gICAgICBbXCJ8XCIsIFwiXlwiLnBhZFN0YXJ0KHN1YkxpbmVDb2x1bW5OdW0pXSxcbiAgICAgIFtcInxcIiwgc3ViTGluZXNbc3ViTGluZUluZGV4ICsgMV1dXG4gICAgXSk7XG4gIH1cbiAgcmV0dXJuIGxvY2F0aW9uU3RyICsgcHJpbnRQcmVmaXhlZExpbmVzKFtcbiAgICBbYCR7bGluZU51bSAtIDF9IHxgLCBsaW5lc1tsaW5lSW5kZXggLSAxXV0sXG4gICAgW2Ake2xpbmVOdW19IHxgLCBsb2NhdGlvbkxpbmVdLFxuICAgIFtcInxcIiwgXCJeXCIucGFkU3RhcnQoY29sdW1uTnVtKV0sXG4gICAgW2Ake2xpbmVOdW0gKyAxfSB8YCwgbGluZXNbbGluZUluZGV4ICsgMV1dXG4gIF0pO1xufVxuX19uYW1lKHByaW50U291cmNlTG9jYXRpb24sIFwicHJpbnRTb3VyY2VMb2NhdGlvblwiKTtcbmZ1bmN0aW9uIHByaW50UHJlZml4ZWRMaW5lcyhsaW5lcykge1xuICBjb25zdCBleGlzdGluZ0xpbmVzID0gbGluZXMuZmlsdGVyKChbXywgbGluZV0pID0+IGxpbmUgIT09IHZvaWQgMCk7XG4gIGNvbnN0IHBhZExlbiA9IE1hdGgubWF4KC4uLmV4aXN0aW5nTGluZXMubWFwKChbcHJlZml4XSkgPT4gcHJlZml4Lmxlbmd0aCkpO1xuICByZXR1cm4gZXhpc3RpbmdMaW5lcy5tYXAoKFtwcmVmaXgsIGxpbmVdKSA9PiBwcmVmaXgucGFkU3RhcnQocGFkTGVuKSArIChsaW5lID8gXCIgXCIgKyBsaW5lIDogXCJcIikpLmpvaW4oXCJcXG5cIik7XG59XG5fX25hbWUocHJpbnRQcmVmaXhlZExpbmVzLCBcInByaW50UHJlZml4ZWRMaW5lc1wiKTtcbmZ1bmN0aW9uIHRvTm9ybWFsaXplZE9wdGlvbnMoYXJncykge1xuICBjb25zdCBmaXJzdEFyZyA9IGFyZ3NbMF07XG4gIGlmIChmaXJzdEFyZyA9PSBudWxsIHx8IFwia2luZFwiIGluIGZpcnN0QXJnIHx8IFwibGVuZ3RoXCIgaW4gZmlyc3RBcmcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbm9kZXM6IGZpcnN0QXJnLFxuICAgICAgc291cmNlOiBhcmdzWzFdLFxuICAgICAgcG9zaXRpb25zOiBhcmdzWzJdLFxuICAgICAgcGF0aDogYXJnc1szXSxcbiAgICAgIG9yaWdpbmFsRXJyb3I6IGFyZ3NbNF0sXG4gICAgICBleHRlbnNpb25zOiBhcmdzWzVdXG4gICAgfTtcbiAgfVxuICByZXR1cm4gZmlyc3RBcmc7XG59XG5fX25hbWUodG9Ob3JtYWxpemVkT3B0aW9ucywgXCJ0b05vcm1hbGl6ZWRPcHRpb25zXCIpO1xuY2xhc3MgR3JhcGhRTEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCAuLi5yYXdBcmdzKSB7XG4gICAgdmFyIF90aGlzJG5vZGVzLCBfbm9kZUxvY2F0aW9ucyQsIF9yZWY7XG4gICAgY29uc3QgeyBub2Rlcywgc291cmNlLCBwb3NpdGlvbnMsIHBhdGgsIG9yaWdpbmFsRXJyb3IsIGV4dGVuc2lvbnMgfSA9IHRvTm9ybWFsaXplZE9wdGlvbnMocmF3QXJncyk7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gXCJHcmFwaFFMRXJyb3JcIjtcbiAgICB0aGlzLnBhdGggPSBwYXRoICE9PSBudWxsICYmIHBhdGggIT09IHZvaWQgMCA/IHBhdGggOiB2b2lkIDA7XG4gICAgdGhpcy5vcmlnaW5hbEVycm9yID0gb3JpZ2luYWxFcnJvciAhPT0gbnVsbCAmJiBvcmlnaW5hbEVycm9yICE9PSB2b2lkIDAgPyBvcmlnaW5hbEVycm9yIDogdm9pZCAwO1xuICAgIHRoaXMubm9kZXMgPSB1bmRlZmluZWRJZkVtcHR5KEFycmF5LmlzQXJyYXkobm9kZXMpID8gbm9kZXMgOiBub2RlcyA/IFtub2Rlc10gOiB2b2lkIDApO1xuICAgIGNvbnN0IG5vZGVMb2NhdGlvbnMgPSB1bmRlZmluZWRJZkVtcHR5KChfdGhpcyRub2RlcyA9IHRoaXMubm9kZXMpID09PSBudWxsIHx8IF90aGlzJG5vZGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRub2Rlcy5tYXAoKG5vZGUpID0+IG5vZGUubG9jKS5maWx0ZXIoKGxvYykgPT4gbG9jICE9IG51bGwpKTtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZSAhPT0gbnVsbCAmJiBzb3VyY2UgIT09IHZvaWQgMCA/IHNvdXJjZSA6IG5vZGVMb2NhdGlvbnMgPT09IG51bGwgfHwgbm9kZUxvY2F0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9ub2RlTG9jYXRpb25zJCA9IG5vZGVMb2NhdGlvbnNbMF0pID09PSBudWxsIHx8IF9ub2RlTG9jYXRpb25zJCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGVMb2NhdGlvbnMkLnNvdXJjZTtcbiAgICB0aGlzLnBvc2l0aW9ucyA9IHBvc2l0aW9ucyAhPT0gbnVsbCAmJiBwb3NpdGlvbnMgIT09IHZvaWQgMCA/IHBvc2l0aW9ucyA6IG5vZGVMb2NhdGlvbnMgPT09IG51bGwgfHwgbm9kZUxvY2F0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZUxvY2F0aW9ucy5tYXAoKGxvYykgPT4gbG9jLnN0YXJ0KTtcbiAgICB0aGlzLmxvY2F0aW9ucyA9IHBvc2l0aW9ucyAmJiBzb3VyY2UgPyBwb3NpdGlvbnMubWFwKChwb3MpID0+IGdldExvY2F0aW9uKHNvdXJjZSwgcG9zKSkgOiBub2RlTG9jYXRpb25zID09PSBudWxsIHx8IG5vZGVMb2NhdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGVMb2NhdGlvbnMubWFwKChsb2MpID0+IGdldExvY2F0aW9uKGxvYy5zb3VyY2UsIGxvYy5zdGFydCkpO1xuICAgIGNvbnN0IG9yaWdpbmFsRXh0ZW5zaW9ucyA9IGlzT2JqZWN0TGlrZShvcmlnaW5hbEVycm9yID09PSBudWxsIHx8IG9yaWdpbmFsRXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsRXJyb3IuZXh0ZW5zaW9ucykgPyBvcmlnaW5hbEVycm9yID09PSBudWxsIHx8IG9yaWdpbmFsRXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsRXJyb3IuZXh0ZW5zaW9ucyA6IHZvaWQgMDtcbiAgICB0aGlzLmV4dGVuc2lvbnMgPSAoX3JlZiA9IGV4dGVuc2lvbnMgIT09IG51bGwgJiYgZXh0ZW5zaW9ucyAhPT0gdm9pZCAwID8gZXh0ZW5zaW9ucyA6IG9yaWdpbmFsRXh0ZW5zaW9ucykgIT09IG51bGwgJiYgX3JlZiAhPT0gdm9pZCAwID8gX3JlZiA6IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgIG1lc3NhZ2U6IHtcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgIH0sXG4gICAgICBuYW1lOiB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICB9LFxuICAgICAgbm9kZXM6IHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgIH0sXG4gICAgICBzb3VyY2U6IHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgIH0sXG4gICAgICBwb3NpdGlvbnM6IHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgIH0sXG4gICAgICBvcmlnaW5hbEVycm9yOiB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKG9yaWdpbmFsRXJyb3IgIT09IG51bGwgJiYgb3JpZ2luYWxFcnJvciAhPT0gdm9pZCAwICYmIG9yaWdpbmFsRXJyb3Iuc3RhY2spIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YWNrXCIsIHtcbiAgICAgICAgdmFsdWU6IG9yaWdpbmFsRXJyb3Iuc3RhY2ssXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEdyYXBoUUxFcnJvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YWNrXCIsIHtcbiAgICAgICAgdmFsdWU6IEVycm9yKCkuc3RhY2ssXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuIFwiR3JhcGhRTEVycm9yXCI7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgbGV0IG91dHB1dCA9IHRoaXMubWVzc2FnZTtcbiAgICBpZiAodGhpcy5ub2Rlcykge1xuICAgICAgZm9yIChjb25zdCBub2RlIG9mIHRoaXMubm9kZXMpIHtcbiAgICAgICAgaWYgKG5vZGUubG9jKSB7XG4gICAgICAgICAgb3V0cHV0ICs9IFwiXFxuXFxuXCIgKyBwcmludExvY2F0aW9uKG5vZGUubG9jKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5zb3VyY2UgJiYgdGhpcy5sb2NhdGlvbnMpIHtcbiAgICAgIGZvciAoY29uc3QgbG9jYXRpb24gb2YgdGhpcy5sb2NhdGlvbnMpIHtcbiAgICAgICAgb3V0cHV0ICs9IFwiXFxuXFxuXCIgKyBwcmludFNvdXJjZUxvY2F0aW9uKHRoaXMuc291cmNlLCBsb2NhdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIGNvbnN0IGZvcm1hdHRlZEVycm9yID0ge1xuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlXG4gICAgfTtcbiAgICBpZiAodGhpcy5sb2NhdGlvbnMgIT0gbnVsbCkge1xuICAgICAgZm9ybWF0dGVkRXJyb3IubG9jYXRpb25zID0gdGhpcy5sb2NhdGlvbnM7XG4gICAgfVxuICAgIGlmICh0aGlzLnBhdGggIT0gbnVsbCkge1xuICAgICAgZm9ybWF0dGVkRXJyb3IucGF0aCA9IHRoaXMucGF0aDtcbiAgICB9XG4gICAgaWYgKHRoaXMuZXh0ZW5zaW9ucyAhPSBudWxsICYmIE9iamVjdC5rZXlzKHRoaXMuZXh0ZW5zaW9ucykubGVuZ3RoID4gMCkge1xuICAgICAgZm9ybWF0dGVkRXJyb3IuZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcbiAgICB9XG4gICAgcmV0dXJuIGZvcm1hdHRlZEVycm9yO1xuICB9XG59XG5fX25hbWUoR3JhcGhRTEVycm9yLCBcIkdyYXBoUUxFcnJvclwiKTtcbmZ1bmN0aW9uIHVuZGVmaW5lZElmRW1wdHkoYXJyYXkpIHtcbiAgcmV0dXJuIGFycmF5ID09PSB2b2lkIDAgfHwgYXJyYXkubGVuZ3RoID09PSAwID8gdm9pZCAwIDogYXJyYXk7XG59XG5fX25hbWUodW5kZWZpbmVkSWZFbXB0eSwgXCJ1bmRlZmluZWRJZkVtcHR5XCIpO1xuZnVuY3Rpb24gdmFsdWVGcm9tQVNUVW50eXBlZCh2YWx1ZU5vZGUsIHZhcmlhYmxlcykge1xuICBzd2l0Y2ggKHZhbHVlTm9kZS5raW5kKSB7XG4gICAgY2FzZSBLaW5kLk5VTEw6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIEtpbmQuSU5UOlxuICAgICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlTm9kZS52YWx1ZSwgMTApO1xuICAgIGNhc2UgS2luZC5GTE9BVDpcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlTm9kZS52YWx1ZSk7XG4gICAgY2FzZSBLaW5kLlNUUklORzpcbiAgICBjYXNlIEtpbmQuRU5VTTpcbiAgICBjYXNlIEtpbmQuQk9PTEVBTjpcbiAgICAgIHJldHVybiB2YWx1ZU5vZGUudmFsdWU7XG4gICAgY2FzZSBLaW5kLkxJU1Q6XG4gICAgICByZXR1cm4gdmFsdWVOb2RlLnZhbHVlcy5tYXAoKG5vZGUpID0+IHZhbHVlRnJvbUFTVFVudHlwZWQobm9kZSwgdmFyaWFibGVzKSk7XG4gICAgY2FzZSBLaW5kLk9CSkVDVDpcbiAgICAgIHJldHVybiBrZXlWYWxNYXAodmFsdWVOb2RlLmZpZWxkcywgKGZpZWxkKSA9PiBmaWVsZC5uYW1lLnZhbHVlLCAoZmllbGQpID0+IHZhbHVlRnJvbUFTVFVudHlwZWQoZmllbGQudmFsdWUsIHZhcmlhYmxlcykpO1xuICAgIGNhc2UgS2luZC5WQVJJQUJMRTpcbiAgICAgIHJldHVybiB2YXJpYWJsZXMgPT09IG51bGwgfHwgdmFyaWFibGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YXJpYWJsZXNbdmFsdWVOb2RlLm5hbWUudmFsdWVdO1xuICB9XG59XG5fX25hbWUodmFsdWVGcm9tQVNUVW50eXBlZCwgXCJ2YWx1ZUZyb21BU1RVbnR5cGVkXCIpO1xuZnVuY3Rpb24gYXNzZXJ0TmFtZShuYW1lKSB7XG4gIG5hbWUgIT0gbnVsbCB8fCBkZXZBc3NlcnQoZmFsc2UsIFwiTXVzdCBwcm92aWRlIG5hbWUuXCIpO1xuICB0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIiB8fCBkZXZBc3NlcnQoZmFsc2UsIFwiRXhwZWN0ZWQgbmFtZSB0byBiZSBhIHN0cmluZy5cIik7XG4gIGlmIChuYW1lLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBHcmFwaFFMRXJyb3IoXCJFeHBlY3RlZCBuYW1lIHRvIGJlIGEgbm9uLWVtcHR5IHN0cmluZy5cIik7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBuYW1lLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCFpc05hbWVDb250aW51ZShuYW1lLmNoYXJDb2RlQXQoaSkpKSB7XG4gICAgICB0aHJvdyBuZXcgR3JhcGhRTEVycm9yKGBOYW1lcyBtdXN0IG9ubHkgY29udGFpbiBbX2EtekEtWjAtOV0gYnV0IFwiJHtuYW1lfVwiIGRvZXMgbm90LmApO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzTmFtZVN0YXJ0KG5hbWUuY2hhckNvZGVBdCgwKSkpIHtcbiAgICB0aHJvdyBuZXcgR3JhcGhRTEVycm9yKGBOYW1lcyBtdXN0IHN0YXJ0IHdpdGggW19hLXpBLVpdIGJ1dCBcIiR7bmFtZX1cIiBkb2VzIG5vdC5gKTtcbiAgfVxuICByZXR1cm4gbmFtZTtcbn1cbl9fbmFtZShhc3NlcnROYW1lLCBcImFzc2VydE5hbWVcIik7XG5mdW5jdGlvbiBhc3NlcnRFbnVtVmFsdWVOYW1lKG5hbWUpIHtcbiAgaWYgKG5hbWUgPT09IFwidHJ1ZVwiIHx8IG5hbWUgPT09IFwiZmFsc2VcIiB8fCBuYW1lID09PSBcIm51bGxcIikge1xuICAgIHRocm93IG5ldyBHcmFwaFFMRXJyb3IoYEVudW0gdmFsdWVzIGNhbm5vdCBiZSBuYW1lZDogJHtuYW1lfWApO1xuICB9XG4gIHJldHVybiBhc3NlcnROYW1lKG5hbWUpO1xufVxuX19uYW1lKGFzc2VydEVudW1WYWx1ZU5hbWUsIFwiYXNzZXJ0RW51bVZhbHVlTmFtZVwiKTtcbmZ1bmN0aW9uIGlzVHlwZSh0eXBlKSB7XG4gIHJldHVybiBpc1NjYWxhclR5cGUodHlwZSkgfHwgaXNPYmplY3RUeXBlKHR5cGUpIHx8IGlzSW50ZXJmYWNlVHlwZSh0eXBlKSB8fCBpc1VuaW9uVHlwZSh0eXBlKSB8fCBpc0VudW1UeXBlKHR5cGUpIHx8IGlzSW5wdXRPYmplY3RUeXBlKHR5cGUpIHx8IGlzTGlzdFR5cGUodHlwZSkgfHwgaXNOb25OdWxsVHlwZSh0eXBlKTtcbn1cbl9fbmFtZShpc1R5cGUsIFwiaXNUeXBlXCIpO1xuZnVuY3Rpb24gaXNTY2FsYXJUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIGluc3RhbmNlT2YodHlwZSwgR3JhcGhRTFNjYWxhclR5cGUpO1xufVxuX19uYW1lKGlzU2NhbGFyVHlwZSwgXCJpc1NjYWxhclR5cGVcIik7XG5mdW5jdGlvbiBpc09iamVjdFR5cGUodHlwZSkge1xuICByZXR1cm4gaW5zdGFuY2VPZih0eXBlLCBHcmFwaFFMT2JqZWN0VHlwZSk7XG59XG5fX25hbWUoaXNPYmplY3RUeXBlLCBcImlzT2JqZWN0VHlwZVwiKTtcbmZ1bmN0aW9uIGlzSW50ZXJmYWNlVHlwZSh0eXBlKSB7XG4gIHJldHVybiBpbnN0YW5jZU9mKHR5cGUsIEdyYXBoUUxJbnRlcmZhY2VUeXBlKTtcbn1cbl9fbmFtZShpc0ludGVyZmFjZVR5cGUsIFwiaXNJbnRlcmZhY2VUeXBlXCIpO1xuZnVuY3Rpb24gaXNVbmlvblR5cGUodHlwZSkge1xuICByZXR1cm4gaW5zdGFuY2VPZih0eXBlLCBHcmFwaFFMVW5pb25UeXBlKTtcbn1cbl9fbmFtZShpc1VuaW9uVHlwZSwgXCJpc1VuaW9uVHlwZVwiKTtcbmZ1bmN0aW9uIGlzRW51bVR5cGUodHlwZSkge1xuICByZXR1cm4gaW5zdGFuY2VPZih0eXBlLCBHcmFwaFFMRW51bVR5cGUpO1xufVxuX19uYW1lKGlzRW51bVR5cGUsIFwiaXNFbnVtVHlwZVwiKTtcbmZ1bmN0aW9uIGlzSW5wdXRPYmplY3RUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIGluc3RhbmNlT2YodHlwZSwgR3JhcGhRTElucHV0T2JqZWN0VHlwZSk7XG59XG5fX25hbWUoaXNJbnB1dE9iamVjdFR5cGUsIFwiaXNJbnB1dE9iamVjdFR5cGVcIik7XG5mdW5jdGlvbiBpc0xpc3RUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIGluc3RhbmNlT2YodHlwZSwgR3JhcGhRTExpc3QpO1xufVxuX19uYW1lKGlzTGlzdFR5cGUsIFwiaXNMaXN0VHlwZVwiKTtcbmZ1bmN0aW9uIGlzTm9uTnVsbFR5cGUodHlwZSkge1xuICByZXR1cm4gaW5zdGFuY2VPZih0eXBlLCBHcmFwaFFMTm9uTnVsbCk7XG59XG5fX25hbWUoaXNOb25OdWxsVHlwZSwgXCJpc05vbk51bGxUeXBlXCIpO1xuZnVuY3Rpb24gaXNMZWFmVHlwZSh0eXBlKSB7XG4gIHJldHVybiBpc1NjYWxhclR5cGUodHlwZSkgfHwgaXNFbnVtVHlwZSh0eXBlKTtcbn1cbl9fbmFtZShpc0xlYWZUeXBlLCBcImlzTGVhZlR5cGVcIik7XG5mdW5jdGlvbiBpc0Fic3RyYWN0VHlwZSh0eXBlKSB7XG4gIHJldHVybiBpc0ludGVyZmFjZVR5cGUodHlwZSkgfHwgaXNVbmlvblR5cGUodHlwZSk7XG59XG5fX25hbWUoaXNBYnN0cmFjdFR5cGUsIFwiaXNBYnN0cmFjdFR5cGVcIik7XG5jbGFzcyBHcmFwaFFMTGlzdCB7XG4gIGNvbnN0cnVjdG9yKG9mVHlwZSkge1xuICAgIGlzVHlwZShvZlR5cGUpIHx8IGRldkFzc2VydChmYWxzZSwgYEV4cGVjdGVkICR7aW5zcGVjdChvZlR5cGUpfSB0byBiZSBhIEdyYXBoUUwgdHlwZS5gKTtcbiAgICB0aGlzLm9mVHlwZSA9IG9mVHlwZTtcbiAgfVxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuIFwiR3JhcGhRTExpc3RcIjtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gXCJbXCIgKyBTdHJpbmcodGhpcy5vZlR5cGUpICsgXCJdXCI7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH1cbn1cbl9fbmFtZShHcmFwaFFMTGlzdCwgXCJHcmFwaFFMTGlzdFwiKTtcbmNsYXNzIEdyYXBoUUxOb25OdWxsIHtcbiAgY29uc3RydWN0b3Iob2ZUeXBlKSB7XG4gICAgaXNOdWxsYWJsZVR5cGUob2ZUeXBlKSB8fCBkZXZBc3NlcnQoZmFsc2UsIGBFeHBlY3RlZCAke2luc3BlY3Qob2ZUeXBlKX0gdG8gYmUgYSBHcmFwaFFMIG51bGxhYmxlIHR5cGUuYCk7XG4gICAgdGhpcy5vZlR5cGUgPSBvZlR5cGU7XG4gIH1cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiBcIkdyYXBoUUxOb25OdWxsXCI7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFN0cmluZyh0aGlzLm9mVHlwZSkgKyBcIiFcIjtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgfVxufVxuX19uYW1lKEdyYXBoUUxOb25OdWxsLCBcIkdyYXBoUUxOb25OdWxsXCIpO1xuZnVuY3Rpb24gaXNOdWxsYWJsZVR5cGUodHlwZSkge1xuICByZXR1cm4gaXNUeXBlKHR5cGUpICYmICFpc05vbk51bGxUeXBlKHR5cGUpO1xufVxuX19uYW1lKGlzTnVsbGFibGVUeXBlLCBcImlzTnVsbGFibGVUeXBlXCIpO1xuZnVuY3Rpb24gcmVzb2x2ZVJlYWRvbmx5QXJyYXlUaHVuayh0aHVuaykge1xuICByZXR1cm4gdHlwZW9mIHRodW5rID09PSBcImZ1bmN0aW9uXCIgPyB0aHVuaygpIDogdGh1bms7XG59XG5fX25hbWUocmVzb2x2ZVJlYWRvbmx5QXJyYXlUaHVuaywgXCJyZXNvbHZlUmVhZG9ubHlBcnJheVRodW5rXCIpO1xuZnVuY3Rpb24gcmVzb2x2ZU9iak1hcFRodW5rKHRodW5rKSB7XG4gIHJldHVybiB0eXBlb2YgdGh1bmsgPT09IFwiZnVuY3Rpb25cIiA/IHRodW5rKCkgOiB0aHVuaztcbn1cbl9fbmFtZShyZXNvbHZlT2JqTWFwVGh1bmssIFwicmVzb2x2ZU9iak1hcFRodW5rXCIpO1xuY2xhc3MgR3JhcGhRTFNjYWxhclR5cGUge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB2YXIgX2NvbmZpZyRwYXJzZVZhbHVlLCBfY29uZmlnJHNlcmlhbGl6ZSwgX2NvbmZpZyRwYXJzZUxpdGVyYWwsIF9jb25maWckZXh0ZW5zaW9uQVNUTjtcbiAgICBjb25zdCBwYXJzZVZhbHVlID0gKF9jb25maWckcGFyc2VWYWx1ZSA9IGNvbmZpZy5wYXJzZVZhbHVlKSAhPT0gbnVsbCAmJiBfY29uZmlnJHBhcnNlVmFsdWUgIT09IHZvaWQgMCA/IF9jb25maWckcGFyc2VWYWx1ZSA6IGlkZW50aXR5RnVuYztcbiAgICB0aGlzLm5hbWUgPSBhc3NlcnROYW1lKGNvbmZpZy5uYW1lKTtcbiAgICB0aGlzLmRlc2NyaXB0aW9uID0gY29uZmlnLmRlc2NyaXB0aW9uO1xuICAgIHRoaXMuc3BlY2lmaWVkQnlVUkwgPSBjb25maWcuc3BlY2lmaWVkQnlVUkw7XG4gICAgdGhpcy5zZXJpYWxpemUgPSAoX2NvbmZpZyRzZXJpYWxpemUgPSBjb25maWcuc2VyaWFsaXplKSAhPT0gbnVsbCAmJiBfY29uZmlnJHNlcmlhbGl6ZSAhPT0gdm9pZCAwID8gX2NvbmZpZyRzZXJpYWxpemUgOiBpZGVudGl0eUZ1bmM7XG4gICAgdGhpcy5wYXJzZVZhbHVlID0gcGFyc2VWYWx1ZTtcbiAgICB0aGlzLnBhcnNlTGl0ZXJhbCA9IChfY29uZmlnJHBhcnNlTGl0ZXJhbCA9IGNvbmZpZy5wYXJzZUxpdGVyYWwpICE9PSBudWxsICYmIF9jb25maWckcGFyc2VMaXRlcmFsICE9PSB2b2lkIDAgPyBfY29uZmlnJHBhcnNlTGl0ZXJhbCA6IChub2RlLCB2YXJpYWJsZXMpID0+IHBhcnNlVmFsdWUodmFsdWVGcm9tQVNUVW50eXBlZChub2RlLCB2YXJpYWJsZXMpKTtcbiAgICB0aGlzLmV4dGVuc2lvbnMgPSB0b09iak1hcChjb25maWcuZXh0ZW5zaW9ucyk7XG4gICAgdGhpcy5hc3ROb2RlID0gY29uZmlnLmFzdE5vZGU7XG4gICAgdGhpcy5leHRlbnNpb25BU1ROb2RlcyA9IChfY29uZmlnJGV4dGVuc2lvbkFTVE4gPSBjb25maWcuZXh0ZW5zaW9uQVNUTm9kZXMpICE9PSBudWxsICYmIF9jb25maWckZXh0ZW5zaW9uQVNUTiAhPT0gdm9pZCAwID8gX2NvbmZpZyRleHRlbnNpb25BU1ROIDogW107XG4gICAgY29uZmlnLnNwZWNpZmllZEJ5VVJMID09IG51bGwgfHwgdHlwZW9mIGNvbmZpZy5zcGVjaWZpZWRCeVVSTCA9PT0gXCJzdHJpbmdcIiB8fCBkZXZBc3NlcnQoZmFsc2UsIGAke3RoaXMubmFtZX0gbXVzdCBwcm92aWRlIFwic3BlY2lmaWVkQnlVUkxcIiBhcyBhIHN0cmluZywgYnV0IGdvdDogJHtpbnNwZWN0KGNvbmZpZy5zcGVjaWZpZWRCeVVSTCl9LmApO1xuICAgIGNvbmZpZy5zZXJpYWxpemUgPT0gbnVsbCB8fCB0eXBlb2YgY29uZmlnLnNlcmlhbGl6ZSA9PT0gXCJmdW5jdGlvblwiIHx8IGRldkFzc2VydChmYWxzZSwgYCR7dGhpcy5uYW1lfSBtdXN0IHByb3ZpZGUgXCJzZXJpYWxpemVcIiBmdW5jdGlvbi4gSWYgdGhpcyBjdXN0b20gU2NhbGFyIGlzIGFsc28gdXNlZCBhcyBhbiBpbnB1dCB0eXBlLCBlbnN1cmUgXCJwYXJzZVZhbHVlXCIgYW5kIFwicGFyc2VMaXRlcmFsXCIgZnVuY3Rpb25zIGFyZSBhbHNvIHByb3ZpZGVkLmApO1xuICAgIGlmIChjb25maWcucGFyc2VMaXRlcmFsKSB7XG4gICAgICB0eXBlb2YgY29uZmlnLnBhcnNlVmFsdWUgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgY29uZmlnLnBhcnNlTGl0ZXJhbCA9PT0gXCJmdW5jdGlvblwiIHx8IGRldkFzc2VydChmYWxzZSwgYCR7dGhpcy5uYW1lfSBtdXN0IHByb3ZpZGUgYm90aCBcInBhcnNlVmFsdWVcIiBhbmQgXCJwYXJzZUxpdGVyYWxcIiBmdW5jdGlvbnMuYCk7XG4gICAgfVxuICB9XG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gXCJHcmFwaFFMU2NhbGFyVHlwZVwiO1xuICB9XG4gIHRvQ29uZmlnKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvbixcbiAgICAgIHNwZWNpZmllZEJ5VVJMOiB0aGlzLnNwZWNpZmllZEJ5VVJMLFxuICAgICAgc2VyaWFsaXplOiB0aGlzLnNlcmlhbGl6ZSxcbiAgICAgIHBhcnNlVmFsdWU6IHRoaXMucGFyc2VWYWx1ZSxcbiAgICAgIHBhcnNlTGl0ZXJhbDogdGhpcy5wYXJzZUxpdGVyYWwsXG4gICAgICBleHRlbnNpb25zOiB0aGlzLmV4dGVuc2lvbnMsXG4gICAgICBhc3ROb2RlOiB0aGlzLmFzdE5vZGUsXG4gICAgICBleHRlbnNpb25BU1ROb2RlczogdGhpcy5leHRlbnNpb25BU1ROb2Rlc1xuICAgIH07XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgfVxufVxuX19uYW1lKEdyYXBoUUxTY2FsYXJUeXBlLCBcIkdyYXBoUUxTY2FsYXJUeXBlXCIpO1xuY2xhc3MgR3JhcGhRTE9iamVjdFR5cGUge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB2YXIgX2NvbmZpZyRleHRlbnNpb25BU1ROMjtcbiAgICB0aGlzLm5hbWUgPSBhc3NlcnROYW1lKGNvbmZpZy5uYW1lKTtcbiAgICB0aGlzLmRlc2NyaXB0aW9uID0gY29uZmlnLmRlc2NyaXB0aW9uO1xuICAgIHRoaXMuaXNUeXBlT2YgPSBjb25maWcuaXNUeXBlT2Y7XG4gICAgdGhpcy5leHRlbnNpb25zID0gdG9PYmpNYXAoY29uZmlnLmV4dGVuc2lvbnMpO1xuICAgIHRoaXMuYXN0Tm9kZSA9IGNvbmZpZy5hc3ROb2RlO1xuICAgIHRoaXMuZXh0ZW5zaW9uQVNUTm9kZXMgPSAoX2NvbmZpZyRleHRlbnNpb25BU1ROMiA9IGNvbmZpZy5leHRlbnNpb25BU1ROb2RlcykgIT09IG51bGwgJiYgX2NvbmZpZyRleHRlbnNpb25BU1ROMiAhPT0gdm9pZCAwID8gX2NvbmZpZyRleHRlbnNpb25BU1ROMiA6IFtdO1xuICAgIHRoaXMuX2ZpZWxkcyA9ICgpID0+IGRlZmluZUZpZWxkTWFwKGNvbmZpZyk7XG4gICAgdGhpcy5faW50ZXJmYWNlcyA9ICgpID0+IGRlZmluZUludGVyZmFjZXMoY29uZmlnKTtcbiAgICBjb25maWcuaXNUeXBlT2YgPT0gbnVsbCB8fCB0eXBlb2YgY29uZmlnLmlzVHlwZU9mID09PSBcImZ1bmN0aW9uXCIgfHwgZGV2QXNzZXJ0KGZhbHNlLCBgJHt0aGlzLm5hbWV9IG11c3QgcHJvdmlkZSBcImlzVHlwZU9mXCIgYXMgYSBmdW5jdGlvbiwgYnV0IGdvdDogJHtpbnNwZWN0KGNvbmZpZy5pc1R5cGVPZil9LmApO1xuICB9XG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gXCJHcmFwaFFMT2JqZWN0VHlwZVwiO1xuICB9XG4gIGdldEZpZWxkcygpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuX2ZpZWxkcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aGlzLl9maWVsZHMgPSB0aGlzLl9maWVsZHMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2ZpZWxkcztcbiAgfVxuICBnZXRJbnRlcmZhY2VzKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5faW50ZXJmYWNlcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aGlzLl9pbnRlcmZhY2VzID0gdGhpcy5faW50ZXJmYWNlcygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5faW50ZXJmYWNlcztcbiAgfVxuICB0b0NvbmZpZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb24sXG4gICAgICBpbnRlcmZhY2VzOiB0aGlzLmdldEludGVyZmFjZXMoKSxcbiAgICAgIGZpZWxkczogZmllbGRzVG9GaWVsZHNDb25maWcodGhpcy5nZXRGaWVsZHMoKSksXG4gICAgICBpc1R5cGVPZjogdGhpcy5pc1R5cGVPZixcbiAgICAgIGV4dGVuc2lvbnM6IHRoaXMuZXh0ZW5zaW9ucyxcbiAgICAgIGFzdE5vZGU6IHRoaXMuYXN0Tm9kZSxcbiAgICAgIGV4dGVuc2lvbkFTVE5vZGVzOiB0aGlzLmV4dGVuc2lvbkFTVE5vZGVzXG4gICAgfTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9XG59XG5fX25hbWUoR3JhcGhRTE9iamVjdFR5cGUsIFwiR3JhcGhRTE9iamVjdFR5cGVcIik7XG5mdW5jdGlvbiBkZWZpbmVJbnRlcmZhY2VzKGNvbmZpZykge1xuICB2YXIgX2NvbmZpZyRpbnRlcmZhY2VzO1xuICBjb25zdCBpbnRlcmZhY2VzID0gcmVzb2x2ZVJlYWRvbmx5QXJyYXlUaHVuaygoX2NvbmZpZyRpbnRlcmZhY2VzID0gY29uZmlnLmludGVyZmFjZXMpICE9PSBudWxsICYmIF9jb25maWckaW50ZXJmYWNlcyAhPT0gdm9pZCAwID8gX2NvbmZpZyRpbnRlcmZhY2VzIDogW10pO1xuICBBcnJheS5pc0FycmF5KGludGVyZmFjZXMpIHx8IGRldkFzc2VydChmYWxzZSwgYCR7Y29uZmlnLm5hbWV9IGludGVyZmFjZXMgbXVzdCBiZSBhbiBBcnJheSBvciBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gQXJyYXkuYCk7XG4gIHJldHVybiBpbnRlcmZhY2VzO1xufVxuX19uYW1lKGRlZmluZUludGVyZmFjZXMsIFwiZGVmaW5lSW50ZXJmYWNlc1wiKTtcbmZ1bmN0aW9uIGRlZmluZUZpZWxkTWFwKGNvbmZpZykge1xuICBjb25zdCBmaWVsZE1hcCA9IHJlc29sdmVPYmpNYXBUaHVuayhjb25maWcuZmllbGRzKTtcbiAgaXNQbGFpbk9iaihmaWVsZE1hcCkgfHwgZGV2QXNzZXJ0KGZhbHNlLCBgJHtjb25maWcubmFtZX0gZmllbGRzIG11c3QgYmUgYW4gb2JqZWN0IHdpdGggZmllbGQgbmFtZXMgYXMga2V5cyBvciBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgc3VjaCBhbiBvYmplY3QuYCk7XG4gIHJldHVybiBtYXBWYWx1ZShmaWVsZE1hcCwgKGZpZWxkQ29uZmlnLCBmaWVsZE5hbWUpID0+IHtcbiAgICB2YXIgX2ZpZWxkQ29uZmlnJGFyZ3M7XG4gICAgaXNQbGFpbk9iaihmaWVsZENvbmZpZykgfHwgZGV2QXNzZXJ0KGZhbHNlLCBgJHtjb25maWcubmFtZX0uJHtmaWVsZE5hbWV9IGZpZWxkIGNvbmZpZyBtdXN0IGJlIGFuIG9iamVjdC5gKTtcbiAgICBmaWVsZENvbmZpZy5yZXNvbHZlID09IG51bGwgfHwgdHlwZW9mIGZpZWxkQ29uZmlnLnJlc29sdmUgPT09IFwiZnVuY3Rpb25cIiB8fCBkZXZBc3NlcnQoZmFsc2UsIGAke2NvbmZpZy5uYW1lfS4ke2ZpZWxkTmFtZX0gZmllbGQgcmVzb2x2ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uIGlmIHByb3ZpZGVkLCBidXQgZ290OiAke2luc3BlY3QoZmllbGRDb25maWcucmVzb2x2ZSl9LmApO1xuICAgIGNvbnN0IGFyZ3NDb25maWcgPSAoX2ZpZWxkQ29uZmlnJGFyZ3MgPSBmaWVsZENvbmZpZy5hcmdzKSAhPT0gbnVsbCAmJiBfZmllbGRDb25maWckYXJncyAhPT0gdm9pZCAwID8gX2ZpZWxkQ29uZmlnJGFyZ3MgOiB7fTtcbiAgICBpc1BsYWluT2JqKGFyZ3NDb25maWcpIHx8IGRldkFzc2VydChmYWxzZSwgYCR7Y29uZmlnLm5hbWV9LiR7ZmllbGROYW1lfSBhcmdzIG11c3QgYmUgYW4gb2JqZWN0IHdpdGggYXJndW1lbnQgbmFtZXMgYXMga2V5cy5gKTtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogYXNzZXJ0TmFtZShmaWVsZE5hbWUpLFxuICAgICAgZGVzY3JpcHRpb246IGZpZWxkQ29uZmlnLmRlc2NyaXB0aW9uLFxuICAgICAgdHlwZTogZmllbGRDb25maWcudHlwZSxcbiAgICAgIGFyZ3M6IGRlZmluZUFyZ3VtZW50cyhhcmdzQ29uZmlnKSxcbiAgICAgIHJlc29sdmU6IGZpZWxkQ29uZmlnLnJlc29sdmUsXG4gICAgICBzdWJzY3JpYmU6IGZpZWxkQ29uZmlnLnN1YnNjcmliZSxcbiAgICAgIGRlcHJlY2F0aW9uUmVhc29uOiBmaWVsZENvbmZpZy5kZXByZWNhdGlvblJlYXNvbixcbiAgICAgIGV4dGVuc2lvbnM6IHRvT2JqTWFwKGZpZWxkQ29uZmlnLmV4dGVuc2lvbnMpLFxuICAgICAgYXN0Tm9kZTogZmllbGRDb25maWcuYXN0Tm9kZVxuICAgIH07XG4gIH0pO1xufVxuX19uYW1lKGRlZmluZUZpZWxkTWFwLCBcImRlZmluZUZpZWxkTWFwXCIpO1xuZnVuY3Rpb24gZGVmaW5lQXJndW1lbnRzKGNvbmZpZykge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoY29uZmlnKS5tYXAoKFthcmdOYW1lLCBhcmdDb25maWddKSA9PiAoe1xuICAgIG5hbWU6IGFzc2VydE5hbWUoYXJnTmFtZSksXG4gICAgZGVzY3JpcHRpb246IGFyZ0NvbmZpZy5kZXNjcmlwdGlvbixcbiAgICB0eXBlOiBhcmdDb25maWcudHlwZSxcbiAgICBkZWZhdWx0VmFsdWU6IGFyZ0NvbmZpZy5kZWZhdWx0VmFsdWUsXG4gICAgZGVwcmVjYXRpb25SZWFzb246IGFyZ0NvbmZpZy5kZXByZWNhdGlvblJlYXNvbixcbiAgICBleHRlbnNpb25zOiB0b09iak1hcChhcmdDb25maWcuZXh0ZW5zaW9ucyksXG4gICAgYXN0Tm9kZTogYXJnQ29uZmlnLmFzdE5vZGVcbiAgfSkpO1xufVxuX19uYW1lKGRlZmluZUFyZ3VtZW50cywgXCJkZWZpbmVBcmd1bWVudHNcIik7XG5mdW5jdGlvbiBpc1BsYWluT2JqKG9iaikge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKG9iaikgJiYgIUFycmF5LmlzQXJyYXkob2JqKTtcbn1cbl9fbmFtZShpc1BsYWluT2JqLCBcImlzUGxhaW5PYmpcIik7XG5mdW5jdGlvbiBmaWVsZHNUb0ZpZWxkc0NvbmZpZyhmaWVsZHMpIHtcbiAgcmV0dXJuIG1hcFZhbHVlKGZpZWxkcywgKGZpZWxkKSA9PiAoe1xuICAgIGRlc2NyaXB0aW9uOiBmaWVsZC5kZXNjcmlwdGlvbixcbiAgICB0eXBlOiBmaWVsZC50eXBlLFxuICAgIGFyZ3M6IGFyZ3NUb0FyZ3NDb25maWcoZmllbGQuYXJncyksXG4gICAgcmVzb2x2ZTogZmllbGQucmVzb2x2ZSxcbiAgICBzdWJzY3JpYmU6IGZpZWxkLnN1YnNjcmliZSxcbiAgICBkZXByZWNhdGlvblJlYXNvbjogZmllbGQuZGVwcmVjYXRpb25SZWFzb24sXG4gICAgZXh0ZW5zaW9uczogZmllbGQuZXh0ZW5zaW9ucyxcbiAgICBhc3ROb2RlOiBmaWVsZC5hc3ROb2RlXG4gIH0pKTtcbn1cbl9fbmFtZShmaWVsZHNUb0ZpZWxkc0NvbmZpZywgXCJmaWVsZHNUb0ZpZWxkc0NvbmZpZ1wiKTtcbmZ1bmN0aW9uIGFyZ3NUb0FyZ3NDb25maWcoYXJncykge1xuICByZXR1cm4ga2V5VmFsTWFwKGFyZ3MsIChhcmcpID0+IGFyZy5uYW1lLCAoYXJnKSA9PiAoe1xuICAgIGRlc2NyaXB0aW9uOiBhcmcuZGVzY3JpcHRpb24sXG4gICAgdHlwZTogYXJnLnR5cGUsXG4gICAgZGVmYXVsdFZhbHVlOiBhcmcuZGVmYXVsdFZhbHVlLFxuICAgIGRlcHJlY2F0aW9uUmVhc29uOiBhcmcuZGVwcmVjYXRpb25SZWFzb24sXG4gICAgZXh0ZW5zaW9uczogYXJnLmV4dGVuc2lvbnMsXG4gICAgYXN0Tm9kZTogYXJnLmFzdE5vZGVcbiAgfSkpO1xufVxuX19uYW1lKGFyZ3NUb0FyZ3NDb25maWcsIFwiYXJnc1RvQXJnc0NvbmZpZ1wiKTtcbmNsYXNzIEdyYXBoUUxJbnRlcmZhY2VUeXBlIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdmFyIF9jb25maWckZXh0ZW5zaW9uQVNUTjM7XG4gICAgdGhpcy5uYW1lID0gYXNzZXJ0TmFtZShjb25maWcubmFtZSk7XG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IGNvbmZpZy5kZXNjcmlwdGlvbjtcbiAgICB0aGlzLnJlc29sdmVUeXBlID0gY29uZmlnLnJlc29sdmVUeXBlO1xuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IHRvT2JqTWFwKGNvbmZpZy5leHRlbnNpb25zKTtcbiAgICB0aGlzLmFzdE5vZGUgPSBjb25maWcuYXN0Tm9kZTtcbiAgICB0aGlzLmV4dGVuc2lvbkFTVE5vZGVzID0gKF9jb25maWckZXh0ZW5zaW9uQVNUTjMgPSBjb25maWcuZXh0ZW5zaW9uQVNUTm9kZXMpICE9PSBudWxsICYmIF9jb25maWckZXh0ZW5zaW9uQVNUTjMgIT09IHZvaWQgMCA/IF9jb25maWckZXh0ZW5zaW9uQVNUTjMgOiBbXTtcbiAgICB0aGlzLl9maWVsZHMgPSBkZWZpbmVGaWVsZE1hcC5iaW5kKHZvaWQgMCwgY29uZmlnKTtcbiAgICB0aGlzLl9pbnRlcmZhY2VzID0gZGVmaW5lSW50ZXJmYWNlcy5iaW5kKHZvaWQgMCwgY29uZmlnKTtcbiAgICBjb25maWcucmVzb2x2ZVR5cGUgPT0gbnVsbCB8fCB0eXBlb2YgY29uZmlnLnJlc29sdmVUeXBlID09PSBcImZ1bmN0aW9uXCIgfHwgZGV2QXNzZXJ0KGZhbHNlLCBgJHt0aGlzLm5hbWV9IG11c3QgcHJvdmlkZSBcInJlc29sdmVUeXBlXCIgYXMgYSBmdW5jdGlvbiwgYnV0IGdvdDogJHtpbnNwZWN0KGNvbmZpZy5yZXNvbHZlVHlwZSl9LmApO1xuICB9XG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gXCJHcmFwaFFMSW50ZXJmYWNlVHlwZVwiO1xuICB9XG4gIGdldEZpZWxkcygpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuX2ZpZWxkcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aGlzLl9maWVsZHMgPSB0aGlzLl9maWVsZHMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2ZpZWxkcztcbiAgfVxuICBnZXRJbnRlcmZhY2VzKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5faW50ZXJmYWNlcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aGlzLl9pbnRlcmZhY2VzID0gdGhpcy5faW50ZXJmYWNlcygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5faW50ZXJmYWNlcztcbiAgfVxuICB0b0NvbmZpZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb24sXG4gICAgICBpbnRlcmZhY2VzOiB0aGlzLmdldEludGVyZmFjZXMoKSxcbiAgICAgIGZpZWxkczogZmllbGRzVG9GaWVsZHNDb25maWcodGhpcy5nZXRGaWVsZHMoKSksXG4gICAgICByZXNvbHZlVHlwZTogdGhpcy5yZXNvbHZlVHlwZSxcbiAgICAgIGV4dGVuc2lvbnM6IHRoaXMuZXh0ZW5zaW9ucyxcbiAgICAgIGFzdE5vZGU6IHRoaXMuYXN0Tm9kZSxcbiAgICAgIGV4dGVuc2lvbkFTVE5vZGVzOiB0aGlzLmV4dGVuc2lvbkFTVE5vZGVzXG4gICAgfTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9XG59XG5fX25hbWUoR3JhcGhRTEludGVyZmFjZVR5cGUsIFwiR3JhcGhRTEludGVyZmFjZVR5cGVcIik7XG5jbGFzcyBHcmFwaFFMVW5pb25UeXBlIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdmFyIF9jb25maWckZXh0ZW5zaW9uQVNUTjQ7XG4gICAgdGhpcy5uYW1lID0gYXNzZXJ0TmFtZShjb25maWcubmFtZSk7XG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IGNvbmZpZy5kZXNjcmlwdGlvbjtcbiAgICB0aGlzLnJlc29sdmVUeXBlID0gY29uZmlnLnJlc29sdmVUeXBlO1xuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IHRvT2JqTWFwKGNvbmZpZy5leHRlbnNpb25zKTtcbiAgICB0aGlzLmFzdE5vZGUgPSBjb25maWcuYXN0Tm9kZTtcbiAgICB0aGlzLmV4dGVuc2lvbkFTVE5vZGVzID0gKF9jb25maWckZXh0ZW5zaW9uQVNUTjQgPSBjb25maWcuZXh0ZW5zaW9uQVNUTm9kZXMpICE9PSBudWxsICYmIF9jb25maWckZXh0ZW5zaW9uQVNUTjQgIT09IHZvaWQgMCA/IF9jb25maWckZXh0ZW5zaW9uQVNUTjQgOiBbXTtcbiAgICB0aGlzLl90eXBlcyA9IGRlZmluZVR5cGVzLmJpbmQodm9pZCAwLCBjb25maWcpO1xuICAgIGNvbmZpZy5yZXNvbHZlVHlwZSA9PSBudWxsIHx8IHR5cGVvZiBjb25maWcucmVzb2x2ZVR5cGUgPT09IFwiZnVuY3Rpb25cIiB8fCBkZXZBc3NlcnQoZmFsc2UsIGAke3RoaXMubmFtZX0gbXVzdCBwcm92aWRlIFwicmVzb2x2ZVR5cGVcIiBhcyBhIGZ1bmN0aW9uLCBidXQgZ290OiAke2luc3BlY3QoY29uZmlnLnJlc29sdmVUeXBlKX0uYCk7XG4gIH1cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiBcIkdyYXBoUUxVbmlvblR5cGVcIjtcbiAgfVxuICBnZXRUeXBlcygpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuX3R5cGVzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRoaXMuX3R5cGVzID0gdGhpcy5fdHlwZXMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3R5cGVzO1xuICB9XG4gIHRvQ29uZmlnKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvbixcbiAgICAgIHR5cGVzOiB0aGlzLmdldFR5cGVzKCksXG4gICAgICByZXNvbHZlVHlwZTogdGhpcy5yZXNvbHZlVHlwZSxcbiAgICAgIGV4dGVuc2lvbnM6IHRoaXMuZXh0ZW5zaW9ucyxcbiAgICAgIGFzdE5vZGU6IHRoaXMuYXN0Tm9kZSxcbiAgICAgIGV4dGVuc2lvbkFTVE5vZGVzOiB0aGlzLmV4dGVuc2lvbkFTVE5vZGVzXG4gICAgfTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9XG59XG5fX25hbWUoR3JhcGhRTFVuaW9uVHlwZSwgXCJHcmFwaFFMVW5pb25UeXBlXCIpO1xuZnVuY3Rpb24gZGVmaW5lVHlwZXMoY29uZmlnKSB7XG4gIGNvbnN0IHR5cGVzID0gcmVzb2x2ZVJlYWRvbmx5QXJyYXlUaHVuayhjb25maWcudHlwZXMpO1xuICBBcnJheS5pc0FycmF5KHR5cGVzKSB8fCBkZXZBc3NlcnQoZmFsc2UsIGBNdXN0IHByb3ZpZGUgQXJyYXkgb2YgdHlwZXMgb3IgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIHN1Y2ggYW4gYXJyYXkgZm9yIFVuaW9uICR7Y29uZmlnLm5hbWV9LmApO1xuICByZXR1cm4gdHlwZXM7XG59XG5fX25hbWUoZGVmaW5lVHlwZXMsIFwiZGVmaW5lVHlwZXNcIik7XG5jbGFzcyBHcmFwaFFMRW51bVR5cGUge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB2YXIgX2NvbmZpZyRleHRlbnNpb25BU1RONTtcbiAgICB0aGlzLm5hbWUgPSBhc3NlcnROYW1lKGNvbmZpZy5uYW1lKTtcbiAgICB0aGlzLmRlc2NyaXB0aW9uID0gY29uZmlnLmRlc2NyaXB0aW9uO1xuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IHRvT2JqTWFwKGNvbmZpZy5leHRlbnNpb25zKTtcbiAgICB0aGlzLmFzdE5vZGUgPSBjb25maWcuYXN0Tm9kZTtcbiAgICB0aGlzLmV4dGVuc2lvbkFTVE5vZGVzID0gKF9jb25maWckZXh0ZW5zaW9uQVNUTjUgPSBjb25maWcuZXh0ZW5zaW9uQVNUTm9kZXMpICE9PSBudWxsICYmIF9jb25maWckZXh0ZW5zaW9uQVNUTjUgIT09IHZvaWQgMCA/IF9jb25maWckZXh0ZW5zaW9uQVNUTjUgOiBbXTtcbiAgICB0aGlzLl92YWx1ZXMgPSBkZWZpbmVFbnVtVmFsdWVzKHRoaXMubmFtZSwgY29uZmlnLnZhbHVlcyk7XG4gICAgdGhpcy5fdmFsdWVMb29rdXAgPSBuZXcgTWFwKHRoaXMuX3ZhbHVlcy5tYXAoKGVudW1WYWx1ZSkgPT4gW2VudW1WYWx1ZS52YWx1ZSwgZW51bVZhbHVlXSkpO1xuICAgIHRoaXMuX25hbWVMb29rdXAgPSBrZXlNYXAodGhpcy5fdmFsdWVzLCAodmFsdWUpID0+IHZhbHVlLm5hbWUpO1xuICB9XG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gXCJHcmFwaFFMRW51bVR5cGVcIjtcbiAgfVxuICBnZXRWYWx1ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlcztcbiAgfVxuICBnZXRWYWx1ZShuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX25hbWVMb29rdXBbbmFtZV07XG4gIH1cbiAgc2VyaWFsaXplKG91dHB1dFZhbHVlKSB7XG4gICAgY29uc3QgZW51bVZhbHVlID0gdGhpcy5fdmFsdWVMb29rdXAuZ2V0KG91dHB1dFZhbHVlKTtcbiAgICBpZiAoZW51bVZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBHcmFwaFFMRXJyb3IoYEVudW0gXCIke3RoaXMubmFtZX1cIiBjYW5ub3QgcmVwcmVzZW50IHZhbHVlOiAke2luc3BlY3Qob3V0cHV0VmFsdWUpfWApO1xuICAgIH1cbiAgICByZXR1cm4gZW51bVZhbHVlLm5hbWU7XG4gIH1cbiAgcGFyc2VWYWx1ZShpbnB1dFZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dFZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zdCB2YWx1ZVN0ciA9IGluc3BlY3QoaW5wdXRWYWx1ZSk7XG4gICAgICB0aHJvdyBuZXcgR3JhcGhRTEVycm9yKGBFbnVtIFwiJHt0aGlzLm5hbWV9XCIgY2Fubm90IHJlcHJlc2VudCBub24tc3RyaW5nIHZhbHVlOiAke3ZhbHVlU3RyfS5gICsgZGlkWW91TWVhbkVudW1WYWx1ZSh0aGlzLCB2YWx1ZVN0cikpO1xuICAgIH1cbiAgICBjb25zdCBlbnVtVmFsdWUgPSB0aGlzLmdldFZhbHVlKGlucHV0VmFsdWUpO1xuICAgIGlmIChlbnVtVmFsdWUgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEdyYXBoUUxFcnJvcihgVmFsdWUgXCIke2lucHV0VmFsdWV9XCIgZG9lcyBub3QgZXhpc3QgaW4gXCIke3RoaXMubmFtZX1cIiBlbnVtLmAgKyBkaWRZb3VNZWFuRW51bVZhbHVlKHRoaXMsIGlucHV0VmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGVudW1WYWx1ZS52YWx1ZTtcbiAgfVxuICBwYXJzZUxpdGVyYWwodmFsdWVOb2RlLCBfdmFyaWFibGVzKSB7XG4gICAgaWYgKHZhbHVlTm9kZS5raW5kICE9PSBLaW5kLkVOVU0pIHtcbiAgICAgIGNvbnN0IHZhbHVlU3RyID0gcHJpbnQodmFsdWVOb2RlKTtcbiAgICAgIHRocm93IG5ldyBHcmFwaFFMRXJyb3IoYEVudW0gXCIke3RoaXMubmFtZX1cIiBjYW5ub3QgcmVwcmVzZW50IG5vbi1lbnVtIHZhbHVlOiAke3ZhbHVlU3RyfS5gICsgZGlkWW91TWVhbkVudW1WYWx1ZSh0aGlzLCB2YWx1ZVN0ciksIHtcbiAgICAgICAgbm9kZXM6IHZhbHVlTm9kZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGVudW1WYWx1ZSA9IHRoaXMuZ2V0VmFsdWUodmFsdWVOb2RlLnZhbHVlKTtcbiAgICBpZiAoZW51bVZhbHVlID09IG51bGwpIHtcbiAgICAgIGNvbnN0IHZhbHVlU3RyID0gcHJpbnQodmFsdWVOb2RlKTtcbiAgICAgIHRocm93IG5ldyBHcmFwaFFMRXJyb3IoYFZhbHVlIFwiJHt2YWx1ZVN0cn1cIiBkb2VzIG5vdCBleGlzdCBpbiBcIiR7dGhpcy5uYW1lfVwiIGVudW0uYCArIGRpZFlvdU1lYW5FbnVtVmFsdWUodGhpcywgdmFsdWVTdHIpLCB7XG4gICAgICAgIG5vZGVzOiB2YWx1ZU5vZGVcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZW51bVZhbHVlLnZhbHVlO1xuICB9XG4gIHRvQ29uZmlnKCkge1xuICAgIGNvbnN0IHZhbHVlcyA9IGtleVZhbE1hcCh0aGlzLmdldFZhbHVlcygpLCAodmFsdWUpID0+IHZhbHVlLm5hbWUsICh2YWx1ZSkgPT4gKHtcbiAgICAgIGRlc2NyaXB0aW9uOiB2YWx1ZS5kZXNjcmlwdGlvbixcbiAgICAgIHZhbHVlOiB2YWx1ZS52YWx1ZSxcbiAgICAgIGRlcHJlY2F0aW9uUmVhc29uOiB2YWx1ZS5kZXByZWNhdGlvblJlYXNvbixcbiAgICAgIGV4dGVuc2lvbnM6IHZhbHVlLmV4dGVuc2lvbnMsXG4gICAgICBhc3ROb2RlOiB2YWx1ZS5hc3ROb2RlXG4gICAgfSkpO1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvbixcbiAgICAgIHZhbHVlcyxcbiAgICAgIGV4dGVuc2lvbnM6IHRoaXMuZXh0ZW5zaW9ucyxcbiAgICAgIGFzdE5vZGU6IHRoaXMuYXN0Tm9kZSxcbiAgICAgIGV4dGVuc2lvbkFTVE5vZGVzOiB0aGlzLmV4dGVuc2lvbkFTVE5vZGVzXG4gICAgfTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9XG59XG5fX25hbWUoR3JhcGhRTEVudW1UeXBlLCBcIkdyYXBoUUxFbnVtVHlwZVwiKTtcbmZ1bmN0aW9uIGRpZFlvdU1lYW5FbnVtVmFsdWUoZW51bVR5cGUsIHVua25vd25WYWx1ZVN0cikge1xuICBjb25zdCBhbGxOYW1lcyA9IGVudW1UeXBlLmdldFZhbHVlcygpLm1hcCgodmFsdWUpID0+IHZhbHVlLm5hbWUpO1xuICBjb25zdCBzdWdnZXN0ZWRWYWx1ZXMgPSBzdWdnZXN0aW9uTGlzdCh1bmtub3duVmFsdWVTdHIsIGFsbE5hbWVzKTtcbiAgcmV0dXJuIGRpZFlvdU1lYW4oXCJ0aGUgZW51bSB2YWx1ZVwiLCBzdWdnZXN0ZWRWYWx1ZXMpO1xufVxuX19uYW1lKGRpZFlvdU1lYW5FbnVtVmFsdWUsIFwiZGlkWW91TWVhbkVudW1WYWx1ZVwiKTtcbmZ1bmN0aW9uIGRlZmluZUVudW1WYWx1ZXModHlwZU5hbWUsIHZhbHVlTWFwKSB7XG4gIGlzUGxhaW5PYmoodmFsdWVNYXApIHx8IGRldkFzc2VydChmYWxzZSwgYCR7dHlwZU5hbWV9IHZhbHVlcyBtdXN0IGJlIGFuIG9iamVjdCB3aXRoIHZhbHVlIG5hbWVzIGFzIGtleXMuYCk7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyh2YWx1ZU1hcCkubWFwKChbdmFsdWVOYW1lLCB2YWx1ZUNvbmZpZ10pID0+IHtcbiAgICBpc1BsYWluT2JqKHZhbHVlQ29uZmlnKSB8fCBkZXZBc3NlcnQoZmFsc2UsIGAke3R5cGVOYW1lfS4ke3ZhbHVlTmFtZX0gbXVzdCByZWZlciB0byBhbiBvYmplY3Qgd2l0aCBhIFwidmFsdWVcIiBrZXkgcmVwcmVzZW50aW5nIGFuIGludGVybmFsIHZhbHVlIGJ1dCBnb3Q6ICR7aW5zcGVjdCh2YWx1ZUNvbmZpZyl9LmApO1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBhc3NlcnRFbnVtVmFsdWVOYW1lKHZhbHVlTmFtZSksXG4gICAgICBkZXNjcmlwdGlvbjogdmFsdWVDb25maWcuZGVzY3JpcHRpb24sXG4gICAgICB2YWx1ZTogdmFsdWVDb25maWcudmFsdWUgIT09IHZvaWQgMCA/IHZhbHVlQ29uZmlnLnZhbHVlIDogdmFsdWVOYW1lLFxuICAgICAgZGVwcmVjYXRpb25SZWFzb246IHZhbHVlQ29uZmlnLmRlcHJlY2F0aW9uUmVhc29uLFxuICAgICAgZXh0ZW5zaW9uczogdG9PYmpNYXAodmFsdWVDb25maWcuZXh0ZW5zaW9ucyksXG4gICAgICBhc3ROb2RlOiB2YWx1ZUNvbmZpZy5hc3ROb2RlXG4gICAgfTtcbiAgfSk7XG59XG5fX25hbWUoZGVmaW5lRW51bVZhbHVlcywgXCJkZWZpbmVFbnVtVmFsdWVzXCIpO1xuY2xhc3MgR3JhcGhRTElucHV0T2JqZWN0VHlwZSB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHZhciBfY29uZmlnJGV4dGVuc2lvbkFTVE42O1xuICAgIHRoaXMubmFtZSA9IGFzc2VydE5hbWUoY29uZmlnLm5hbWUpO1xuICAgIHRoaXMuZGVzY3JpcHRpb24gPSBjb25maWcuZGVzY3JpcHRpb247XG4gICAgdGhpcy5leHRlbnNpb25zID0gdG9PYmpNYXAoY29uZmlnLmV4dGVuc2lvbnMpO1xuICAgIHRoaXMuYXN0Tm9kZSA9IGNvbmZpZy5hc3ROb2RlO1xuICAgIHRoaXMuZXh0ZW5zaW9uQVNUTm9kZXMgPSAoX2NvbmZpZyRleHRlbnNpb25BU1RONiA9IGNvbmZpZy5leHRlbnNpb25BU1ROb2RlcykgIT09IG51bGwgJiYgX2NvbmZpZyRleHRlbnNpb25BU1RONiAhPT0gdm9pZCAwID8gX2NvbmZpZyRleHRlbnNpb25BU1RONiA6IFtdO1xuICAgIHRoaXMuX2ZpZWxkcyA9IGRlZmluZUlucHV0RmllbGRNYXAuYmluZCh2b2lkIDAsIGNvbmZpZyk7XG4gIH1cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiBcIkdyYXBoUUxJbnB1dE9iamVjdFR5cGVcIjtcbiAgfVxuICBnZXRGaWVsZHMoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl9maWVsZHMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhpcy5fZmllbGRzID0gdGhpcy5fZmllbGRzKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9maWVsZHM7XG4gIH1cbiAgdG9Db25maWcoKSB7XG4gICAgY29uc3QgZmllbGRzID0gbWFwVmFsdWUodGhpcy5nZXRGaWVsZHMoKSwgKGZpZWxkKSA9PiAoe1xuICAgICAgZGVzY3JpcHRpb246IGZpZWxkLmRlc2NyaXB0aW9uLFxuICAgICAgdHlwZTogZmllbGQudHlwZSxcbiAgICAgIGRlZmF1bHRWYWx1ZTogZmllbGQuZGVmYXVsdFZhbHVlLFxuICAgICAgZGVwcmVjYXRpb25SZWFzb246IGZpZWxkLmRlcHJlY2F0aW9uUmVhc29uLFxuICAgICAgZXh0ZW5zaW9uczogZmllbGQuZXh0ZW5zaW9ucyxcbiAgICAgIGFzdE5vZGU6IGZpZWxkLmFzdE5vZGVcbiAgICB9KSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uLFxuICAgICAgZmllbGRzLFxuICAgICAgZXh0ZW5zaW9uczogdGhpcy5leHRlbnNpb25zLFxuICAgICAgYXN0Tm9kZTogdGhpcy5hc3ROb2RlLFxuICAgICAgZXh0ZW5zaW9uQVNUTm9kZXM6IHRoaXMuZXh0ZW5zaW9uQVNUTm9kZXNcbiAgICB9O1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWU7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH1cbn1cbl9fbmFtZShHcmFwaFFMSW5wdXRPYmplY3RUeXBlLCBcIkdyYXBoUUxJbnB1dE9iamVjdFR5cGVcIik7XG5mdW5jdGlvbiBkZWZpbmVJbnB1dEZpZWxkTWFwKGNvbmZpZykge1xuICBjb25zdCBmaWVsZE1hcCA9IHJlc29sdmVPYmpNYXBUaHVuayhjb25maWcuZmllbGRzKTtcbiAgaXNQbGFpbk9iaihmaWVsZE1hcCkgfHwgZGV2QXNzZXJ0KGZhbHNlLCBgJHtjb25maWcubmFtZX0gZmllbGRzIG11c3QgYmUgYW4gb2JqZWN0IHdpdGggZmllbGQgbmFtZXMgYXMga2V5cyBvciBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgc3VjaCBhbiBvYmplY3QuYCk7XG4gIHJldHVybiBtYXBWYWx1ZShmaWVsZE1hcCwgKGZpZWxkQ29uZmlnLCBmaWVsZE5hbWUpID0+IHtcbiAgICAhKFwicmVzb2x2ZVwiIGluIGZpZWxkQ29uZmlnKSB8fCBkZXZBc3NlcnQoZmFsc2UsIGAke2NvbmZpZy5uYW1lfS4ke2ZpZWxkTmFtZX0gZmllbGQgaGFzIGEgcmVzb2x2ZSBwcm9wZXJ0eSwgYnV0IElucHV0IFR5cGVzIGNhbm5vdCBkZWZpbmUgcmVzb2x2ZXJzLmApO1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBhc3NlcnROYW1lKGZpZWxkTmFtZSksXG4gICAgICBkZXNjcmlwdGlvbjogZmllbGRDb25maWcuZGVzY3JpcHRpb24sXG4gICAgICB0eXBlOiBmaWVsZENvbmZpZy50eXBlLFxuICAgICAgZGVmYXVsdFZhbHVlOiBmaWVsZENvbmZpZy5kZWZhdWx0VmFsdWUsXG4gICAgICBkZXByZWNhdGlvblJlYXNvbjogZmllbGRDb25maWcuZGVwcmVjYXRpb25SZWFzb24sXG4gICAgICBleHRlbnNpb25zOiB0b09iak1hcChmaWVsZENvbmZpZy5leHRlbnNpb25zKSxcbiAgICAgIGFzdE5vZGU6IGZpZWxkQ29uZmlnLmFzdE5vZGVcbiAgICB9O1xuICB9KTtcbn1cbl9fbmFtZShkZWZpbmVJbnB1dEZpZWxkTWFwLCBcImRlZmluZUlucHV0RmllbGRNYXBcIik7XG5jb25zdCBHUkFQSFFMX01BWF9JTlQgPSAyMTQ3NDgzNjQ3O1xuY29uc3QgR1JBUEhRTF9NSU5fSU5UID0gLTIxNDc0ODM2NDg7XG5jb25zdCBHcmFwaFFMSW50ID0gbmV3IEdyYXBoUUxTY2FsYXJUeXBlKHtcbiAgbmFtZTogXCJJbnRcIixcbiAgZGVzY3JpcHRpb246IFwiVGhlIGBJbnRgIHNjYWxhciB0eXBlIHJlcHJlc2VudHMgbm9uLWZyYWN0aW9uYWwgc2lnbmVkIHdob2xlIG51bWVyaWMgdmFsdWVzLiBJbnQgY2FuIHJlcHJlc2VudCB2YWx1ZXMgYmV0d2VlbiAtKDJeMzEpIGFuZCAyXjMxIC0gMS5cIixcbiAgc2VyaWFsaXplKG91dHB1dFZhbHVlKSB7XG4gICAgY29uc3QgY29lcmNlZFZhbHVlID0gc2VyaWFsaXplT2JqZWN0KG91dHB1dFZhbHVlKTtcbiAgICBpZiAodHlwZW9mIGNvZXJjZWRWYWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHJldHVybiBjb2VyY2VkVmFsdWUgPyAxIDogMDtcbiAgICB9XG4gICAgbGV0IG51bSA9IGNvZXJjZWRWYWx1ZTtcbiAgICBpZiAodHlwZW9mIGNvZXJjZWRWYWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiBjb2VyY2VkVmFsdWUgIT09IFwiXCIpIHtcbiAgICAgIG51bSA9IE51bWJlcihjb2VyY2VkVmFsdWUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG51bSAhPT0gXCJudW1iZXJcIiB8fCAhTnVtYmVyLmlzSW50ZWdlcihudW0pKSB7XG4gICAgICB0aHJvdyBuZXcgR3JhcGhRTEVycm9yKGBJbnQgY2Fubm90IHJlcHJlc2VudCBub24taW50ZWdlciB2YWx1ZTogJHtpbnNwZWN0KGNvZXJjZWRWYWx1ZSl9YCk7XG4gICAgfVxuICAgIGlmIChudW0gPiBHUkFQSFFMX01BWF9JTlQgfHwgbnVtIDwgR1JBUEhRTF9NSU5fSU5UKSB7XG4gICAgICB0aHJvdyBuZXcgR3JhcGhRTEVycm9yKFwiSW50IGNhbm5vdCByZXByZXNlbnQgbm9uIDMyLWJpdCBzaWduZWQgaW50ZWdlciB2YWx1ZTogXCIgKyBpbnNwZWN0KGNvZXJjZWRWYWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gbnVtO1xuICB9LFxuICBwYXJzZVZhbHVlKGlucHV0VmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0VmFsdWUgIT09IFwibnVtYmVyXCIgfHwgIU51bWJlci5pc0ludGVnZXIoaW5wdXRWYWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBHcmFwaFFMRXJyb3IoYEludCBjYW5ub3QgcmVwcmVzZW50IG5vbi1pbnRlZ2VyIHZhbHVlOiAke2luc3BlY3QoaW5wdXRWYWx1ZSl9YCk7XG4gICAgfVxuICAgIGlmIChpbnB1dFZhbHVlID4gR1JBUEhRTF9NQVhfSU5UIHx8IGlucHV0VmFsdWUgPCBHUkFQSFFMX01JTl9JTlQpIHtcbiAgICAgIHRocm93IG5ldyBHcmFwaFFMRXJyb3IoYEludCBjYW5ub3QgcmVwcmVzZW50IG5vbiAzMi1iaXQgc2lnbmVkIGludGVnZXIgdmFsdWU6ICR7aW5wdXRWYWx1ZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0VmFsdWU7XG4gIH0sXG4gIHBhcnNlTGl0ZXJhbCh2YWx1ZU5vZGUpIHtcbiAgICBpZiAodmFsdWVOb2RlLmtpbmQgIT09IEtpbmQuSU5UKSB7XG4gICAgICB0aHJvdyBuZXcgR3JhcGhRTEVycm9yKGBJbnQgY2Fubm90IHJlcHJlc2VudCBub24taW50ZWdlciB2YWx1ZTogJHtwcmludCh2YWx1ZU5vZGUpfWAsIHtcbiAgICAgICAgbm9kZXM6IHZhbHVlTm9kZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG51bSA9IHBhcnNlSW50KHZhbHVlTm9kZS52YWx1ZSwgMTApO1xuICAgIGlmIChudW0gPiBHUkFQSFFMX01BWF9JTlQgfHwgbnVtIDwgR1JBUEhRTF9NSU5fSU5UKSB7XG4gICAgICB0aHJvdyBuZXcgR3JhcGhRTEVycm9yKGBJbnQgY2Fubm90IHJlcHJlc2VudCBub24gMzItYml0IHNpZ25lZCBpbnRlZ2VyIHZhbHVlOiAke3ZhbHVlTm9kZS52YWx1ZX1gLCB7XG4gICAgICAgIG5vZGVzOiB2YWx1ZU5vZGVcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbnVtO1xuICB9XG59KTtcbmNvbnN0IEdyYXBoUUxGbG9hdCA9IG5ldyBHcmFwaFFMU2NhbGFyVHlwZSh7XG4gIG5hbWU6IFwiRmxvYXRcIixcbiAgZGVzY3JpcHRpb246IFwiVGhlIGBGbG9hdGAgc2NhbGFyIHR5cGUgcmVwcmVzZW50cyBzaWduZWQgZG91YmxlLXByZWNpc2lvbiBmcmFjdGlvbmFsIHZhbHVlcyBhcyBzcGVjaWZpZWQgYnkgW0lFRUUgNzU0XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JRUVFX2Zsb2F0aW5nX3BvaW50KS5cIixcbiAgc2VyaWFsaXplKG91dHB1dFZhbHVlKSB7XG4gICAgY29uc3QgY29lcmNlZFZhbHVlID0gc2VyaWFsaXplT2JqZWN0KG91dHB1dFZhbHVlKTtcbiAgICBpZiAodHlwZW9mIGNvZXJjZWRWYWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHJldHVybiBjb2VyY2VkVmFsdWUgPyAxIDogMDtcbiAgICB9XG4gICAgbGV0IG51bSA9IGNvZXJjZWRWYWx1ZTtcbiAgICBpZiAodHlwZW9mIGNvZXJjZWRWYWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiBjb2VyY2VkVmFsdWUgIT09IFwiXCIpIHtcbiAgICAgIG51bSA9IE51bWJlcihjb2VyY2VkVmFsdWUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG51bSAhPT0gXCJudW1iZXJcIiB8fCAhTnVtYmVyLmlzRmluaXRlKG51bSkpIHtcbiAgICAgIHRocm93IG5ldyBHcmFwaFFMRXJyb3IoYEZsb2F0IGNhbm5vdCByZXByZXNlbnQgbm9uIG51bWVyaWMgdmFsdWU6ICR7aW5zcGVjdChjb2VyY2VkVmFsdWUpfWApO1xuICAgIH1cbiAgICByZXR1cm4gbnVtO1xuICB9LFxuICBwYXJzZVZhbHVlKGlucHV0VmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0VmFsdWUgIT09IFwibnVtYmVyXCIgfHwgIU51bWJlci5pc0Zpbml0ZShpbnB1dFZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEdyYXBoUUxFcnJvcihgRmxvYXQgY2Fubm90IHJlcHJlc2VudCBub24gbnVtZXJpYyB2YWx1ZTogJHtpbnNwZWN0KGlucHV0VmFsdWUpfWApO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXRWYWx1ZTtcbiAgfSxcbiAgcGFyc2VMaXRlcmFsKHZhbHVlTm9kZSkge1xuICAgIGlmICh2YWx1ZU5vZGUua2luZCAhPT0gS2luZC5GTE9BVCAmJiB2YWx1ZU5vZGUua2luZCAhPT0gS2luZC5JTlQpIHtcbiAgICAgIHRocm93IG5ldyBHcmFwaFFMRXJyb3IoYEZsb2F0IGNhbm5vdCByZXByZXNlbnQgbm9uIG51bWVyaWMgdmFsdWU6ICR7cHJpbnQodmFsdWVOb2RlKX1gLCB2YWx1ZU5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZU5vZGUudmFsdWUpO1xuICB9XG59KTtcbmNvbnN0IEdyYXBoUUxTdHJpbmcgPSBuZXcgR3JhcGhRTFNjYWxhclR5cGUoe1xuICBuYW1lOiBcIlN0cmluZ1wiLFxuICBkZXNjcmlwdGlvbjogXCJUaGUgYFN0cmluZ2Agc2NhbGFyIHR5cGUgcmVwcmVzZW50cyB0ZXh0dWFsIGRhdGEsIHJlcHJlc2VudGVkIGFzIFVURi04IGNoYXJhY3RlciBzZXF1ZW5jZXMuIFRoZSBTdHJpbmcgdHlwZSBpcyBtb3N0IG9mdGVuIHVzZWQgYnkgR3JhcGhRTCB0byByZXByZXNlbnQgZnJlZS1mb3JtIGh1bWFuLXJlYWRhYmxlIHRleHQuXCIsXG4gIHNlcmlhbGl6ZShvdXRwdXRWYWx1ZSkge1xuICAgIGNvbnN0IGNvZXJjZWRWYWx1ZSA9IHNlcmlhbGl6ZU9iamVjdChvdXRwdXRWYWx1ZSk7XG4gICAgaWYgKHR5cGVvZiBjb2VyY2VkVmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBjb2VyY2VkVmFsdWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY29lcmNlZFZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgcmV0dXJuIGNvZXJjZWRWYWx1ZSA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvZXJjZWRWYWx1ZSA9PT0gXCJudW1iZXJcIiAmJiBOdW1iZXIuaXNGaW5pdGUoY29lcmNlZFZhbHVlKSkge1xuICAgICAgcmV0dXJuIGNvZXJjZWRWYWx1ZS50b1N0cmluZygpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgR3JhcGhRTEVycm9yKGBTdHJpbmcgY2Fubm90IHJlcHJlc2VudCB2YWx1ZTogJHtpbnNwZWN0KG91dHB1dFZhbHVlKX1gKTtcbiAgfSxcbiAgcGFyc2VWYWx1ZShpbnB1dFZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dFZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgR3JhcGhRTEVycm9yKGBTdHJpbmcgY2Fubm90IHJlcHJlc2VudCBhIG5vbiBzdHJpbmcgdmFsdWU6ICR7aW5zcGVjdChpbnB1dFZhbHVlKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0VmFsdWU7XG4gIH0sXG4gIHBhcnNlTGl0ZXJhbCh2YWx1ZU5vZGUpIHtcbiAgICBpZiAodmFsdWVOb2RlLmtpbmQgIT09IEtpbmQuU1RSSU5HKSB7XG4gICAgICB0aHJvdyBuZXcgR3JhcGhRTEVycm9yKGBTdHJpbmcgY2Fubm90IHJlcHJlc2VudCBhIG5vbiBzdHJpbmcgdmFsdWU6ICR7cHJpbnQodmFsdWVOb2RlKX1gLCB7XG4gICAgICAgIG5vZGVzOiB2YWx1ZU5vZGVcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVOb2RlLnZhbHVlO1xuICB9XG59KTtcbmNvbnN0IEdyYXBoUUxCb29sZWFuID0gbmV3IEdyYXBoUUxTY2FsYXJUeXBlKHtcbiAgbmFtZTogXCJCb29sZWFuXCIsXG4gIGRlc2NyaXB0aW9uOiBcIlRoZSBgQm9vbGVhbmAgc2NhbGFyIHR5cGUgcmVwcmVzZW50cyBgdHJ1ZWAgb3IgYGZhbHNlYC5cIixcbiAgc2VyaWFsaXplKG91dHB1dFZhbHVlKSB7XG4gICAgY29uc3QgY29lcmNlZFZhbHVlID0gc2VyaWFsaXplT2JqZWN0KG91dHB1dFZhbHVlKTtcbiAgICBpZiAodHlwZW9mIGNvZXJjZWRWYWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHJldHVybiBjb2VyY2VkVmFsdWU7XG4gICAgfVxuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoY29lcmNlZFZhbHVlKSkge1xuICAgICAgcmV0dXJuIGNvZXJjZWRWYWx1ZSAhPT0gMDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEdyYXBoUUxFcnJvcihgQm9vbGVhbiBjYW5ub3QgcmVwcmVzZW50IGEgbm9uIGJvb2xlYW4gdmFsdWU6ICR7aW5zcGVjdChjb2VyY2VkVmFsdWUpfWApO1xuICB9LFxuICBwYXJzZVZhbHVlKGlucHV0VmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0VmFsdWUgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICB0aHJvdyBuZXcgR3JhcGhRTEVycm9yKGBCb29sZWFuIGNhbm5vdCByZXByZXNlbnQgYSBub24gYm9vbGVhbiB2YWx1ZTogJHtpbnNwZWN0KGlucHV0VmFsdWUpfWApO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXRWYWx1ZTtcbiAgfSxcbiAgcGFyc2VMaXRlcmFsKHZhbHVlTm9kZSkge1xuICAgIGlmICh2YWx1ZU5vZGUua2luZCAhPT0gS2luZC5CT09MRUFOKSB7XG4gICAgICB0aHJvdyBuZXcgR3JhcGhRTEVycm9yKGBCb29sZWFuIGNhbm5vdCByZXByZXNlbnQgYSBub24gYm9vbGVhbiB2YWx1ZTogJHtwcmludCh2YWx1ZU5vZGUpfWAsIHtcbiAgICAgICAgbm9kZXM6IHZhbHVlTm9kZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZU5vZGUudmFsdWU7XG4gIH1cbn0pO1xuY29uc3QgR3JhcGhRTElEID0gbmV3IEdyYXBoUUxTY2FsYXJUeXBlKHtcbiAgbmFtZTogXCJJRFwiLFxuICBkZXNjcmlwdGlvbjogJ1RoZSBgSURgIHNjYWxhciB0eXBlIHJlcHJlc2VudHMgYSB1bmlxdWUgaWRlbnRpZmllciwgb2Z0ZW4gdXNlZCB0byByZWZldGNoIGFuIG9iamVjdCBvciBhcyBrZXkgZm9yIGEgY2FjaGUuIFRoZSBJRCB0eXBlIGFwcGVhcnMgaW4gYSBKU09OIHJlc3BvbnNlIGFzIGEgU3RyaW5nOyBob3dldmVyLCBpdCBpcyBub3QgaW50ZW5kZWQgdG8gYmUgaHVtYW4tcmVhZGFibGUuIFdoZW4gZXhwZWN0ZWQgYXMgYW4gaW5wdXQgdHlwZSwgYW55IHN0cmluZyAoc3VjaCBhcyBgXCI0XCJgKSBvciBpbnRlZ2VyIChzdWNoIGFzIGA0YCkgaW5wdXQgdmFsdWUgd2lsbCBiZSBhY2NlcHRlZCBhcyBhbiBJRC4nLFxuICBzZXJpYWxpemUob3V0cHV0VmFsdWUpIHtcbiAgICBjb25zdCBjb2VyY2VkVmFsdWUgPSBzZXJpYWxpemVPYmplY3Qob3V0cHV0VmFsdWUpO1xuICAgIGlmICh0eXBlb2YgY29lcmNlZFZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gY29lcmNlZFZhbHVlO1xuICAgIH1cbiAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihjb2VyY2VkVmFsdWUpKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGNvZXJjZWRWYWx1ZSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBHcmFwaFFMRXJyb3IoYElEIGNhbm5vdCByZXByZXNlbnQgdmFsdWU6ICR7aW5zcGVjdChvdXRwdXRWYWx1ZSl9YCk7XG4gIH0sXG4gIHBhcnNlVmFsdWUoaW5wdXRWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgaW5wdXRWYWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIGlucHV0VmFsdWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXRWYWx1ZSA9PT0gXCJudW1iZXJcIiAmJiBOdW1iZXIuaXNJbnRlZ2VyKGlucHV0VmFsdWUpKSB7XG4gICAgICByZXR1cm4gaW5wdXRWYWx1ZS50b1N0cmluZygpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgR3JhcGhRTEVycm9yKGBJRCBjYW5ub3QgcmVwcmVzZW50IHZhbHVlOiAke2luc3BlY3QoaW5wdXRWYWx1ZSl9YCk7XG4gIH0sXG4gIHBhcnNlTGl0ZXJhbCh2YWx1ZU5vZGUpIHtcbiAgICBpZiAodmFsdWVOb2RlLmtpbmQgIT09IEtpbmQuU1RSSU5HICYmIHZhbHVlTm9kZS5raW5kICE9PSBLaW5kLklOVCkge1xuICAgICAgdGhyb3cgbmV3IEdyYXBoUUxFcnJvcihcIklEIGNhbm5vdCByZXByZXNlbnQgYSBub24tc3RyaW5nIGFuZCBub24taW50ZWdlciB2YWx1ZTogXCIgKyBwcmludCh2YWx1ZU5vZGUpLCB7XG4gICAgICAgIG5vZGVzOiB2YWx1ZU5vZGVcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVOb2RlLnZhbHVlO1xuICB9XG59KTtcbk9iamVjdC5mcmVlemUoW1xuICBHcmFwaFFMU3RyaW5nLFxuICBHcmFwaFFMSW50LFxuICBHcmFwaFFMRmxvYXQsXG4gIEdyYXBoUUxCb29sZWFuLFxuICBHcmFwaFFMSURcbl0pO1xuZnVuY3Rpb24gc2VyaWFsaXplT2JqZWN0KG91dHB1dFZhbHVlKSB7XG4gIGlmIChpc09iamVjdExpa2Uob3V0cHV0VmFsdWUpKSB7XG4gICAgaWYgKHR5cGVvZiBvdXRwdXRWYWx1ZS52YWx1ZU9mID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNvbnN0IHZhbHVlT2ZSZXN1bHQgPSBvdXRwdXRWYWx1ZS52YWx1ZU9mKCk7XG4gICAgICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZU9mUmVzdWx0KSkge1xuICAgICAgICByZXR1cm4gdmFsdWVPZlJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvdXRwdXRWYWx1ZS50b0pTT04gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIG91dHB1dFZhbHVlLnRvSlNPTigpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0cHV0VmFsdWU7XG59XG5fX25hbWUoc2VyaWFsaXplT2JqZWN0LCBcInNlcmlhbGl6ZU9iamVjdFwiKTtcbmZ1bmN0aW9uIGFzdEZyb21WYWx1ZSh2YWx1ZSwgdHlwZSkge1xuICBpZiAoaXNOb25OdWxsVHlwZSh0eXBlKSkge1xuICAgIGNvbnN0IGFzdFZhbHVlID0gYXN0RnJvbVZhbHVlKHZhbHVlLCB0eXBlLm9mVHlwZSk7XG4gICAgaWYgKChhc3RWYWx1ZSA9PT0gbnVsbCB8fCBhc3RWYWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXN0VmFsdWUua2luZCkgPT09IEtpbmQuTlVMTCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBhc3RWYWx1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2luZDogS2luZC5OVUxMXG4gICAgfTtcbiAgfVxuICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChpc0xpc3RUeXBlKHR5cGUpKSB7XG4gICAgY29uc3QgaXRlbVR5cGUgPSB0eXBlLm9mVHlwZTtcbiAgICBpZiAoaXNJdGVyYWJsZU9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIGNvbnN0IHZhbHVlc05vZGVzID0gW107XG4gICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgaXRlbU5vZGUgPSBhc3RGcm9tVmFsdWUoaXRlbSwgaXRlbVR5cGUpO1xuICAgICAgICBpZiAoaXRlbU5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgIHZhbHVlc05vZGVzLnB1c2goaXRlbU5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBraW5kOiBLaW5kLkxJU1QsXG4gICAgICAgIHZhbHVlczogdmFsdWVzTm9kZXNcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBhc3RGcm9tVmFsdWUodmFsdWUsIGl0ZW1UeXBlKTtcbiAgfVxuICBpZiAoaXNJbnB1dE9iamVjdFR5cGUodHlwZSkpIHtcbiAgICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBmaWVsZE5vZGVzID0gW107XG4gICAgZm9yIChjb25zdCBmaWVsZCBvZiBPYmplY3QudmFsdWVzKHR5cGUuZ2V0RmllbGRzKCkpKSB7XG4gICAgICBjb25zdCBmaWVsZFZhbHVlID0gYXN0RnJvbVZhbHVlKHZhbHVlW2ZpZWxkLm5hbWVdLCBmaWVsZC50eXBlKTtcbiAgICAgIGlmIChmaWVsZFZhbHVlKSB7XG4gICAgICAgIGZpZWxkTm9kZXMucHVzaCh7XG4gICAgICAgICAga2luZDogS2luZC5PQkpFQ1RfRklFTEQsXG4gICAgICAgICAgbmFtZToge1xuICAgICAgICAgICAga2luZDogS2luZC5OQU1FLFxuICAgICAgICAgICAgdmFsdWU6IGZpZWxkLm5hbWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIHZhbHVlOiBmaWVsZFZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAga2luZDogS2luZC5PQkpFQ1QsXG4gICAgICBmaWVsZHM6IGZpZWxkTm9kZXNcbiAgICB9O1xuICB9XG4gIGlmIChpc0xlYWZUeXBlKHR5cGUpKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IHR5cGUuc2VyaWFsaXplKHZhbHVlKTtcbiAgICBpZiAoc2VyaWFsaXplZCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzZXJpYWxpemVkID09PSBcImJvb2xlYW5cIikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2luZDogS2luZC5CT09MRUFOLFxuICAgICAgICB2YWx1ZTogc2VyaWFsaXplZFxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzZXJpYWxpemVkID09PSBcIm51bWJlclwiICYmIE51bWJlci5pc0Zpbml0ZShzZXJpYWxpemVkKSkge1xuICAgICAgY29uc3Qgc3RyaW5nTnVtID0gU3RyaW5nKHNlcmlhbGl6ZWQpO1xuICAgICAgcmV0dXJuIGludGVnZXJTdHJpbmdSZWdFeHAudGVzdChzdHJpbmdOdW0pID8ge1xuICAgICAgICBraW5kOiBLaW5kLklOVCxcbiAgICAgICAgdmFsdWU6IHN0cmluZ051bVxuICAgICAgfSA6IHtcbiAgICAgICAga2luZDogS2luZC5GTE9BVCxcbiAgICAgICAgdmFsdWU6IHN0cmluZ051bVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzZXJpYWxpemVkID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAoaXNFbnVtVHlwZSh0eXBlKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGtpbmQ6IEtpbmQuRU5VTSxcbiAgICAgICAgICB2YWx1ZTogc2VyaWFsaXplZFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09IEdyYXBoUUxJRCAmJiBpbnRlZ2VyU3RyaW5nUmVnRXhwLnRlc3Qoc2VyaWFsaXplZCkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBraW5kOiBLaW5kLklOVCxcbiAgICAgICAgICB2YWx1ZTogc2VyaWFsaXplZFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2luZDogS2luZC5TVFJJTkcsXG4gICAgICAgIHZhbHVlOiBzZXJpYWxpemVkXG4gICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW5ub3QgY29udmVydCB2YWx1ZSB0byBBU1Q6ICR7aW5zcGVjdChzZXJpYWxpemVkKX0uYCk7XG4gIH1cbiAgaW52YXJpYW50KGZhbHNlLCBcIlVuZXhwZWN0ZWQgaW5wdXQgdHlwZTogXCIgKyBpbnNwZWN0KHR5cGUpKTtcbn1cbl9fbmFtZShhc3RGcm9tVmFsdWUsIFwiYXN0RnJvbVZhbHVlXCIpO1xuY29uc3QgaW50ZWdlclN0cmluZ1JlZ0V4cCA9IC9eLT8oPzowfFsxLTldWzAtOV0qKSQvO1xuY29uc3QgX19TY2hlbWEgPSBuZXcgR3JhcGhRTE9iamVjdFR5cGUoe1xuICBuYW1lOiBcIl9fU2NoZW1hXCIsXG4gIGRlc2NyaXB0aW9uOiBcIkEgR3JhcGhRTCBTY2hlbWEgZGVmaW5lcyB0aGUgY2FwYWJpbGl0aWVzIG9mIGEgR3JhcGhRTCBzZXJ2ZXIuIEl0IGV4cG9zZXMgYWxsIGF2YWlsYWJsZSB0eXBlcyBhbmQgZGlyZWN0aXZlcyBvbiB0aGUgc2VydmVyLCBhcyB3ZWxsIGFzIHRoZSBlbnRyeSBwb2ludHMgZm9yIHF1ZXJ5LCBtdXRhdGlvbiwgYW5kIHN1YnNjcmlwdGlvbiBvcGVyYXRpb25zLlwiLFxuICBmaWVsZHM6ICgpID0+ICh7XG4gICAgZGVzY3JpcHRpb246IHtcbiAgICAgIHR5cGU6IEdyYXBoUUxTdHJpbmcsXG4gICAgICByZXNvbHZlOiAoc2NoZW1hKSA9PiBzY2hlbWEuZGVzY3JpcHRpb25cbiAgICB9LFxuICAgIHR5cGVzOiB7XG4gICAgICBkZXNjcmlwdGlvbjogXCJBIGxpc3Qgb2YgYWxsIHR5cGVzIHN1cHBvcnRlZCBieSB0aGlzIHNlcnZlci5cIixcbiAgICAgIHR5cGU6IG5ldyBHcmFwaFFMTm9uTnVsbChuZXcgR3JhcGhRTExpc3QobmV3IEdyYXBoUUxOb25OdWxsKF9fVHlwZSkpKSxcbiAgICAgIHJlc29sdmUoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHNjaGVtYS5nZXRUeXBlTWFwKCkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcXVlcnlUeXBlOiB7XG4gICAgICBkZXNjcmlwdGlvbjogXCJUaGUgdHlwZSB0aGF0IHF1ZXJ5IG9wZXJhdGlvbnMgd2lsbCBiZSByb290ZWQgYXQuXCIsXG4gICAgICB0eXBlOiBuZXcgR3JhcGhRTE5vbk51bGwoX19UeXBlKSxcbiAgICAgIHJlc29sdmU6IChzY2hlbWEpID0+IHNjaGVtYS5nZXRRdWVyeVR5cGUoKVxuICAgIH0sXG4gICAgbXV0YXRpb25UeXBlOiB7XG4gICAgICBkZXNjcmlwdGlvbjogXCJJZiB0aGlzIHNlcnZlciBzdXBwb3J0cyBtdXRhdGlvbiwgdGhlIHR5cGUgdGhhdCBtdXRhdGlvbiBvcGVyYXRpb25zIHdpbGwgYmUgcm9vdGVkIGF0LlwiLFxuICAgICAgdHlwZTogX19UeXBlLFxuICAgICAgcmVzb2x2ZTogKHNjaGVtYSkgPT4gc2NoZW1hLmdldE11dGF0aW9uVHlwZSgpXG4gICAgfSxcbiAgICBzdWJzY3JpcHRpb25UeXBlOiB7XG4gICAgICBkZXNjcmlwdGlvbjogXCJJZiB0aGlzIHNlcnZlciBzdXBwb3J0IHN1YnNjcmlwdGlvbiwgdGhlIHR5cGUgdGhhdCBzdWJzY3JpcHRpb24gb3BlcmF0aW9ucyB3aWxsIGJlIHJvb3RlZCBhdC5cIixcbiAgICAgIHR5cGU6IF9fVHlwZSxcbiAgICAgIHJlc29sdmU6IChzY2hlbWEpID0+IHNjaGVtYS5nZXRTdWJzY3JpcHRpb25UeXBlKClcbiAgICB9LFxuICAgIGRpcmVjdGl2ZXM6IHtcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkEgbGlzdCBvZiBhbGwgZGlyZWN0aXZlcyBzdXBwb3J0ZWQgYnkgdGhpcyBzZXJ2ZXIuXCIsXG4gICAgICB0eXBlOiBuZXcgR3JhcGhRTE5vbk51bGwobmV3IEdyYXBoUUxMaXN0KG5ldyBHcmFwaFFMTm9uTnVsbChfX0RpcmVjdGl2ZSkpKSxcbiAgICAgIHJlc29sdmU6IChzY2hlbWEpID0+IHNjaGVtYS5nZXREaXJlY3RpdmVzKClcbiAgICB9XG4gIH0pXG59KTtcbmNvbnN0IF9fRGlyZWN0aXZlID0gbmV3IEdyYXBoUUxPYmplY3RUeXBlKHtcbiAgbmFtZTogXCJfX0RpcmVjdGl2ZVwiLFxuICBkZXNjcmlwdGlvbjogXCJBIERpcmVjdGl2ZSBwcm92aWRlcyBhIHdheSB0byBkZXNjcmliZSBhbHRlcm5hdGUgcnVudGltZSBleGVjdXRpb24gYW5kIHR5cGUgdmFsaWRhdGlvbiBiZWhhdmlvciBpbiBhIEdyYXBoUUwgZG9jdW1lbnQuXFxuXFxuSW4gc29tZSBjYXNlcywgeW91IG5lZWQgdG8gcHJvdmlkZSBvcHRpb25zIHRvIGFsdGVyIEdyYXBoUUwncyBleGVjdXRpb24gYmVoYXZpb3IgaW4gd2F5cyBmaWVsZCBhcmd1bWVudHMgd2lsbCBub3Qgc3VmZmljZSwgc3VjaCBhcyBjb25kaXRpb25hbGx5IGluY2x1ZGluZyBvciBza2lwcGluZyBhIGZpZWxkLiBEaXJlY3RpdmVzIHByb3ZpZGUgdGhpcyBieSBkZXNjcmliaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gdG8gdGhlIGV4ZWN1dG9yLlwiLFxuICBmaWVsZHM6ICgpID0+ICh7XG4gICAgbmFtZToge1xuICAgICAgdHlwZTogbmV3IEdyYXBoUUxOb25OdWxsKEdyYXBoUUxTdHJpbmcpLFxuICAgICAgcmVzb2x2ZTogKGRpcmVjdGl2ZSkgPT4gZGlyZWN0aXZlLm5hbWVcbiAgICB9LFxuICAgIGRlc2NyaXB0aW9uOiB7XG4gICAgICB0eXBlOiBHcmFwaFFMU3RyaW5nLFxuICAgICAgcmVzb2x2ZTogKGRpcmVjdGl2ZSkgPT4gZGlyZWN0aXZlLmRlc2NyaXB0aW9uXG4gICAgfSxcbiAgICBpc1JlcGVhdGFibGU6IHtcbiAgICAgIHR5cGU6IG5ldyBHcmFwaFFMTm9uTnVsbChHcmFwaFFMQm9vbGVhbiksXG4gICAgICByZXNvbHZlOiAoZGlyZWN0aXZlKSA9PiBkaXJlY3RpdmUuaXNSZXBlYXRhYmxlXG4gICAgfSxcbiAgICBsb2NhdGlvbnM6IHtcbiAgICAgIHR5cGU6IG5ldyBHcmFwaFFMTm9uTnVsbChuZXcgR3JhcGhRTExpc3QobmV3IEdyYXBoUUxOb25OdWxsKF9fRGlyZWN0aXZlTG9jYXRpb24pKSksXG4gICAgICByZXNvbHZlOiAoZGlyZWN0aXZlKSA9PiBkaXJlY3RpdmUubG9jYXRpb25zXG4gICAgfSxcbiAgICBhcmdzOiB7XG4gICAgICB0eXBlOiBuZXcgR3JhcGhRTE5vbk51bGwobmV3IEdyYXBoUUxMaXN0KG5ldyBHcmFwaFFMTm9uTnVsbChfX0lucHV0VmFsdWUpKSksXG4gICAgICBhcmdzOiB7XG4gICAgICAgIGluY2x1ZGVEZXByZWNhdGVkOiB7XG4gICAgICAgICAgdHlwZTogR3JhcGhRTEJvb2xlYW4sXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVzb2x2ZShmaWVsZCwgeyBpbmNsdWRlRGVwcmVjYXRlZCB9KSB7XG4gICAgICAgIHJldHVybiBpbmNsdWRlRGVwcmVjYXRlZCA/IGZpZWxkLmFyZ3MgOiBmaWVsZC5hcmdzLmZpbHRlcigoYXJnKSA9PiBhcmcuZGVwcmVjYXRpb25SZWFzb24gPT0gbnVsbCk7XG4gICAgICB9XG4gICAgfVxuICB9KVxufSk7XG5jb25zdCBfX0RpcmVjdGl2ZUxvY2F0aW9uID0gbmV3IEdyYXBoUUxFbnVtVHlwZSh7XG4gIG5hbWU6IFwiX19EaXJlY3RpdmVMb2NhdGlvblwiLFxuICBkZXNjcmlwdGlvbjogXCJBIERpcmVjdGl2ZSBjYW4gYmUgYWRqYWNlbnQgdG8gbWFueSBwYXJ0cyBvZiB0aGUgR3JhcGhRTCBsYW5ndWFnZSwgYSBfX0RpcmVjdGl2ZUxvY2F0aW9uIGRlc2NyaWJlcyBvbmUgc3VjaCBwb3NzaWJsZSBhZGphY2VuY2llcy5cIixcbiAgdmFsdWVzOiB7XG4gICAgUVVFUlk6IHtcbiAgICAgIHZhbHVlOiBEaXJlY3RpdmVMb2NhdGlvbi5RVUVSWSxcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkxvY2F0aW9uIGFkamFjZW50IHRvIGEgcXVlcnkgb3BlcmF0aW9uLlwiXG4gICAgfSxcbiAgICBNVVRBVElPTjoge1xuICAgICAgdmFsdWU6IERpcmVjdGl2ZUxvY2F0aW9uLk1VVEFUSU9OLFxuICAgICAgZGVzY3JpcHRpb246IFwiTG9jYXRpb24gYWRqYWNlbnQgdG8gYSBtdXRhdGlvbiBvcGVyYXRpb24uXCJcbiAgICB9LFxuICAgIFNVQlNDUklQVElPTjoge1xuICAgICAgdmFsdWU6IERpcmVjdGl2ZUxvY2F0aW9uLlNVQlNDUklQVElPTixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkxvY2F0aW9uIGFkamFjZW50IHRvIGEgc3Vic2NyaXB0aW9uIG9wZXJhdGlvbi5cIlxuICAgIH0sXG4gICAgRklFTEQ6IHtcbiAgICAgIHZhbHVlOiBEaXJlY3RpdmVMb2NhdGlvbi5GSUVMRCxcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkxvY2F0aW9uIGFkamFjZW50IHRvIGEgZmllbGQuXCJcbiAgICB9LFxuICAgIEZSQUdNRU5UX0RFRklOSVRJT046IHtcbiAgICAgIHZhbHVlOiBEaXJlY3RpdmVMb2NhdGlvbi5GUkFHTUVOVF9ERUZJTklUSU9OLFxuICAgICAgZGVzY3JpcHRpb246IFwiTG9jYXRpb24gYWRqYWNlbnQgdG8gYSBmcmFnbWVudCBkZWZpbml0aW9uLlwiXG4gICAgfSxcbiAgICBGUkFHTUVOVF9TUFJFQUQ6IHtcbiAgICAgIHZhbHVlOiBEaXJlY3RpdmVMb2NhdGlvbi5GUkFHTUVOVF9TUFJFQUQsXG4gICAgICBkZXNjcmlwdGlvbjogXCJMb2NhdGlvbiBhZGphY2VudCB0byBhIGZyYWdtZW50IHNwcmVhZC5cIlxuICAgIH0sXG4gICAgSU5MSU5FX0ZSQUdNRU5UOiB7XG4gICAgICB2YWx1ZTogRGlyZWN0aXZlTG9jYXRpb24uSU5MSU5FX0ZSQUdNRU5ULFxuICAgICAgZGVzY3JpcHRpb246IFwiTG9jYXRpb24gYWRqYWNlbnQgdG8gYW4gaW5saW5lIGZyYWdtZW50LlwiXG4gICAgfSxcbiAgICBWQVJJQUJMRV9ERUZJTklUSU9OOiB7XG4gICAgICB2YWx1ZTogRGlyZWN0aXZlTG9jYXRpb24uVkFSSUFCTEVfREVGSU5JVElPTixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkxvY2F0aW9uIGFkamFjZW50IHRvIGEgdmFyaWFibGUgZGVmaW5pdGlvbi5cIlxuICAgIH0sXG4gICAgU0NIRU1BOiB7XG4gICAgICB2YWx1ZTogRGlyZWN0aXZlTG9jYXRpb24uU0NIRU1BLFxuICAgICAgZGVzY3JpcHRpb246IFwiTG9jYXRpb24gYWRqYWNlbnQgdG8gYSBzY2hlbWEgZGVmaW5pdGlvbi5cIlxuICAgIH0sXG4gICAgU0NBTEFSOiB7XG4gICAgICB2YWx1ZTogRGlyZWN0aXZlTG9jYXRpb24uU0NBTEFSLFxuICAgICAgZGVzY3JpcHRpb246IFwiTG9jYXRpb24gYWRqYWNlbnQgdG8gYSBzY2FsYXIgZGVmaW5pdGlvbi5cIlxuICAgIH0sXG4gICAgT0JKRUNUOiB7XG4gICAgICB2YWx1ZTogRGlyZWN0aXZlTG9jYXRpb24uT0JKRUNULFxuICAgICAgZGVzY3JpcHRpb246IFwiTG9jYXRpb24gYWRqYWNlbnQgdG8gYW4gb2JqZWN0IHR5cGUgZGVmaW5pdGlvbi5cIlxuICAgIH0sXG4gICAgRklFTERfREVGSU5JVElPTjoge1xuICAgICAgdmFsdWU6IERpcmVjdGl2ZUxvY2F0aW9uLkZJRUxEX0RFRklOSVRJT04sXG4gICAgICBkZXNjcmlwdGlvbjogXCJMb2NhdGlvbiBhZGphY2VudCB0byBhIGZpZWxkIGRlZmluaXRpb24uXCJcbiAgICB9LFxuICAgIEFSR1VNRU5UX0RFRklOSVRJT046IHtcbiAgICAgIHZhbHVlOiBEaXJlY3RpdmVMb2NhdGlvbi5BUkdVTUVOVF9ERUZJTklUSU9OLFxuICAgICAgZGVzY3JpcHRpb246IFwiTG9jYXRpb24gYWRqYWNlbnQgdG8gYW4gYXJndW1lbnQgZGVmaW5pdGlvbi5cIlxuICAgIH0sXG4gICAgSU5URVJGQUNFOiB7XG4gICAgICB2YWx1ZTogRGlyZWN0aXZlTG9jYXRpb24uSU5URVJGQUNFLFxuICAgICAgZGVzY3JpcHRpb246IFwiTG9jYXRpb24gYWRqYWNlbnQgdG8gYW4gaW50ZXJmYWNlIGRlZmluaXRpb24uXCJcbiAgICB9LFxuICAgIFVOSU9OOiB7XG4gICAgICB2YWx1ZTogRGlyZWN0aXZlTG9jYXRpb24uVU5JT04sXG4gICAgICBkZXNjcmlwdGlvbjogXCJMb2NhdGlvbiBhZGphY2VudCB0byBhIHVuaW9uIGRlZmluaXRpb24uXCJcbiAgICB9LFxuICAgIEVOVU06IHtcbiAgICAgIHZhbHVlOiBEaXJlY3RpdmVMb2NhdGlvbi5FTlVNLFxuICAgICAgZGVzY3JpcHRpb246IFwiTG9jYXRpb24gYWRqYWNlbnQgdG8gYW4gZW51bSBkZWZpbml0aW9uLlwiXG4gICAgfSxcbiAgICBFTlVNX1ZBTFVFOiB7XG4gICAgICB2YWx1ZTogRGlyZWN0aXZlTG9jYXRpb24uRU5VTV9WQUxVRSxcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkxvY2F0aW9uIGFkamFjZW50IHRvIGFuIGVudW0gdmFsdWUgZGVmaW5pdGlvbi5cIlxuICAgIH0sXG4gICAgSU5QVVRfT0JKRUNUOiB7XG4gICAgICB2YWx1ZTogRGlyZWN0aXZlTG9jYXRpb24uSU5QVVRfT0JKRUNULFxuICAgICAgZGVzY3JpcHRpb246IFwiTG9jYXRpb24gYWRqYWNlbnQgdG8gYW4gaW5wdXQgb2JqZWN0IHR5cGUgZGVmaW5pdGlvbi5cIlxuICAgIH0sXG4gICAgSU5QVVRfRklFTERfREVGSU5JVElPTjoge1xuICAgICAgdmFsdWU6IERpcmVjdGl2ZUxvY2F0aW9uLklOUFVUX0ZJRUxEX0RFRklOSVRJT04sXG4gICAgICBkZXNjcmlwdGlvbjogXCJMb2NhdGlvbiBhZGphY2VudCB0byBhbiBpbnB1dCBvYmplY3QgZmllbGQgZGVmaW5pdGlvbi5cIlxuICAgIH1cbiAgfVxufSk7XG5jb25zdCBfX1R5cGUgPSBuZXcgR3JhcGhRTE9iamVjdFR5cGUoe1xuICBuYW1lOiBcIl9fVHlwZVwiLFxuICBkZXNjcmlwdGlvbjogXCJUaGUgZnVuZGFtZW50YWwgdW5pdCBvZiBhbnkgR3JhcGhRTCBTY2hlbWEgaXMgdGhlIHR5cGUuIFRoZXJlIGFyZSBtYW55IGtpbmRzIG9mIHR5cGVzIGluIEdyYXBoUUwgYXMgcmVwcmVzZW50ZWQgYnkgdGhlIGBfX1R5cGVLaW5kYCBlbnVtLlxcblxcbkRlcGVuZGluZyBvbiB0aGUga2luZCBvZiBhIHR5cGUsIGNlcnRhaW4gZmllbGRzIGRlc2NyaWJlIGluZm9ybWF0aW9uIGFib3V0IHRoYXQgdHlwZS4gU2NhbGFyIHR5cGVzIHByb3ZpZGUgbm8gaW5mb3JtYXRpb24gYmV5b25kIGEgbmFtZSwgZGVzY3JpcHRpb24gYW5kIG9wdGlvbmFsIGBzcGVjaWZpZWRCeVVSTGAsIHdoaWxlIEVudW0gdHlwZXMgcHJvdmlkZSB0aGVpciB2YWx1ZXMuIE9iamVjdCBhbmQgSW50ZXJmYWNlIHR5cGVzIHByb3ZpZGUgdGhlIGZpZWxkcyB0aGV5IGRlc2NyaWJlLiBBYnN0cmFjdCB0eXBlcywgVW5pb24gYW5kIEludGVyZmFjZSwgcHJvdmlkZSB0aGUgT2JqZWN0IHR5cGVzIHBvc3NpYmxlIGF0IHJ1bnRpbWUuIExpc3QgYW5kIE5vbk51bGwgdHlwZXMgY29tcG9zZSBvdGhlciB0eXBlcy5cIixcbiAgZmllbGRzOiAoKSA9PiAoe1xuICAgIGtpbmQ6IHtcbiAgICAgIHR5cGU6IG5ldyBHcmFwaFFMTm9uTnVsbChfX1R5cGVLaW5kKSxcbiAgICAgIHJlc29sdmUodHlwZSkge1xuICAgICAgICBpZiAoaXNTY2FsYXJUeXBlKHR5cGUpKSB7XG4gICAgICAgICAgcmV0dXJuIFR5cGVLaW5kLlNDQUxBUjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNPYmplY3RUeXBlKHR5cGUpKSB7XG4gICAgICAgICAgcmV0dXJuIFR5cGVLaW5kLk9CSkVDVDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNJbnRlcmZhY2VUeXBlKHR5cGUpKSB7XG4gICAgICAgICAgcmV0dXJuIFR5cGVLaW5kLklOVEVSRkFDRTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNVbmlvblR5cGUodHlwZSkpIHtcbiAgICAgICAgICByZXR1cm4gVHlwZUtpbmQuVU5JT047XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRW51bVR5cGUodHlwZSkpIHtcbiAgICAgICAgICByZXR1cm4gVHlwZUtpbmQuRU5VTTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNJbnB1dE9iamVjdFR5cGUodHlwZSkpIHtcbiAgICAgICAgICByZXR1cm4gVHlwZUtpbmQuSU5QVVRfT0JKRUNUO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0xpc3RUeXBlKHR5cGUpKSB7XG4gICAgICAgICAgcmV0dXJuIFR5cGVLaW5kLkxJU1Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTm9uTnVsbFR5cGUodHlwZSkpIHtcbiAgICAgICAgICByZXR1cm4gVHlwZUtpbmQuTk9OX05VTEw7XG4gICAgICAgIH1cbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCBgVW5leHBlY3RlZCB0eXBlOiBcIiR7aW5zcGVjdCh0eXBlKX1cIi5gKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG5hbWU6IHtcbiAgICAgIHR5cGU6IEdyYXBoUUxTdHJpbmcsXG4gICAgICByZXNvbHZlOiAodHlwZSkgPT4gXCJuYW1lXCIgaW4gdHlwZSA/IHR5cGUubmFtZSA6IHZvaWQgMFxuICAgIH0sXG4gICAgZGVzY3JpcHRpb246IHtcbiAgICAgIHR5cGU6IEdyYXBoUUxTdHJpbmcsXG4gICAgICByZXNvbHZlOiAodHlwZSkgPT4gXCJkZXNjcmlwdGlvblwiIGluIHR5cGUgPyB0eXBlLmRlc2NyaXB0aW9uIDogdm9pZCAwXG4gICAgfSxcbiAgICBzcGVjaWZpZWRCeVVSTDoge1xuICAgICAgdHlwZTogR3JhcGhRTFN0cmluZyxcbiAgICAgIHJlc29sdmU6IChvYmopID0+IFwic3BlY2lmaWVkQnlVUkxcIiBpbiBvYmogPyBvYmouc3BlY2lmaWVkQnlVUkwgOiB2b2lkIDBcbiAgICB9LFxuICAgIGZpZWxkczoge1xuICAgICAgdHlwZTogbmV3IEdyYXBoUUxMaXN0KG5ldyBHcmFwaFFMTm9uTnVsbChfX0ZpZWxkKSksXG4gICAgICBhcmdzOiB7XG4gICAgICAgIGluY2x1ZGVEZXByZWNhdGVkOiB7XG4gICAgICAgICAgdHlwZTogR3JhcGhRTEJvb2xlYW4sXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVzb2x2ZSh0eXBlLCB7IGluY2x1ZGVEZXByZWNhdGVkIH0pIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0VHlwZSh0eXBlKSB8fCBpc0ludGVyZmFjZVR5cGUodHlwZSkpIHtcbiAgICAgICAgICBjb25zdCBmaWVsZHMgPSBPYmplY3QudmFsdWVzKHR5cGUuZ2V0RmllbGRzKCkpO1xuICAgICAgICAgIHJldHVybiBpbmNsdWRlRGVwcmVjYXRlZCA/IGZpZWxkcyA6IGZpZWxkcy5maWx0ZXIoKGZpZWxkKSA9PiBmaWVsZC5kZXByZWNhdGlvblJlYXNvbiA9PSBudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgaW50ZXJmYWNlczoge1xuICAgICAgdHlwZTogbmV3IEdyYXBoUUxMaXN0KG5ldyBHcmFwaFFMTm9uTnVsbChfX1R5cGUpKSxcbiAgICAgIHJlc29sdmUodHlwZSkge1xuICAgICAgICBpZiAoaXNPYmplY3RUeXBlKHR5cGUpIHx8IGlzSW50ZXJmYWNlVHlwZSh0eXBlKSkge1xuICAgICAgICAgIHJldHVybiB0eXBlLmdldEludGVyZmFjZXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgcG9zc2libGVUeXBlczoge1xuICAgICAgdHlwZTogbmV3IEdyYXBoUUxMaXN0KG5ldyBHcmFwaFFMTm9uTnVsbChfX1R5cGUpKSxcbiAgICAgIHJlc29sdmUodHlwZSwgX2FyZ3MsIF9jb250ZXh0LCB7IHNjaGVtYSB9KSB7XG4gICAgICAgIGlmIChpc0Fic3RyYWN0VHlwZSh0eXBlKSkge1xuICAgICAgICAgIHJldHVybiBzY2hlbWEuZ2V0UG9zc2libGVUeXBlcyh0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZW51bVZhbHVlczoge1xuICAgICAgdHlwZTogbmV3IEdyYXBoUUxMaXN0KG5ldyBHcmFwaFFMTm9uTnVsbChfX0VudW1WYWx1ZSkpLFxuICAgICAgYXJnczoge1xuICAgICAgICBpbmNsdWRlRGVwcmVjYXRlZDoge1xuICAgICAgICAgIHR5cGU6IEdyYXBoUUxCb29sZWFuLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlc29sdmUodHlwZSwgeyBpbmNsdWRlRGVwcmVjYXRlZCB9KSB7XG4gICAgICAgIGlmIChpc0VudW1UeXBlKHR5cGUpKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWVzID0gdHlwZS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgICByZXR1cm4gaW5jbHVkZURlcHJlY2F0ZWQgPyB2YWx1ZXMgOiB2YWx1ZXMuZmlsdGVyKChmaWVsZCkgPT4gZmllbGQuZGVwcmVjYXRpb25SZWFzb24gPT0gbnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGlucHV0RmllbGRzOiB7XG4gICAgICB0eXBlOiBuZXcgR3JhcGhRTExpc3QobmV3IEdyYXBoUUxOb25OdWxsKF9fSW5wdXRWYWx1ZSkpLFxuICAgICAgYXJnczoge1xuICAgICAgICBpbmNsdWRlRGVwcmVjYXRlZDoge1xuICAgICAgICAgIHR5cGU6IEdyYXBoUUxCb29sZWFuLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlc29sdmUodHlwZSwgeyBpbmNsdWRlRGVwcmVjYXRlZCB9KSB7XG4gICAgICAgIGlmIChpc0lucHV0T2JqZWN0VHlwZSh0eXBlKSkge1xuICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IE9iamVjdC52YWx1ZXModHlwZS5nZXRGaWVsZHMoKSk7XG4gICAgICAgICAgcmV0dXJuIGluY2x1ZGVEZXByZWNhdGVkID8gdmFsdWVzIDogdmFsdWVzLmZpbHRlcigoZmllbGQpID0+IGZpZWxkLmRlcHJlY2F0aW9uUmVhc29uID09IG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBvZlR5cGU6IHtcbiAgICAgIHR5cGU6IF9fVHlwZSxcbiAgICAgIHJlc29sdmU6ICh0eXBlKSA9PiBcIm9mVHlwZVwiIGluIHR5cGUgPyB0eXBlLm9mVHlwZSA6IHZvaWQgMFxuICAgIH1cbiAgfSlcbn0pO1xuY29uc3QgX19GaWVsZCA9IG5ldyBHcmFwaFFMT2JqZWN0VHlwZSh7XG4gIG5hbWU6IFwiX19GaWVsZFwiLFxuICBkZXNjcmlwdGlvbjogXCJPYmplY3QgYW5kIEludGVyZmFjZSB0eXBlcyBhcmUgZGVzY3JpYmVkIGJ5IGEgbGlzdCBvZiBGaWVsZHMsIGVhY2ggb2Ygd2hpY2ggaGFzIGEgbmFtZSwgcG90ZW50aWFsbHkgYSBsaXN0IG9mIGFyZ3VtZW50cywgYW5kIGEgcmV0dXJuIHR5cGUuXCIsXG4gIGZpZWxkczogKCkgPT4gKHtcbiAgICBuYW1lOiB7XG4gICAgICB0eXBlOiBuZXcgR3JhcGhRTE5vbk51bGwoR3JhcGhRTFN0cmluZyksXG4gICAgICByZXNvbHZlOiAoZmllbGQpID0+IGZpZWxkLm5hbWVcbiAgICB9LFxuICAgIGRlc2NyaXB0aW9uOiB7XG4gICAgICB0eXBlOiBHcmFwaFFMU3RyaW5nLFxuICAgICAgcmVzb2x2ZTogKGZpZWxkKSA9PiBmaWVsZC5kZXNjcmlwdGlvblxuICAgIH0sXG4gICAgYXJnczoge1xuICAgICAgdHlwZTogbmV3IEdyYXBoUUxOb25OdWxsKG5ldyBHcmFwaFFMTGlzdChuZXcgR3JhcGhRTE5vbk51bGwoX19JbnB1dFZhbHVlKSkpLFxuICAgICAgYXJnczoge1xuICAgICAgICBpbmNsdWRlRGVwcmVjYXRlZDoge1xuICAgICAgICAgIHR5cGU6IEdyYXBoUUxCb29sZWFuLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlc29sdmUoZmllbGQsIHsgaW5jbHVkZURlcHJlY2F0ZWQgfSkge1xuICAgICAgICByZXR1cm4gaW5jbHVkZURlcHJlY2F0ZWQgPyBmaWVsZC5hcmdzIDogZmllbGQuYXJncy5maWx0ZXIoKGFyZykgPT4gYXJnLmRlcHJlY2F0aW9uUmVhc29uID09IG51bGwpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdHlwZToge1xuICAgICAgdHlwZTogbmV3IEdyYXBoUUxOb25OdWxsKF9fVHlwZSksXG4gICAgICByZXNvbHZlOiAoZmllbGQpID0+IGZpZWxkLnR5cGVcbiAgICB9LFxuICAgIGlzRGVwcmVjYXRlZDoge1xuICAgICAgdHlwZTogbmV3IEdyYXBoUUxOb25OdWxsKEdyYXBoUUxCb29sZWFuKSxcbiAgICAgIHJlc29sdmU6IChmaWVsZCkgPT4gZmllbGQuZGVwcmVjYXRpb25SZWFzb24gIT0gbnVsbFxuICAgIH0sXG4gICAgZGVwcmVjYXRpb25SZWFzb246IHtcbiAgICAgIHR5cGU6IEdyYXBoUUxTdHJpbmcsXG4gICAgICByZXNvbHZlOiAoZmllbGQpID0+IGZpZWxkLmRlcHJlY2F0aW9uUmVhc29uXG4gICAgfVxuICB9KVxufSk7XG5jb25zdCBfX0lucHV0VmFsdWUgPSBuZXcgR3JhcGhRTE9iamVjdFR5cGUoe1xuICBuYW1lOiBcIl9fSW5wdXRWYWx1ZVwiLFxuICBkZXNjcmlwdGlvbjogXCJBcmd1bWVudHMgcHJvdmlkZWQgdG8gRmllbGRzIG9yIERpcmVjdGl2ZXMgYW5kIHRoZSBpbnB1dCBmaWVsZHMgb2YgYW4gSW5wdXRPYmplY3QgYXJlIHJlcHJlc2VudGVkIGFzIElucHV0IFZhbHVlcyB3aGljaCBkZXNjcmliZSB0aGVpciB0eXBlIGFuZCBvcHRpb25hbGx5IGEgZGVmYXVsdCB2YWx1ZS5cIixcbiAgZmllbGRzOiAoKSA9PiAoe1xuICAgIG5hbWU6IHtcbiAgICAgIHR5cGU6IG5ldyBHcmFwaFFMTm9uTnVsbChHcmFwaFFMU3RyaW5nKSxcbiAgICAgIHJlc29sdmU6IChpbnB1dFZhbHVlKSA9PiBpbnB1dFZhbHVlLm5hbWVcbiAgICB9LFxuICAgIGRlc2NyaXB0aW9uOiB7XG4gICAgICB0eXBlOiBHcmFwaFFMU3RyaW5nLFxuICAgICAgcmVzb2x2ZTogKGlucHV0VmFsdWUpID0+IGlucHV0VmFsdWUuZGVzY3JpcHRpb25cbiAgICB9LFxuICAgIHR5cGU6IHtcbiAgICAgIHR5cGU6IG5ldyBHcmFwaFFMTm9uTnVsbChfX1R5cGUpLFxuICAgICAgcmVzb2x2ZTogKGlucHV0VmFsdWUpID0+IGlucHV0VmFsdWUudHlwZVxuICAgIH0sXG4gICAgZGVmYXVsdFZhbHVlOiB7XG4gICAgICB0eXBlOiBHcmFwaFFMU3RyaW5nLFxuICAgICAgZGVzY3JpcHRpb246IFwiQSBHcmFwaFFMLWZvcm1hdHRlZCBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBkZWZhdWx0IHZhbHVlIGZvciB0aGlzIGlucHV0IHZhbHVlLlwiLFxuICAgICAgcmVzb2x2ZShpbnB1dFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHsgdHlwZSwgZGVmYXVsdFZhbHVlIH0gPSBpbnB1dFZhbHVlO1xuICAgICAgICBjb25zdCB2YWx1ZUFTVCA9IGFzdEZyb21WYWx1ZShkZWZhdWx0VmFsdWUsIHR5cGUpO1xuICAgICAgICByZXR1cm4gdmFsdWVBU1QgPyBwcmludCh2YWx1ZUFTVCkgOiBudWxsO1xuICAgICAgfVxuICAgIH0sXG4gICAgaXNEZXByZWNhdGVkOiB7XG4gICAgICB0eXBlOiBuZXcgR3JhcGhRTE5vbk51bGwoR3JhcGhRTEJvb2xlYW4pLFxuICAgICAgcmVzb2x2ZTogKGZpZWxkKSA9PiBmaWVsZC5kZXByZWNhdGlvblJlYXNvbiAhPSBudWxsXG4gICAgfSxcbiAgICBkZXByZWNhdGlvblJlYXNvbjoge1xuICAgICAgdHlwZTogR3JhcGhRTFN0cmluZyxcbiAgICAgIHJlc29sdmU6IChvYmopID0+IG9iai5kZXByZWNhdGlvblJlYXNvblxuICAgIH1cbiAgfSlcbn0pO1xuY29uc3QgX19FbnVtVmFsdWUgPSBuZXcgR3JhcGhRTE9iamVjdFR5cGUoe1xuICBuYW1lOiBcIl9fRW51bVZhbHVlXCIsXG4gIGRlc2NyaXB0aW9uOiBcIk9uZSBwb3NzaWJsZSB2YWx1ZSBmb3IgYSBnaXZlbiBFbnVtLiBFbnVtIHZhbHVlcyBhcmUgdW5pcXVlIHZhbHVlcywgbm90IGEgcGxhY2Vob2xkZXIgZm9yIGEgc3RyaW5nIG9yIG51bWVyaWMgdmFsdWUuIEhvd2V2ZXIgYW4gRW51bSB2YWx1ZSBpcyByZXR1cm5lZCBpbiBhIEpTT04gcmVzcG9uc2UgYXMgYSBzdHJpbmcuXCIsXG4gIGZpZWxkczogKCkgPT4gKHtcbiAgICBuYW1lOiB7XG4gICAgICB0eXBlOiBuZXcgR3JhcGhRTE5vbk51bGwoR3JhcGhRTFN0cmluZyksXG4gICAgICByZXNvbHZlOiAoZW51bVZhbHVlKSA9PiBlbnVtVmFsdWUubmFtZVxuICAgIH0sXG4gICAgZGVzY3JpcHRpb246IHtcbiAgICAgIHR5cGU6IEdyYXBoUUxTdHJpbmcsXG4gICAgICByZXNvbHZlOiAoZW51bVZhbHVlKSA9PiBlbnVtVmFsdWUuZGVzY3JpcHRpb25cbiAgICB9LFxuICAgIGlzRGVwcmVjYXRlZDoge1xuICAgICAgdHlwZTogbmV3IEdyYXBoUUxOb25OdWxsKEdyYXBoUUxCb29sZWFuKSxcbiAgICAgIHJlc29sdmU6IChlbnVtVmFsdWUpID0+IGVudW1WYWx1ZS5kZXByZWNhdGlvblJlYXNvbiAhPSBudWxsXG4gICAgfSxcbiAgICBkZXByZWNhdGlvblJlYXNvbjoge1xuICAgICAgdHlwZTogR3JhcGhRTFN0cmluZyxcbiAgICAgIHJlc29sdmU6IChlbnVtVmFsdWUpID0+IGVudW1WYWx1ZS5kZXByZWNhdGlvblJlYXNvblxuICAgIH1cbiAgfSlcbn0pO1xubGV0IFR5cGVLaW5kO1xuKGZ1bmN0aW9uKFR5cGVLaW5kMikge1xuICBUeXBlS2luZDJbXCJTQ0FMQVJcIl0gPSBcIlNDQUxBUlwiO1xuICBUeXBlS2luZDJbXCJPQkpFQ1RcIl0gPSBcIk9CSkVDVFwiO1xuICBUeXBlS2luZDJbXCJJTlRFUkZBQ0VcIl0gPSBcIklOVEVSRkFDRVwiO1xuICBUeXBlS2luZDJbXCJVTklPTlwiXSA9IFwiVU5JT05cIjtcbiAgVHlwZUtpbmQyW1wiRU5VTVwiXSA9IFwiRU5VTVwiO1xuICBUeXBlS2luZDJbXCJJTlBVVF9PQkpFQ1RcIl0gPSBcIklOUFVUX09CSkVDVFwiO1xuICBUeXBlS2luZDJbXCJMSVNUXCJdID0gXCJMSVNUXCI7XG4gIFR5cGVLaW5kMltcIk5PTl9OVUxMXCJdID0gXCJOT05fTlVMTFwiO1xufSkoVHlwZUtpbmQgfHwgKFR5cGVLaW5kID0ge30pKTtcbmNvbnN0IF9fVHlwZUtpbmQgPSBuZXcgR3JhcGhRTEVudW1UeXBlKHtcbiAgbmFtZTogXCJfX1R5cGVLaW5kXCIsXG4gIGRlc2NyaXB0aW9uOiBcIkFuIGVudW0gZGVzY3JpYmluZyB3aGF0IGtpbmQgb2YgdHlwZSBhIGdpdmVuIGBfX1R5cGVgIGlzLlwiLFxuICB2YWx1ZXM6IHtcbiAgICBTQ0FMQVI6IHtcbiAgICAgIHZhbHVlOiBUeXBlS2luZC5TQ0FMQVIsXG4gICAgICBkZXNjcmlwdGlvbjogXCJJbmRpY2F0ZXMgdGhpcyB0eXBlIGlzIGEgc2NhbGFyLlwiXG4gICAgfSxcbiAgICBPQkpFQ1Q6IHtcbiAgICAgIHZhbHVlOiBUeXBlS2luZC5PQkpFQ1QsXG4gICAgICBkZXNjcmlwdGlvbjogXCJJbmRpY2F0ZXMgdGhpcyB0eXBlIGlzIGFuIG9iamVjdC4gYGZpZWxkc2AgYW5kIGBpbnRlcmZhY2VzYCBhcmUgdmFsaWQgZmllbGRzLlwiXG4gICAgfSxcbiAgICBJTlRFUkZBQ0U6IHtcbiAgICAgIHZhbHVlOiBUeXBlS2luZC5JTlRFUkZBQ0UsXG4gICAgICBkZXNjcmlwdGlvbjogXCJJbmRpY2F0ZXMgdGhpcyB0eXBlIGlzIGFuIGludGVyZmFjZS4gYGZpZWxkc2AsIGBpbnRlcmZhY2VzYCwgYW5kIGBwb3NzaWJsZVR5cGVzYCBhcmUgdmFsaWQgZmllbGRzLlwiXG4gICAgfSxcbiAgICBVTklPTjoge1xuICAgICAgdmFsdWU6IFR5cGVLaW5kLlVOSU9OLFxuICAgICAgZGVzY3JpcHRpb246IFwiSW5kaWNhdGVzIHRoaXMgdHlwZSBpcyBhIHVuaW9uLiBgcG9zc2libGVUeXBlc2AgaXMgYSB2YWxpZCBmaWVsZC5cIlxuICAgIH0sXG4gICAgRU5VTToge1xuICAgICAgdmFsdWU6IFR5cGVLaW5kLkVOVU0sXG4gICAgICBkZXNjcmlwdGlvbjogXCJJbmRpY2F0ZXMgdGhpcyB0eXBlIGlzIGFuIGVudW0uIGBlbnVtVmFsdWVzYCBpcyBhIHZhbGlkIGZpZWxkLlwiXG4gICAgfSxcbiAgICBJTlBVVF9PQkpFQ1Q6IHtcbiAgICAgIHZhbHVlOiBUeXBlS2luZC5JTlBVVF9PQkpFQ1QsXG4gICAgICBkZXNjcmlwdGlvbjogXCJJbmRpY2F0ZXMgdGhpcyB0eXBlIGlzIGFuIGlucHV0IG9iamVjdC4gYGlucHV0RmllbGRzYCBpcyBhIHZhbGlkIGZpZWxkLlwiXG4gICAgfSxcbiAgICBMSVNUOiB7XG4gICAgICB2YWx1ZTogVHlwZUtpbmQuTElTVCxcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkluZGljYXRlcyB0aGlzIHR5cGUgaXMgYSBsaXN0LiBgb2ZUeXBlYCBpcyBhIHZhbGlkIGZpZWxkLlwiXG4gICAgfSxcbiAgICBOT05fTlVMTDoge1xuICAgICAgdmFsdWU6IFR5cGVLaW5kLk5PTl9OVUxMLFxuICAgICAgZGVzY3JpcHRpb246IFwiSW5kaWNhdGVzIHRoaXMgdHlwZSBpcyBhIG5vbi1udWxsLiBgb2ZUeXBlYCBpcyBhIHZhbGlkIGZpZWxkLlwiXG4gICAgfVxuICB9XG59KTtcbmNvbnN0IFNjaGVtYU1ldGFGaWVsZERlZiA9IHtcbiAgbmFtZTogXCJfX3NjaGVtYVwiLFxuICB0eXBlOiBuZXcgR3JhcGhRTE5vbk51bGwoX19TY2hlbWEpLFxuICBkZXNjcmlwdGlvbjogXCJBY2Nlc3MgdGhlIGN1cnJlbnQgdHlwZSBzY2hlbWEgb2YgdGhpcyBzZXJ2ZXIuXCIsXG4gIGFyZ3M6IFtdLFxuICByZXNvbHZlOiAoX3NvdXJjZSwgX2FyZ3MsIF9jb250ZXh0LCB7IHNjaGVtYSB9KSA9PiBzY2hlbWEsXG4gIGRlcHJlY2F0aW9uUmVhc29uOiB2b2lkIDAsXG4gIGV4dGVuc2lvbnM6IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLFxuICBhc3ROb2RlOiB2b2lkIDBcbn07XG5jb25zdCBUeXBlTWV0YUZpZWxkRGVmID0ge1xuICBuYW1lOiBcIl9fdHlwZVwiLFxuICB0eXBlOiBfX1R5cGUsXG4gIGRlc2NyaXB0aW9uOiBcIlJlcXVlc3QgdGhlIHR5cGUgaW5mb3JtYXRpb24gb2YgYSBzaW5nbGUgdHlwZS5cIixcbiAgYXJnczogW1xuICAgIHtcbiAgICAgIG5hbWU6IFwibmFtZVwiLFxuICAgICAgZGVzY3JpcHRpb246IHZvaWQgMCxcbiAgICAgIHR5cGU6IG5ldyBHcmFwaFFMTm9uTnVsbChHcmFwaFFMU3RyaW5nKSxcbiAgICAgIGRlZmF1bHRWYWx1ZTogdm9pZCAwLFxuICAgICAgZGVwcmVjYXRpb25SZWFzb246IHZvaWQgMCxcbiAgICAgIGV4dGVuc2lvbnM6IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgYXN0Tm9kZTogdm9pZCAwXG4gICAgfVxuICBdLFxuICByZXNvbHZlOiAoX3NvdXJjZSwgeyBuYW1lIH0sIF9jb250ZXh0LCB7IHNjaGVtYSB9KSA9PiBzY2hlbWEuZ2V0VHlwZShuYW1lKSxcbiAgZGVwcmVjYXRpb25SZWFzb246IHZvaWQgMCxcbiAgZXh0ZW5zaW9uczogLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksXG4gIGFzdE5vZGU6IHZvaWQgMFxufTtcbmNvbnN0IFR5cGVOYW1lTWV0YUZpZWxkRGVmID0ge1xuICBuYW1lOiBcIl9fdHlwZW5hbWVcIixcbiAgdHlwZTogbmV3IEdyYXBoUUxOb25OdWxsKEdyYXBoUUxTdHJpbmcpLFxuICBkZXNjcmlwdGlvbjogXCJUaGUgbmFtZSBvZiB0aGUgY3VycmVudCBPYmplY3QgdHlwZSBhdCBydW50aW1lLlwiLFxuICBhcmdzOiBbXSxcbiAgcmVzb2x2ZTogKF9zb3VyY2UsIF9hcmdzLCBfY29udGV4dCwgeyBwYXJlbnRUeXBlIH0pID0+IHBhcmVudFR5cGUubmFtZSxcbiAgZGVwcmVjYXRpb25SZWFzb246IHZvaWQgMCxcbiAgZXh0ZW5zaW9uczogLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksXG4gIGFzdE5vZGU6IHZvaWQgMFxufTtcbk9iamVjdC5mcmVlemUoW1xuICBfX1NjaGVtYSxcbiAgX19EaXJlY3RpdmUsXG4gIF9fRGlyZWN0aXZlTG9jYXRpb24sXG4gIF9fVHlwZSxcbiAgX19GaWVsZCxcbiAgX19JbnB1dFZhbHVlLFxuICBfX0VudW1WYWx1ZSxcbiAgX19UeXBlS2luZFxuXSk7XG5leHBvcnQgeyBTY2hlbWFNZXRhRmllbGREZWYgYXMgUywgVHlwZU1ldGFGaWVsZERlZiBhcyBULCBUeXBlTmFtZU1ldGFGaWVsZERlZiBhcyBhIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///92584\n')}}]);