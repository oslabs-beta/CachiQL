"use strict";(self.webpackChunkcachiql_demo=self.webpackChunkcachiql_demo||[]).push([[662],{50045:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "C": () => (/* binding */ CharacterStream),\n/* harmony export */   "P": () => (/* binding */ Position),\n/* harmony export */   "R": () => (/* binding */ Range)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, "name", { value, configurable: true });\nclass CharacterStream {\n  constructor(sourceText) {\n    this.getStartOfToken = () => this._start;\n    this.getCurrentPosition = () => this._pos;\n    this.eol = () => this._sourceText.length === this._pos;\n    this.sol = () => this._pos === 0;\n    this.peek = () => {\n      return this._sourceText.charAt(this._pos) ? this._sourceText.charAt(this._pos) : null;\n    };\n    this.next = () => {\n      const char = this._sourceText.charAt(this._pos);\n      this._pos++;\n      return char;\n    };\n    this.eat = (pattern) => {\n      const isMatched = this._testNextCharacter(pattern);\n      if (isMatched) {\n        this._start = this._pos;\n        this._pos++;\n        return this._sourceText.charAt(this._pos - 1);\n      }\n      return void 0;\n    };\n    this.eatWhile = (match) => {\n      let isMatched = this._testNextCharacter(match);\n      let didEat = false;\n      if (isMatched) {\n        didEat = isMatched;\n        this._start = this._pos;\n      }\n      while (isMatched) {\n        this._pos++;\n        isMatched = this._testNextCharacter(match);\n        didEat = true;\n      }\n      return didEat;\n    };\n    this.eatSpace = () => this.eatWhile(/[\\s\\u00a0]/);\n    this.skipToEnd = () => {\n      this._pos = this._sourceText.length;\n    };\n    this.skipTo = (position) => {\n      this._pos = position;\n    };\n    this.match = (pattern, consume = true, caseFold = false) => {\n      let token = null;\n      let match = null;\n      if (typeof pattern === "string") {\n        const regex = new RegExp(pattern, caseFold ? "i" : "g");\n        match = regex.test(this._sourceText.substr(this._pos, pattern.length));\n        token = pattern;\n      } else if (pattern instanceof RegExp) {\n        match = this._sourceText.slice(this._pos).match(pattern);\n        token = match === null || match === void 0 ? void 0 : match[0];\n      }\n      if (match != null) {\n        if (typeof pattern === "string" || match instanceof Array && this._sourceText.startsWith(match[0], this._pos)) {\n          if (consume) {\n            this._start = this._pos;\n            if (token && token.length) {\n              this._pos += token.length;\n            }\n          }\n          return match;\n        }\n      }\n      return false;\n    };\n    this.backUp = (num) => {\n      this._pos -= num;\n    };\n    this.column = () => this._pos;\n    this.indentation = () => {\n      const match = this._sourceText.match(/\\s*/);\n      let indent = 0;\n      if (match && match.length !== 0) {\n        const whiteSpaces = match[0];\n        let pos = 0;\n        while (whiteSpaces.length > pos) {\n          if (whiteSpaces.charCodeAt(pos) === 9) {\n            indent += 2;\n          } else {\n            indent++;\n          }\n          pos++;\n        }\n      }\n      return indent;\n    };\n    this.current = () => this._sourceText.slice(this._start, this._pos);\n    this._start = 0;\n    this._pos = 0;\n    this._sourceText = sourceText;\n  }\n  _testNextCharacter(pattern) {\n    const character = this._sourceText.charAt(this._pos);\n    let isMatched = false;\n    if (typeof pattern === "string") {\n      isMatched = character === pattern;\n    } else {\n      isMatched = pattern instanceof RegExp ? pattern.test(character) : pattern(character);\n    }\n    return isMatched;\n  }\n}\n__name(CharacterStream, "CharacterStream");\nclass Range {\n  constructor(start, end) {\n    this.containsPosition = (position) => {\n      if (this.start.line === position.line) {\n        return this.start.character <= position.character;\n      } else if (this.end.line === position.line) {\n        return this.end.character >= position.character;\n      } else {\n        return this.start.line <= position.line && this.end.line >= position.line;\n      }\n    };\n    this.start = start;\n    this.end = end;\n  }\n  setStart(line, character) {\n    this.start = new Position(line, character);\n  }\n  setEnd(line, character) {\n    this.end = new Position(line, character);\n  }\n}\n__name(Range, "Range");\nclass Position {\n  constructor(line, character) {\n    this.lessThanOrEqualTo = (position) => this.line < position.line || this.line === position.line && this.character <= position.character;\n    this.line = line;\n    this.character = character;\n  }\n  setLine(line) {\n    this.line = line;\n  }\n  setCharacter(character) {\n    this.character = character;\n  }\n}\n__name(Position, "Position");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTAwNDUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBLDREQUE0RCwyQkFBMkI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzJEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2FjaGlxbC1kZW1vLy4vbm9kZV9tb2R1bGVzL0BncmFwaGlxbC9yZWFjdC9kaXN0L1JhbmdlLmVzLmpzPzA4MTMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX25hbWUgPSAodGFyZ2V0LCB2YWx1ZSkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJuYW1lXCIsIHsgdmFsdWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbmNsYXNzIENoYXJhY3RlclN0cmVhbSB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZVRleHQpIHtcbiAgICB0aGlzLmdldFN0YXJ0T2ZUb2tlbiA9ICgpID0+IHRoaXMuX3N0YXJ0O1xuICAgIHRoaXMuZ2V0Q3VycmVudFBvc2l0aW9uID0gKCkgPT4gdGhpcy5fcG9zO1xuICAgIHRoaXMuZW9sID0gKCkgPT4gdGhpcy5fc291cmNlVGV4dC5sZW5ndGggPT09IHRoaXMuX3BvcztcbiAgICB0aGlzLnNvbCA9ICgpID0+IHRoaXMuX3BvcyA9PT0gMDtcbiAgICB0aGlzLnBlZWsgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5fc291cmNlVGV4dC5jaGFyQXQodGhpcy5fcG9zKSA/IHRoaXMuX3NvdXJjZVRleHQuY2hhckF0KHRoaXMuX3BvcykgOiBudWxsO1xuICAgIH07XG4gICAgdGhpcy5uZXh0ID0gKCkgPT4ge1xuICAgICAgY29uc3QgY2hhciA9IHRoaXMuX3NvdXJjZVRleHQuY2hhckF0KHRoaXMuX3Bvcyk7XG4gICAgICB0aGlzLl9wb3MrKztcbiAgICAgIHJldHVybiBjaGFyO1xuICAgIH07XG4gICAgdGhpcy5lYXQgPSAocGF0dGVybikgPT4ge1xuICAgICAgY29uc3QgaXNNYXRjaGVkID0gdGhpcy5fdGVzdE5leHRDaGFyYWN0ZXIocGF0dGVybik7XG4gICAgICBpZiAoaXNNYXRjaGVkKSB7XG4gICAgICAgIHRoaXMuX3N0YXJ0ID0gdGhpcy5fcG9zO1xuICAgICAgICB0aGlzLl9wb3MrKztcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZVRleHQuY2hhckF0KHRoaXMuX3BvcyAtIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9O1xuICAgIHRoaXMuZWF0V2hpbGUgPSAobWF0Y2gpID0+IHtcbiAgICAgIGxldCBpc01hdGNoZWQgPSB0aGlzLl90ZXN0TmV4dENoYXJhY3RlcihtYXRjaCk7XG4gICAgICBsZXQgZGlkRWF0ID0gZmFsc2U7XG4gICAgICBpZiAoaXNNYXRjaGVkKSB7XG4gICAgICAgIGRpZEVhdCA9IGlzTWF0Y2hlZDtcbiAgICAgICAgdGhpcy5fc3RhcnQgPSB0aGlzLl9wb3M7XG4gICAgICB9XG4gICAgICB3aGlsZSAoaXNNYXRjaGVkKSB7XG4gICAgICAgIHRoaXMuX3BvcysrO1xuICAgICAgICBpc01hdGNoZWQgPSB0aGlzLl90ZXN0TmV4dENoYXJhY3RlcihtYXRjaCk7XG4gICAgICAgIGRpZEVhdCA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGlkRWF0O1xuICAgIH07XG4gICAgdGhpcy5lYXRTcGFjZSA9ICgpID0+IHRoaXMuZWF0V2hpbGUoL1tcXHNcXHUwMGEwXS8pO1xuICAgIHRoaXMuc2tpcFRvRW5kID0gKCkgPT4ge1xuICAgICAgdGhpcy5fcG9zID0gdGhpcy5fc291cmNlVGV4dC5sZW5ndGg7XG4gICAgfTtcbiAgICB0aGlzLnNraXBUbyA9IChwb3NpdGlvbikgPT4ge1xuICAgICAgdGhpcy5fcG9zID0gcG9zaXRpb247XG4gICAgfTtcbiAgICB0aGlzLm1hdGNoID0gKHBhdHRlcm4sIGNvbnN1bWUgPSB0cnVlLCBjYXNlRm9sZCA9IGZhbHNlKSA9PiB7XG4gICAgICBsZXQgdG9rZW4gPSBudWxsO1xuICAgICAgbGV0IG1hdGNoID0gbnVsbDtcbiAgICAgIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAocGF0dGVybiwgY2FzZUZvbGQgPyBcImlcIiA6IFwiZ1wiKTtcbiAgICAgICAgbWF0Y2ggPSByZWdleC50ZXN0KHRoaXMuX3NvdXJjZVRleHQuc3Vic3RyKHRoaXMuX3BvcywgcGF0dGVybi5sZW5ndGgpKTtcbiAgICAgICAgdG9rZW4gPSBwYXR0ZXJuO1xuICAgICAgfSBlbHNlIGlmIChwYXR0ZXJuIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIG1hdGNoID0gdGhpcy5fc291cmNlVGV4dC5zbGljZSh0aGlzLl9wb3MpLm1hdGNoKHBhdHRlcm4pO1xuICAgICAgICB0b2tlbiA9IG1hdGNoID09PSBudWxsIHx8IG1hdGNoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXRjaFswXTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXRjaCAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gXCJzdHJpbmdcIiB8fCBtYXRjaCBpbnN0YW5jZW9mIEFycmF5ICYmIHRoaXMuX3NvdXJjZVRleHQuc3RhcnRzV2l0aChtYXRjaFswXSwgdGhpcy5fcG9zKSkge1xuICAgICAgICAgIGlmIChjb25zdW1lKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGFydCA9IHRoaXMuX3BvcztcbiAgICAgICAgICAgIGlmICh0b2tlbiAmJiB0b2tlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcG9zICs9IHRva2VuLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICB0aGlzLmJhY2tVcCA9IChudW0pID0+IHtcbiAgICAgIHRoaXMuX3BvcyAtPSBudW07XG4gICAgfTtcbiAgICB0aGlzLmNvbHVtbiA9ICgpID0+IHRoaXMuX3BvcztcbiAgICB0aGlzLmluZGVudGF0aW9uID0gKCkgPT4ge1xuICAgICAgY29uc3QgbWF0Y2ggPSB0aGlzLl9zb3VyY2VUZXh0Lm1hdGNoKC9cXHMqLyk7XG4gICAgICBsZXQgaW5kZW50ID0gMDtcbiAgICAgIGlmIChtYXRjaCAmJiBtYXRjaC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgY29uc3Qgd2hpdGVTcGFjZXMgPSBtYXRjaFswXTtcbiAgICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICAgIHdoaWxlICh3aGl0ZVNwYWNlcy5sZW5ndGggPiBwb3MpIHtcbiAgICAgICAgICBpZiAod2hpdGVTcGFjZXMuY2hhckNvZGVBdChwb3MpID09PSA5KSB7XG4gICAgICAgICAgICBpbmRlbnQgKz0gMjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5kZW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5kZW50O1xuICAgIH07XG4gICAgdGhpcy5jdXJyZW50ID0gKCkgPT4gdGhpcy5fc291cmNlVGV4dC5zbGljZSh0aGlzLl9zdGFydCwgdGhpcy5fcG9zKTtcbiAgICB0aGlzLl9zdGFydCA9IDA7XG4gICAgdGhpcy5fcG9zID0gMDtcbiAgICB0aGlzLl9zb3VyY2VUZXh0ID0gc291cmNlVGV4dDtcbiAgfVxuICBfdGVzdE5leHRDaGFyYWN0ZXIocGF0dGVybikge1xuICAgIGNvbnN0IGNoYXJhY3RlciA9IHRoaXMuX3NvdXJjZVRleHQuY2hhckF0KHRoaXMuX3Bvcyk7XG4gICAgbGV0IGlzTWF0Y2hlZCA9IGZhbHNlO1xuICAgIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaXNNYXRjaGVkID0gY2hhcmFjdGVyID09PSBwYXR0ZXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICBpc01hdGNoZWQgPSBwYXR0ZXJuIGluc3RhbmNlb2YgUmVnRXhwID8gcGF0dGVybi50ZXN0KGNoYXJhY3RlcikgOiBwYXR0ZXJuKGNoYXJhY3Rlcik7XG4gICAgfVxuICAgIHJldHVybiBpc01hdGNoZWQ7XG4gIH1cbn1cbl9fbmFtZShDaGFyYWN0ZXJTdHJlYW0sIFwiQ2hhcmFjdGVyU3RyZWFtXCIpO1xuY2xhc3MgUmFuZ2Uge1xuICBjb25zdHJ1Y3RvcihzdGFydCwgZW5kKSB7XG4gICAgdGhpcy5jb250YWluc1Bvc2l0aW9uID0gKHBvc2l0aW9uKSA9PiB7XG4gICAgICBpZiAodGhpcy5zdGFydC5saW5lID09PSBwb3NpdGlvbi5saW5lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0LmNoYXJhY3RlciA8PSBwb3NpdGlvbi5jaGFyYWN0ZXI7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZW5kLmxpbmUgPT09IHBvc2l0aW9uLmxpbmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kLmNoYXJhY3RlciA+PSBwb3NpdGlvbi5jaGFyYWN0ZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFydC5saW5lIDw9IHBvc2l0aW9uLmxpbmUgJiYgdGhpcy5lbmQubGluZSA+PSBwb3NpdGlvbi5saW5lO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuZW5kID0gZW5kO1xuICB9XG4gIHNldFN0YXJ0KGxpbmUsIGNoYXJhY3Rlcikge1xuICAgIHRoaXMuc3RhcnQgPSBuZXcgUG9zaXRpb24obGluZSwgY2hhcmFjdGVyKTtcbiAgfVxuICBzZXRFbmQobGluZSwgY2hhcmFjdGVyKSB7XG4gICAgdGhpcy5lbmQgPSBuZXcgUG9zaXRpb24obGluZSwgY2hhcmFjdGVyKTtcbiAgfVxufVxuX19uYW1lKFJhbmdlLCBcIlJhbmdlXCIpO1xuY2xhc3MgUG9zaXRpb24ge1xuICBjb25zdHJ1Y3RvcihsaW5lLCBjaGFyYWN0ZXIpIHtcbiAgICB0aGlzLmxlc3NUaGFuT3JFcXVhbFRvID0gKHBvc2l0aW9uKSA9PiB0aGlzLmxpbmUgPCBwb3NpdGlvbi5saW5lIHx8IHRoaXMubGluZSA9PT0gcG9zaXRpb24ubGluZSAmJiB0aGlzLmNoYXJhY3RlciA8PSBwb3NpdGlvbi5jaGFyYWN0ZXI7XG4gICAgdGhpcy5saW5lID0gbGluZTtcbiAgICB0aGlzLmNoYXJhY3RlciA9IGNoYXJhY3RlcjtcbiAgfVxuICBzZXRMaW5lKGxpbmUpIHtcbiAgICB0aGlzLmxpbmUgPSBsaW5lO1xuICB9XG4gIHNldENoYXJhY3RlcihjaGFyYWN0ZXIpIHtcbiAgICB0aGlzLmNoYXJhY3RlciA9IGNoYXJhY3RlcjtcbiAgfVxufVxuX19uYW1lKFBvc2l0aW9uLCBcIlBvc2l0aW9uXCIpO1xuZXhwb3J0IHsgQ2hhcmFjdGVyU3RyZWFtIGFzIEMsIFBvc2l0aW9uIGFzIFAsIFJhbmdlIGFzIFIgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///50045\n')},67662:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _codemirror_es_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97480);\n/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(52877);\n/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(77990);\n/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(69538);\n/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(93201);\n/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(22618);\n/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(53274);\n/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(25580);\n/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(84873);\n/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(96300);\n/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(34800);\n/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(42266);\n/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(92767);\n/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(24196);\n/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(81294);\n/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(88081);\n/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(5311);\n/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(24635);\n/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(97359);\n/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(39011);\n/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(84275);\n/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(28087);\n/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(15394);\n/* harmony import */ var _index_es_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(59361);\n/* harmony import */ var _Range_es_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(50045);\n/* harmony import */ var _onlineParser_es_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(98007);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(67294);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(73935);\nvar __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, "name", { value, configurable: true });\n\n\n\n\n\n\n\nconst specifiedSDLRules = [\n  graphql__WEBPACK_IMPORTED_MODULE_6__/* .LoneSchemaDefinitionRule */ .t,\n  graphql__WEBPACK_IMPORTED_MODULE_7__/* .UniqueOperationTypesRule */ .q,\n  graphql__WEBPACK_IMPORTED_MODULE_8__/* .UniqueTypeNamesRule */ .P,\n  graphql__WEBPACK_IMPORTED_MODULE_9__/* .UniqueEnumValueNamesRule */ .L,\n  graphql__WEBPACK_IMPORTED_MODULE_10__/* .UniqueFieldDefinitionNamesRule */ .y,\n  graphql__WEBPACK_IMPORTED_MODULE_11__/* .UniqueDirectiveNamesRule */ .o,\n  graphql__WEBPACK_IMPORTED_MODULE_12__/* .KnownTypeNamesRule */ .I,\n  graphql__WEBPACK_IMPORTED_MODULE_13__/* .KnownDirectivesRule */ .J,\n  graphql__WEBPACK_IMPORTED_MODULE_14__/* .UniqueDirectivesPerLocationRule */ .k,\n  graphql__WEBPACK_IMPORTED_MODULE_15__/* .PossibleTypeExtensionsRule */ .g,\n  graphql__WEBPACK_IMPORTED_MODULE_16__/* .UniqueArgumentNamesRule */ .L,\n  graphql__WEBPACK_IMPORTED_MODULE_17__/* .UniqueInputFieldNamesRule */ .P\n];\nfunction validateWithCustomRules(schema, ast, customRules, isRelayCompatMode, isSchemaDocument) {\n  const rules = graphql__WEBPACK_IMPORTED_MODULE_18__/* .specifiedRules.filter */ .i.filter((rule) => {\n    if (rule === graphql__WEBPACK_IMPORTED_MODULE_19__/* .NoUnusedFragmentsRule */ .J || rule === graphql__WEBPACK_IMPORTED_MODULE_20__/* .ExecutableDefinitionsRule */ .i) {\n      return false;\n    }\n    if (isRelayCompatMode && rule === graphql__WEBPACK_IMPORTED_MODULE_21__/* .KnownFragmentNamesRule */ .a) {\n      return false;\n    }\n    return true;\n  });\n  if (customRules) {\n    Array.prototype.push.apply(rules, customRules);\n  }\n  if (isSchemaDocument) {\n    Array.prototype.push.apply(rules, specifiedSDLRules);\n  }\n  const errors = (0,graphql__WEBPACK_IMPORTED_MODULE_22__/* .validate */ .Gu)(schema, ast, rules);\n  return errors.filter((error) => {\n    if (error.message.indexOf("Unknown directive") !== -1 && error.nodes) {\n      const node = error.nodes[0];\n      if (node && node.kind === graphql__WEBPACK_IMPORTED_MODULE_23__/* .Kind.DIRECTIVE */ .h.DIRECTIVE) {\n        const name = node.name.value;\n        if (name === "arguments" || name === "argumentDefinitions") {\n          return false;\n        }\n      }\n    }\n    return true;\n  });\n}\n__name(validateWithCustomRules, "validateWithCustomRules");\nconst SEVERITY$1 = {\n  Error: "Error",\n  Warning: "Warning",\n  Information: "Information",\n  Hint: "Hint"\n};\nconst DIAGNOSTIC_SEVERITY = {\n  [SEVERITY$1.Error]: 1,\n  [SEVERITY$1.Warning]: 2,\n  [SEVERITY$1.Information]: 3,\n  [SEVERITY$1.Hint]: 4\n};\nconst invariant = /* @__PURE__ */ __name((condition, message) => {\n  if (!condition) {\n    throw new Error(message);\n  }\n}, "invariant");\nfunction getDiagnostics(query, schema = null, customRules, isRelayCompatMode, externalFragments) {\n  var _a, _b;\n  let ast = null;\n  if (externalFragments) {\n    if (typeof externalFragments === "string") {\n      query += "\\n\\n" + externalFragments;\n    } else {\n      query += "\\n\\n" + externalFragments.reduce((agg, node) => {\n        agg += (0,graphql__WEBPACK_IMPORTED_MODULE_24__/* .print */ .S)(node) + "\\n\\n";\n        return agg;\n      }, "");\n    }\n  }\n  try {\n    ast = (0,graphql__WEBPACK_IMPORTED_MODULE_25__/* .parse */ .Qc)(query);\n  } catch (error) {\n    if (error instanceof graphql__WEBPACK_IMPORTED_MODULE_26__/* .GraphQLError */ ._) {\n      const range = getRange((_b = (_a = error.locations) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : { line: 0, column: 0 }, query);\n      return [\n        {\n          severity: DIAGNOSTIC_SEVERITY.Error,\n          message: error.message,\n          source: "GraphQL: Syntax",\n          range\n        }\n      ];\n    }\n    throw error;\n  }\n  return validateQuery(ast, schema, customRules, isRelayCompatMode);\n}\n__name(getDiagnostics, "getDiagnostics");\nfunction validateQuery(ast, schema = null, customRules, isRelayCompatMode) {\n  if (!schema) {\n    return [];\n  }\n  const validationErrorAnnotations = mapCat(validateWithCustomRules(schema, ast, customRules, isRelayCompatMode), (error) => annotations(error, DIAGNOSTIC_SEVERITY.Error, "Validation"));\n  const deprecationWarningAnnotations = mapCat((0,graphql__WEBPACK_IMPORTED_MODULE_22__/* .validate */ .Gu)(schema, ast, [graphql__WEBPACK_IMPORTED_MODULE_27__/* .NoDeprecatedCustomRule */ .r]), (error) => annotations(error, DIAGNOSTIC_SEVERITY.Warning, "Deprecation"));\n  return validationErrorAnnotations.concat(deprecationWarningAnnotations);\n}\n__name(validateQuery, "validateQuery");\nfunction mapCat(array, mapper) {\n  return Array.prototype.concat.apply([], array.map(mapper));\n}\n__name(mapCat, "mapCat");\nfunction annotations(error, severity, type) {\n  if (!error.nodes) {\n    return [];\n  }\n  const highlightedNodes = [];\n  error.nodes.forEach((node) => {\n    const highlightNode = node.kind !== "Variable" && "name" in node && node.name !== void 0 ? node.name : "variable" in node && node.variable !== void 0 ? node.variable : node;\n    if (highlightNode) {\n      invariant(error.locations, "GraphQL validation error requires locations.");\n      const loc = error.locations[0];\n      const highlightLoc = getLocation(highlightNode);\n      const end = loc.column + (highlightLoc.end - highlightLoc.start);\n      highlightedNodes.push({\n        source: `GraphQL: ${type}`,\n        message: error.message,\n        severity,\n        range: new _Range_es_js__WEBPACK_IMPORTED_MODULE_2__.R(new _Range_es_js__WEBPACK_IMPORTED_MODULE_2__.P(loc.line - 1, loc.column - 1), new _Range_es_js__WEBPACK_IMPORTED_MODULE_2__.P(loc.line - 1, end))\n      });\n    }\n  });\n  return highlightedNodes;\n}\n__name(annotations, "annotations");\nfunction getRange(location, queryText) {\n  const parser = (0,_onlineParser_es_js__WEBPACK_IMPORTED_MODULE_3__.o)();\n  const state = parser.startState();\n  const lines = queryText.split("\\n");\n  invariant(lines.length >= location.line, "Query text must have more lines than where the error happened");\n  let stream = null;\n  for (let i = 0; i < location.line; i++) {\n    stream = new _Range_es_js__WEBPACK_IMPORTED_MODULE_2__.C(lines[i]);\n    while (!stream.eol()) {\n      const style = parser.token(stream, state);\n      if (style === "invalidchar") {\n        break;\n      }\n    }\n  }\n  invariant(stream, "Expected Parser stream to be available.");\n  const line = location.line - 1;\n  const start = stream.getStartOfToken();\n  const end = stream.getCurrentPosition();\n  return new _Range_es_js__WEBPACK_IMPORTED_MODULE_2__.R(new _Range_es_js__WEBPACK_IMPORTED_MODULE_2__.P(line, start), new _Range_es_js__WEBPACK_IMPORTED_MODULE_2__.P(line, end));\n}\n__name(getRange, "getRange");\nfunction getLocation(node) {\n  const typeCastedNode = node;\n  const location = typeCastedNode.loc;\n  invariant(location, "Expected ASTNode to have a location.");\n  return location;\n}\n__name(getLocation, "getLocation");\nconst SEVERITY = ["error", "warning", "information", "hint"];\nconst TYPE = {\n  "GraphQL: Validation": "validation",\n  "GraphQL: Deprecation": "deprecation",\n  "GraphQL: Syntax": "syntax"\n};\n_codemirror_es_js__WEBPACK_IMPORTED_MODULE_0__.C.registerHelper("lint", "graphql", (text, options) => {\n  const schema = options.schema;\n  const rawResults = getDiagnostics(text, schema, options.validationRules, void 0, options.externalFragments);\n  const results = rawResults.map((error) => ({\n    message: error.message,\n    severity: error.severity ? SEVERITY[error.severity - 1] : SEVERITY[0],\n    type: error.source ? TYPE[error.source] : void 0,\n    from: _codemirror_es_js__WEBPACK_IMPORTED_MODULE_0__.C.Pos(error.range.start.line, error.range.start.character),\n    to: _codemirror_es_js__WEBPACK_IMPORTED_MODULE_0__.C.Pos(error.range.end.line, error.range.end.character)\n  }));\n  return results;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjc2NjIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBLDREQUE0RCwyQkFBMkI7QUFDbEM7QUFDeWI7QUFDdmQ7QUFDeUQ7QUFDdkI7QUFDMUM7QUFDSTtBQUNuQjtBQUNBLEVBQUUsc0VBQXdCO0FBQzFCLEVBQUUsc0VBQXdCO0FBQzFCLEVBQUUsaUVBQW1CO0FBQ3JCLEVBQUUsc0VBQXdCO0FBQzFCLEVBQUUsNkVBQThCO0FBQ2hDLEVBQUUsdUVBQXdCO0FBQzFCLEVBQUUsaUVBQWtCO0FBQ3BCLEVBQUUsa0VBQW1CO0FBQ3JCLEVBQUUsOEVBQStCO0FBQ2pDLEVBQUUseUVBQTBCO0FBQzVCLEVBQUUsc0VBQXVCO0FBQ3pCLEVBQUUsd0VBQXlCO0FBQzNCO0FBQ0E7QUFDQSxnQkFBZ0IsMkVBQXFCO0FBQ3JDLGlCQUFpQixvRUFBcUIsYUFBYSx3RUFBeUI7QUFDNUU7QUFDQTtBQUNBLHNDQUFzQyxxRUFBc0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw0REFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsdUVBQWM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGVBQWUsd0RBQUs7QUFDcEI7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsVUFBVSx5REFBSztBQUNmLElBQUk7QUFDSix5QkFBeUIsMkRBQVk7QUFDckMseUlBQXlJLG9CQUFvQjtBQUM3SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyw0REFBUSxlQUFlLHFFQUFzQjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLEtBQUs7QUFDakM7QUFDQTtBQUNBLG1CQUFtQiwyQ0FBSyxLQUFLLDJDQUFRLG9DQUFvQywyQ0FBUTtBQUNqRixPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0RBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDLGlCQUFpQiwyQ0FBZTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwyQ0FBSyxLQUFLLDJDQUFRLG1CQUFtQiwyQ0FBUTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxvREFBYztBQUN4QixRQUFRLG9EQUFjO0FBQ3RCLEdBQUc7QUFDSDtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYWNoaXFsLWRlbW8vLi9ub2RlX21vZHVsZXMvQGdyYXBoaXFsL3JlYWN0L2Rpc3QvbGludC5lcy5qcz9lM2I0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19uYW1lID0gKHRhcmdldCwgdmFsdWUpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwibmFtZVwiLCB7IHZhbHVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG5pbXBvcnQgeyBDIGFzIENvZGVNaXJyb3IgfSBmcm9tIFwiLi9jb2RlbWlycm9yLmVzLmpzXCI7XG5pbXBvcnQgeyBLaW5kLCBzcGVjaWZpZWRSdWxlcywgTm9VbnVzZWRGcmFnbWVudHNSdWxlLCBFeGVjdXRhYmxlRGVmaW5pdGlvbnNSdWxlLCBLbm93bkZyYWdtZW50TmFtZXNSdWxlLCB2YWxpZGF0ZSwgTG9uZVNjaGVtYURlZmluaXRpb25SdWxlLCBVbmlxdWVPcGVyYXRpb25UeXBlc1J1bGUsIFVuaXF1ZVR5cGVOYW1lc1J1bGUsIFVuaXF1ZUVudW1WYWx1ZU5hbWVzUnVsZSwgVW5pcXVlRmllbGREZWZpbml0aW9uTmFtZXNSdWxlLCBVbmlxdWVEaXJlY3RpdmVOYW1lc1J1bGUsIEtub3duVHlwZU5hbWVzUnVsZSwgS25vd25EaXJlY3RpdmVzUnVsZSwgVW5pcXVlRGlyZWN0aXZlc1BlckxvY2F0aW9uUnVsZSwgUG9zc2libGVUeXBlRXh0ZW5zaW9uc1J1bGUsIFVuaXF1ZUFyZ3VtZW50TmFtZXNSdWxlLCBVbmlxdWVJbnB1dEZpZWxkTmFtZXNSdWxlLCBwcmludCwgcGFyc2UsIEdyYXBoUUxFcnJvciwgTm9EZXByZWNhdGVkQ3VzdG9tUnVsZSB9IGZyb20gXCJncmFwaHFsXCI7XG5pbXBvcnQgXCIuL2luZGV4LmVzLmpzXCI7XG5pbXBvcnQgeyBSIGFzIFJhbmdlLCBQIGFzIFBvc2l0aW9uLCBDIGFzIENoYXJhY3RlclN0cmVhbSB9IGZyb20gXCIuL1JhbmdlLmVzLmpzXCI7XG5pbXBvcnQgeyBvIGFzIG9ubGluZVBhcnNlciB9IGZyb20gXCIuL29ubGluZVBhcnNlci5lcy5qc1wiO1xuaW1wb3J0IFwicmVhY3RcIjtcbmltcG9ydCBcInJlYWN0LWRvbVwiO1xuY29uc3Qgc3BlY2lmaWVkU0RMUnVsZXMgPSBbXG4gIExvbmVTY2hlbWFEZWZpbml0aW9uUnVsZSxcbiAgVW5pcXVlT3BlcmF0aW9uVHlwZXNSdWxlLFxuICBVbmlxdWVUeXBlTmFtZXNSdWxlLFxuICBVbmlxdWVFbnVtVmFsdWVOYW1lc1J1bGUsXG4gIFVuaXF1ZUZpZWxkRGVmaW5pdGlvbk5hbWVzUnVsZSxcbiAgVW5pcXVlRGlyZWN0aXZlTmFtZXNSdWxlLFxuICBLbm93blR5cGVOYW1lc1J1bGUsXG4gIEtub3duRGlyZWN0aXZlc1J1bGUsXG4gIFVuaXF1ZURpcmVjdGl2ZXNQZXJMb2NhdGlvblJ1bGUsXG4gIFBvc3NpYmxlVHlwZUV4dGVuc2lvbnNSdWxlLFxuICBVbmlxdWVBcmd1bWVudE5hbWVzUnVsZSxcbiAgVW5pcXVlSW5wdXRGaWVsZE5hbWVzUnVsZVxuXTtcbmZ1bmN0aW9uIHZhbGlkYXRlV2l0aEN1c3RvbVJ1bGVzKHNjaGVtYSwgYXN0LCBjdXN0b21SdWxlcywgaXNSZWxheUNvbXBhdE1vZGUsIGlzU2NoZW1hRG9jdW1lbnQpIHtcbiAgY29uc3QgcnVsZXMgPSBzcGVjaWZpZWRSdWxlcy5maWx0ZXIoKHJ1bGUpID0+IHtcbiAgICBpZiAocnVsZSA9PT0gTm9VbnVzZWRGcmFnbWVudHNSdWxlIHx8IHJ1bGUgPT09IEV4ZWN1dGFibGVEZWZpbml0aW9uc1J1bGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGlzUmVsYXlDb21wYXRNb2RlICYmIHJ1bGUgPT09IEtub3duRnJhZ21lbnROYW1lc1J1bGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xuICBpZiAoY3VzdG9tUnVsZXMpIHtcbiAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShydWxlcywgY3VzdG9tUnVsZXMpO1xuICB9XG4gIGlmIChpc1NjaGVtYURvY3VtZW50KSB7XG4gICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkocnVsZXMsIHNwZWNpZmllZFNETFJ1bGVzKTtcbiAgfVxuICBjb25zdCBlcnJvcnMgPSB2YWxpZGF0ZShzY2hlbWEsIGFzdCwgcnVsZXMpO1xuICByZXR1cm4gZXJyb3JzLmZpbHRlcigoZXJyb3IpID0+IHtcbiAgICBpZiAoZXJyb3IubWVzc2FnZS5pbmRleE9mKFwiVW5rbm93biBkaXJlY3RpdmVcIikgIT09IC0xICYmIGVycm9yLm5vZGVzKSB7XG4gICAgICBjb25zdCBub2RlID0gZXJyb3Iubm9kZXNbMF07XG4gICAgICBpZiAobm9kZSAmJiBub2RlLmtpbmQgPT09IEtpbmQuRElSRUNUSVZFKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBub2RlLm5hbWUudmFsdWU7XG4gICAgICAgIGlmIChuYW1lID09PSBcImFyZ3VtZW50c1wiIHx8IG5hbWUgPT09IFwiYXJndW1lbnREZWZpbml0aW9uc1wiKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9KTtcbn1cbl9fbmFtZSh2YWxpZGF0ZVdpdGhDdXN0b21SdWxlcywgXCJ2YWxpZGF0ZVdpdGhDdXN0b21SdWxlc1wiKTtcbmNvbnN0IFNFVkVSSVRZJDEgPSB7XG4gIEVycm9yOiBcIkVycm9yXCIsXG4gIFdhcm5pbmc6IFwiV2FybmluZ1wiLFxuICBJbmZvcm1hdGlvbjogXCJJbmZvcm1hdGlvblwiLFxuICBIaW50OiBcIkhpbnRcIlxufTtcbmNvbnN0IERJQUdOT1NUSUNfU0VWRVJJVFkgPSB7XG4gIFtTRVZFUklUWSQxLkVycm9yXTogMSxcbiAgW1NFVkVSSVRZJDEuV2FybmluZ106IDIsXG4gIFtTRVZFUklUWSQxLkluZm9ybWF0aW9uXTogMyxcbiAgW1NFVkVSSVRZJDEuSGludF06IDRcbn07XG5jb25zdCBpbnZhcmlhbnQgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChjb25kaXRpb24sIG1lc3NhZ2UpID0+IHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbn0sIFwiaW52YXJpYW50XCIpO1xuZnVuY3Rpb24gZ2V0RGlhZ25vc3RpY3MocXVlcnksIHNjaGVtYSA9IG51bGwsIGN1c3RvbVJ1bGVzLCBpc1JlbGF5Q29tcGF0TW9kZSwgZXh0ZXJuYWxGcmFnbWVudHMpIHtcbiAgdmFyIF9hLCBfYjtcbiAgbGV0IGFzdCA9IG51bGw7XG4gIGlmIChleHRlcm5hbEZyYWdtZW50cykge1xuICAgIGlmICh0eXBlb2YgZXh0ZXJuYWxGcmFnbWVudHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHF1ZXJ5ICs9IFwiXFxuXFxuXCIgKyBleHRlcm5hbEZyYWdtZW50cztcbiAgICB9IGVsc2Uge1xuICAgICAgcXVlcnkgKz0gXCJcXG5cXG5cIiArIGV4dGVybmFsRnJhZ21lbnRzLnJlZHVjZSgoYWdnLCBub2RlKSA9PiB7XG4gICAgICAgIGFnZyArPSBwcmludChub2RlKSArIFwiXFxuXFxuXCI7XG4gICAgICAgIHJldHVybiBhZ2c7XG4gICAgICB9LCBcIlwiKTtcbiAgICB9XG4gIH1cbiAgdHJ5IHtcbiAgICBhc3QgPSBwYXJzZShxdWVyeSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgR3JhcGhRTEVycm9yKSB7XG4gICAgICBjb25zdCByYW5nZSA9IGdldFJhbmdlKChfYiA9IChfYSA9IGVycm9yLmxvY2F0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7IGxpbmU6IDAsIGNvbHVtbjogMCB9LCBxdWVyeSk7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgc2V2ZXJpdHk6IERJQUdOT1NUSUNfU0VWRVJJVFkuRXJyb3IsXG4gICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICBzb3VyY2U6IFwiR3JhcGhRTDogU3ludGF4XCIsXG4gICAgICAgICAgcmFuZ2VcbiAgICAgICAgfVxuICAgICAgXTtcbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgcmV0dXJuIHZhbGlkYXRlUXVlcnkoYXN0LCBzY2hlbWEsIGN1c3RvbVJ1bGVzLCBpc1JlbGF5Q29tcGF0TW9kZSk7XG59XG5fX25hbWUoZ2V0RGlhZ25vc3RpY3MsIFwiZ2V0RGlhZ25vc3RpY3NcIik7XG5mdW5jdGlvbiB2YWxpZGF0ZVF1ZXJ5KGFzdCwgc2NoZW1hID0gbnVsbCwgY3VzdG9tUnVsZXMsIGlzUmVsYXlDb21wYXRNb2RlKSB7XG4gIGlmICghc2NoZW1hKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGNvbnN0IHZhbGlkYXRpb25FcnJvckFubm90YXRpb25zID0gbWFwQ2F0KHZhbGlkYXRlV2l0aEN1c3RvbVJ1bGVzKHNjaGVtYSwgYXN0LCBjdXN0b21SdWxlcywgaXNSZWxheUNvbXBhdE1vZGUpLCAoZXJyb3IpID0+IGFubm90YXRpb25zKGVycm9yLCBESUFHTk9TVElDX1NFVkVSSVRZLkVycm9yLCBcIlZhbGlkYXRpb25cIikpO1xuICBjb25zdCBkZXByZWNhdGlvbldhcm5pbmdBbm5vdGF0aW9ucyA9IG1hcENhdCh2YWxpZGF0ZShzY2hlbWEsIGFzdCwgW05vRGVwcmVjYXRlZEN1c3RvbVJ1bGVdKSwgKGVycm9yKSA9PiBhbm5vdGF0aW9ucyhlcnJvciwgRElBR05PU1RJQ19TRVZFUklUWS5XYXJuaW5nLCBcIkRlcHJlY2F0aW9uXCIpKTtcbiAgcmV0dXJuIHZhbGlkYXRpb25FcnJvckFubm90YXRpb25zLmNvbmNhdChkZXByZWNhdGlvbldhcm5pbmdBbm5vdGF0aW9ucyk7XG59XG5fX25hbWUodmFsaWRhdGVRdWVyeSwgXCJ2YWxpZGF0ZVF1ZXJ5XCIpO1xuZnVuY3Rpb24gbWFwQ2F0KGFycmF5LCBtYXBwZXIpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGFycmF5Lm1hcChtYXBwZXIpKTtcbn1cbl9fbmFtZShtYXBDYXQsIFwibWFwQ2F0XCIpO1xuZnVuY3Rpb24gYW5ub3RhdGlvbnMoZXJyb3IsIHNldmVyaXR5LCB0eXBlKSB7XG4gIGlmICghZXJyb3Iubm9kZXMpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29uc3QgaGlnaGxpZ2h0ZWROb2RlcyA9IFtdO1xuICBlcnJvci5ub2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgY29uc3QgaGlnaGxpZ2h0Tm9kZSA9IG5vZGUua2luZCAhPT0gXCJWYXJpYWJsZVwiICYmIFwibmFtZVwiIGluIG5vZGUgJiYgbm9kZS5uYW1lICE9PSB2b2lkIDAgPyBub2RlLm5hbWUgOiBcInZhcmlhYmxlXCIgaW4gbm9kZSAmJiBub2RlLnZhcmlhYmxlICE9PSB2b2lkIDAgPyBub2RlLnZhcmlhYmxlIDogbm9kZTtcbiAgICBpZiAoaGlnaGxpZ2h0Tm9kZSkge1xuICAgICAgaW52YXJpYW50KGVycm9yLmxvY2F0aW9ucywgXCJHcmFwaFFMIHZhbGlkYXRpb24gZXJyb3IgcmVxdWlyZXMgbG9jYXRpb25zLlwiKTtcbiAgICAgIGNvbnN0IGxvYyA9IGVycm9yLmxvY2F0aW9uc1swXTtcbiAgICAgIGNvbnN0IGhpZ2hsaWdodExvYyA9IGdldExvY2F0aW9uKGhpZ2hsaWdodE5vZGUpO1xuICAgICAgY29uc3QgZW5kID0gbG9jLmNvbHVtbiArIChoaWdobGlnaHRMb2MuZW5kIC0gaGlnaGxpZ2h0TG9jLnN0YXJ0KTtcbiAgICAgIGhpZ2hsaWdodGVkTm9kZXMucHVzaCh7XG4gICAgICAgIHNvdXJjZTogYEdyYXBoUUw6ICR7dHlwZX1gLFxuICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICBzZXZlcml0eSxcbiAgICAgICAgcmFuZ2U6IG5ldyBSYW5nZShuZXcgUG9zaXRpb24obG9jLmxpbmUgLSAxLCBsb2MuY29sdW1uIC0gMSksIG5ldyBQb3NpdGlvbihsb2MubGluZSAtIDEsIGVuZCkpXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gaGlnaGxpZ2h0ZWROb2Rlcztcbn1cbl9fbmFtZShhbm5vdGF0aW9ucywgXCJhbm5vdGF0aW9uc1wiKTtcbmZ1bmN0aW9uIGdldFJhbmdlKGxvY2F0aW9uLCBxdWVyeVRleHQpIHtcbiAgY29uc3QgcGFyc2VyID0gb25saW5lUGFyc2VyKCk7XG4gIGNvbnN0IHN0YXRlID0gcGFyc2VyLnN0YXJ0U3RhdGUoKTtcbiAgY29uc3QgbGluZXMgPSBxdWVyeVRleHQuc3BsaXQoXCJcXG5cIik7XG4gIGludmFyaWFudChsaW5lcy5sZW5ndGggPj0gbG9jYXRpb24ubGluZSwgXCJRdWVyeSB0ZXh0IG11c3QgaGF2ZSBtb3JlIGxpbmVzIHRoYW4gd2hlcmUgdGhlIGVycm9yIGhhcHBlbmVkXCIpO1xuICBsZXQgc3RyZWFtID0gbnVsbDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhdGlvbi5saW5lOyBpKyspIHtcbiAgICBzdHJlYW0gPSBuZXcgQ2hhcmFjdGVyU3RyZWFtKGxpbmVzW2ldKTtcbiAgICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xuICAgICAgY29uc3Qgc3R5bGUgPSBwYXJzZXIudG9rZW4oc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBpZiAoc3R5bGUgPT09IFwiaW52YWxpZGNoYXJcIikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaW52YXJpYW50KHN0cmVhbSwgXCJFeHBlY3RlZCBQYXJzZXIgc3RyZWFtIHRvIGJlIGF2YWlsYWJsZS5cIik7XG4gIGNvbnN0IGxpbmUgPSBsb2NhdGlvbi5saW5lIC0gMTtcbiAgY29uc3Qgc3RhcnQgPSBzdHJlYW0uZ2V0U3RhcnRPZlRva2VuKCk7XG4gIGNvbnN0IGVuZCA9IHN0cmVhbS5nZXRDdXJyZW50UG9zaXRpb24oKTtcbiAgcmV0dXJuIG5ldyBSYW5nZShuZXcgUG9zaXRpb24obGluZSwgc3RhcnQpLCBuZXcgUG9zaXRpb24obGluZSwgZW5kKSk7XG59XG5fX25hbWUoZ2V0UmFuZ2UsIFwiZ2V0UmFuZ2VcIik7XG5mdW5jdGlvbiBnZXRMb2NhdGlvbihub2RlKSB7XG4gIGNvbnN0IHR5cGVDYXN0ZWROb2RlID0gbm9kZTtcbiAgY29uc3QgbG9jYXRpb24gPSB0eXBlQ2FzdGVkTm9kZS5sb2M7XG4gIGludmFyaWFudChsb2NhdGlvbiwgXCJFeHBlY3RlZCBBU1ROb2RlIHRvIGhhdmUgYSBsb2NhdGlvbi5cIik7XG4gIHJldHVybiBsb2NhdGlvbjtcbn1cbl9fbmFtZShnZXRMb2NhdGlvbiwgXCJnZXRMb2NhdGlvblwiKTtcbmNvbnN0IFNFVkVSSVRZID0gW1wiZXJyb3JcIiwgXCJ3YXJuaW5nXCIsIFwiaW5mb3JtYXRpb25cIiwgXCJoaW50XCJdO1xuY29uc3QgVFlQRSA9IHtcbiAgXCJHcmFwaFFMOiBWYWxpZGF0aW9uXCI6IFwidmFsaWRhdGlvblwiLFxuICBcIkdyYXBoUUw6IERlcHJlY2F0aW9uXCI6IFwiZGVwcmVjYXRpb25cIixcbiAgXCJHcmFwaFFMOiBTeW50YXhcIjogXCJzeW50YXhcIlxufTtcbkNvZGVNaXJyb3IucmVnaXN0ZXJIZWxwZXIoXCJsaW50XCIsIFwiZ3JhcGhxbFwiLCAodGV4dCwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBzY2hlbWEgPSBvcHRpb25zLnNjaGVtYTtcbiAgY29uc3QgcmF3UmVzdWx0cyA9IGdldERpYWdub3N0aWNzKHRleHQsIHNjaGVtYSwgb3B0aW9ucy52YWxpZGF0aW9uUnVsZXMsIHZvaWQgMCwgb3B0aW9ucy5leHRlcm5hbEZyYWdtZW50cyk7XG4gIGNvbnN0IHJlc3VsdHMgPSByYXdSZXN1bHRzLm1hcCgoZXJyb3IpID0+ICh7XG4gICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICBzZXZlcml0eTogZXJyb3Iuc2V2ZXJpdHkgPyBTRVZFUklUWVtlcnJvci5zZXZlcml0eSAtIDFdIDogU0VWRVJJVFlbMF0sXG4gICAgdHlwZTogZXJyb3Iuc291cmNlID8gVFlQRVtlcnJvci5zb3VyY2VdIDogdm9pZCAwLFxuICAgIGZyb206IENvZGVNaXJyb3IuUG9zKGVycm9yLnJhbmdlLnN0YXJ0LmxpbmUsIGVycm9yLnJhbmdlLnN0YXJ0LmNoYXJhY3RlciksXG4gICAgdG86IENvZGVNaXJyb3IuUG9zKGVycm9yLnJhbmdlLmVuZC5saW5lLCBlcnJvci5yYW5nZS5lbmQuY2hhcmFjdGVyKVxuICB9KSk7XG4gIHJldHVybiByZXN1bHRzO1xufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///67662\n')},98007:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "o": () => (/* binding */ onlineParser)\n/* harmony export */ });\n/* harmony import */ var _index_es_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59361);\n/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(97359);\nvar __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, "name", { value, configurable: true });\n\n\nfunction onlineParser(options = {\n  eatWhitespace: (stream) => stream.eatWhile(_index_es_js__WEBPACK_IMPORTED_MODULE_0__.i),\n  lexRules: _index_es_js__WEBPACK_IMPORTED_MODULE_0__.L,\n  parseRules: _index_es_js__WEBPACK_IMPORTED_MODULE_0__.P,\n  editorConfig: {}\n}) {\n  return {\n    startState() {\n      const initialState = {\n        level: 0,\n        step: 0,\n        name: null,\n        kind: null,\n        type: null,\n        rule: null,\n        needsSeparator: false,\n        prevState: null\n      };\n      pushRule(options.parseRules, initialState, graphql__WEBPACK_IMPORTED_MODULE_1__/* .Kind.DOCUMENT */ .h.DOCUMENT);\n      return initialState;\n    },\n    token(stream, state) {\n      return getToken(stream, state, options);\n    }\n  };\n}\n__name(onlineParser, "onlineParser");\nfunction getToken(stream, state, options) {\n  var _a;\n  if (state.inBlockstring) {\n    if (stream.match(/.*"""/)) {\n      state.inBlockstring = false;\n      return "string";\n    } else {\n      stream.skipToEnd();\n      return "string";\n    }\n  }\n  const { lexRules, parseRules, eatWhitespace, editorConfig } = options;\n  if (state.rule && state.rule.length === 0) {\n    popRule(state);\n  } else if (state.needsAdvance) {\n    state.needsAdvance = false;\n    advanceRule(state, true);\n  }\n  if (stream.sol()) {\n    const tabSize = (editorConfig === null || editorConfig === void 0 ? void 0 : editorConfig.tabSize) || 2;\n    state.indentLevel = Math.floor(stream.indentation() / tabSize);\n  }\n  if (eatWhitespace(stream)) {\n    return "ws";\n  }\n  const token = lex(lexRules, stream);\n  if (!token) {\n    const matchedSomething = stream.match(/\\S+/);\n    if (!matchedSomething) {\n      stream.match(/\\s/);\n    }\n    pushRule(SpecialParseRules, state, "Invalid");\n    return "invalidchar";\n  }\n  if (token.kind === "Comment") {\n    pushRule(SpecialParseRules, state, "Comment");\n    return "comment";\n  }\n  const backupState = assign({}, state);\n  if (token.kind === "Punctuation") {\n    if (/^[{([]/.test(token.value)) {\n      if (state.indentLevel !== void 0) {\n        state.levels = (state.levels || []).concat(state.indentLevel + 1);\n      }\n    } else if (/^[})\\]]/.test(token.value)) {\n      const levels = state.levels = (state.levels || []).slice(0, -1);\n      if (state.indentLevel) {\n        if (levels.length > 0 && levels[levels.length - 1] < state.indentLevel) {\n          state.indentLevel = levels[levels.length - 1];\n        }\n      }\n    }\n  }\n  while (state.rule) {\n    let expected = typeof state.rule === "function" ? state.step === 0 ? state.rule(token, stream) : null : state.rule[state.step];\n    if (state.needsSeparator) {\n      expected = expected === null || expected === void 0 ? void 0 : expected.separator;\n    }\n    if (expected) {\n      if (expected.ofRule) {\n        expected = expected.ofRule;\n      }\n      if (typeof expected === "string") {\n        pushRule(parseRules, state, expected);\n        continue;\n      }\n      if ((_a = expected.match) === null || _a === void 0 ? void 0 : _a.call(expected, token)) {\n        if (expected.update) {\n          expected.update(state, token);\n        }\n        if (token.kind === "Punctuation") {\n          advanceRule(state, true);\n        } else {\n          state.needsAdvance = true;\n        }\n        return expected.style;\n      }\n    }\n    unsuccessful(state);\n  }\n  assign(state, backupState);\n  pushRule(SpecialParseRules, state, "Invalid");\n  return "invalidchar";\n}\n__name(getToken, "getToken");\nfunction assign(to, from) {\n  const keys = Object.keys(from);\n  for (let i = 0; i < keys.length; i++) {\n    to[keys[i]] = from[keys[i]];\n  }\n  return to;\n}\n__name(assign, "assign");\nconst SpecialParseRules = {\n  Invalid: [],\n  Comment: []\n};\nfunction pushRule(rules, state, ruleKind) {\n  if (!rules[ruleKind]) {\n    throw new TypeError("Unknown rule: " + ruleKind);\n  }\n  state.prevState = Object.assign({}, state);\n  state.kind = ruleKind;\n  state.name = null;\n  state.type = null;\n  state.rule = rules[ruleKind];\n  state.step = 0;\n  state.needsSeparator = false;\n}\n__name(pushRule, "pushRule");\nfunction popRule(state) {\n  if (!state.prevState) {\n    return;\n  }\n  state.kind = state.prevState.kind;\n  state.name = state.prevState.name;\n  state.type = state.prevState.type;\n  state.rule = state.prevState.rule;\n  state.step = state.prevState.step;\n  state.needsSeparator = state.prevState.needsSeparator;\n  state.prevState = state.prevState.prevState;\n}\n__name(popRule, "popRule");\nfunction advanceRule(state, successful) {\n  var _a;\n  if (isList(state) && state.rule) {\n    const step = state.rule[state.step];\n    if (step.separator) {\n      const separator = step.separator;\n      state.needsSeparator = !state.needsSeparator;\n      if (!state.needsSeparator && separator.ofRule) {\n        return;\n      }\n    }\n    if (successful) {\n      return;\n    }\n  }\n  state.needsSeparator = false;\n  state.step++;\n  while (state.rule && !(Array.isArray(state.rule) && state.step < state.rule.length)) {\n    popRule(state);\n    if (state.rule) {\n      if (isList(state)) {\n        if ((_a = state.rule) === null || _a === void 0 ? void 0 : _a[state.step].separator) {\n          state.needsSeparator = !state.needsSeparator;\n        }\n      } else {\n        state.needsSeparator = false;\n        state.step++;\n      }\n    }\n  }\n}\n__name(advanceRule, "advanceRule");\nfunction isList(state) {\n  const step = Array.isArray(state.rule) && typeof state.rule[state.step] !== "string" && state.rule[state.step];\n  return step && step.isList;\n}\n__name(isList, "isList");\nfunction unsuccessful(state) {\n  while (state.rule && !(Array.isArray(state.rule) && state.rule[state.step].ofRule)) {\n    popRule(state);\n  }\n  if (state.rule) {\n    advanceRule(state, false);\n  }\n}\n__name(unsuccessful, "unsuccessful");\nfunction lex(lexRules, stream) {\n  const kinds = Object.keys(lexRules);\n  for (let i = 0; i < kinds.length; i++) {\n    const match = stream.match(lexRules[kinds[i]]);\n    if (match && match instanceof Array) {\n      return { kind: kinds[i], value: match[0] };\n    }\n  }\n}\n__name(lex, "lex");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTgwMDcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBLDREQUE0RCwyQkFBMkI7QUFDUjtBQUNoRDtBQUMvQjtBQUNBLDZDQUE2QywyQ0FBUztBQUN0RCxZQUFZLDJDQUFRO0FBQ3BCLGNBQWMsMkNBQVU7QUFDeEI7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELG9FQUFhO0FBQzlEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0RBQW9EO0FBQzlEO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxNQUFNLGFBQWE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQzZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2FjaGlxbC1kZW1vLy4vbm9kZV9tb2R1bGVzL0BncmFwaGlxbC9yZWFjdC9kaXN0L29ubGluZVBhcnNlci5lcy5qcz9jZjQ0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19uYW1lID0gKHRhcmdldCwgdmFsdWUpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwibmFtZVwiLCB7IHZhbHVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG5pbXBvcnQgeyBpIGFzIGlzSWdub3JlZCwgTCBhcyBMZXhSdWxlcywgUCBhcyBQYXJzZVJ1bGVzIH0gZnJvbSBcIi4vaW5kZXguZXMuanNcIjtcbmltcG9ydCB7IEtpbmQgfSBmcm9tIFwiZ3JhcGhxbFwiO1xuZnVuY3Rpb24gb25saW5lUGFyc2VyKG9wdGlvbnMgPSB7XG4gIGVhdFdoaXRlc3BhY2U6IChzdHJlYW0pID0+IHN0cmVhbS5lYXRXaGlsZShpc0lnbm9yZWQpLFxuICBsZXhSdWxlczogTGV4UnVsZXMsXG4gIHBhcnNlUnVsZXM6IFBhcnNlUnVsZXMsXG4gIGVkaXRvckNvbmZpZzoge31cbn0pIHtcbiAgcmV0dXJuIHtcbiAgICBzdGFydFN0YXRlKCkge1xuICAgICAgY29uc3QgaW5pdGlhbFN0YXRlID0ge1xuICAgICAgICBsZXZlbDogMCxcbiAgICAgICAgc3RlcDogMCxcbiAgICAgICAgbmFtZTogbnVsbCxcbiAgICAgICAga2luZDogbnVsbCxcbiAgICAgICAgdHlwZTogbnVsbCxcbiAgICAgICAgcnVsZTogbnVsbCxcbiAgICAgICAgbmVlZHNTZXBhcmF0b3I6IGZhbHNlLFxuICAgICAgICBwcmV2U3RhdGU6IG51bGxcbiAgICAgIH07XG4gICAgICBwdXNoUnVsZShvcHRpb25zLnBhcnNlUnVsZXMsIGluaXRpYWxTdGF0ZSwgS2luZC5ET0NVTUVOVCk7XG4gICAgICByZXR1cm4gaW5pdGlhbFN0YXRlO1xuICAgIH0sXG4gICAgdG9rZW4oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgcmV0dXJuIGdldFRva2VuKHN0cmVhbSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgIH1cbiAgfTtcbn1cbl9fbmFtZShvbmxpbmVQYXJzZXIsIFwib25saW5lUGFyc2VyXCIpO1xuZnVuY3Rpb24gZ2V0VG9rZW4oc3RyZWFtLCBzdGF0ZSwgb3B0aW9ucykge1xuICB2YXIgX2E7XG4gIGlmIChzdGF0ZS5pbkJsb2Nrc3RyaW5nKSB7XG4gICAgaWYgKHN0cmVhbS5tYXRjaCgvLipcIlwiXCIvKSkge1xuICAgICAgc3RhdGUuaW5CbG9ja3N0cmluZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgIH1cbiAgfVxuICBjb25zdCB7IGxleFJ1bGVzLCBwYXJzZVJ1bGVzLCBlYXRXaGl0ZXNwYWNlLCBlZGl0b3JDb25maWcgfSA9IG9wdGlvbnM7XG4gIGlmIChzdGF0ZS5ydWxlICYmIHN0YXRlLnJ1bGUubGVuZ3RoID09PSAwKSB7XG4gICAgcG9wUnVsZShzdGF0ZSk7XG4gIH0gZWxzZSBpZiAoc3RhdGUubmVlZHNBZHZhbmNlKSB7XG4gICAgc3RhdGUubmVlZHNBZHZhbmNlID0gZmFsc2U7XG4gICAgYWR2YW5jZVJ1bGUoc3RhdGUsIHRydWUpO1xuICB9XG4gIGlmIChzdHJlYW0uc29sKCkpIHtcbiAgICBjb25zdCB0YWJTaXplID0gKGVkaXRvckNvbmZpZyA9PT0gbnVsbCB8fCBlZGl0b3JDb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVkaXRvckNvbmZpZy50YWJTaXplKSB8fCAyO1xuICAgIHN0YXRlLmluZGVudExldmVsID0gTWF0aC5mbG9vcihzdHJlYW0uaW5kZW50YXRpb24oKSAvIHRhYlNpemUpO1xuICB9XG4gIGlmIChlYXRXaGl0ZXNwYWNlKHN0cmVhbSkpIHtcbiAgICByZXR1cm4gXCJ3c1wiO1xuICB9XG4gIGNvbnN0IHRva2VuID0gbGV4KGxleFJ1bGVzLCBzdHJlYW0pO1xuICBpZiAoIXRva2VuKSB7XG4gICAgY29uc3QgbWF0Y2hlZFNvbWV0aGluZyA9IHN0cmVhbS5tYXRjaCgvXFxTKy8pO1xuICAgIGlmICghbWF0Y2hlZFNvbWV0aGluZykge1xuICAgICAgc3RyZWFtLm1hdGNoKC9cXHMvKTtcbiAgICB9XG4gICAgcHVzaFJ1bGUoU3BlY2lhbFBhcnNlUnVsZXMsIHN0YXRlLCBcIkludmFsaWRcIik7XG4gICAgcmV0dXJuIFwiaW52YWxpZGNoYXJcIjtcbiAgfVxuICBpZiAodG9rZW4ua2luZCA9PT0gXCJDb21tZW50XCIpIHtcbiAgICBwdXNoUnVsZShTcGVjaWFsUGFyc2VSdWxlcywgc3RhdGUsIFwiQ29tbWVudFwiKTtcbiAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gIH1cbiAgY29uc3QgYmFja3VwU3RhdGUgPSBhc3NpZ24oe30sIHN0YXRlKTtcbiAgaWYgKHRva2VuLmtpbmQgPT09IFwiUHVuY3R1YXRpb25cIikge1xuICAgIGlmICgvXlt7KFtdLy50ZXN0KHRva2VuLnZhbHVlKSkge1xuICAgICAgaWYgKHN0YXRlLmluZGVudExldmVsICE9PSB2b2lkIDApIHtcbiAgICAgICAgc3RhdGUubGV2ZWxzID0gKHN0YXRlLmxldmVscyB8fCBbXSkuY29uY2F0KHN0YXRlLmluZGVudExldmVsICsgMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgvXlt9KVxcXV0vLnRlc3QodG9rZW4udmFsdWUpKSB7XG4gICAgICBjb25zdCBsZXZlbHMgPSBzdGF0ZS5sZXZlbHMgPSAoc3RhdGUubGV2ZWxzIHx8IFtdKS5zbGljZSgwLCAtMSk7XG4gICAgICBpZiAoc3RhdGUuaW5kZW50TGV2ZWwpIHtcbiAgICAgICAgaWYgKGxldmVscy5sZW5ndGggPiAwICYmIGxldmVsc1tsZXZlbHMubGVuZ3RoIC0gMV0gPCBzdGF0ZS5pbmRlbnRMZXZlbCkge1xuICAgICAgICAgIHN0YXRlLmluZGVudExldmVsID0gbGV2ZWxzW2xldmVscy5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB3aGlsZSAoc3RhdGUucnVsZSkge1xuICAgIGxldCBleHBlY3RlZCA9IHR5cGVvZiBzdGF0ZS5ydWxlID09PSBcImZ1bmN0aW9uXCIgPyBzdGF0ZS5zdGVwID09PSAwID8gc3RhdGUucnVsZSh0b2tlbiwgc3RyZWFtKSA6IG51bGwgOiBzdGF0ZS5ydWxlW3N0YXRlLnN0ZXBdO1xuICAgIGlmIChzdGF0ZS5uZWVkc1NlcGFyYXRvcikge1xuICAgICAgZXhwZWN0ZWQgPSBleHBlY3RlZCA9PT0gbnVsbCB8fCBleHBlY3RlZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXhwZWN0ZWQuc2VwYXJhdG9yO1xuICAgIH1cbiAgICBpZiAoZXhwZWN0ZWQpIHtcbiAgICAgIGlmIChleHBlY3RlZC5vZlJ1bGUpIHtcbiAgICAgICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5vZlJ1bGU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGV4cGVjdGVkID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHB1c2hSdWxlKHBhcnNlUnVsZXMsIHN0YXRlLCBleHBlY3RlZCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKChfYSA9IGV4cGVjdGVkLm1hdGNoKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChleHBlY3RlZCwgdG9rZW4pKSB7XG4gICAgICAgIGlmIChleHBlY3RlZC51cGRhdGUpIHtcbiAgICAgICAgICBleHBlY3RlZC51cGRhdGUoc3RhdGUsIHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4ua2luZCA9PT0gXCJQdW5jdHVhdGlvblwiKSB7XG4gICAgICAgICAgYWR2YW5jZVJ1bGUoc3RhdGUsIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLm5lZWRzQWR2YW5jZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cGVjdGVkLnN0eWxlO1xuICAgICAgfVxuICAgIH1cbiAgICB1bnN1Y2Nlc3NmdWwoc3RhdGUpO1xuICB9XG4gIGFzc2lnbihzdGF0ZSwgYmFja3VwU3RhdGUpO1xuICBwdXNoUnVsZShTcGVjaWFsUGFyc2VSdWxlcywgc3RhdGUsIFwiSW52YWxpZFwiKTtcbiAgcmV0dXJuIFwiaW52YWxpZGNoYXJcIjtcbn1cbl9fbmFtZShnZXRUb2tlbiwgXCJnZXRUb2tlblwiKTtcbmZ1bmN0aW9uIGFzc2lnbih0bywgZnJvbSkge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZnJvbSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHRvW2tleXNbaV1dID0gZnJvbVtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gdG87XG59XG5fX25hbWUoYXNzaWduLCBcImFzc2lnblwiKTtcbmNvbnN0IFNwZWNpYWxQYXJzZVJ1bGVzID0ge1xuICBJbnZhbGlkOiBbXSxcbiAgQ29tbWVudDogW11cbn07XG5mdW5jdGlvbiBwdXNoUnVsZShydWxlcywgc3RhdGUsIHJ1bGVLaW5kKSB7XG4gIGlmICghcnVsZXNbcnVsZUtpbmRdKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gcnVsZTogXCIgKyBydWxlS2luZCk7XG4gIH1cbiAgc3RhdGUucHJldlN0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpO1xuICBzdGF0ZS5raW5kID0gcnVsZUtpbmQ7XG4gIHN0YXRlLm5hbWUgPSBudWxsO1xuICBzdGF0ZS50eXBlID0gbnVsbDtcbiAgc3RhdGUucnVsZSA9IHJ1bGVzW3J1bGVLaW5kXTtcbiAgc3RhdGUuc3RlcCA9IDA7XG4gIHN0YXRlLm5lZWRzU2VwYXJhdG9yID0gZmFsc2U7XG59XG5fX25hbWUocHVzaFJ1bGUsIFwicHVzaFJ1bGVcIik7XG5mdW5jdGlvbiBwb3BSdWxlKHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJldlN0YXRlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHN0YXRlLmtpbmQgPSBzdGF0ZS5wcmV2U3RhdGUua2luZDtcbiAgc3RhdGUubmFtZSA9IHN0YXRlLnByZXZTdGF0ZS5uYW1lO1xuICBzdGF0ZS50eXBlID0gc3RhdGUucHJldlN0YXRlLnR5cGU7XG4gIHN0YXRlLnJ1bGUgPSBzdGF0ZS5wcmV2U3RhdGUucnVsZTtcbiAgc3RhdGUuc3RlcCA9IHN0YXRlLnByZXZTdGF0ZS5zdGVwO1xuICBzdGF0ZS5uZWVkc1NlcGFyYXRvciA9IHN0YXRlLnByZXZTdGF0ZS5uZWVkc1NlcGFyYXRvcjtcbiAgc3RhdGUucHJldlN0YXRlID0gc3RhdGUucHJldlN0YXRlLnByZXZTdGF0ZTtcbn1cbl9fbmFtZShwb3BSdWxlLCBcInBvcFJ1bGVcIik7XG5mdW5jdGlvbiBhZHZhbmNlUnVsZShzdGF0ZSwgc3VjY2Vzc2Z1bCkge1xuICB2YXIgX2E7XG4gIGlmIChpc0xpc3Qoc3RhdGUpICYmIHN0YXRlLnJ1bGUpIHtcbiAgICBjb25zdCBzdGVwID0gc3RhdGUucnVsZVtzdGF0ZS5zdGVwXTtcbiAgICBpZiAoc3RlcC5zZXBhcmF0b3IpIHtcbiAgICAgIGNvbnN0IHNlcGFyYXRvciA9IHN0ZXAuc2VwYXJhdG9yO1xuICAgICAgc3RhdGUubmVlZHNTZXBhcmF0b3IgPSAhc3RhdGUubmVlZHNTZXBhcmF0b3I7XG4gICAgICBpZiAoIXN0YXRlLm5lZWRzU2VwYXJhdG9yICYmIHNlcGFyYXRvci5vZlJ1bGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3VjY2Vzc2Z1bCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBzdGF0ZS5uZWVkc1NlcGFyYXRvciA9IGZhbHNlO1xuICBzdGF0ZS5zdGVwKys7XG4gIHdoaWxlIChzdGF0ZS5ydWxlICYmICEoQXJyYXkuaXNBcnJheShzdGF0ZS5ydWxlKSAmJiBzdGF0ZS5zdGVwIDwgc3RhdGUucnVsZS5sZW5ndGgpKSB7XG4gICAgcG9wUnVsZShzdGF0ZSk7XG4gICAgaWYgKHN0YXRlLnJ1bGUpIHtcbiAgICAgIGlmIChpc0xpc3Qoc3RhdGUpKSB7XG4gICAgICAgIGlmICgoX2EgPSBzdGF0ZS5ydWxlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Fbc3RhdGUuc3RlcF0uc2VwYXJhdG9yKSB7XG4gICAgICAgICAgc3RhdGUubmVlZHNTZXBhcmF0b3IgPSAhc3RhdGUubmVlZHNTZXBhcmF0b3I7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLm5lZWRzU2VwYXJhdG9yID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLnN0ZXArKztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbl9fbmFtZShhZHZhbmNlUnVsZSwgXCJhZHZhbmNlUnVsZVwiKTtcbmZ1bmN0aW9uIGlzTGlzdChzdGF0ZSkge1xuICBjb25zdCBzdGVwID0gQXJyYXkuaXNBcnJheShzdGF0ZS5ydWxlKSAmJiB0eXBlb2Ygc3RhdGUucnVsZVtzdGF0ZS5zdGVwXSAhPT0gXCJzdHJpbmdcIiAmJiBzdGF0ZS5ydWxlW3N0YXRlLnN0ZXBdO1xuICByZXR1cm4gc3RlcCAmJiBzdGVwLmlzTGlzdDtcbn1cbl9fbmFtZShpc0xpc3QsIFwiaXNMaXN0XCIpO1xuZnVuY3Rpb24gdW5zdWNjZXNzZnVsKHN0YXRlKSB7XG4gIHdoaWxlIChzdGF0ZS5ydWxlICYmICEoQXJyYXkuaXNBcnJheShzdGF0ZS5ydWxlKSAmJiBzdGF0ZS5ydWxlW3N0YXRlLnN0ZXBdLm9mUnVsZSkpIHtcbiAgICBwb3BSdWxlKHN0YXRlKTtcbiAgfVxuICBpZiAoc3RhdGUucnVsZSkge1xuICAgIGFkdmFuY2VSdWxlKHN0YXRlLCBmYWxzZSk7XG4gIH1cbn1cbl9fbmFtZSh1bnN1Y2Nlc3NmdWwsIFwidW5zdWNjZXNzZnVsXCIpO1xuZnVuY3Rpb24gbGV4KGxleFJ1bGVzLCBzdHJlYW0pIHtcbiAgY29uc3Qga2luZHMgPSBPYmplY3Qua2V5cyhsZXhSdWxlcyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2luZHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBtYXRjaCA9IHN0cmVhbS5tYXRjaChsZXhSdWxlc1traW5kc1tpXV0pO1xuICAgIGlmIChtYXRjaCAmJiBtYXRjaCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICByZXR1cm4geyBraW5kOiBraW5kc1tpXSwgdmFsdWU6IG1hdGNoWzBdIH07XG4gICAgfVxuICB9XG59XG5fX25hbWUobGV4LCBcImxleFwiKTtcbmV4cG9ydCB7IG9ubGluZVBhcnNlciBhcyBvIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///98007\n')}}]);