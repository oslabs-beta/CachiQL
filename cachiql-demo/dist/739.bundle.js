"use strict";(self.webpackChunkcachiql_demo=self.webpackChunkcachiql_demo||[]).push([[739],{55739:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "f": () => (/* binding */ foldgutter$1)\n/* harmony export */ });\n/* harmony import */ var _codemirror_es_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97480);\nvar __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, "name", { value, configurable: true });\n\nfunction _mergeNamespaces(n, m) {\n  m.forEach(function(e) {\n    e && typeof e !== "string" && !Array.isArray(e) && Object.keys(e).forEach(function(k) {\n      if (k !== "default" && !(k in n)) {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function() {\n            return e[k];\n          }\n        });\n      }\n    });\n  });\n  return Object.freeze(n);\n}\n__name(_mergeNamespaces, "_mergeNamespaces");\nvar foldgutter$2 = { exports: {} };\nvar foldcode = { exports: {} };\n(function(module, exports) {\n  (function(mod) {\n    mod(_codemirror_es_js__WEBPACK_IMPORTED_MODULE_0__.a.exports);\n  })(function(CodeMirror) {\n    function doFold(cm, pos, options, force) {\n      if (options && options.call) {\n        var finder = options;\n        options = null;\n      } else {\n        var finder = getOption(cm, options, "rangeFinder");\n      }\n      if (typeof pos == "number")\n        pos = CodeMirror.Pos(pos, 0);\n      var minSize = getOption(cm, options, "minFoldSize");\n      function getRange(allowFolded) {\n        var range2 = finder(cm, pos);\n        if (!range2 || range2.to.line - range2.from.line < minSize)\n          return null;\n        if (force === "fold")\n          return range2;\n        var marks = cm.findMarksAt(range2.from);\n        for (var i = 0; i < marks.length; ++i) {\n          if (marks[i].__isFold) {\n            if (!allowFolded)\n              return null;\n            range2.cleared = true;\n            marks[i].clear();\n          }\n        }\n        return range2;\n      }\n      __name(getRange, "getRange");\n      var range = getRange(true);\n      if (getOption(cm, options, "scanUp"))\n        while (!range && pos.line > cm.firstLine()) {\n          pos = CodeMirror.Pos(pos.line - 1, 0);\n          range = getRange(false);\n        }\n      if (!range || range.cleared || force === "unfold")\n        return;\n      var myWidget = makeWidget(cm, options, range);\n      CodeMirror.on(myWidget, "mousedown", function(e) {\n        myRange.clear();\n        CodeMirror.e_preventDefault(e);\n      });\n      var myRange = cm.markText(range.from, range.to, {\n        replacedWith: myWidget,\n        clearOnEnter: getOption(cm, options, "clearOnEnter"),\n        __isFold: true\n      });\n      myRange.on("clear", function(from, to) {\n        CodeMirror.signal(cm, "unfold", cm, from, to);\n      });\n      CodeMirror.signal(cm, "fold", cm, range.from, range.to);\n    }\n    __name(doFold, "doFold");\n    function makeWidget(cm, options, range) {\n      var widget = getOption(cm, options, "widget");\n      if (typeof widget == "function") {\n        widget = widget(range.from, range.to);\n      }\n      if (typeof widget == "string") {\n        var text = document.createTextNode(widget);\n        widget = document.createElement("span");\n        widget.appendChild(text);\n        widget.className = "CodeMirror-foldmarker";\n      } else if (widget) {\n        widget = widget.cloneNode(true);\n      }\n      return widget;\n    }\n    __name(makeWidget, "makeWidget");\n    CodeMirror.newFoldFunction = function(rangeFinder, widget) {\n      return function(cm, pos) {\n        doFold(cm, pos, { rangeFinder, widget });\n      };\n    };\n    CodeMirror.defineExtension("foldCode", function(pos, options, force) {\n      doFold(this, pos, options, force);\n    });\n    CodeMirror.defineExtension("isFolded", function(pos) {\n      var marks = this.findMarksAt(pos);\n      for (var i = 0; i < marks.length; ++i)\n        if (marks[i].__isFold)\n          return true;\n    });\n    CodeMirror.commands.toggleFold = function(cm) {\n      cm.foldCode(cm.getCursor());\n    };\n    CodeMirror.commands.fold = function(cm) {\n      cm.foldCode(cm.getCursor(), null, "fold");\n    };\n    CodeMirror.commands.unfold = function(cm) {\n      cm.foldCode(cm.getCursor(), { scanUp: false }, "unfold");\n    };\n    CodeMirror.commands.foldAll = function(cm) {\n      cm.operation(function() {\n        for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)\n          cm.foldCode(CodeMirror.Pos(i, 0), { scanUp: false }, "fold");\n      });\n    };\n    CodeMirror.commands.unfoldAll = function(cm) {\n      cm.operation(function() {\n        for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)\n          cm.foldCode(CodeMirror.Pos(i, 0), { scanUp: false }, "unfold");\n      });\n    };\n    CodeMirror.registerHelper("fold", "combine", function() {\n      var funcs = Array.prototype.slice.call(arguments, 0);\n      return function(cm, start) {\n        for (var i = 0; i < funcs.length; ++i) {\n          var found = funcs[i](cm, start);\n          if (found)\n            return found;\n        }\n      };\n    });\n    CodeMirror.registerHelper("fold", "auto", function(cm, start) {\n      var helpers = cm.getHelpers(start, "fold");\n      for (var i = 0; i < helpers.length; i++) {\n        var cur = helpers[i](cm, start);\n        if (cur)\n          return cur;\n      }\n    });\n    var defaultOptions = {\n      rangeFinder: CodeMirror.fold.auto,\n      widget: "\\u2194",\n      minFoldSize: 0,\n      scanUp: false,\n      clearOnEnter: true\n    };\n    CodeMirror.defineOption("foldOptions", null);\n    function getOption(cm, options, name) {\n      if (options && options[name] !== void 0)\n        return options[name];\n      var editorOptions = cm.options.foldOptions;\n      if (editorOptions && editorOptions[name] !== void 0)\n        return editorOptions[name];\n      return defaultOptions[name];\n    }\n    __name(getOption, "getOption");\n    CodeMirror.defineExtension("foldOption", function(options, name) {\n      return getOption(this, options, name);\n    });\n  });\n})();\n(function(module, exports) {\n  (function(mod) {\n    mod(_codemirror_es_js__WEBPACK_IMPORTED_MODULE_0__.a.exports, foldcode.exports);\n  })(function(CodeMirror) {\n    CodeMirror.defineOption("foldGutter", false, function(cm, val, old) {\n      if (old && old != CodeMirror.Init) {\n        cm.clearGutter(cm.state.foldGutter.options.gutter);\n        cm.state.foldGutter = null;\n        cm.off("gutterClick", onGutterClick);\n        cm.off("changes", onChange);\n        cm.off("viewportChange", onViewportChange);\n        cm.off("fold", onFold);\n        cm.off("unfold", onFold);\n        cm.off("swapDoc", onChange);\n      }\n      if (val) {\n        cm.state.foldGutter = new State(parseOptions(val));\n        updateInViewport(cm);\n        cm.on("gutterClick", onGutterClick);\n        cm.on("changes", onChange);\n        cm.on("viewportChange", onViewportChange);\n        cm.on("fold", onFold);\n        cm.on("unfold", onFold);\n        cm.on("swapDoc", onChange);\n      }\n    });\n    var Pos = CodeMirror.Pos;\n    function State(options) {\n      this.options = options;\n      this.from = this.to = 0;\n    }\n    __name(State, "State");\n    function parseOptions(opts) {\n      if (opts === true)\n        opts = {};\n      if (opts.gutter == null)\n        opts.gutter = "CodeMirror-foldgutter";\n      if (opts.indicatorOpen == null)\n        opts.indicatorOpen = "CodeMirror-foldgutter-open";\n      if (opts.indicatorFolded == null)\n        opts.indicatorFolded = "CodeMirror-foldgutter-folded";\n      return opts;\n    }\n    __name(parseOptions, "parseOptions");\n    function isFolded(cm, line) {\n      var marks = cm.findMarks(Pos(line, 0), Pos(line + 1, 0));\n      for (var i = 0; i < marks.length; ++i) {\n        if (marks[i].__isFold) {\n          var fromPos = marks[i].find(-1);\n          if (fromPos && fromPos.line === line)\n            return marks[i];\n        }\n      }\n    }\n    __name(isFolded, "isFolded");\n    function marker(spec) {\n      if (typeof spec == "string") {\n        var elt = document.createElement("div");\n        elt.className = spec + " CodeMirror-guttermarker-subtle";\n        return elt;\n      } else {\n        return spec.cloneNode(true);\n      }\n    }\n    __name(marker, "marker");\n    function updateFoldInfo(cm, from, to) {\n      var opts = cm.state.foldGutter.options, cur = from - 1;\n      var minSize = cm.foldOption(opts, "minFoldSize");\n      var func = cm.foldOption(opts, "rangeFinder");\n      var clsFolded = typeof opts.indicatorFolded == "string" && classTest(opts.indicatorFolded);\n      var clsOpen = typeof opts.indicatorOpen == "string" && classTest(opts.indicatorOpen);\n      cm.eachLine(from, to, function(line) {\n        ++cur;\n        var mark = null;\n        var old = line.gutterMarkers;\n        if (old)\n          old = old[opts.gutter];\n        if (isFolded(cm, cur)) {\n          if (clsFolded && old && clsFolded.test(old.className))\n            return;\n          mark = marker(opts.indicatorFolded);\n        } else {\n          var pos = Pos(cur, 0);\n          var range = func && func(cm, pos);\n          if (range && range.to.line - range.from.line >= minSize) {\n            if (clsOpen && old && clsOpen.test(old.className))\n              return;\n            mark = marker(opts.indicatorOpen);\n          }\n        }\n        if (!mark && !old)\n          return;\n        cm.setGutterMarker(line, opts.gutter, mark);\n      });\n    }\n    __name(updateFoldInfo, "updateFoldInfo");\n    function classTest(cls) {\n      return new RegExp("(^|\\\\s)" + cls + "(?:$|\\\\s)\\\\s*");\n    }\n    __name(classTest, "classTest");\n    function updateInViewport(cm) {\n      var vp = cm.getViewport(), state = cm.state.foldGutter;\n      if (!state)\n        return;\n      cm.operation(function() {\n        updateFoldInfo(cm, vp.from, vp.to);\n      });\n      state.from = vp.from;\n      state.to = vp.to;\n    }\n    __name(updateInViewport, "updateInViewport");\n    function onGutterClick(cm, line, gutter) {\n      var state = cm.state.foldGutter;\n      if (!state)\n        return;\n      var opts = state.options;\n      if (gutter != opts.gutter)\n        return;\n      var folded = isFolded(cm, line);\n      if (folded)\n        folded.clear();\n      else\n        cm.foldCode(Pos(line, 0), opts);\n    }\n    __name(onGutterClick, "onGutterClick");\n    function onChange(cm) {\n      var state = cm.state.foldGutter;\n      if (!state)\n        return;\n      var opts = state.options;\n      state.from = state.to = 0;\n      clearTimeout(state.changeUpdate);\n      state.changeUpdate = setTimeout(function() {\n        updateInViewport(cm);\n      }, opts.foldOnChangeTimeSpan || 600);\n    }\n    __name(onChange, "onChange");\n    function onViewportChange(cm) {\n      var state = cm.state.foldGutter;\n      if (!state)\n        return;\n      var opts = state.options;\n      clearTimeout(state.changeUpdate);\n      state.changeUpdate = setTimeout(function() {\n        var vp = cm.getViewport();\n        if (state.from == state.to || vp.from - state.to > 20 || state.from - vp.to > 20) {\n          updateInViewport(cm);\n        } else {\n          cm.operation(function() {\n            if (vp.from < state.from) {\n              updateFoldInfo(cm, vp.from, state.from);\n              state.from = vp.from;\n            }\n            if (vp.to > state.to) {\n              updateFoldInfo(cm, state.to, vp.to);\n              state.to = vp.to;\n            }\n          });\n        }\n      }, opts.updateViewportTimeSpan || 400);\n    }\n    __name(onViewportChange, "onViewportChange");\n    function onFold(cm, from) {\n      var state = cm.state.foldGutter;\n      if (!state)\n        return;\n      var line = from.line;\n      if (line >= state.from && line < state.to)\n        updateFoldInfo(cm, line, line + 1);\n    }\n    __name(onFold, "onFold");\n  });\n})();\nvar foldgutter = foldgutter$2.exports;\nvar foldgutter$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  [Symbol.toStringTag]: "Module",\n  "default": foldgutter\n}, [foldgutter$2.exports]));\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUM0QiIsInNvdXJjZXMiOlsid2VicGFjazovL2NhY2hpcWwtZGVtby8uL25vZGVfbW9kdWxlcy9AZ3JhcGhpcWwvcmVhY3QvZGlzdC9mb2xkZ3V0dGVyLmVzLmpzP2ZiNmIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX25hbWUgPSAodGFyZ2V0LCB2YWx1ZSkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJuYW1lXCIsIHsgdmFsdWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbmltcG9ydCB7IGEgYXMgY29kZW1pcnJvciB9IGZyb20gXCIuL2NvZGVtaXJyb3IuZXMuanNcIjtcbmZ1bmN0aW9uIF9tZXJnZU5hbWVzcGFjZXMobiwgbSkge1xuICBtLmZvckVhY2goZnVuY3Rpb24oZSkge1xuICAgIGUgJiYgdHlwZW9mIGUgIT09IFwic3RyaW5nXCIgJiYgIUFycmF5LmlzQXJyYXkoZSkgJiYgT2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgIShrIGluIG4pKSB7XG4gICAgICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGssIGQuZ2V0ID8gZCA6IHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZVtrXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUobik7XG59XG5fX25hbWUoX21lcmdlTmFtZXNwYWNlcywgXCJfbWVyZ2VOYW1lc3BhY2VzXCIpO1xudmFyIGZvbGRndXR0ZXIkMiA9IHsgZXhwb3J0czoge30gfTtcbnZhciBmb2xkY29kZSA9IHsgZXhwb3J0czoge30gfTtcbihmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcbiAgKGZ1bmN0aW9uKG1vZCkge1xuICAgIG1vZChjb2RlbWlycm9yLmV4cG9ydHMpO1xuICB9KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG4gICAgZnVuY3Rpb24gZG9Gb2xkKGNtLCBwb3MsIG9wdGlvbnMsIGZvcmNlKSB7XG4gICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmNhbGwpIHtcbiAgICAgICAgdmFyIGZpbmRlciA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGZpbmRlciA9IGdldE9wdGlvbihjbSwgb3B0aW9ucywgXCJyYW5nZUZpbmRlclwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcG9zID09IFwibnVtYmVyXCIpXG4gICAgICAgIHBvcyA9IENvZGVNaXJyb3IuUG9zKHBvcywgMCk7XG4gICAgICB2YXIgbWluU2l6ZSA9IGdldE9wdGlvbihjbSwgb3B0aW9ucywgXCJtaW5Gb2xkU2l6ZVwiKTtcbiAgICAgIGZ1bmN0aW9uIGdldFJhbmdlKGFsbG93Rm9sZGVkKSB7XG4gICAgICAgIHZhciByYW5nZTIgPSBmaW5kZXIoY20sIHBvcyk7XG4gICAgICAgIGlmICghcmFuZ2UyIHx8IHJhbmdlMi50by5saW5lIC0gcmFuZ2UyLmZyb20ubGluZSA8IG1pblNpemUpXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChmb3JjZSA9PT0gXCJmb2xkXCIpXG4gICAgICAgICAgcmV0dXJuIHJhbmdlMjtcbiAgICAgICAgdmFyIG1hcmtzID0gY20uZmluZE1hcmtzQXQocmFuZ2UyLmZyb20pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaWYgKG1hcmtzW2ldLl9faXNGb2xkKSB7XG4gICAgICAgICAgICBpZiAoIWFsbG93Rm9sZGVkKVxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJhbmdlMi5jbGVhcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIG1hcmtzW2ldLmNsZWFyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYW5nZTI7XG4gICAgICB9XG4gICAgICBfX25hbWUoZ2V0UmFuZ2UsIFwiZ2V0UmFuZ2VcIik7XG4gICAgICB2YXIgcmFuZ2UgPSBnZXRSYW5nZSh0cnVlKTtcbiAgICAgIGlmIChnZXRPcHRpb24oY20sIG9wdGlvbnMsIFwic2NhblVwXCIpKVxuICAgICAgICB3aGlsZSAoIXJhbmdlICYmIHBvcy5saW5lID4gY20uZmlyc3RMaW5lKCkpIHtcbiAgICAgICAgICBwb3MgPSBDb2RlTWlycm9yLlBvcyhwb3MubGluZSAtIDEsIDApO1xuICAgICAgICAgIHJhbmdlID0gZ2V0UmFuZ2UoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICBpZiAoIXJhbmdlIHx8IHJhbmdlLmNsZWFyZWQgfHwgZm9yY2UgPT09IFwidW5mb2xkXCIpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHZhciBteVdpZGdldCA9IG1ha2VXaWRnZXQoY20sIG9wdGlvbnMsIHJhbmdlKTtcbiAgICAgIENvZGVNaXJyb3Iub24obXlXaWRnZXQsIFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgbXlSYW5nZS5jbGVhcigpO1xuICAgICAgICBDb2RlTWlycm9yLmVfcHJldmVudERlZmF1bHQoZSk7XG4gICAgICB9KTtcbiAgICAgIHZhciBteVJhbmdlID0gY20ubWFya1RleHQocmFuZ2UuZnJvbSwgcmFuZ2UudG8sIHtcbiAgICAgICAgcmVwbGFjZWRXaXRoOiBteVdpZGdldCxcbiAgICAgICAgY2xlYXJPbkVudGVyOiBnZXRPcHRpb24oY20sIG9wdGlvbnMsIFwiY2xlYXJPbkVudGVyXCIpLFxuICAgICAgICBfX2lzRm9sZDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBteVJhbmdlLm9uKFwiY2xlYXJcIiwgZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgICAgICAgQ29kZU1pcnJvci5zaWduYWwoY20sIFwidW5mb2xkXCIsIGNtLCBmcm9tLCB0byk7XG4gICAgICB9KTtcbiAgICAgIENvZGVNaXJyb3Iuc2lnbmFsKGNtLCBcImZvbGRcIiwgY20sIHJhbmdlLmZyb20sIHJhbmdlLnRvKTtcbiAgICB9XG4gICAgX19uYW1lKGRvRm9sZCwgXCJkb0ZvbGRcIik7XG4gICAgZnVuY3Rpb24gbWFrZVdpZGdldChjbSwgb3B0aW9ucywgcmFuZ2UpIHtcbiAgICAgIHZhciB3aWRnZXQgPSBnZXRPcHRpb24oY20sIG9wdGlvbnMsIFwid2lkZ2V0XCIpO1xuICAgICAgaWYgKHR5cGVvZiB3aWRnZXQgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHdpZGdldCA9IHdpZGdldChyYW5nZS5mcm9tLCByYW5nZS50byk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHdpZGdldCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUod2lkZ2V0KTtcbiAgICAgICAgd2lkZ2V0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHdpZGdldC5hcHBlbmRDaGlsZCh0ZXh0KTtcbiAgICAgICAgd2lkZ2V0LmNsYXNzTmFtZSA9IFwiQ29kZU1pcnJvci1mb2xkbWFya2VyXCI7XG4gICAgICB9IGVsc2UgaWYgKHdpZGdldCkge1xuICAgICAgICB3aWRnZXQgPSB3aWRnZXQuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdpZGdldDtcbiAgICB9XG4gICAgX19uYW1lKG1ha2VXaWRnZXQsIFwibWFrZVdpZGdldFwiKTtcbiAgICBDb2RlTWlycm9yLm5ld0ZvbGRGdW5jdGlvbiA9IGZ1bmN0aW9uKHJhbmdlRmluZGVyLCB3aWRnZXQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjbSwgcG9zKSB7XG4gICAgICAgIGRvRm9sZChjbSwgcG9zLCB7IHJhbmdlRmluZGVyLCB3aWRnZXQgfSk7XG4gICAgICB9O1xuICAgIH07XG4gICAgQ29kZU1pcnJvci5kZWZpbmVFeHRlbnNpb24oXCJmb2xkQ29kZVwiLCBmdW5jdGlvbihwb3MsIG9wdGlvbnMsIGZvcmNlKSB7XG4gICAgICBkb0ZvbGQodGhpcywgcG9zLCBvcHRpb25zLCBmb3JjZSk7XG4gICAgfSk7XG4gICAgQ29kZU1pcnJvci5kZWZpbmVFeHRlbnNpb24oXCJpc0ZvbGRlZFwiLCBmdW5jdGlvbihwb3MpIHtcbiAgICAgIHZhciBtYXJrcyA9IHRoaXMuZmluZE1hcmtzQXQocG9zKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyArK2kpXG4gICAgICAgIGlmIChtYXJrc1tpXS5fX2lzRm9sZClcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICBDb2RlTWlycm9yLmNvbW1hbmRzLnRvZ2dsZUZvbGQgPSBmdW5jdGlvbihjbSkge1xuICAgICAgY20uZm9sZENvZGUoY20uZ2V0Q3Vyc29yKCkpO1xuICAgIH07XG4gICAgQ29kZU1pcnJvci5jb21tYW5kcy5mb2xkID0gZnVuY3Rpb24oY20pIHtcbiAgICAgIGNtLmZvbGRDb2RlKGNtLmdldEN1cnNvcigpLCBudWxsLCBcImZvbGRcIik7XG4gICAgfTtcbiAgICBDb2RlTWlycm9yLmNvbW1hbmRzLnVuZm9sZCA9IGZ1bmN0aW9uKGNtKSB7XG4gICAgICBjbS5mb2xkQ29kZShjbS5nZXRDdXJzb3IoKSwgeyBzY2FuVXA6IGZhbHNlIH0sIFwidW5mb2xkXCIpO1xuICAgIH07XG4gICAgQ29kZU1pcnJvci5jb21tYW5kcy5mb2xkQWxsID0gZnVuY3Rpb24oY20pIHtcbiAgICAgIGNtLm9wZXJhdGlvbihmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IGNtLmZpcnN0TGluZSgpLCBlID0gY20ubGFzdExpbmUoKTsgaSA8PSBlOyBpKyspXG4gICAgICAgICAgY20uZm9sZENvZGUoQ29kZU1pcnJvci5Qb3MoaSwgMCksIHsgc2NhblVwOiBmYWxzZSB9LCBcImZvbGRcIik7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIENvZGVNaXJyb3IuY29tbWFuZHMudW5mb2xkQWxsID0gZnVuY3Rpb24oY20pIHtcbiAgICAgIGNtLm9wZXJhdGlvbihmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IGNtLmZpcnN0TGluZSgpLCBlID0gY20ubGFzdExpbmUoKTsgaSA8PSBlOyBpKyspXG4gICAgICAgICAgY20uZm9sZENvZGUoQ29kZU1pcnJvci5Qb3MoaSwgMCksIHsgc2NhblVwOiBmYWxzZSB9LCBcInVuZm9sZFwiKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgQ29kZU1pcnJvci5yZWdpc3RlckhlbHBlcihcImZvbGRcIiwgXCJjb21iaW5lXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGZ1bmNzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjbSwgc3RhcnQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmdW5jcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhciBmb3VuZCA9IGZ1bmNzW2ldKGNtLCBzdGFydCk7XG4gICAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICAgIENvZGVNaXJyb3IucmVnaXN0ZXJIZWxwZXIoXCJmb2xkXCIsIFwiYXV0b1wiLCBmdW5jdGlvbihjbSwgc3RhcnQpIHtcbiAgICAgIHZhciBoZWxwZXJzID0gY20uZ2V0SGVscGVycyhzdGFydCwgXCJmb2xkXCIpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZWxwZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjdXIgPSBoZWxwZXJzW2ldKGNtLCBzdGFydCk7XG4gICAgICAgIGlmIChjdXIpXG4gICAgICAgICAgcmV0dXJuIGN1cjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICByYW5nZUZpbmRlcjogQ29kZU1pcnJvci5mb2xkLmF1dG8sXG4gICAgICB3aWRnZXQ6IFwiXFx1MjE5NFwiLFxuICAgICAgbWluRm9sZFNpemU6IDAsXG4gICAgICBzY2FuVXA6IGZhbHNlLFxuICAgICAgY2xlYXJPbkVudGVyOiB0cnVlXG4gICAgfTtcbiAgICBDb2RlTWlycm9yLmRlZmluZU9wdGlvbihcImZvbGRPcHRpb25zXCIsIG51bGwpO1xuICAgIGZ1bmN0aW9uIGdldE9wdGlvbihjbSwgb3B0aW9ucywgbmFtZSkge1xuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9uc1tuYW1lXSAhPT0gdm9pZCAwKVxuICAgICAgICByZXR1cm4gb3B0aW9uc1tuYW1lXTtcbiAgICAgIHZhciBlZGl0b3JPcHRpb25zID0gY20ub3B0aW9ucy5mb2xkT3B0aW9ucztcbiAgICAgIGlmIChlZGl0b3JPcHRpb25zICYmIGVkaXRvck9wdGlvbnNbbmFtZV0gIT09IHZvaWQgMClcbiAgICAgICAgcmV0dXJuIGVkaXRvck9wdGlvbnNbbmFtZV07XG4gICAgICByZXR1cm4gZGVmYXVsdE9wdGlvbnNbbmFtZV07XG4gICAgfVxuICAgIF9fbmFtZShnZXRPcHRpb24sIFwiZ2V0T3B0aW9uXCIpO1xuICAgIENvZGVNaXJyb3IuZGVmaW5lRXh0ZW5zaW9uKFwiZm9sZE9wdGlvblwiLCBmdW5jdGlvbihvcHRpb25zLCBuYW1lKSB7XG4gICAgICByZXR1cm4gZ2V0T3B0aW9uKHRoaXMsIG9wdGlvbnMsIG5hbWUpO1xuICAgIH0pO1xuICB9KTtcbn0pKCk7XG4oZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG4gIChmdW5jdGlvbihtb2QpIHtcbiAgICBtb2QoY29kZW1pcnJvci5leHBvcnRzLCBmb2xkY29kZS5leHBvcnRzKTtcbiAgfSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuICAgIENvZGVNaXJyb3IuZGVmaW5lT3B0aW9uKFwiZm9sZEd1dHRlclwiLCBmYWxzZSwgZnVuY3Rpb24oY20sIHZhbCwgb2xkKSB7XG4gICAgICBpZiAob2xkICYmIG9sZCAhPSBDb2RlTWlycm9yLkluaXQpIHtcbiAgICAgICAgY20uY2xlYXJHdXR0ZXIoY20uc3RhdGUuZm9sZEd1dHRlci5vcHRpb25zLmd1dHRlcik7XG4gICAgICAgIGNtLnN0YXRlLmZvbGRHdXR0ZXIgPSBudWxsO1xuICAgICAgICBjbS5vZmYoXCJndXR0ZXJDbGlja1wiLCBvbkd1dHRlckNsaWNrKTtcbiAgICAgICAgY20ub2ZmKFwiY2hhbmdlc1wiLCBvbkNoYW5nZSk7XG4gICAgICAgIGNtLm9mZihcInZpZXdwb3J0Q2hhbmdlXCIsIG9uVmlld3BvcnRDaGFuZ2UpO1xuICAgICAgICBjbS5vZmYoXCJmb2xkXCIsIG9uRm9sZCk7XG4gICAgICAgIGNtLm9mZihcInVuZm9sZFwiLCBvbkZvbGQpO1xuICAgICAgICBjbS5vZmYoXCJzd2FwRG9jXCIsIG9uQ2hhbmdlKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgY20uc3RhdGUuZm9sZEd1dHRlciA9IG5ldyBTdGF0ZShwYXJzZU9wdGlvbnModmFsKSk7XG4gICAgICAgIHVwZGF0ZUluVmlld3BvcnQoY20pO1xuICAgICAgICBjbS5vbihcImd1dHRlckNsaWNrXCIsIG9uR3V0dGVyQ2xpY2spO1xuICAgICAgICBjbS5vbihcImNoYW5nZXNcIiwgb25DaGFuZ2UpO1xuICAgICAgICBjbS5vbihcInZpZXdwb3J0Q2hhbmdlXCIsIG9uVmlld3BvcnRDaGFuZ2UpO1xuICAgICAgICBjbS5vbihcImZvbGRcIiwgb25Gb2xkKTtcbiAgICAgICAgY20ub24oXCJ1bmZvbGRcIiwgb25Gb2xkKTtcbiAgICAgICAgY20ub24oXCJzd2FwRG9jXCIsIG9uQ2hhbmdlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgUG9zID0gQ29kZU1pcnJvci5Qb3M7XG4gICAgZnVuY3Rpb24gU3RhdGUob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIHRoaXMuZnJvbSA9IHRoaXMudG8gPSAwO1xuICAgIH1cbiAgICBfX25hbWUoU3RhdGUsIFwiU3RhdGVcIik7XG4gICAgZnVuY3Rpb24gcGFyc2VPcHRpb25zKG9wdHMpIHtcbiAgICAgIGlmIChvcHRzID09PSB0cnVlKVxuICAgICAgICBvcHRzID0ge307XG4gICAgICBpZiAob3B0cy5ndXR0ZXIgPT0gbnVsbClcbiAgICAgICAgb3B0cy5ndXR0ZXIgPSBcIkNvZGVNaXJyb3ItZm9sZGd1dHRlclwiO1xuICAgICAgaWYgKG9wdHMuaW5kaWNhdG9yT3BlbiA9PSBudWxsKVxuICAgICAgICBvcHRzLmluZGljYXRvck9wZW4gPSBcIkNvZGVNaXJyb3ItZm9sZGd1dHRlci1vcGVuXCI7XG4gICAgICBpZiAob3B0cy5pbmRpY2F0b3JGb2xkZWQgPT0gbnVsbClcbiAgICAgICAgb3B0cy5pbmRpY2F0b3JGb2xkZWQgPSBcIkNvZGVNaXJyb3ItZm9sZGd1dHRlci1mb2xkZWRcIjtcbiAgICAgIHJldHVybiBvcHRzO1xuICAgIH1cbiAgICBfX25hbWUocGFyc2VPcHRpb25zLCBcInBhcnNlT3B0aW9uc1wiKTtcbiAgICBmdW5jdGlvbiBpc0ZvbGRlZChjbSwgbGluZSkge1xuICAgICAgdmFyIG1hcmtzID0gY20uZmluZE1hcmtzKFBvcyhsaW5lLCAwKSwgUG9zKGxpbmUgKyAxLCAwKSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChtYXJrc1tpXS5fX2lzRm9sZCkge1xuICAgICAgICAgIHZhciBmcm9tUG9zID0gbWFya3NbaV0uZmluZCgtMSk7XG4gICAgICAgICAgaWYgKGZyb21Qb3MgJiYgZnJvbVBvcy5saW5lID09PSBsaW5lKVxuICAgICAgICAgICAgcmV0dXJuIG1hcmtzW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShpc0ZvbGRlZCwgXCJpc0ZvbGRlZFwiKTtcbiAgICBmdW5jdGlvbiBtYXJrZXIoc3BlYykge1xuICAgICAgaWYgKHR5cGVvZiBzcGVjID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFyIGVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGVsdC5jbGFzc05hbWUgPSBzcGVjICsgXCIgQ29kZU1pcnJvci1ndXR0ZXJtYXJrZXItc3VidGxlXCI7XG4gICAgICAgIHJldHVybiBlbHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc3BlYy5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShtYXJrZXIsIFwibWFya2VyXCIpO1xuICAgIGZ1bmN0aW9uIHVwZGF0ZUZvbGRJbmZvKGNtLCBmcm9tLCB0bykge1xuICAgICAgdmFyIG9wdHMgPSBjbS5zdGF0ZS5mb2xkR3V0dGVyLm9wdGlvbnMsIGN1ciA9IGZyb20gLSAxO1xuICAgICAgdmFyIG1pblNpemUgPSBjbS5mb2xkT3B0aW9uKG9wdHMsIFwibWluRm9sZFNpemVcIik7XG4gICAgICB2YXIgZnVuYyA9IGNtLmZvbGRPcHRpb24ob3B0cywgXCJyYW5nZUZpbmRlclwiKTtcbiAgICAgIHZhciBjbHNGb2xkZWQgPSB0eXBlb2Ygb3B0cy5pbmRpY2F0b3JGb2xkZWQgPT0gXCJzdHJpbmdcIiAmJiBjbGFzc1Rlc3Qob3B0cy5pbmRpY2F0b3JGb2xkZWQpO1xuICAgICAgdmFyIGNsc09wZW4gPSB0eXBlb2Ygb3B0cy5pbmRpY2F0b3JPcGVuID09IFwic3RyaW5nXCIgJiYgY2xhc3NUZXN0KG9wdHMuaW5kaWNhdG9yT3Blbik7XG4gICAgICBjbS5lYWNoTGluZShmcm9tLCB0bywgZnVuY3Rpb24obGluZSkge1xuICAgICAgICArK2N1cjtcbiAgICAgICAgdmFyIG1hcmsgPSBudWxsO1xuICAgICAgICB2YXIgb2xkID0gbGluZS5ndXR0ZXJNYXJrZXJzO1xuICAgICAgICBpZiAob2xkKVxuICAgICAgICAgIG9sZCA9IG9sZFtvcHRzLmd1dHRlcl07XG4gICAgICAgIGlmIChpc0ZvbGRlZChjbSwgY3VyKSkge1xuICAgICAgICAgIGlmIChjbHNGb2xkZWQgJiYgb2xkICYmIGNsc0ZvbGRlZC50ZXN0KG9sZC5jbGFzc05hbWUpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIG1hcmsgPSBtYXJrZXIob3B0cy5pbmRpY2F0b3JGb2xkZWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwb3MgPSBQb3MoY3VyLCAwKTtcbiAgICAgICAgICB2YXIgcmFuZ2UgPSBmdW5jICYmIGZ1bmMoY20sIHBvcyk7XG4gICAgICAgICAgaWYgKHJhbmdlICYmIHJhbmdlLnRvLmxpbmUgLSByYW5nZS5mcm9tLmxpbmUgPj0gbWluU2l6ZSkge1xuICAgICAgICAgICAgaWYgKGNsc09wZW4gJiYgb2xkICYmIGNsc09wZW4udGVzdChvbGQuY2xhc3NOYW1lKSlcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbWFyayA9IG1hcmtlcihvcHRzLmluZGljYXRvck9wZW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1hcmsgJiYgIW9sZClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNtLnNldEd1dHRlck1hcmtlcihsaW5lLCBvcHRzLmd1dHRlciwgbWFyayk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgX19uYW1lKHVwZGF0ZUZvbGRJbmZvLCBcInVwZGF0ZUZvbGRJbmZvXCIpO1xuICAgIGZ1bmN0aW9uIGNsYXNzVGVzdChjbHMpIHtcbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKFwiKF58XFxcXHMpXCIgKyBjbHMgKyBcIig/OiR8XFxcXHMpXFxcXHMqXCIpO1xuICAgIH1cbiAgICBfX25hbWUoY2xhc3NUZXN0LCBcImNsYXNzVGVzdFwiKTtcbiAgICBmdW5jdGlvbiB1cGRhdGVJblZpZXdwb3J0KGNtKSB7XG4gICAgICB2YXIgdnAgPSBjbS5nZXRWaWV3cG9ydCgpLCBzdGF0ZSA9IGNtLnN0YXRlLmZvbGRHdXR0ZXI7XG4gICAgICBpZiAoIXN0YXRlKVxuICAgICAgICByZXR1cm47XG4gICAgICBjbS5vcGVyYXRpb24oZnVuY3Rpb24oKSB7XG4gICAgICAgIHVwZGF0ZUZvbGRJbmZvKGNtLCB2cC5mcm9tLCB2cC50byk7XG4gICAgICB9KTtcbiAgICAgIHN0YXRlLmZyb20gPSB2cC5mcm9tO1xuICAgICAgc3RhdGUudG8gPSB2cC50bztcbiAgICB9XG4gICAgX19uYW1lKHVwZGF0ZUluVmlld3BvcnQsIFwidXBkYXRlSW5WaWV3cG9ydFwiKTtcbiAgICBmdW5jdGlvbiBvbkd1dHRlckNsaWNrKGNtLCBsaW5lLCBndXR0ZXIpIHtcbiAgICAgIHZhciBzdGF0ZSA9IGNtLnN0YXRlLmZvbGRHdXR0ZXI7XG4gICAgICBpZiAoIXN0YXRlKVxuICAgICAgICByZXR1cm47XG4gICAgICB2YXIgb3B0cyA9IHN0YXRlLm9wdGlvbnM7XG4gICAgICBpZiAoZ3V0dGVyICE9IG9wdHMuZ3V0dGVyKVxuICAgICAgICByZXR1cm47XG4gICAgICB2YXIgZm9sZGVkID0gaXNGb2xkZWQoY20sIGxpbmUpO1xuICAgICAgaWYgKGZvbGRlZClcbiAgICAgICAgZm9sZGVkLmNsZWFyKCk7XG4gICAgICBlbHNlXG4gICAgICAgIGNtLmZvbGRDb2RlKFBvcyhsaW5lLCAwKSwgb3B0cyk7XG4gICAgfVxuICAgIF9fbmFtZShvbkd1dHRlckNsaWNrLCBcIm9uR3V0dGVyQ2xpY2tcIik7XG4gICAgZnVuY3Rpb24gb25DaGFuZ2UoY20pIHtcbiAgICAgIHZhciBzdGF0ZSA9IGNtLnN0YXRlLmZvbGRHdXR0ZXI7XG4gICAgICBpZiAoIXN0YXRlKVxuICAgICAgICByZXR1cm47XG4gICAgICB2YXIgb3B0cyA9IHN0YXRlLm9wdGlvbnM7XG4gICAgICBzdGF0ZS5mcm9tID0gc3RhdGUudG8gPSAwO1xuICAgICAgY2xlYXJUaW1lb3V0KHN0YXRlLmNoYW5nZVVwZGF0ZSk7XG4gICAgICBzdGF0ZS5jaGFuZ2VVcGRhdGUgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICB1cGRhdGVJblZpZXdwb3J0KGNtKTtcbiAgICAgIH0sIG9wdHMuZm9sZE9uQ2hhbmdlVGltZVNwYW4gfHwgNjAwKTtcbiAgICB9XG4gICAgX19uYW1lKG9uQ2hhbmdlLCBcIm9uQ2hhbmdlXCIpO1xuICAgIGZ1bmN0aW9uIG9uVmlld3BvcnRDaGFuZ2UoY20pIHtcbiAgICAgIHZhciBzdGF0ZSA9IGNtLnN0YXRlLmZvbGRHdXR0ZXI7XG4gICAgICBpZiAoIXN0YXRlKVxuICAgICAgICByZXR1cm47XG4gICAgICB2YXIgb3B0cyA9IHN0YXRlLm9wdGlvbnM7XG4gICAgICBjbGVhclRpbWVvdXQoc3RhdGUuY2hhbmdlVXBkYXRlKTtcbiAgICAgIHN0YXRlLmNoYW5nZVVwZGF0ZSA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2cCA9IGNtLmdldFZpZXdwb3J0KCk7XG4gICAgICAgIGlmIChzdGF0ZS5mcm9tID09IHN0YXRlLnRvIHx8IHZwLmZyb20gLSBzdGF0ZS50byA+IDIwIHx8IHN0YXRlLmZyb20gLSB2cC50byA+IDIwKSB7XG4gICAgICAgICAgdXBkYXRlSW5WaWV3cG9ydChjbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY20ub3BlcmF0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHZwLmZyb20gPCBzdGF0ZS5mcm9tKSB7XG4gICAgICAgICAgICAgIHVwZGF0ZUZvbGRJbmZvKGNtLCB2cC5mcm9tLCBzdGF0ZS5mcm9tKTtcbiAgICAgICAgICAgICAgc3RhdGUuZnJvbSA9IHZwLmZyb207XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodnAudG8gPiBzdGF0ZS50bykge1xuICAgICAgICAgICAgICB1cGRhdGVGb2xkSW5mbyhjbSwgc3RhdGUudG8sIHZwLnRvKTtcbiAgICAgICAgICAgICAgc3RhdGUudG8gPSB2cC50bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSwgb3B0cy51cGRhdGVWaWV3cG9ydFRpbWVTcGFuIHx8IDQwMCk7XG4gICAgfVxuICAgIF9fbmFtZShvblZpZXdwb3J0Q2hhbmdlLCBcIm9uVmlld3BvcnRDaGFuZ2VcIik7XG4gICAgZnVuY3Rpb24gb25Gb2xkKGNtLCBmcm9tKSB7XG4gICAgICB2YXIgc3RhdGUgPSBjbS5zdGF0ZS5mb2xkR3V0dGVyO1xuICAgICAgaWYgKCFzdGF0ZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdmFyIGxpbmUgPSBmcm9tLmxpbmU7XG4gICAgICBpZiAobGluZSA+PSBzdGF0ZS5mcm9tICYmIGxpbmUgPCBzdGF0ZS50bylcbiAgICAgICAgdXBkYXRlRm9sZEluZm8oY20sIGxpbmUsIGxpbmUgKyAxKTtcbiAgICB9XG4gICAgX19uYW1lKG9uRm9sZCwgXCJvbkZvbGRcIik7XG4gIH0pO1xufSkoKTtcbnZhciBmb2xkZ3V0dGVyID0gZm9sZGd1dHRlciQyLmV4cG9ydHM7XG52YXIgZm9sZGd1dHRlciQxID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIF9tZXJnZU5hbWVzcGFjZXMoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiBcIk1vZHVsZVwiLFxuICBcImRlZmF1bHRcIjogZm9sZGd1dHRlclxufSwgW2ZvbGRndXR0ZXIkMi5leHBvcnRzXSkpO1xuZXhwb3J0IHsgZm9sZGd1dHRlciQxIGFzIGYgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///55739\n')}}]);