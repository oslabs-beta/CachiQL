"use strict";(self.webpackChunkcachiql_demo=self.webpackChunkcachiql_demo||[]).push([[768],{10768:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "b": () => (/* binding */ braceFold$1)\n/* harmony export */ });\n/* harmony import */ var _codemirror_es_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97480);\nvar __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, "name", { value, configurable: true });\n\nfunction _mergeNamespaces(n, m) {\n  m.forEach(function(e) {\n    e && typeof e !== "string" && !Array.isArray(e) && Object.keys(e).forEach(function(k) {\n      if (k !== "default" && !(k in n)) {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function() {\n            return e[k];\n          }\n        });\n      }\n    });\n  });\n  return Object.freeze(n);\n}\n__name(_mergeNamespaces, "_mergeNamespaces");\nvar braceFold$2 = { exports: {} };\n(function(module, exports) {\n  (function(mod) {\n    mod(_codemirror_es_js__WEBPACK_IMPORTED_MODULE_0__.a.exports);\n  })(function(CodeMirror) {\n    function bracketFolding(pairs) {\n      return function(cm, start) {\n        var line = start.line, lineText = cm.getLine(line);\n        function findOpening(pair) {\n          var tokenType;\n          for (var at = start.ch, pass = 0; ; ) {\n            var found2 = at <= 0 ? -1 : lineText.lastIndexOf(pair[0], at - 1);\n            if (found2 == -1) {\n              if (pass == 1)\n                break;\n              pass = 1;\n              at = lineText.length;\n              continue;\n            }\n            if (pass == 1 && found2 < start.ch)\n              break;\n            tokenType = cm.getTokenTypeAt(CodeMirror.Pos(line, found2 + 1));\n            if (!/^(comment|string)/.test(tokenType))\n              return { ch: found2 + 1, tokenType, pair };\n            at = found2 - 1;\n          }\n        }\n        __name(findOpening, "findOpening");\n        function findRange(found2) {\n          var count = 1, lastLine = cm.lastLine(), end, startCh = found2.ch, endCh;\n          outer:\n            for (var i2 = line; i2 <= lastLine; ++i2) {\n              var text = cm.getLine(i2), pos = i2 == line ? startCh : 0;\n              for (; ; ) {\n                var nextOpen = text.indexOf(found2.pair[0], pos), nextClose = text.indexOf(found2.pair[1], pos);\n                if (nextOpen < 0)\n                  nextOpen = text.length;\n                if (nextClose < 0)\n                  nextClose = text.length;\n                pos = Math.min(nextOpen, nextClose);\n                if (pos == text.length)\n                  break;\n                if (cm.getTokenTypeAt(CodeMirror.Pos(i2, pos + 1)) == found2.tokenType) {\n                  if (pos == nextOpen)\n                    ++count;\n                  else if (!--count) {\n                    end = i2;\n                    endCh = pos;\n                    break outer;\n                  }\n                }\n                ++pos;\n              }\n            }\n          if (end == null || line == end)\n            return null;\n          return {\n            from: CodeMirror.Pos(line, startCh),\n            to: CodeMirror.Pos(end, endCh)\n          };\n        }\n        __name(findRange, "findRange");\n        var found = [];\n        for (var i = 0; i < pairs.length; i++) {\n          var open = findOpening(pairs[i]);\n          if (open)\n            found.push(open);\n        }\n        found.sort(function(a, b) {\n          return a.ch - b.ch;\n        });\n        for (var i = 0; i < found.length; i++) {\n          var range = findRange(found[i]);\n          if (range)\n            return range;\n        }\n        return null;\n      };\n    }\n    __name(bracketFolding, "bracketFolding");\n    CodeMirror.registerHelper("fold", "brace", bracketFolding([["{", "}"], ["[", "]"]]));\n    CodeMirror.registerHelper("fold", "brace-paren", bracketFolding([["{", "}"], ["[", "]"], ["(", ")"]]));\n    CodeMirror.registerHelper("fold", "import", function(cm, start) {\n      function hasImport(line) {\n        if (line < cm.firstLine() || line > cm.lastLine())\n          return null;\n        var start2 = cm.getTokenAt(CodeMirror.Pos(line, 1));\n        if (!/\\S/.test(start2.string))\n          start2 = cm.getTokenAt(CodeMirror.Pos(line, start2.end + 1));\n        if (start2.type != "keyword" || start2.string != "import")\n          return null;\n        for (var i = line, e = Math.min(cm.lastLine(), line + 10); i <= e; ++i) {\n          var text = cm.getLine(i), semi = text.indexOf(";");\n          if (semi != -1)\n            return { startCh: start2.end, end: CodeMirror.Pos(i, semi) };\n        }\n      }\n      __name(hasImport, "hasImport");\n      var startLine = start.line, has = hasImport(startLine), prev;\n      if (!has || hasImport(startLine - 1) || (prev = hasImport(startLine - 2)) && prev.end.line == startLine - 1)\n        return null;\n      for (var end = has.end; ; ) {\n        var next = hasImport(end.line + 1);\n        if (next == null)\n          break;\n        end = next.end;\n      }\n      return { from: cm.clipPos(CodeMirror.Pos(startLine, has.startCh + 1)), to: end };\n    });\n    CodeMirror.registerHelper("fold", "include", function(cm, start) {\n      function hasInclude(line) {\n        if (line < cm.firstLine() || line > cm.lastLine())\n          return null;\n        var start2 = cm.getTokenAt(CodeMirror.Pos(line, 1));\n        if (!/\\S/.test(start2.string))\n          start2 = cm.getTokenAt(CodeMirror.Pos(line, start2.end + 1));\n        if (start2.type == "meta" && start2.string.slice(0, 8) == "#include")\n          return start2.start + 8;\n      }\n      __name(hasInclude, "hasInclude");\n      var startLine = start.line, has = hasInclude(startLine);\n      if (has == null || hasInclude(startLine - 1) != null)\n        return null;\n      for (var end = startLine; ; ) {\n        var next = hasInclude(end + 1);\n        if (next == null)\n          break;\n        ++end;\n      }\n      return {\n        from: CodeMirror.Pos(startLine, has + 1),\n        to: cm.clipPos(CodeMirror.Pos(end))\n      };\n    });\n  });\n})();\nvar braceFold = braceFold$2.exports;\nvar braceFold$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  [Symbol.toStringTag]: "Module",\n  "default": braceFold\n}, [braceFold$2.exports]));\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA3NjguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBLDREQUE0RCwyQkFBMkI7QUFDbEM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EsUUFBUSx3REFBa0I7QUFDMUIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdCQUFnQjtBQUNoRDtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLEtBQUs7QUFDdkUsd0VBQXdFLEtBQUs7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLFFBQVE7QUFDM0UsMERBQTBEO0FBQzFEO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQzJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2FjaGlxbC1kZW1vLy4vbm9kZV9tb2R1bGVzL0BncmFwaGlxbC9yZWFjdC9kaXN0L2JyYWNlLWZvbGQuZXMuanM/NGNhNCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fbmFtZSA9ICh0YXJnZXQsIHZhbHVlKSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIm5hbWVcIiwgeyB2YWx1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuaW1wb3J0IHsgYSBhcyBjb2RlbWlycm9yIH0gZnJvbSBcIi4vY29kZW1pcnJvci5lcy5qc1wiO1xuZnVuY3Rpb24gX21lcmdlTmFtZXNwYWNlcyhuLCBtKSB7XG4gIG0uZm9yRWFjaChmdW5jdGlvbihlKSB7XG4gICAgZSAmJiB0eXBlb2YgZSAhPT0gXCJzdHJpbmdcIiAmJiAhQXJyYXkuaXNBcnJheShlKSAmJiBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiAhKGsgaW4gbikpIHtcbiAgICAgICAgdmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGspO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgaywgZC5nZXQgPyBkIDoge1xuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBlW2tdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShuKTtcbn1cbl9fbmFtZShfbWVyZ2VOYW1lc3BhY2VzLCBcIl9tZXJnZU5hbWVzcGFjZXNcIik7XG52YXIgYnJhY2VGb2xkJDIgPSB7IGV4cG9ydHM6IHt9IH07XG4oZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG4gIChmdW5jdGlvbihtb2QpIHtcbiAgICBtb2QoY29kZW1pcnJvci5leHBvcnRzKTtcbiAgfSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuICAgIGZ1bmN0aW9uIGJyYWNrZXRGb2xkaW5nKHBhaXJzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY20sIHN0YXJ0KSB7XG4gICAgICAgIHZhciBsaW5lID0gc3RhcnQubGluZSwgbGluZVRleHQgPSBjbS5nZXRMaW5lKGxpbmUpO1xuICAgICAgICBmdW5jdGlvbiBmaW5kT3BlbmluZyhwYWlyKSB7XG4gICAgICAgICAgdmFyIHRva2VuVHlwZTtcbiAgICAgICAgICBmb3IgKHZhciBhdCA9IHN0YXJ0LmNoLCBwYXNzID0gMDsgOyApIHtcbiAgICAgICAgICAgIHZhciBmb3VuZDIgPSBhdCA8PSAwID8gLTEgOiBsaW5lVGV4dC5sYXN0SW5kZXhPZihwYWlyWzBdLCBhdCAtIDEpO1xuICAgICAgICAgICAgaWYgKGZvdW5kMiA9PSAtMSkge1xuICAgICAgICAgICAgICBpZiAocGFzcyA9PSAxKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBwYXNzID0gMTtcbiAgICAgICAgICAgICAgYXQgPSBsaW5lVGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhc3MgPT0gMSAmJiBmb3VuZDIgPCBzdGFydC5jaClcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB0b2tlblR5cGUgPSBjbS5nZXRUb2tlblR5cGVBdChDb2RlTWlycm9yLlBvcyhsaW5lLCBmb3VuZDIgKyAxKSk7XG4gICAgICAgICAgICBpZiAoIS9eKGNvbW1lbnR8c3RyaW5nKS8udGVzdCh0b2tlblR5cGUpKVxuICAgICAgICAgICAgICByZXR1cm4geyBjaDogZm91bmQyICsgMSwgdG9rZW5UeXBlLCBwYWlyIH07XG4gICAgICAgICAgICBhdCA9IGZvdW5kMiAtIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF9fbmFtZShmaW5kT3BlbmluZywgXCJmaW5kT3BlbmluZ1wiKTtcbiAgICAgICAgZnVuY3Rpb24gZmluZFJhbmdlKGZvdW5kMikge1xuICAgICAgICAgIHZhciBjb3VudCA9IDEsIGxhc3RMaW5lID0gY20ubGFzdExpbmUoKSwgZW5kLCBzdGFydENoID0gZm91bmQyLmNoLCBlbmRDaDtcbiAgICAgICAgICBvdXRlcjpcbiAgICAgICAgICAgIGZvciAodmFyIGkyID0gbGluZTsgaTIgPD0gbGFzdExpbmU7ICsraTIpIHtcbiAgICAgICAgICAgICAgdmFyIHRleHQgPSBjbS5nZXRMaW5lKGkyKSwgcG9zID0gaTIgPT0gbGluZSA/IHN0YXJ0Q2ggOiAwO1xuICAgICAgICAgICAgICBmb3IgKDsgOyApIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dE9wZW4gPSB0ZXh0LmluZGV4T2YoZm91bmQyLnBhaXJbMF0sIHBvcyksIG5leHRDbG9zZSA9IHRleHQuaW5kZXhPZihmb3VuZDIucGFpclsxXSwgcG9zKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dE9wZW4gPCAwKVxuICAgICAgICAgICAgICAgICAgbmV4dE9wZW4gPSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobmV4dENsb3NlIDwgMClcbiAgICAgICAgICAgICAgICAgIG5leHRDbG9zZSA9IHRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHBvcyA9IE1hdGgubWluKG5leHRPcGVuLCBuZXh0Q2xvc2UpO1xuICAgICAgICAgICAgICAgIGlmIChwb3MgPT0gdGV4dC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoY20uZ2V0VG9rZW5UeXBlQXQoQ29kZU1pcnJvci5Qb3MoaTIsIHBvcyArIDEpKSA9PSBmb3VuZDIudG9rZW5UeXBlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAocG9zID09IG5leHRPcGVuKVxuICAgICAgICAgICAgICAgICAgICArK2NvdW50O1xuICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIS0tY291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gaTI7XG4gICAgICAgICAgICAgICAgICAgIGVuZENoID0gcG9zO1xuICAgICAgICAgICAgICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKytwb3M7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZW5kID09IG51bGwgfHwgbGluZSA9PSBlbmQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZnJvbTogQ29kZU1pcnJvci5Qb3MobGluZSwgc3RhcnRDaCksXG4gICAgICAgICAgICB0bzogQ29kZU1pcnJvci5Qb3MoZW5kLCBlbmRDaClcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIF9fbmFtZShmaW5kUmFuZ2UsIFwiZmluZFJhbmdlXCIpO1xuICAgICAgICB2YXIgZm91bmQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBvcGVuID0gZmluZE9wZW5pbmcocGFpcnNbaV0pO1xuICAgICAgICAgIGlmIChvcGVuKVxuICAgICAgICAgICAgZm91bmQucHVzaChvcGVuKTtcbiAgICAgICAgfVxuICAgICAgICBmb3VuZC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gYS5jaCAtIGIuY2g7XG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvdW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHJhbmdlID0gZmluZFJhbmdlKGZvdW5kW2ldKTtcbiAgICAgICAgICBpZiAocmFuZ2UpXG4gICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgIH1cbiAgICBfX25hbWUoYnJhY2tldEZvbGRpbmcsIFwiYnJhY2tldEZvbGRpbmdcIik7XG4gICAgQ29kZU1pcnJvci5yZWdpc3RlckhlbHBlcihcImZvbGRcIiwgXCJicmFjZVwiLCBicmFja2V0Rm9sZGluZyhbW1wie1wiLCBcIn1cIl0sIFtcIltcIiwgXCJdXCJdXSkpO1xuICAgIENvZGVNaXJyb3IucmVnaXN0ZXJIZWxwZXIoXCJmb2xkXCIsIFwiYnJhY2UtcGFyZW5cIiwgYnJhY2tldEZvbGRpbmcoW1tcIntcIiwgXCJ9XCJdLCBbXCJbXCIsIFwiXVwiXSwgW1wiKFwiLCBcIilcIl1dKSk7XG4gICAgQ29kZU1pcnJvci5yZWdpc3RlckhlbHBlcihcImZvbGRcIiwgXCJpbXBvcnRcIiwgZnVuY3Rpb24oY20sIHN0YXJ0KSB7XG4gICAgICBmdW5jdGlvbiBoYXNJbXBvcnQobGluZSkge1xuICAgICAgICBpZiAobGluZSA8IGNtLmZpcnN0TGluZSgpIHx8IGxpbmUgPiBjbS5sYXN0TGluZSgpKVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgc3RhcnQyID0gY20uZ2V0VG9rZW5BdChDb2RlTWlycm9yLlBvcyhsaW5lLCAxKSk7XG4gICAgICAgIGlmICghL1xcUy8udGVzdChzdGFydDIuc3RyaW5nKSlcbiAgICAgICAgICBzdGFydDIgPSBjbS5nZXRUb2tlbkF0KENvZGVNaXJyb3IuUG9zKGxpbmUsIHN0YXJ0Mi5lbmQgKyAxKSk7XG4gICAgICAgIGlmIChzdGFydDIudHlwZSAhPSBcImtleXdvcmRcIiB8fCBzdGFydDIuc3RyaW5nICE9IFwiaW1wb3J0XCIpXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGZvciAodmFyIGkgPSBsaW5lLCBlID0gTWF0aC5taW4oY20ubGFzdExpbmUoKSwgbGluZSArIDEwKTsgaSA8PSBlOyArK2kpIHtcbiAgICAgICAgICB2YXIgdGV4dCA9IGNtLmdldExpbmUoaSksIHNlbWkgPSB0ZXh0LmluZGV4T2YoXCI7XCIpO1xuICAgICAgICAgIGlmIChzZW1pICE9IC0xKVxuICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnRDaDogc3RhcnQyLmVuZCwgZW5kOiBDb2RlTWlycm9yLlBvcyhpLCBzZW1pKSB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBfX25hbWUoaGFzSW1wb3J0LCBcImhhc0ltcG9ydFwiKTtcbiAgICAgIHZhciBzdGFydExpbmUgPSBzdGFydC5saW5lLCBoYXMgPSBoYXNJbXBvcnQoc3RhcnRMaW5lKSwgcHJldjtcbiAgICAgIGlmICghaGFzIHx8IGhhc0ltcG9ydChzdGFydExpbmUgLSAxKSB8fCAocHJldiA9IGhhc0ltcG9ydChzdGFydExpbmUgLSAyKSkgJiYgcHJldi5lbmQubGluZSA9PSBzdGFydExpbmUgLSAxKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGZvciAodmFyIGVuZCA9IGhhcy5lbmQ7IDsgKSB7XG4gICAgICAgIHZhciBuZXh0ID0gaGFzSW1wb3J0KGVuZC5saW5lICsgMSk7XG4gICAgICAgIGlmIChuZXh0ID09IG51bGwpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGVuZCA9IG5leHQuZW5kO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgZnJvbTogY20uY2xpcFBvcyhDb2RlTWlycm9yLlBvcyhzdGFydExpbmUsIGhhcy5zdGFydENoICsgMSkpLCB0bzogZW5kIH07XG4gICAgfSk7XG4gICAgQ29kZU1pcnJvci5yZWdpc3RlckhlbHBlcihcImZvbGRcIiwgXCJpbmNsdWRlXCIsIGZ1bmN0aW9uKGNtLCBzdGFydCkge1xuICAgICAgZnVuY3Rpb24gaGFzSW5jbHVkZShsaW5lKSB7XG4gICAgICAgIGlmIChsaW5lIDwgY20uZmlyc3RMaW5lKCkgfHwgbGluZSA+IGNtLmxhc3RMaW5lKCkpXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBzdGFydDIgPSBjbS5nZXRUb2tlbkF0KENvZGVNaXJyb3IuUG9zKGxpbmUsIDEpKTtcbiAgICAgICAgaWYgKCEvXFxTLy50ZXN0KHN0YXJ0Mi5zdHJpbmcpKVxuICAgICAgICAgIHN0YXJ0MiA9IGNtLmdldFRva2VuQXQoQ29kZU1pcnJvci5Qb3MobGluZSwgc3RhcnQyLmVuZCArIDEpKTtcbiAgICAgICAgaWYgKHN0YXJ0Mi50eXBlID09IFwibWV0YVwiICYmIHN0YXJ0Mi5zdHJpbmcuc2xpY2UoMCwgOCkgPT0gXCIjaW5jbHVkZVwiKVxuICAgICAgICAgIHJldHVybiBzdGFydDIuc3RhcnQgKyA4O1xuICAgICAgfVxuICAgICAgX19uYW1lKGhhc0luY2x1ZGUsIFwiaGFzSW5jbHVkZVwiKTtcbiAgICAgIHZhciBzdGFydExpbmUgPSBzdGFydC5saW5lLCBoYXMgPSBoYXNJbmNsdWRlKHN0YXJ0TGluZSk7XG4gICAgICBpZiAoaGFzID09IG51bGwgfHwgaGFzSW5jbHVkZShzdGFydExpbmUgLSAxKSAhPSBudWxsKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGZvciAodmFyIGVuZCA9IHN0YXJ0TGluZTsgOyApIHtcbiAgICAgICAgdmFyIG5leHQgPSBoYXNJbmNsdWRlKGVuZCArIDEpO1xuICAgICAgICBpZiAobmV4dCA9PSBudWxsKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICArK2VuZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZyb206IENvZGVNaXJyb3IuUG9zKHN0YXJ0TGluZSwgaGFzICsgMSksXG4gICAgICAgIHRvOiBjbS5jbGlwUG9zKENvZGVNaXJyb3IuUG9zKGVuZCkpXG4gICAgICB9O1xuICAgIH0pO1xuICB9KTtcbn0pKCk7XG52YXIgYnJhY2VGb2xkID0gYnJhY2VGb2xkJDIuZXhwb3J0cztcbnZhciBicmFjZUZvbGQkMSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBfbWVyZ2VOYW1lc3BhY2VzKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBbU3ltYm9sLnRvU3RyaW5nVGFnXTogXCJNb2R1bGVcIixcbiAgXCJkZWZhdWx0XCI6IGJyYWNlRm9sZFxufSwgW2JyYWNlRm9sZCQyLmV4cG9ydHNdKSk7XG5leHBvcnQgeyBicmFjZUZvbGQkMSBhcyBiIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///10768\n')}}]);