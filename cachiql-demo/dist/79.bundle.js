"use strict";(self.webpackChunkcachiql_demo=self.webpackChunkcachiql_demo||[]).push([[79],{26079:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "s": () => (/* binding */ showHint$1)\n/* harmony export */ });\n/* harmony import */ var _codemirror_es_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97480);\nvar __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, "name", { value, configurable: true });\n\nfunction _mergeNamespaces(n, m) {\n  m.forEach(function(e) {\n    e && typeof e !== "string" && !Array.isArray(e) && Object.keys(e).forEach(function(k) {\n      if (k !== "default" && !(k in n)) {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function() {\n            return e[k];\n          }\n        });\n      }\n    });\n  });\n  return Object.freeze(n);\n}\n__name(_mergeNamespaces, "_mergeNamespaces");\nvar showHint$2 = { exports: {} };\n(function(module, exports) {\n  (function(mod) {\n    mod(_codemirror_es_js__WEBPACK_IMPORTED_MODULE_0__.a.exports);\n  })(function(CodeMirror) {\n    var HINT_ELEMENT_CLASS = "CodeMirror-hint";\n    var ACTIVE_HINT_ELEMENT_CLASS = "CodeMirror-hint-active";\n    CodeMirror.showHint = function(cm, getHints, options) {\n      if (!getHints)\n        return cm.showHint(options);\n      if (options && options.async)\n        getHints.async = true;\n      var newOpts = { hint: getHints };\n      if (options)\n        for (var prop in options)\n          newOpts[prop] = options[prop];\n      return cm.showHint(newOpts);\n    };\n    CodeMirror.defineExtension("showHint", function(options) {\n      options = parseOptions(this, this.getCursor("start"), options);\n      var selections = this.listSelections();\n      if (selections.length > 1)\n        return;\n      if (this.somethingSelected()) {\n        if (!options.hint.supportsSelection)\n          return;\n        for (var i = 0; i < selections.length; i++)\n          if (selections[i].head.line != selections[i].anchor.line)\n            return;\n      }\n      if (this.state.completionActive)\n        this.state.completionActive.close();\n      var completion = this.state.completionActive = new Completion(this, options);\n      if (!completion.options.hint)\n        return;\n      CodeMirror.signal(this, "startCompletion", this);\n      completion.update(true);\n    });\n    CodeMirror.defineExtension("closeHint", function() {\n      if (this.state.completionActive)\n        this.state.completionActive.close();\n    });\n    function Completion(cm, options) {\n      this.cm = cm;\n      this.options = options;\n      this.widget = null;\n      this.debounce = 0;\n      this.tick = 0;\n      this.startPos = this.cm.getCursor("start");\n      this.startLen = this.cm.getLine(this.startPos.line).length - this.cm.getSelection().length;\n      if (this.options.updateOnCursorActivity) {\n        var self = this;\n        cm.on("cursorActivity", this.activityFunc = function() {\n          self.cursorActivity();\n        });\n      }\n    }\n    __name(Completion, "Completion");\n    var requestAnimationFrame = window.requestAnimationFrame || function(fn) {\n      return setTimeout(fn, 1e3 / 60);\n    };\n    var cancelAnimationFrame = window.cancelAnimationFrame || clearTimeout;\n    Completion.prototype = {\n      close: function() {\n        if (!this.active())\n          return;\n        this.cm.state.completionActive = null;\n        this.tick = null;\n        if (this.options.updateOnCursorActivity) {\n          this.cm.off("cursorActivity", this.activityFunc);\n        }\n        if (this.widget && this.data)\n          CodeMirror.signal(this.data, "close");\n        if (this.widget)\n          this.widget.close();\n        CodeMirror.signal(this.cm, "endCompletion", this.cm);\n      },\n      active: function() {\n        return this.cm.state.completionActive == this;\n      },\n      pick: function(data, i) {\n        var completion = data.list[i], self = this;\n        this.cm.operation(function() {\n          if (completion.hint)\n            completion.hint(self.cm, data, completion);\n          else\n            self.cm.replaceRange(getText(completion), completion.from || data.from, completion.to || data.to, "complete");\n          CodeMirror.signal(data, "pick", completion);\n          self.cm.scrollIntoView();\n        });\n        if (this.options.closeOnPick) {\n          this.close();\n        }\n      },\n      cursorActivity: function() {\n        if (this.debounce) {\n          cancelAnimationFrame(this.debounce);\n          this.debounce = 0;\n        }\n        var identStart = this.startPos;\n        if (this.data) {\n          identStart = this.data.from;\n        }\n        var pos = this.cm.getCursor(), line = this.cm.getLine(pos.line);\n        if (pos.line != this.startPos.line || line.length - pos.ch != this.startLen - this.startPos.ch || pos.ch < identStart.ch || this.cm.somethingSelected() || (!pos.ch || this.options.closeCharacters.test(line.charAt(pos.ch - 1)))) {\n          this.close();\n        } else {\n          var self = this;\n          this.debounce = requestAnimationFrame(function() {\n            self.update();\n          });\n          if (this.widget)\n            this.widget.disable();\n        }\n      },\n      update: function(first) {\n        if (this.tick == null)\n          return;\n        var self = this, myTick = ++this.tick;\n        fetchHints(this.options.hint, this.cm, this.options, function(data) {\n          if (self.tick == myTick)\n            self.finishUpdate(data, first);\n        });\n      },\n      finishUpdate: function(data, first) {\n        if (this.data)\n          CodeMirror.signal(this.data, "update");\n        var picked = this.widget && this.widget.picked || first && this.options.completeSingle;\n        if (this.widget)\n          this.widget.close();\n        this.data = data;\n        if (data && data.list.length) {\n          if (picked && data.list.length == 1) {\n            this.pick(data, 0);\n          } else {\n            this.widget = new Widget(this, data);\n            CodeMirror.signal(data, "shown");\n          }\n        }\n      }\n    };\n    function parseOptions(cm, pos, options) {\n      var editor = cm.options.hintOptions;\n      var out = {};\n      for (var prop in defaultOptions)\n        out[prop] = defaultOptions[prop];\n      if (editor) {\n        for (var prop in editor)\n          if (editor[prop] !== void 0)\n            out[prop] = editor[prop];\n      }\n      if (options) {\n        for (var prop in options)\n          if (options[prop] !== void 0)\n            out[prop] = options[prop];\n      }\n      if (out.hint.resolve)\n        out.hint = out.hint.resolve(cm, pos);\n      return out;\n    }\n    __name(parseOptions, "parseOptions");\n    function getText(completion) {\n      if (typeof completion == "string")\n        return completion;\n      else\n        return completion.text;\n    }\n    __name(getText, "getText");\n    function buildKeyMap(completion, handle) {\n      var baseMap = {\n        Up: function() {\n          handle.moveFocus(-1);\n        },\n        Down: function() {\n          handle.moveFocus(1);\n        },\n        PageUp: function() {\n          handle.moveFocus(-handle.menuSize() + 1, true);\n        },\n        PageDown: function() {\n          handle.moveFocus(handle.menuSize() - 1, true);\n        },\n        Home: function() {\n          handle.setFocus(0);\n        },\n        End: function() {\n          handle.setFocus(handle.length - 1);\n        },\n        Enter: handle.pick,\n        Tab: handle.pick,\n        Esc: handle.close\n      };\n      var mac = /Mac/.test(navigator.platform);\n      if (mac) {\n        baseMap["Ctrl-P"] = function() {\n          handle.moveFocus(-1);\n        };\n        baseMap["Ctrl-N"] = function() {\n          handle.moveFocus(1);\n        };\n      }\n      var custom = completion.options.customKeys;\n      var ourMap = custom ? {} : baseMap;\n      function addBinding(key2, val) {\n        var bound;\n        if (typeof val != "string")\n          bound = /* @__PURE__ */ __name(function(cm) {\n            return val(cm, handle);\n          }, "bound");\n        else if (baseMap.hasOwnProperty(val))\n          bound = baseMap[val];\n        else\n          bound = val;\n        ourMap[key2] = bound;\n      }\n      __name(addBinding, "addBinding");\n      if (custom) {\n        for (var key in custom)\n          if (custom.hasOwnProperty(key))\n            addBinding(key, custom[key]);\n      }\n      var extra = completion.options.extraKeys;\n      if (extra) {\n        for (var key in extra)\n          if (extra.hasOwnProperty(key))\n            addBinding(key, extra[key]);\n      }\n      return ourMap;\n    }\n    __name(buildKeyMap, "buildKeyMap");\n    function getHintElement(hintsElement, el) {\n      while (el && el != hintsElement) {\n        if (el.nodeName.toUpperCase() === "LI" && el.parentNode == hintsElement)\n          return el;\n        el = el.parentNode;\n      }\n    }\n    __name(getHintElement, "getHintElement");\n    function Widget(completion, data) {\n      this.id = "cm-complete-" + Math.floor(Math.random(1e6));\n      this.completion = completion;\n      this.data = data;\n      this.picked = false;\n      var widget = this, cm = completion.cm;\n      var ownerDocument = cm.getInputField().ownerDocument;\n      var parentWindow = ownerDocument.defaultView || ownerDocument.parentWindow;\n      var hints = this.hints = ownerDocument.createElement("ul");\n      hints.setAttribute("role", "listbox");\n      hints.setAttribute("aria-expanded", "true");\n      hints.id = this.id;\n      var theme = completion.cm.options.theme;\n      hints.className = "CodeMirror-hints " + theme;\n      this.selectedHint = data.selectedHint || 0;\n      var completions = data.list;\n      for (var i = 0; i < completions.length; ++i) {\n        var elt = hints.appendChild(ownerDocument.createElement("li")), cur = completions[i];\n        var className = HINT_ELEMENT_CLASS + (i != this.selectedHint ? "" : " " + ACTIVE_HINT_ELEMENT_CLASS);\n        if (cur.className != null)\n          className = cur.className + " " + className;\n        elt.className = className;\n        if (i == this.selectedHint)\n          elt.setAttribute("aria-selected", "true");\n        elt.id = this.id + "-" + i;\n        elt.setAttribute("role", "option");\n        if (cur.render)\n          cur.render(elt, data, cur);\n        else\n          elt.appendChild(ownerDocument.createTextNode(cur.displayText || getText(cur)));\n        elt.hintId = i;\n      }\n      var container = completion.options.container || ownerDocument.body;\n      var pos = cm.cursorCoords(completion.options.alignWithWord ? data.from : null);\n      var left = pos.left, top = pos.bottom, below = true;\n      var offsetLeft = 0, offsetTop = 0;\n      if (container !== ownerDocument.body) {\n        var isContainerPositioned = ["absolute", "relative", "fixed"].indexOf(parentWindow.getComputedStyle(container).position) !== -1;\n        var offsetParent = isContainerPositioned ? container : container.offsetParent;\n        var offsetParentPosition = offsetParent.getBoundingClientRect();\n        var bodyPosition = ownerDocument.body.getBoundingClientRect();\n        offsetLeft = offsetParentPosition.left - bodyPosition.left - offsetParent.scrollLeft;\n        offsetTop = offsetParentPosition.top - bodyPosition.top - offsetParent.scrollTop;\n      }\n      hints.style.left = left - offsetLeft + "px";\n      hints.style.top = top - offsetTop + "px";\n      var winW = parentWindow.innerWidth || Math.max(ownerDocument.body.offsetWidth, ownerDocument.documentElement.offsetWidth);\n      var winH = parentWindow.innerHeight || Math.max(ownerDocument.body.offsetHeight, ownerDocument.documentElement.offsetHeight);\n      container.appendChild(hints);\n      cm.getInputField().setAttribute("aria-autocomplete", "list");\n      cm.getInputField().setAttribute("aria-owns", this.id);\n      cm.getInputField().setAttribute("aria-activedescendant", this.id + "-" + this.selectedHint);\n      var box = completion.options.moveOnOverlap ? hints.getBoundingClientRect() : new DOMRect();\n      var scrolls = completion.options.paddingForScrollbar ? hints.scrollHeight > hints.clientHeight + 1 : false;\n      var startScroll;\n      setTimeout(function() {\n        startScroll = cm.getScrollInfo();\n      });\n      var overlapY = box.bottom - winH;\n      if (overlapY > 0) {\n        var height = box.bottom - box.top, curTop = pos.top - (pos.bottom - box.top);\n        if (curTop - height > 0) {\n          hints.style.top = (top = pos.top - height - offsetTop) + "px";\n          below = false;\n        } else if (height > winH) {\n          hints.style.height = winH - 5 + "px";\n          hints.style.top = (top = pos.bottom - box.top - offsetTop) + "px";\n          var cursor = cm.getCursor();\n          if (data.from.ch != cursor.ch) {\n            pos = cm.cursorCoords(cursor);\n            hints.style.left = (left = pos.left - offsetLeft) + "px";\n            box = hints.getBoundingClientRect();\n          }\n        }\n      }\n      var overlapX = box.right - winW;\n      if (scrolls)\n        overlapX += cm.display.nativeBarWidth;\n      if (overlapX > 0) {\n        if (box.right - box.left > winW) {\n          hints.style.width = winW - 5 + "px";\n          overlapX -= box.right - box.left - winW;\n        }\n        hints.style.left = (left = pos.left - overlapX - offsetLeft) + "px";\n      }\n      if (scrolls)\n        for (var node = hints.firstChild; node; node = node.nextSibling)\n          node.style.paddingRight = cm.display.nativeBarWidth + "px";\n      cm.addKeyMap(this.keyMap = buildKeyMap(completion, {\n        moveFocus: function(n, avoidWrap) {\n          widget.changeActive(widget.selectedHint + n, avoidWrap);\n        },\n        setFocus: function(n) {\n          widget.changeActive(n);\n        },\n        menuSize: function() {\n          return widget.screenAmount();\n        },\n        length: completions.length,\n        close: function() {\n          completion.close();\n        },\n        pick: function() {\n          widget.pick();\n        },\n        data\n      }));\n      if (completion.options.closeOnUnfocus) {\n        var closingOnBlur;\n        cm.on("blur", this.onBlur = function() {\n          closingOnBlur = setTimeout(function() {\n            completion.close();\n          }, 100);\n        });\n        cm.on("focus", this.onFocus = function() {\n          clearTimeout(closingOnBlur);\n        });\n      }\n      cm.on("scroll", this.onScroll = function() {\n        var curScroll = cm.getScrollInfo(), editor = cm.getWrapperElement().getBoundingClientRect();\n        if (!startScroll)\n          startScroll = cm.getScrollInfo();\n        var newTop = top + startScroll.top - curScroll.top;\n        var point = newTop - (parentWindow.pageYOffset || (ownerDocument.documentElement || ownerDocument.body).scrollTop);\n        if (!below)\n          point += hints.offsetHeight;\n        if (point <= editor.top || point >= editor.bottom)\n          return completion.close();\n        hints.style.top = newTop + "px";\n        hints.style.left = left + startScroll.left - curScroll.left + "px";\n      });\n      CodeMirror.on(hints, "dblclick", function(e) {\n        var t = getHintElement(hints, e.target || e.srcElement);\n        if (t && t.hintId != null) {\n          widget.changeActive(t.hintId);\n          widget.pick();\n        }\n      });\n      CodeMirror.on(hints, "click", function(e) {\n        var t = getHintElement(hints, e.target || e.srcElement);\n        if (t && t.hintId != null) {\n          widget.changeActive(t.hintId);\n          if (completion.options.completeOnSingleClick)\n            widget.pick();\n        }\n      });\n      CodeMirror.on(hints, "mousedown", function() {\n        setTimeout(function() {\n          cm.focus();\n        }, 20);\n      });\n      var selectedHintRange = this.getSelectedHintRange();\n      if (selectedHintRange.from !== 0 || selectedHintRange.to !== 0) {\n        this.scrollToActive();\n      }\n      CodeMirror.signal(data, "select", completions[this.selectedHint], hints.childNodes[this.selectedHint]);\n      return true;\n    }\n    __name(Widget, "Widget");\n    Widget.prototype = {\n      close: function() {\n        if (this.completion.widget != this)\n          return;\n        this.completion.widget = null;\n        if (this.hints.parentNode)\n          this.hints.parentNode.removeChild(this.hints);\n        this.completion.cm.removeKeyMap(this.keyMap);\n        var input = this.completion.cm.getInputField();\n        input.removeAttribute("aria-activedescendant");\n        input.removeAttribute("aria-owns");\n        var cm = this.completion.cm;\n        if (this.completion.options.closeOnUnfocus) {\n          cm.off("blur", this.onBlur);\n          cm.off("focus", this.onFocus);\n        }\n        cm.off("scroll", this.onScroll);\n      },\n      disable: function() {\n        this.completion.cm.removeKeyMap(this.keyMap);\n        var widget = this;\n        this.keyMap = { Enter: function() {\n          widget.picked = true;\n        } };\n        this.completion.cm.addKeyMap(this.keyMap);\n      },\n      pick: function() {\n        this.completion.pick(this.data, this.selectedHint);\n      },\n      changeActive: function(i, avoidWrap) {\n        if (i >= this.data.list.length)\n          i = avoidWrap ? this.data.list.length - 1 : 0;\n        else if (i < 0)\n          i = avoidWrap ? 0 : this.data.list.length - 1;\n        if (this.selectedHint == i)\n          return;\n        var node = this.hints.childNodes[this.selectedHint];\n        if (node) {\n          node.className = node.className.replace(" " + ACTIVE_HINT_ELEMENT_CLASS, "");\n          node.removeAttribute("aria-selected");\n        }\n        node = this.hints.childNodes[this.selectedHint = i];\n        node.className += " " + ACTIVE_HINT_ELEMENT_CLASS;\n        node.setAttribute("aria-selected", "true");\n        this.completion.cm.getInputField().setAttribute("aria-activedescendant", node.id);\n        this.scrollToActive();\n        CodeMirror.signal(this.data, "select", this.data.list[this.selectedHint], node);\n      },\n      scrollToActive: function() {\n        var selectedHintRange = this.getSelectedHintRange();\n        var node1 = this.hints.childNodes[selectedHintRange.from];\n        var node2 = this.hints.childNodes[selectedHintRange.to];\n        var firstNode = this.hints.firstChild;\n        if (node1.offsetTop < this.hints.scrollTop)\n          this.hints.scrollTop = node1.offsetTop - firstNode.offsetTop;\n        else if (node2.offsetTop + node2.offsetHeight > this.hints.scrollTop + this.hints.clientHeight)\n          this.hints.scrollTop = node2.offsetTop + node2.offsetHeight - this.hints.clientHeight + firstNode.offsetTop;\n      },\n      screenAmount: function() {\n        return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;\n      },\n      getSelectedHintRange: function() {\n        var margin = this.completion.options.scrollMargin || 0;\n        return {\n          from: Math.max(0, this.selectedHint - margin),\n          to: Math.min(this.data.list.length - 1, this.selectedHint + margin)\n        };\n      }\n    };\n    function applicableHelpers(cm, helpers) {\n      if (!cm.somethingSelected())\n        return helpers;\n      var result = [];\n      for (var i = 0; i < helpers.length; i++)\n        if (helpers[i].supportsSelection)\n          result.push(helpers[i]);\n      return result;\n    }\n    __name(applicableHelpers, "applicableHelpers");\n    function fetchHints(hint, cm, options, callback) {\n      if (hint.async) {\n        hint(cm, callback, options);\n      } else {\n        var result = hint(cm, options);\n        if (result && result.then)\n          result.then(callback);\n        else\n          callback(result);\n      }\n    }\n    __name(fetchHints, "fetchHints");\n    function resolveAutoHints(cm, pos) {\n      var helpers = cm.getHelpers(pos, "hint"), words;\n      if (helpers.length) {\n        var resolved = /* @__PURE__ */ __name(function(cm2, callback, options) {\n          var app = applicableHelpers(cm2, helpers);\n          function run(i) {\n            if (i == app.length)\n              return callback(null);\n            fetchHints(app[i], cm2, options, function(result) {\n              if (result && result.list.length > 0)\n                callback(result);\n              else\n                run(i + 1);\n            });\n          }\n          __name(run, "run");\n          run(0);\n        }, "resolved");\n        resolved.async = true;\n        resolved.supportsSelection = true;\n        return resolved;\n      } else if (words = cm.getHelper(cm.getCursor(), "hintWords")) {\n        return function(cm2) {\n          return CodeMirror.hint.fromList(cm2, { words });\n        };\n      } else if (CodeMirror.hint.anyword) {\n        return function(cm2, options) {\n          return CodeMirror.hint.anyword(cm2, options);\n        };\n      } else {\n        return function() {\n        };\n      }\n    }\n    __name(resolveAutoHints, "resolveAutoHints");\n    CodeMirror.registerHelper("hint", "auto", {\n      resolve: resolveAutoHints\n    });\n    CodeMirror.registerHelper("hint", "fromList", function(cm, options) {\n      var cur = cm.getCursor(), token = cm.getTokenAt(cur);\n      var term, from = CodeMirror.Pos(cur.line, token.start), to = cur;\n      if (token.start < cur.ch && /\\w/.test(token.string.charAt(cur.ch - token.start - 1))) {\n        term = token.string.substr(0, cur.ch - token.start);\n      } else {\n        term = "";\n        from = cur;\n      }\n      var found = [];\n      for (var i = 0; i < options.words.length; i++) {\n        var word = options.words[i];\n        if (word.slice(0, term.length) == term)\n          found.push(word);\n      }\n      if (found.length)\n        return { list: found, from, to };\n    });\n    CodeMirror.commands.autocomplete = CodeMirror.showHint;\n    var defaultOptions = {\n      hint: CodeMirror.hint.auto,\n      completeSingle: true,\n      alignWithWord: true,\n      closeCharacters: /[\\s()\\[\\]{};:>,]/,\n      closeOnPick: true,\n      closeOnUnfocus: true,\n      updateOnCursorActivity: true,\n      completeOnSingleClick: true,\n      container: null,\n      customKeys: null,\n      extraKeys: null,\n      paddingForScrollbar: true,\n      moveOnOverlap: true\n    };\n    CodeMirror.defineOption("hintOptions", null);\n  });\n})();\nvar showHint = showHint$2.exports;\nvar showHint$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  [Symbol.toStringTag]: "Module",\n  "default": showHint\n}, [showHint$2.exports]));\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjYwNzkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBLDREQUE0RCwyQkFBMkI7QUFDbEM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsUUFBUSx3REFBa0I7QUFDMUIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdCQUF3QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE1BQU07QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwQkFBMEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUMwQiIsInNvdXJjZXMiOlsid2VicGFjazovL2NhY2hpcWwtZGVtby8uL25vZGVfbW9kdWxlcy9AZ3JhcGhpcWwvcmVhY3QvZGlzdC9zaG93LWhpbnQuZXMuanM/N2FiZCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fbmFtZSA9ICh0YXJnZXQsIHZhbHVlKSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIm5hbWVcIiwgeyB2YWx1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuaW1wb3J0IHsgYSBhcyBjb2RlbWlycm9yIH0gZnJvbSBcIi4vY29kZW1pcnJvci5lcy5qc1wiO1xuZnVuY3Rpb24gX21lcmdlTmFtZXNwYWNlcyhuLCBtKSB7XG4gIG0uZm9yRWFjaChmdW5jdGlvbihlKSB7XG4gICAgZSAmJiB0eXBlb2YgZSAhPT0gXCJzdHJpbmdcIiAmJiAhQXJyYXkuaXNBcnJheShlKSAmJiBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiAhKGsgaW4gbikpIHtcbiAgICAgICAgdmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGspO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgaywgZC5nZXQgPyBkIDoge1xuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBlW2tdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShuKTtcbn1cbl9fbmFtZShfbWVyZ2VOYW1lc3BhY2VzLCBcIl9tZXJnZU5hbWVzcGFjZXNcIik7XG52YXIgc2hvd0hpbnQkMiA9IHsgZXhwb3J0czoge30gfTtcbihmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcbiAgKGZ1bmN0aW9uKG1vZCkge1xuICAgIG1vZChjb2RlbWlycm9yLmV4cG9ydHMpO1xuICB9KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG4gICAgdmFyIEhJTlRfRUxFTUVOVF9DTEFTUyA9IFwiQ29kZU1pcnJvci1oaW50XCI7XG4gICAgdmFyIEFDVElWRV9ISU5UX0VMRU1FTlRfQ0xBU1MgPSBcIkNvZGVNaXJyb3ItaGludC1hY3RpdmVcIjtcbiAgICBDb2RlTWlycm9yLnNob3dIaW50ID0gZnVuY3Rpb24oY20sIGdldEhpbnRzLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIWdldEhpbnRzKVxuICAgICAgICByZXR1cm4gY20uc2hvd0hpbnQob3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFzeW5jKVxuICAgICAgICBnZXRIaW50cy5hc3luYyA9IHRydWU7XG4gICAgICB2YXIgbmV3T3B0cyA9IHsgaGludDogZ2V0SGludHMgfTtcbiAgICAgIGlmIChvcHRpb25zKVxuICAgICAgICBmb3IgKHZhciBwcm9wIGluIG9wdGlvbnMpXG4gICAgICAgICAgbmV3T3B0c1twcm9wXSA9IG9wdGlvbnNbcHJvcF07XG4gICAgICByZXR1cm4gY20uc2hvd0hpbnQobmV3T3B0cyk7XG4gICAgfTtcbiAgICBDb2RlTWlycm9yLmRlZmluZUV4dGVuc2lvbihcInNob3dIaW50XCIsIGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBwYXJzZU9wdGlvbnModGhpcywgdGhpcy5nZXRDdXJzb3IoXCJzdGFydFwiKSwgb3B0aW9ucyk7XG4gICAgICB2YXIgc2VsZWN0aW9ucyA9IHRoaXMubGlzdFNlbGVjdGlvbnMoKTtcbiAgICAgIGlmIChzZWxlY3Rpb25zLmxlbmd0aCA+IDEpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmICh0aGlzLnNvbWV0aGluZ1NlbGVjdGVkKCkpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLmhpbnQuc3VwcG9ydHNTZWxlY3Rpb24pXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdGlvbnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgaWYgKHNlbGVjdGlvbnNbaV0uaGVhZC5saW5lICE9IHNlbGVjdGlvbnNbaV0uYW5jaG9yLmxpbmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdGF0ZS5jb21wbGV0aW9uQWN0aXZlKVxuICAgICAgICB0aGlzLnN0YXRlLmNvbXBsZXRpb25BY3RpdmUuY2xvc2UoKTtcbiAgICAgIHZhciBjb21wbGV0aW9uID0gdGhpcy5zdGF0ZS5jb21wbGV0aW9uQWN0aXZlID0gbmV3IENvbXBsZXRpb24odGhpcywgb3B0aW9ucyk7XG4gICAgICBpZiAoIWNvbXBsZXRpb24ub3B0aW9ucy5oaW50KVxuICAgICAgICByZXR1cm47XG4gICAgICBDb2RlTWlycm9yLnNpZ25hbCh0aGlzLCBcInN0YXJ0Q29tcGxldGlvblwiLCB0aGlzKTtcbiAgICAgIGNvbXBsZXRpb24udXBkYXRlKHRydWUpO1xuICAgIH0pO1xuICAgIENvZGVNaXJyb3IuZGVmaW5lRXh0ZW5zaW9uKFwiY2xvc2VIaW50XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuc3RhdGUuY29tcGxldGlvbkFjdGl2ZSlcbiAgICAgICAgdGhpcy5zdGF0ZS5jb21wbGV0aW9uQWN0aXZlLmNsb3NlKCk7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gQ29tcGxldGlvbihjbSwgb3B0aW9ucykge1xuICAgICAgdGhpcy5jbSA9IGNtO1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIHRoaXMud2lkZ2V0ID0gbnVsbDtcbiAgICAgIHRoaXMuZGVib3VuY2UgPSAwO1xuICAgICAgdGhpcy50aWNrID0gMDtcbiAgICAgIHRoaXMuc3RhcnRQb3MgPSB0aGlzLmNtLmdldEN1cnNvcihcInN0YXJ0XCIpO1xuICAgICAgdGhpcy5zdGFydExlbiA9IHRoaXMuY20uZ2V0TGluZSh0aGlzLnN0YXJ0UG9zLmxpbmUpLmxlbmd0aCAtIHRoaXMuY20uZ2V0U2VsZWN0aW9uKCkubGVuZ3RoO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy51cGRhdGVPbkN1cnNvckFjdGl2aXR5KSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgY20ub24oXCJjdXJzb3JBY3Rpdml0eVwiLCB0aGlzLmFjdGl2aXR5RnVuYyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNlbGYuY3Vyc29yQWN0aXZpdHkoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShDb21wbGV0aW9uLCBcIkNvbXBsZXRpb25cIik7XG4gICAgdmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgZnVuY3Rpb24oZm4pIHtcbiAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZuLCAxZTMgLyA2MCk7XG4gICAgfTtcbiAgICB2YXIgY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgY2xlYXJUaW1lb3V0O1xuICAgIENvbXBsZXRpb24ucHJvdG90eXBlID0ge1xuICAgICAgY2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKCkpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmNtLnN0YXRlLmNvbXBsZXRpb25BY3RpdmUgPSBudWxsO1xuICAgICAgICB0aGlzLnRpY2sgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnVwZGF0ZU9uQ3Vyc29yQWN0aXZpdHkpIHtcbiAgICAgICAgICB0aGlzLmNtLm9mZihcImN1cnNvckFjdGl2aXR5XCIsIHRoaXMuYWN0aXZpdHlGdW5jKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy53aWRnZXQgJiYgdGhpcy5kYXRhKVxuICAgICAgICAgIENvZGVNaXJyb3Iuc2lnbmFsKHRoaXMuZGF0YSwgXCJjbG9zZVwiKTtcbiAgICAgICAgaWYgKHRoaXMud2lkZ2V0KVxuICAgICAgICAgIHRoaXMud2lkZ2V0LmNsb3NlKCk7XG4gICAgICAgIENvZGVNaXJyb3Iuc2lnbmFsKHRoaXMuY20sIFwiZW5kQ29tcGxldGlvblwiLCB0aGlzLmNtKTtcbiAgICAgIH0sXG4gICAgICBhY3RpdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbS5zdGF0ZS5jb21wbGV0aW9uQWN0aXZlID09IHRoaXM7XG4gICAgICB9LFxuICAgICAgcGljazogZnVuY3Rpb24oZGF0YSwgaSkge1xuICAgICAgICB2YXIgY29tcGxldGlvbiA9IGRhdGEubGlzdFtpXSwgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuY20ub3BlcmF0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChjb21wbGV0aW9uLmhpbnQpXG4gICAgICAgICAgICBjb21wbGV0aW9uLmhpbnQoc2VsZi5jbSwgZGF0YSwgY29tcGxldGlvbik7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgc2VsZi5jbS5yZXBsYWNlUmFuZ2UoZ2V0VGV4dChjb21wbGV0aW9uKSwgY29tcGxldGlvbi5mcm9tIHx8IGRhdGEuZnJvbSwgY29tcGxldGlvbi50byB8fCBkYXRhLnRvLCBcImNvbXBsZXRlXCIpO1xuICAgICAgICAgIENvZGVNaXJyb3Iuc2lnbmFsKGRhdGEsIFwicGlja1wiLCBjb21wbGV0aW9uKTtcbiAgICAgICAgICBzZWxmLmNtLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNsb3NlT25QaWNrKSB7XG4gICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY3Vyc29yQWN0aXZpdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5kZWJvdW5jZSkge1xuICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZGVib3VuY2UpO1xuICAgICAgICAgIHRoaXMuZGVib3VuY2UgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpZGVudFN0YXJ0ID0gdGhpcy5zdGFydFBvcztcbiAgICAgICAgaWYgKHRoaXMuZGF0YSkge1xuICAgICAgICAgIGlkZW50U3RhcnQgPSB0aGlzLmRhdGEuZnJvbTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcG9zID0gdGhpcy5jbS5nZXRDdXJzb3IoKSwgbGluZSA9IHRoaXMuY20uZ2V0TGluZShwb3MubGluZSk7XG4gICAgICAgIGlmIChwb3MubGluZSAhPSB0aGlzLnN0YXJ0UG9zLmxpbmUgfHwgbGluZS5sZW5ndGggLSBwb3MuY2ggIT0gdGhpcy5zdGFydExlbiAtIHRoaXMuc3RhcnRQb3MuY2ggfHwgcG9zLmNoIDwgaWRlbnRTdGFydC5jaCB8fCB0aGlzLmNtLnNvbWV0aGluZ1NlbGVjdGVkKCkgfHwgKCFwb3MuY2ggfHwgdGhpcy5vcHRpb25zLmNsb3NlQ2hhcmFjdGVycy50ZXN0KGxpbmUuY2hhckF0KHBvcy5jaCAtIDEpKSkpIHtcbiAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgIHRoaXMuZGVib3VuY2UgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLnVwZGF0ZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICh0aGlzLndpZGdldClcbiAgICAgICAgICAgIHRoaXMud2lkZ2V0LmRpc2FibGUoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVwZGF0ZTogZnVuY3Rpb24oZmlyc3QpIHtcbiAgICAgICAgaWYgKHRoaXMudGljayA9PSBudWxsKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLCBteVRpY2sgPSArK3RoaXMudGljaztcbiAgICAgICAgZmV0Y2hIaW50cyh0aGlzLm9wdGlvbnMuaGludCwgdGhpcy5jbSwgdGhpcy5vcHRpb25zLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgaWYgKHNlbGYudGljayA9PSBteVRpY2spXG4gICAgICAgICAgICBzZWxmLmZpbmlzaFVwZGF0ZShkYXRhLCBmaXJzdCk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGZpbmlzaFVwZGF0ZTogZnVuY3Rpb24oZGF0YSwgZmlyc3QpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YSlcbiAgICAgICAgICBDb2RlTWlycm9yLnNpZ25hbCh0aGlzLmRhdGEsIFwidXBkYXRlXCIpO1xuICAgICAgICB2YXIgcGlja2VkID0gdGhpcy53aWRnZXQgJiYgdGhpcy53aWRnZXQucGlja2VkIHx8IGZpcnN0ICYmIHRoaXMub3B0aW9ucy5jb21wbGV0ZVNpbmdsZTtcbiAgICAgICAgaWYgKHRoaXMud2lkZ2V0KVxuICAgICAgICAgIHRoaXMud2lkZ2V0LmNsb3NlKCk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEubGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAocGlja2VkICYmIGRhdGEubGlzdC5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgdGhpcy5waWNrKGRhdGEsIDApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndpZGdldCA9IG5ldyBXaWRnZXQodGhpcywgZGF0YSk7XG4gICAgICAgICAgICBDb2RlTWlycm9yLnNpZ25hbChkYXRhLCBcInNob3duXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gcGFyc2VPcHRpb25zKGNtLCBwb3MsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBlZGl0b3IgPSBjbS5vcHRpb25zLmhpbnRPcHRpb25zO1xuICAgICAgdmFyIG91dCA9IHt9O1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBkZWZhdWx0T3B0aW9ucylcbiAgICAgICAgb3V0W3Byb3BdID0gZGVmYXVsdE9wdGlvbnNbcHJvcF07XG4gICAgICBpZiAoZWRpdG9yKSB7XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gZWRpdG9yKVxuICAgICAgICAgIGlmIChlZGl0b3JbcHJvcF0gIT09IHZvaWQgMClcbiAgICAgICAgICAgIG91dFtwcm9wXSA9IGVkaXRvcltwcm9wXTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gb3B0aW9ucylcbiAgICAgICAgICBpZiAob3B0aW9uc1twcm9wXSAhPT0gdm9pZCAwKVxuICAgICAgICAgICAgb3V0W3Byb3BdID0gb3B0aW9uc1twcm9wXTtcbiAgICAgIH1cbiAgICAgIGlmIChvdXQuaGludC5yZXNvbHZlKVxuICAgICAgICBvdXQuaGludCA9IG91dC5oaW50LnJlc29sdmUoY20sIHBvcyk7XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBfX25hbWUocGFyc2VPcHRpb25zLCBcInBhcnNlT3B0aW9uc1wiKTtcbiAgICBmdW5jdGlvbiBnZXRUZXh0KGNvbXBsZXRpb24pIHtcbiAgICAgIGlmICh0eXBlb2YgY29tcGxldGlvbiA9PSBcInN0cmluZ1wiKVxuICAgICAgICByZXR1cm4gY29tcGxldGlvbjtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGNvbXBsZXRpb24udGV4dDtcbiAgICB9XG4gICAgX19uYW1lKGdldFRleHQsIFwiZ2V0VGV4dFwiKTtcbiAgICBmdW5jdGlvbiBidWlsZEtleU1hcChjb21wbGV0aW9uLCBoYW5kbGUpIHtcbiAgICAgIHZhciBiYXNlTWFwID0ge1xuICAgICAgICBVcDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaGFuZGxlLm1vdmVGb2N1cygtMSk7XG4gICAgICAgIH0sXG4gICAgICAgIERvd246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGhhbmRsZS5tb3ZlRm9jdXMoMSk7XG4gICAgICAgIH0sXG4gICAgICAgIFBhZ2VVcDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaGFuZGxlLm1vdmVGb2N1cygtaGFuZGxlLm1lbnVTaXplKCkgKyAxLCB0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgUGFnZURvd246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGhhbmRsZS5tb3ZlRm9jdXMoaGFuZGxlLm1lbnVTaXplKCkgLSAxLCB0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgSG9tZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaGFuZGxlLnNldEZvY3VzKDApO1xuICAgICAgICB9LFxuICAgICAgICBFbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGhhbmRsZS5zZXRGb2N1cyhoYW5kbGUubGVuZ3RoIC0gMSk7XG4gICAgICAgIH0sXG4gICAgICAgIEVudGVyOiBoYW5kbGUucGljayxcbiAgICAgICAgVGFiOiBoYW5kbGUucGljayxcbiAgICAgICAgRXNjOiBoYW5kbGUuY2xvc2VcbiAgICAgIH07XG4gICAgICB2YXIgbWFjID0gL01hYy8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xuICAgICAgaWYgKG1hYykge1xuICAgICAgICBiYXNlTWFwW1wiQ3RybC1QXCJdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaGFuZGxlLm1vdmVGb2N1cygtMSk7XG4gICAgICAgIH07XG4gICAgICAgIGJhc2VNYXBbXCJDdHJsLU5cIl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBoYW5kbGUubW92ZUZvY3VzKDEpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdmFyIGN1c3RvbSA9IGNvbXBsZXRpb24ub3B0aW9ucy5jdXN0b21LZXlzO1xuICAgICAgdmFyIG91ck1hcCA9IGN1c3RvbSA/IHt9IDogYmFzZU1hcDtcbiAgICAgIGZ1bmN0aW9uIGFkZEJpbmRpbmcoa2V5MiwgdmFsKSB7XG4gICAgICAgIHZhciBib3VuZDtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICBib3VuZCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24oY20pIHtcbiAgICAgICAgICAgIHJldHVybiB2YWwoY20sIGhhbmRsZSk7XG4gICAgICAgICAgfSwgXCJib3VuZFwiKTtcbiAgICAgICAgZWxzZSBpZiAoYmFzZU1hcC5oYXNPd25Qcm9wZXJ0eSh2YWwpKVxuICAgICAgICAgIGJvdW5kID0gYmFzZU1hcFt2YWxdO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgYm91bmQgPSB2YWw7XG4gICAgICAgIG91ck1hcFtrZXkyXSA9IGJvdW5kO1xuICAgICAgfVxuICAgICAgX19uYW1lKGFkZEJpbmRpbmcsIFwiYWRkQmluZGluZ1wiKTtcbiAgICAgIGlmIChjdXN0b20pIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGN1c3RvbSlcbiAgICAgICAgICBpZiAoY3VzdG9tLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICBhZGRCaW5kaW5nKGtleSwgY3VzdG9tW2tleV0pO1xuICAgICAgfVxuICAgICAgdmFyIGV4dHJhID0gY29tcGxldGlvbi5vcHRpb25zLmV4dHJhS2V5cztcbiAgICAgIGlmIChleHRyYSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZXh0cmEpXG4gICAgICAgICAgaWYgKGV4dHJhLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICBhZGRCaW5kaW5nKGtleSwgZXh0cmFba2V5XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3VyTWFwO1xuICAgIH1cbiAgICBfX25hbWUoYnVpbGRLZXlNYXAsIFwiYnVpbGRLZXlNYXBcIik7XG4gICAgZnVuY3Rpb24gZ2V0SGludEVsZW1lbnQoaGludHNFbGVtZW50LCBlbCkge1xuICAgICAgd2hpbGUgKGVsICYmIGVsICE9IGhpbnRzRWxlbWVudCkge1xuICAgICAgICBpZiAoZWwubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gXCJMSVwiICYmIGVsLnBhcmVudE5vZGUgPT0gaGludHNFbGVtZW50KVxuICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgZWwgPSBlbC5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoZ2V0SGludEVsZW1lbnQsIFwiZ2V0SGludEVsZW1lbnRcIik7XG4gICAgZnVuY3Rpb24gV2lkZ2V0KGNvbXBsZXRpb24sIGRhdGEpIHtcbiAgICAgIHRoaXMuaWQgPSBcImNtLWNvbXBsZXRlLVwiICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgxZTYpKTtcbiAgICAgIHRoaXMuY29tcGxldGlvbiA9IGNvbXBsZXRpb247XG4gICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgdGhpcy5waWNrZWQgPSBmYWxzZTtcbiAgICAgIHZhciB3aWRnZXQgPSB0aGlzLCBjbSA9IGNvbXBsZXRpb24uY207XG4gICAgICB2YXIgb3duZXJEb2N1bWVudCA9IGNtLmdldElucHV0RmllbGQoKS5vd25lckRvY3VtZW50O1xuICAgICAgdmFyIHBhcmVudFdpbmRvdyA9IG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgb3duZXJEb2N1bWVudC5wYXJlbnRXaW5kb3c7XG4gICAgICB2YXIgaGludHMgPSB0aGlzLmhpbnRzID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidWxcIik7XG4gICAgICBoaW50cy5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwibGlzdGJveFwiKTtcbiAgICAgIGhpbnRzLnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgXCJ0cnVlXCIpO1xuICAgICAgaGludHMuaWQgPSB0aGlzLmlkO1xuICAgICAgdmFyIHRoZW1lID0gY29tcGxldGlvbi5jbS5vcHRpb25zLnRoZW1lO1xuICAgICAgaGludHMuY2xhc3NOYW1lID0gXCJDb2RlTWlycm9yLWhpbnRzIFwiICsgdGhlbWU7XG4gICAgICB0aGlzLnNlbGVjdGVkSGludCA9IGRhdGEuc2VsZWN0ZWRIaW50IHx8IDA7XG4gICAgICB2YXIgY29tcGxldGlvbnMgPSBkYXRhLmxpc3Q7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBsZXRpb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBlbHQgPSBoaW50cy5hcHBlbmRDaGlsZChvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaVwiKSksIGN1ciA9IGNvbXBsZXRpb25zW2ldO1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gSElOVF9FTEVNRU5UX0NMQVNTICsgKGkgIT0gdGhpcy5zZWxlY3RlZEhpbnQgPyBcIlwiIDogXCIgXCIgKyBBQ1RJVkVfSElOVF9FTEVNRU5UX0NMQVNTKTtcbiAgICAgICAgaWYgKGN1ci5jbGFzc05hbWUgIT0gbnVsbClcbiAgICAgICAgICBjbGFzc05hbWUgPSBjdXIuY2xhc3NOYW1lICsgXCIgXCIgKyBjbGFzc05hbWU7XG4gICAgICAgIGVsdC5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICAgIGlmIChpID09IHRoaXMuc2VsZWN0ZWRIaW50KVxuICAgICAgICAgIGVsdC5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgZWx0LmlkID0gdGhpcy5pZCArIFwiLVwiICsgaTtcbiAgICAgICAgZWx0LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJvcHRpb25cIik7XG4gICAgICAgIGlmIChjdXIucmVuZGVyKVxuICAgICAgICAgIGN1ci5yZW5kZXIoZWx0LCBkYXRhLCBjdXIpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZWx0LmFwcGVuZENoaWxkKG93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3VyLmRpc3BsYXlUZXh0IHx8IGdldFRleHQoY3VyKSkpO1xuICAgICAgICBlbHQuaGludElkID0gaTtcbiAgICAgIH1cbiAgICAgIHZhciBjb250YWluZXIgPSBjb21wbGV0aW9uLm9wdGlvbnMuY29udGFpbmVyIHx8IG93bmVyRG9jdW1lbnQuYm9keTtcbiAgICAgIHZhciBwb3MgPSBjbS5jdXJzb3JDb29yZHMoY29tcGxldGlvbi5vcHRpb25zLmFsaWduV2l0aFdvcmQgPyBkYXRhLmZyb20gOiBudWxsKTtcbiAgICAgIHZhciBsZWZ0ID0gcG9zLmxlZnQsIHRvcCA9IHBvcy5ib3R0b20sIGJlbG93ID0gdHJ1ZTtcbiAgICAgIHZhciBvZmZzZXRMZWZ0ID0gMCwgb2Zmc2V0VG9wID0gMDtcbiAgICAgIGlmIChjb250YWluZXIgIT09IG93bmVyRG9jdW1lbnQuYm9keSkge1xuICAgICAgICB2YXIgaXNDb250YWluZXJQb3NpdGlvbmVkID0gW1wiYWJzb2x1dGVcIiwgXCJyZWxhdGl2ZVwiLCBcImZpeGVkXCJdLmluZGV4T2YocGFyZW50V2luZG93LmdldENvbXB1dGVkU3R5bGUoY29udGFpbmVyKS5wb3NpdGlvbikgIT09IC0xO1xuICAgICAgICB2YXIgb2Zmc2V0UGFyZW50ID0gaXNDb250YWluZXJQb3NpdGlvbmVkID8gY29udGFpbmVyIDogY29udGFpbmVyLm9mZnNldFBhcmVudDtcbiAgICAgICAgdmFyIG9mZnNldFBhcmVudFBvc2l0aW9uID0gb2Zmc2V0UGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgYm9keVBvc2l0aW9uID0gb3duZXJEb2N1bWVudC5ib2R5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBvZmZzZXRMZWZ0ID0gb2Zmc2V0UGFyZW50UG9zaXRpb24ubGVmdCAtIGJvZHlQb3NpdGlvbi5sZWZ0IC0gb2Zmc2V0UGFyZW50LnNjcm9sbExlZnQ7XG4gICAgICAgIG9mZnNldFRvcCA9IG9mZnNldFBhcmVudFBvc2l0aW9uLnRvcCAtIGJvZHlQb3NpdGlvbi50b3AgLSBvZmZzZXRQYXJlbnQuc2Nyb2xsVG9wO1xuICAgICAgfVxuICAgICAgaGludHMuc3R5bGUubGVmdCA9IGxlZnQgLSBvZmZzZXRMZWZ0ICsgXCJweFwiO1xuICAgICAgaGludHMuc3R5bGUudG9wID0gdG9wIC0gb2Zmc2V0VG9wICsgXCJweFwiO1xuICAgICAgdmFyIHdpblcgPSBwYXJlbnRXaW5kb3cuaW5uZXJXaWR0aCB8fCBNYXRoLm1heChvd25lckRvY3VtZW50LmJvZHkub2Zmc2V0V2lkdGgsIG93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm9mZnNldFdpZHRoKTtcbiAgICAgIHZhciB3aW5IID0gcGFyZW50V2luZG93LmlubmVySGVpZ2h0IHx8IE1hdGgubWF4KG93bmVyRG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQsIG93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm9mZnNldEhlaWdodCk7XG4gICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoaGludHMpO1xuICAgICAgY20uZ2V0SW5wdXRGaWVsZCgpLnNldEF0dHJpYnV0ZShcImFyaWEtYXV0b2NvbXBsZXRlXCIsIFwibGlzdFwiKTtcbiAgICAgIGNtLmdldElucHV0RmllbGQoKS5zZXRBdHRyaWJ1dGUoXCJhcmlhLW93bnNcIiwgdGhpcy5pZCk7XG4gICAgICBjbS5nZXRJbnB1dEZpZWxkKCkuc2V0QXR0cmlidXRlKFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCIsIHRoaXMuaWQgKyBcIi1cIiArIHRoaXMuc2VsZWN0ZWRIaW50KTtcbiAgICAgIHZhciBib3ggPSBjb21wbGV0aW9uLm9wdGlvbnMubW92ZU9uT3ZlcmxhcCA/IGhpbnRzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogbmV3IERPTVJlY3QoKTtcbiAgICAgIHZhciBzY3JvbGxzID0gY29tcGxldGlvbi5vcHRpb25zLnBhZGRpbmdGb3JTY3JvbGxiYXIgPyBoaW50cy5zY3JvbGxIZWlnaHQgPiBoaW50cy5jbGllbnRIZWlnaHQgKyAxIDogZmFsc2U7XG4gICAgICB2YXIgc3RhcnRTY3JvbGw7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBzdGFydFNjcm9sbCA9IGNtLmdldFNjcm9sbEluZm8oKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIG92ZXJsYXBZID0gYm94LmJvdHRvbSAtIHdpbkg7XG4gICAgICBpZiAob3ZlcmxhcFkgPiAwKSB7XG4gICAgICAgIHZhciBoZWlnaHQgPSBib3guYm90dG9tIC0gYm94LnRvcCwgY3VyVG9wID0gcG9zLnRvcCAtIChwb3MuYm90dG9tIC0gYm94LnRvcCk7XG4gICAgICAgIGlmIChjdXJUb3AgLSBoZWlnaHQgPiAwKSB7XG4gICAgICAgICAgaGludHMuc3R5bGUudG9wID0gKHRvcCA9IHBvcy50b3AgLSBoZWlnaHQgLSBvZmZzZXRUb3ApICsgXCJweFwiO1xuICAgICAgICAgIGJlbG93ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoaGVpZ2h0ID4gd2luSCkge1xuICAgICAgICAgIGhpbnRzLnN0eWxlLmhlaWdodCA9IHdpbkggLSA1ICsgXCJweFwiO1xuICAgICAgICAgIGhpbnRzLnN0eWxlLnRvcCA9ICh0b3AgPSBwb3MuYm90dG9tIC0gYm94LnRvcCAtIG9mZnNldFRvcCkgKyBcInB4XCI7XG4gICAgICAgICAgdmFyIGN1cnNvciA9IGNtLmdldEN1cnNvcigpO1xuICAgICAgICAgIGlmIChkYXRhLmZyb20uY2ggIT0gY3Vyc29yLmNoKSB7XG4gICAgICAgICAgICBwb3MgPSBjbS5jdXJzb3JDb29yZHMoY3Vyc29yKTtcbiAgICAgICAgICAgIGhpbnRzLnN0eWxlLmxlZnQgPSAobGVmdCA9IHBvcy5sZWZ0IC0gb2Zmc2V0TGVmdCkgKyBcInB4XCI7XG4gICAgICAgICAgICBib3ggPSBoaW50cy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBvdmVybGFwWCA9IGJveC5yaWdodCAtIHdpblc7XG4gICAgICBpZiAoc2Nyb2xscylcbiAgICAgICAgb3ZlcmxhcFggKz0gY20uZGlzcGxheS5uYXRpdmVCYXJXaWR0aDtcbiAgICAgIGlmIChvdmVybGFwWCA+IDApIHtcbiAgICAgICAgaWYgKGJveC5yaWdodCAtIGJveC5sZWZ0ID4gd2luVykge1xuICAgICAgICAgIGhpbnRzLnN0eWxlLndpZHRoID0gd2luVyAtIDUgKyBcInB4XCI7XG4gICAgICAgICAgb3ZlcmxhcFggLT0gYm94LnJpZ2h0IC0gYm94LmxlZnQgLSB3aW5XO1xuICAgICAgICB9XG4gICAgICAgIGhpbnRzLnN0eWxlLmxlZnQgPSAobGVmdCA9IHBvcy5sZWZ0IC0gb3ZlcmxhcFggLSBvZmZzZXRMZWZ0KSArIFwicHhcIjtcbiAgICAgIH1cbiAgICAgIGlmIChzY3JvbGxzKVxuICAgICAgICBmb3IgKHZhciBub2RlID0gaGludHMuZmlyc3RDaGlsZDsgbm9kZTsgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmcpXG4gICAgICAgICAgbm9kZS5zdHlsZS5wYWRkaW5nUmlnaHQgPSBjbS5kaXNwbGF5Lm5hdGl2ZUJhcldpZHRoICsgXCJweFwiO1xuICAgICAgY20uYWRkS2V5TWFwKHRoaXMua2V5TWFwID0gYnVpbGRLZXlNYXAoY29tcGxldGlvbiwge1xuICAgICAgICBtb3ZlRm9jdXM6IGZ1bmN0aW9uKG4sIGF2b2lkV3JhcCkge1xuICAgICAgICAgIHdpZGdldC5jaGFuZ2VBY3RpdmUod2lkZ2V0LnNlbGVjdGVkSGludCArIG4sIGF2b2lkV3JhcCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldEZvY3VzOiBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgd2lkZ2V0LmNoYW5nZUFjdGl2ZShuKTtcbiAgICAgICAgfSxcbiAgICAgICAgbWVudVNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB3aWRnZXQuc2NyZWVuQW1vdW50KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGxlbmd0aDogY29tcGxldGlvbnMubGVuZ3RoLFxuICAgICAgICBjbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY29tcGxldGlvbi5jbG9zZSgpO1xuICAgICAgICB9LFxuICAgICAgICBwaWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB3aWRnZXQucGljaygpO1xuICAgICAgICB9LFxuICAgICAgICBkYXRhXG4gICAgICB9KSk7XG4gICAgICBpZiAoY29tcGxldGlvbi5vcHRpb25zLmNsb3NlT25VbmZvY3VzKSB7XG4gICAgICAgIHZhciBjbG9zaW5nT25CbHVyO1xuICAgICAgICBjbS5vbihcImJsdXJcIiwgdGhpcy5vbkJsdXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBjbG9zaW5nT25CbHVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNvbXBsZXRpb24uY2xvc2UoKTtcbiAgICAgICAgICB9LCAxMDApO1xuICAgICAgICB9KTtcbiAgICAgICAgY20ub24oXCJmb2N1c1wiLCB0aGlzLm9uRm9jdXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQoY2xvc2luZ09uQmx1cik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY20ub24oXCJzY3JvbGxcIiwgdGhpcy5vblNjcm9sbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY3VyU2Nyb2xsID0gY20uZ2V0U2Nyb2xsSW5mbygpLCBlZGl0b3IgPSBjbS5nZXRXcmFwcGVyRWxlbWVudCgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAoIXN0YXJ0U2Nyb2xsKVxuICAgICAgICAgIHN0YXJ0U2Nyb2xsID0gY20uZ2V0U2Nyb2xsSW5mbygpO1xuICAgICAgICB2YXIgbmV3VG9wID0gdG9wICsgc3RhcnRTY3JvbGwudG9wIC0gY3VyU2Nyb2xsLnRvcDtcbiAgICAgICAgdmFyIHBvaW50ID0gbmV3VG9wIC0gKHBhcmVudFdpbmRvdy5wYWdlWU9mZnNldCB8fCAob3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwgb3duZXJEb2N1bWVudC5ib2R5KS5zY3JvbGxUb3ApO1xuICAgICAgICBpZiAoIWJlbG93KVxuICAgICAgICAgIHBvaW50ICs9IGhpbnRzLm9mZnNldEhlaWdodDtcbiAgICAgICAgaWYgKHBvaW50IDw9IGVkaXRvci50b3AgfHwgcG9pbnQgPj0gZWRpdG9yLmJvdHRvbSlcbiAgICAgICAgICByZXR1cm4gY29tcGxldGlvbi5jbG9zZSgpO1xuICAgICAgICBoaW50cy5zdHlsZS50b3AgPSBuZXdUb3AgKyBcInB4XCI7XG4gICAgICAgIGhpbnRzLnN0eWxlLmxlZnQgPSBsZWZ0ICsgc3RhcnRTY3JvbGwubGVmdCAtIGN1clNjcm9sbC5sZWZ0ICsgXCJweFwiO1xuICAgICAgfSk7XG4gICAgICBDb2RlTWlycm9yLm9uKGhpbnRzLCBcImRibGNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIHQgPSBnZXRIaW50RWxlbWVudChoaW50cywgZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50KTtcbiAgICAgICAgaWYgKHQgJiYgdC5oaW50SWQgIT0gbnVsbCkge1xuICAgICAgICAgIHdpZGdldC5jaGFuZ2VBY3RpdmUodC5oaW50SWQpO1xuICAgICAgICAgIHdpZGdldC5waWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgQ29kZU1pcnJvci5vbihoaW50cywgXCJjbGlja1wiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciB0ID0gZ2V0SGludEVsZW1lbnQoaGludHMsIGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudCk7XG4gICAgICAgIGlmICh0ICYmIHQuaGludElkICE9IG51bGwpIHtcbiAgICAgICAgICB3aWRnZXQuY2hhbmdlQWN0aXZlKHQuaGludElkKTtcbiAgICAgICAgICBpZiAoY29tcGxldGlvbi5vcHRpb25zLmNvbXBsZXRlT25TaW5nbGVDbGljaylcbiAgICAgICAgICAgIHdpZGdldC5waWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgQ29kZU1pcnJvci5vbihoaW50cywgXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY20uZm9jdXMoKTtcbiAgICAgICAgfSwgMjApO1xuICAgICAgfSk7XG4gICAgICB2YXIgc2VsZWN0ZWRIaW50UmFuZ2UgPSB0aGlzLmdldFNlbGVjdGVkSGludFJhbmdlKCk7XG4gICAgICBpZiAoc2VsZWN0ZWRIaW50UmFuZ2UuZnJvbSAhPT0gMCB8fCBzZWxlY3RlZEhpbnRSYW5nZS50byAhPT0gMCkge1xuICAgICAgICB0aGlzLnNjcm9sbFRvQWN0aXZlKCk7XG4gICAgICB9XG4gICAgICBDb2RlTWlycm9yLnNpZ25hbChkYXRhLCBcInNlbGVjdFwiLCBjb21wbGV0aW9uc1t0aGlzLnNlbGVjdGVkSGludF0sIGhpbnRzLmNoaWxkTm9kZXNbdGhpcy5zZWxlY3RlZEhpbnRdKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBfX25hbWUoV2lkZ2V0LCBcIldpZGdldFwiKTtcbiAgICBXaWRnZXQucHJvdG90eXBlID0ge1xuICAgICAgY2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5jb21wbGV0aW9uLndpZGdldCAhPSB0aGlzKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5jb21wbGV0aW9uLndpZGdldCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmhpbnRzLnBhcmVudE5vZGUpXG4gICAgICAgICAgdGhpcy5oaW50cy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuaGludHMpO1xuICAgICAgICB0aGlzLmNvbXBsZXRpb24uY20ucmVtb3ZlS2V5TWFwKHRoaXMua2V5TWFwKTtcbiAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5jb21wbGV0aW9uLmNtLmdldElucHV0RmllbGQoKTtcbiAgICAgICAgaW5wdXQucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCIpO1xuICAgICAgICBpbnB1dC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLW93bnNcIik7XG4gICAgICAgIHZhciBjbSA9IHRoaXMuY29tcGxldGlvbi5jbTtcbiAgICAgICAgaWYgKHRoaXMuY29tcGxldGlvbi5vcHRpb25zLmNsb3NlT25VbmZvY3VzKSB7XG4gICAgICAgICAgY20ub2ZmKFwiYmx1clwiLCB0aGlzLm9uQmx1cik7XG4gICAgICAgICAgY20ub2ZmKFwiZm9jdXNcIiwgdGhpcy5vbkZvY3VzKTtcbiAgICAgICAgfVxuICAgICAgICBjbS5vZmYoXCJzY3JvbGxcIiwgdGhpcy5vblNjcm9sbCk7XG4gICAgICB9LFxuICAgICAgZGlzYWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY29tcGxldGlvbi5jbS5yZW1vdmVLZXlNYXAodGhpcy5rZXlNYXApO1xuICAgICAgICB2YXIgd2lkZ2V0ID0gdGhpcztcbiAgICAgICAgdGhpcy5rZXlNYXAgPSB7IEVudGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB3aWRnZXQucGlja2VkID0gdHJ1ZTtcbiAgICAgICAgfSB9O1xuICAgICAgICB0aGlzLmNvbXBsZXRpb24uY20uYWRkS2V5TWFwKHRoaXMua2V5TWFwKTtcbiAgICAgIH0sXG4gICAgICBwaWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jb21wbGV0aW9uLnBpY2sodGhpcy5kYXRhLCB0aGlzLnNlbGVjdGVkSGludCk7XG4gICAgICB9LFxuICAgICAgY2hhbmdlQWN0aXZlOiBmdW5jdGlvbihpLCBhdm9pZFdyYXApIHtcbiAgICAgICAgaWYgKGkgPj0gdGhpcy5kYXRhLmxpc3QubGVuZ3RoKVxuICAgICAgICAgIGkgPSBhdm9pZFdyYXAgPyB0aGlzLmRhdGEubGlzdC5sZW5ndGggLSAxIDogMDtcbiAgICAgICAgZWxzZSBpZiAoaSA8IDApXG4gICAgICAgICAgaSA9IGF2b2lkV3JhcCA/IDAgOiB0aGlzLmRhdGEubGlzdC5sZW5ndGggLSAxO1xuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZEhpbnQgPT0gaSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5oaW50cy5jaGlsZE5vZGVzW3RoaXMuc2VsZWN0ZWRIaW50XTtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICBub2RlLmNsYXNzTmFtZSA9IG5vZGUuY2xhc3NOYW1lLnJlcGxhY2UoXCIgXCIgKyBBQ1RJVkVfSElOVF9FTEVNRU5UX0NMQVNTLCBcIlwiKTtcbiAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IHRoaXMuaGludHMuY2hpbGROb2Rlc1t0aGlzLnNlbGVjdGVkSGludCA9IGldO1xuICAgICAgICBub2RlLmNsYXNzTmFtZSArPSBcIiBcIiArIEFDVElWRV9ISU5UX0VMRU1FTlRfQ0xBU1M7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCBcInRydWVcIik7XG4gICAgICAgIHRoaXMuY29tcGxldGlvbi5jbS5nZXRJbnB1dEZpZWxkKCkuc2V0QXR0cmlidXRlKFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCIsIG5vZGUuaWQpO1xuICAgICAgICB0aGlzLnNjcm9sbFRvQWN0aXZlKCk7XG4gICAgICAgIENvZGVNaXJyb3Iuc2lnbmFsKHRoaXMuZGF0YSwgXCJzZWxlY3RcIiwgdGhpcy5kYXRhLmxpc3RbdGhpcy5zZWxlY3RlZEhpbnRdLCBub2RlKTtcbiAgICAgIH0sXG4gICAgICBzY3JvbGxUb0FjdGl2ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxlY3RlZEhpbnRSYW5nZSA9IHRoaXMuZ2V0U2VsZWN0ZWRIaW50UmFuZ2UoKTtcbiAgICAgICAgdmFyIG5vZGUxID0gdGhpcy5oaW50cy5jaGlsZE5vZGVzW3NlbGVjdGVkSGludFJhbmdlLmZyb21dO1xuICAgICAgICB2YXIgbm9kZTIgPSB0aGlzLmhpbnRzLmNoaWxkTm9kZXNbc2VsZWN0ZWRIaW50UmFuZ2UudG9dO1xuICAgICAgICB2YXIgZmlyc3ROb2RlID0gdGhpcy5oaW50cy5maXJzdENoaWxkO1xuICAgICAgICBpZiAobm9kZTEub2Zmc2V0VG9wIDwgdGhpcy5oaW50cy5zY3JvbGxUb3ApXG4gICAgICAgICAgdGhpcy5oaW50cy5zY3JvbGxUb3AgPSBub2RlMS5vZmZzZXRUb3AgLSBmaXJzdE5vZGUub2Zmc2V0VG9wO1xuICAgICAgICBlbHNlIGlmIChub2RlMi5vZmZzZXRUb3AgKyBub2RlMi5vZmZzZXRIZWlnaHQgPiB0aGlzLmhpbnRzLnNjcm9sbFRvcCArIHRoaXMuaGludHMuY2xpZW50SGVpZ2h0KVxuICAgICAgICAgIHRoaXMuaGludHMuc2Nyb2xsVG9wID0gbm9kZTIub2Zmc2V0VG9wICsgbm9kZTIub2Zmc2V0SGVpZ2h0IC0gdGhpcy5oaW50cy5jbGllbnRIZWlnaHQgKyBmaXJzdE5vZGUub2Zmc2V0VG9wO1xuICAgICAgfSxcbiAgICAgIHNjcmVlbkFtb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMuaGludHMuY2xpZW50SGVpZ2h0IC8gdGhpcy5oaW50cy5maXJzdENoaWxkLm9mZnNldEhlaWdodCkgfHwgMTtcbiAgICAgIH0sXG4gICAgICBnZXRTZWxlY3RlZEhpbnRSYW5nZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtYXJnaW4gPSB0aGlzLmNvbXBsZXRpb24ub3B0aW9ucy5zY3JvbGxNYXJnaW4gfHwgMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBmcm9tOiBNYXRoLm1heCgwLCB0aGlzLnNlbGVjdGVkSGludCAtIG1hcmdpbiksXG4gICAgICAgICAgdG86IE1hdGgubWluKHRoaXMuZGF0YS5saXN0Lmxlbmd0aCAtIDEsIHRoaXMuc2VsZWN0ZWRIaW50ICsgbWFyZ2luKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gYXBwbGljYWJsZUhlbHBlcnMoY20sIGhlbHBlcnMpIHtcbiAgICAgIGlmICghY20uc29tZXRoaW5nU2VsZWN0ZWQoKSlcbiAgICAgICAgcmV0dXJuIGhlbHBlcnM7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhlbHBlcnMubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmIChoZWxwZXJzW2ldLnN1cHBvcnRzU2VsZWN0aW9uKVxuICAgICAgICAgIHJlc3VsdC5wdXNoKGhlbHBlcnNbaV0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgX19uYW1lKGFwcGxpY2FibGVIZWxwZXJzLCBcImFwcGxpY2FibGVIZWxwZXJzXCIpO1xuICAgIGZ1bmN0aW9uIGZldGNoSGludHMoaGludCwgY20sIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoaGludC5hc3luYykge1xuICAgICAgICBoaW50KGNtLCBjYWxsYmFjaywgb3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gaGludChjbSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LnRoZW4pXG4gICAgICAgICAgcmVzdWx0LnRoZW4oY2FsbGJhY2spO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19uYW1lKGZldGNoSGludHMsIFwiZmV0Y2hIaW50c1wiKTtcbiAgICBmdW5jdGlvbiByZXNvbHZlQXV0b0hpbnRzKGNtLCBwb3MpIHtcbiAgICAgIHZhciBoZWxwZXJzID0gY20uZ2V0SGVscGVycyhwb3MsIFwiaGludFwiKSwgd29yZHM7XG4gICAgICBpZiAoaGVscGVycy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHJlc29sdmVkID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbihjbTIsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICAgICAgdmFyIGFwcCA9IGFwcGxpY2FibGVIZWxwZXJzKGNtMiwgaGVscGVycyk7XG4gICAgICAgICAgZnVuY3Rpb24gcnVuKGkpIHtcbiAgICAgICAgICAgIGlmIChpID09IGFwcC5sZW5ndGgpXG4gICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgIGZldGNoSGludHMoYXBwW2ldLCBjbTIsIG9wdGlvbnMsIGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC5saXN0Lmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJ1bihpICsgMSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX19uYW1lKHJ1biwgXCJydW5cIik7XG4gICAgICAgICAgcnVuKDApO1xuICAgICAgICB9LCBcInJlc29sdmVkXCIpO1xuICAgICAgICByZXNvbHZlZC5hc3luYyA9IHRydWU7XG4gICAgICAgIHJlc29sdmVkLnN1cHBvcnRzU2VsZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVkO1xuICAgICAgfSBlbHNlIGlmICh3b3JkcyA9IGNtLmdldEhlbHBlcihjbS5nZXRDdXJzb3IoKSwgXCJoaW50V29yZHNcIikpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNtMikge1xuICAgICAgICAgIHJldHVybiBDb2RlTWlycm9yLmhpbnQuZnJvbUxpc3QoY20yLCB7IHdvcmRzIH0pO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChDb2RlTWlycm9yLmhpbnQuYW55d29yZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oY20yLCBvcHRpb25zKSB7XG4gICAgICAgICAgcmV0dXJuIENvZGVNaXJyb3IuaGludC5hbnl3b3JkKGNtMiwgb3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShyZXNvbHZlQXV0b0hpbnRzLCBcInJlc29sdmVBdXRvSGludHNcIik7XG4gICAgQ29kZU1pcnJvci5yZWdpc3RlckhlbHBlcihcImhpbnRcIiwgXCJhdXRvXCIsIHtcbiAgICAgIHJlc29sdmU6IHJlc29sdmVBdXRvSGludHNcbiAgICB9KTtcbiAgICBDb2RlTWlycm9yLnJlZ2lzdGVySGVscGVyKFwiaGludFwiLCBcImZyb21MaXN0XCIsIGZ1bmN0aW9uKGNtLCBvcHRpb25zKSB7XG4gICAgICB2YXIgY3VyID0gY20uZ2V0Q3Vyc29yKCksIHRva2VuID0gY20uZ2V0VG9rZW5BdChjdXIpO1xuICAgICAgdmFyIHRlcm0sIGZyb20gPSBDb2RlTWlycm9yLlBvcyhjdXIubGluZSwgdG9rZW4uc3RhcnQpLCB0byA9IGN1cjtcbiAgICAgIGlmICh0b2tlbi5zdGFydCA8IGN1ci5jaCAmJiAvXFx3Ly50ZXN0KHRva2VuLnN0cmluZy5jaGFyQXQoY3VyLmNoIC0gdG9rZW4uc3RhcnQgLSAxKSkpIHtcbiAgICAgICAgdGVybSA9IHRva2VuLnN0cmluZy5zdWJzdHIoMCwgY3VyLmNoIC0gdG9rZW4uc3RhcnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGVybSA9IFwiXCI7XG4gICAgICAgIGZyb20gPSBjdXI7XG4gICAgICB9XG4gICAgICB2YXIgZm91bmQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy53b3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgd29yZCA9IG9wdGlvbnMud29yZHNbaV07XG4gICAgICAgIGlmICh3b3JkLnNsaWNlKDAsIHRlcm0ubGVuZ3RoKSA9PSB0ZXJtKVxuICAgICAgICAgIGZvdW5kLnB1c2god29yZCk7XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQubGVuZ3RoKVxuICAgICAgICByZXR1cm4geyBsaXN0OiBmb3VuZCwgZnJvbSwgdG8gfTtcbiAgICB9KTtcbiAgICBDb2RlTWlycm9yLmNvbW1hbmRzLmF1dG9jb21wbGV0ZSA9IENvZGVNaXJyb3Iuc2hvd0hpbnQ7XG4gICAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgaGludDogQ29kZU1pcnJvci5oaW50LmF1dG8sXG4gICAgICBjb21wbGV0ZVNpbmdsZTogdHJ1ZSxcbiAgICAgIGFsaWduV2l0aFdvcmQ6IHRydWUsXG4gICAgICBjbG9zZUNoYXJhY3RlcnM6IC9bXFxzKClcXFtcXF17fTs6PixdLyxcbiAgICAgIGNsb3NlT25QaWNrOiB0cnVlLFxuICAgICAgY2xvc2VPblVuZm9jdXM6IHRydWUsXG4gICAgICB1cGRhdGVPbkN1cnNvckFjdGl2aXR5OiB0cnVlLFxuICAgICAgY29tcGxldGVPblNpbmdsZUNsaWNrOiB0cnVlLFxuICAgICAgY29udGFpbmVyOiBudWxsLFxuICAgICAgY3VzdG9tS2V5czogbnVsbCxcbiAgICAgIGV4dHJhS2V5czogbnVsbCxcbiAgICAgIHBhZGRpbmdGb3JTY3JvbGxiYXI6IHRydWUsXG4gICAgICBtb3ZlT25PdmVybGFwOiB0cnVlXG4gICAgfTtcbiAgICBDb2RlTWlycm9yLmRlZmluZU9wdGlvbihcImhpbnRPcHRpb25zXCIsIG51bGwpO1xuICB9KTtcbn0pKCk7XG52YXIgc2hvd0hpbnQgPSBzaG93SGludCQyLmV4cG9ydHM7XG52YXIgc2hvd0hpbnQkMSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBfbWVyZ2VOYW1lc3BhY2VzKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBbU3ltYm9sLnRvU3RyaW5nVGFnXTogXCJNb2R1bGVcIixcbiAgXCJkZWZhdWx0XCI6IHNob3dIaW50XG59LCBbc2hvd0hpbnQkMi5leHBvcnRzXSkpO1xuZXhwb3J0IHsgc2hvd0hpbnQkMSBhcyBzIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///26079\n')}}]);