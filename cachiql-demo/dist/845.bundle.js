"use strict";(self.webpackChunkcachiql_demo=self.webpackChunkcachiql_demo||[]).push([[845],{60845:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "c": () => (/* binding */ closebrackets$1)\n/* harmony export */ });\n/* harmony import */ var _codemirror_es_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97480);\nvar __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, "name", { value, configurable: true });\n\nfunction _mergeNamespaces(n, m) {\n  m.forEach(function(e) {\n    e && typeof e !== "string" && !Array.isArray(e) && Object.keys(e).forEach(function(k) {\n      if (k !== "default" && !(k in n)) {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function() {\n            return e[k];\n          }\n        });\n      }\n    });\n  });\n  return Object.freeze(n);\n}\n__name(_mergeNamespaces, "_mergeNamespaces");\nvar closebrackets$2 = { exports: {} };\n(function(module, exports) {\n  (function(mod) {\n    mod(_codemirror_es_js__WEBPACK_IMPORTED_MODULE_0__.a.exports);\n  })(function(CodeMirror) {\n    var defaults = {\n      pairs: `()[]{}\'\'""`,\n      closeBefore: `)]}\'":;>`,\n      triples: "",\n      explode: "[]{}"\n    };\n    var Pos = CodeMirror.Pos;\n    CodeMirror.defineOption("autoCloseBrackets", false, function(cm, val, old) {\n      if (old && old != CodeMirror.Init) {\n        cm.removeKeyMap(keyMap);\n        cm.state.closeBrackets = null;\n      }\n      if (val) {\n        ensureBound(getOption(val, "pairs"));\n        cm.state.closeBrackets = val;\n        cm.addKeyMap(keyMap);\n      }\n    });\n    function getOption(conf, name) {\n      if (name == "pairs" && typeof conf == "string")\n        return conf;\n      if (typeof conf == "object" && conf[name] != null)\n        return conf[name];\n      return defaults[name];\n    }\n    __name(getOption, "getOption");\n    var keyMap = { Backspace: handleBackspace, Enter: handleEnter };\n    function ensureBound(chars) {\n      for (var i = 0; i < chars.length; i++) {\n        var ch = chars.charAt(i), key = "\'" + ch + "\'";\n        if (!keyMap[key])\n          keyMap[key] = handler(ch);\n      }\n    }\n    __name(ensureBound, "ensureBound");\n    ensureBound(defaults.pairs + "`");\n    function handler(ch) {\n      return function(cm) {\n        return handleChar(cm, ch);\n      };\n    }\n    __name(handler, "handler");\n    function getConfig(cm) {\n      var deflt = cm.state.closeBrackets;\n      if (!deflt || deflt.override)\n        return deflt;\n      var mode = cm.getModeAt(cm.getCursor());\n      return mode.closeBrackets || deflt;\n    }\n    __name(getConfig, "getConfig");\n    function handleBackspace(cm) {\n      var conf = getConfig(cm);\n      if (!conf || cm.getOption("disableInput"))\n        return CodeMirror.Pass;\n      var pairs = getOption(conf, "pairs");\n      var ranges = cm.listSelections();\n      for (var i = 0; i < ranges.length; i++) {\n        if (!ranges[i].empty())\n          return CodeMirror.Pass;\n        var around = charsAround(cm, ranges[i].head);\n        if (!around || pairs.indexOf(around) % 2 != 0)\n          return CodeMirror.Pass;\n      }\n      for (var i = ranges.length - 1; i >= 0; i--) {\n        var cur = ranges[i].head;\n        cm.replaceRange("", Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1), "+delete");\n      }\n    }\n    __name(handleBackspace, "handleBackspace");\n    function handleEnter(cm) {\n      var conf = getConfig(cm);\n      var explode = conf && getOption(conf, "explode");\n      if (!explode || cm.getOption("disableInput"))\n        return CodeMirror.Pass;\n      var ranges = cm.listSelections();\n      for (var i = 0; i < ranges.length; i++) {\n        if (!ranges[i].empty())\n          return CodeMirror.Pass;\n        var around = charsAround(cm, ranges[i].head);\n        if (!around || explode.indexOf(around) % 2 != 0)\n          return CodeMirror.Pass;\n      }\n      cm.operation(function() {\n        var linesep = cm.lineSeparator() || "\\n";\n        cm.replaceSelection(linesep + linesep, null);\n        moveSel(cm, -1);\n        ranges = cm.listSelections();\n        for (var i2 = 0; i2 < ranges.length; i2++) {\n          var line = ranges[i2].head.line;\n          cm.indentLine(line, null, true);\n          cm.indentLine(line + 1, null, true);\n        }\n      });\n    }\n    __name(handleEnter, "handleEnter");\n    function moveSel(cm, dir) {\n      var newRanges = [], ranges = cm.listSelections(), primary = 0;\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n        if (range.head == cm.getCursor())\n          primary = i;\n        var pos = range.head.ch || dir > 0 ? { line: range.head.line, ch: range.head.ch + dir } : { line: range.head.line - 1 };\n        newRanges.push({ anchor: pos, head: pos });\n      }\n      cm.setSelections(newRanges, primary);\n    }\n    __name(moveSel, "moveSel");\n    function contractSelection(sel) {\n      var inverted = CodeMirror.cmpPos(sel.anchor, sel.head) > 0;\n      return {\n        anchor: new Pos(sel.anchor.line, sel.anchor.ch + (inverted ? -1 : 1)),\n        head: new Pos(sel.head.line, sel.head.ch + (inverted ? 1 : -1))\n      };\n    }\n    __name(contractSelection, "contractSelection");\n    function handleChar(cm, ch) {\n      var conf = getConfig(cm);\n      if (!conf || cm.getOption("disableInput"))\n        return CodeMirror.Pass;\n      var pairs = getOption(conf, "pairs");\n      var pos = pairs.indexOf(ch);\n      if (pos == -1)\n        return CodeMirror.Pass;\n      var closeBefore = getOption(conf, "closeBefore");\n      var triples = getOption(conf, "triples");\n      var identical = pairs.charAt(pos + 1) == ch;\n      var ranges = cm.listSelections();\n      var opening = pos % 2 == 0;\n      var type;\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i], cur = range.head, curType;\n        var next = cm.getRange(cur, Pos(cur.line, cur.ch + 1));\n        if (opening && !range.empty()) {\n          curType = "surround";\n        } else if ((identical || !opening) && next == ch) {\n          if (identical && stringStartsAfter(cm, cur))\n            curType = "both";\n          else if (triples.indexOf(ch) >= 0 && cm.getRange(cur, Pos(cur.line, cur.ch + 3)) == ch + ch + ch)\n            curType = "skipThree";\n          else\n            curType = "skip";\n        } else if (identical && cur.ch > 1 && triples.indexOf(ch) >= 0 && cm.getRange(Pos(cur.line, cur.ch - 2), cur) == ch + ch) {\n          if (cur.ch > 2 && /\\bstring/.test(cm.getTokenTypeAt(Pos(cur.line, cur.ch - 2))))\n            return CodeMirror.Pass;\n          curType = "addFour";\n        } else if (identical) {\n          var prev = cur.ch == 0 ? " " : cm.getRange(Pos(cur.line, cur.ch - 1), cur);\n          if (!CodeMirror.isWordChar(next) && prev != ch && !CodeMirror.isWordChar(prev))\n            curType = "both";\n          else\n            return CodeMirror.Pass;\n        } else if (opening && (next.length === 0 || /\\s/.test(next) || closeBefore.indexOf(next) > -1)) {\n          curType = "both";\n        } else {\n          return CodeMirror.Pass;\n        }\n        if (!type)\n          type = curType;\n        else if (type != curType)\n          return CodeMirror.Pass;\n      }\n      var left = pos % 2 ? pairs.charAt(pos - 1) : ch;\n      var right = pos % 2 ? ch : pairs.charAt(pos + 1);\n      cm.operation(function() {\n        if (type == "skip") {\n          moveSel(cm, 1);\n        } else if (type == "skipThree") {\n          moveSel(cm, 3);\n        } else if (type == "surround") {\n          var sels = cm.getSelections();\n          for (var i2 = 0; i2 < sels.length; i2++)\n            sels[i2] = left + sels[i2] + right;\n          cm.replaceSelections(sels, "around");\n          sels = cm.listSelections().slice();\n          for (var i2 = 0; i2 < sels.length; i2++)\n            sels[i2] = contractSelection(sels[i2]);\n          cm.setSelections(sels);\n        } else if (type == "both") {\n          cm.replaceSelection(left + right, null);\n          cm.triggerElectric(left + right);\n          moveSel(cm, -1);\n        } else if (type == "addFour") {\n          cm.replaceSelection(left + left + left + left, "before");\n          moveSel(cm, 1);\n        }\n      });\n    }\n    __name(handleChar, "handleChar");\n    function charsAround(cm, pos) {\n      var str = cm.getRange(Pos(pos.line, pos.ch - 1), Pos(pos.line, pos.ch + 1));\n      return str.length == 2 ? str : null;\n    }\n    __name(charsAround, "charsAround");\n    function stringStartsAfter(cm, pos) {\n      var token = cm.getTokenAt(Pos(pos.line, pos.ch + 1));\n      return /\\bstring/.test(token.type) && token.start == pos.ch && (pos.ch == 0 || !/\\bstring/.test(cm.getTokenTypeAt(pos)));\n    }\n    __name(stringStartsAfter, "stringStartsAfter");\n  });\n})();\nvar closebrackets = closebrackets$2.exports;\nvar closebrackets$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  [Symbol.toStringTag]: "Module",\n  "default": closebrackets\n}, [closebrackets$2.exports]));\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjA4NDUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBLDREQUE0RCwyQkFBMkI7QUFDbEM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsUUFBUSx3REFBa0I7QUFDMUIsR0FBRztBQUNIO0FBQ0Esb0JBQW9CO0FBQ3BCLHVCQUF1QixJQUFJO0FBQzNCO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0JBQW9CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsaURBQWlELElBQUk7QUFDcEcseUJBQXlCLHdCQUF3QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQytCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2FjaGlxbC1kZW1vLy4vbm9kZV9tb2R1bGVzL0BncmFwaGlxbC9yZWFjdC9kaXN0L2Nsb3NlYnJhY2tldHMuZXMuanM/ZjE2MSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fbmFtZSA9ICh0YXJnZXQsIHZhbHVlKSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIm5hbWVcIiwgeyB2YWx1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuaW1wb3J0IHsgYSBhcyBjb2RlbWlycm9yIH0gZnJvbSBcIi4vY29kZW1pcnJvci5lcy5qc1wiO1xuZnVuY3Rpb24gX21lcmdlTmFtZXNwYWNlcyhuLCBtKSB7XG4gIG0uZm9yRWFjaChmdW5jdGlvbihlKSB7XG4gICAgZSAmJiB0eXBlb2YgZSAhPT0gXCJzdHJpbmdcIiAmJiAhQXJyYXkuaXNBcnJheShlKSAmJiBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiAhKGsgaW4gbikpIHtcbiAgICAgICAgdmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGspO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgaywgZC5nZXQgPyBkIDoge1xuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBlW2tdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShuKTtcbn1cbl9fbmFtZShfbWVyZ2VOYW1lc3BhY2VzLCBcIl9tZXJnZU5hbWVzcGFjZXNcIik7XG52YXIgY2xvc2VicmFja2V0cyQyID0geyBleHBvcnRzOiB7fSB9O1xuKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuICAoZnVuY3Rpb24obW9kKSB7XG4gICAgbW9kKGNvZGVtaXJyb3IuZXhwb3J0cyk7XG4gIH0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcbiAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICBwYWlyczogYCgpW117fScnXCJcImAsXG4gICAgICBjbG9zZUJlZm9yZTogYCldfSdcIjo7PmAsXG4gICAgICB0cmlwbGVzOiBcIlwiLFxuICAgICAgZXhwbG9kZTogXCJbXXt9XCJcbiAgICB9O1xuICAgIHZhciBQb3MgPSBDb2RlTWlycm9yLlBvcztcbiAgICBDb2RlTWlycm9yLmRlZmluZU9wdGlvbihcImF1dG9DbG9zZUJyYWNrZXRzXCIsIGZhbHNlLCBmdW5jdGlvbihjbSwgdmFsLCBvbGQpIHtcbiAgICAgIGlmIChvbGQgJiYgb2xkICE9IENvZGVNaXJyb3IuSW5pdCkge1xuICAgICAgICBjbS5yZW1vdmVLZXlNYXAoa2V5TWFwKTtcbiAgICAgICAgY20uc3RhdGUuY2xvc2VCcmFja2V0cyA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodmFsKSB7XG4gICAgICAgIGVuc3VyZUJvdW5kKGdldE9wdGlvbih2YWwsIFwicGFpcnNcIikpO1xuICAgICAgICBjbS5zdGF0ZS5jbG9zZUJyYWNrZXRzID0gdmFsO1xuICAgICAgICBjbS5hZGRLZXlNYXAoa2V5TWFwKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmdW5jdGlvbiBnZXRPcHRpb24oY29uZiwgbmFtZSkge1xuICAgICAgaWYgKG5hbWUgPT0gXCJwYWlyc1wiICYmIHR5cGVvZiBjb25mID09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBjb25mO1xuICAgICAgaWYgKHR5cGVvZiBjb25mID09IFwib2JqZWN0XCIgJiYgY29uZltuYW1lXSAhPSBudWxsKVxuICAgICAgICByZXR1cm4gY29uZltuYW1lXTtcbiAgICAgIHJldHVybiBkZWZhdWx0c1tuYW1lXTtcbiAgICB9XG4gICAgX19uYW1lKGdldE9wdGlvbiwgXCJnZXRPcHRpb25cIik7XG4gICAgdmFyIGtleU1hcCA9IHsgQmFja3NwYWNlOiBoYW5kbGVCYWNrc3BhY2UsIEVudGVyOiBoYW5kbGVFbnRlciB9O1xuICAgIGZ1bmN0aW9uIGVuc3VyZUJvdW5kKGNoYXJzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaCA9IGNoYXJzLmNoYXJBdChpKSwga2V5ID0gXCInXCIgKyBjaCArIFwiJ1wiO1xuICAgICAgICBpZiAoIWtleU1hcFtrZXldKVxuICAgICAgICAgIGtleU1hcFtrZXldID0gaGFuZGxlcihjaCk7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShlbnN1cmVCb3VuZCwgXCJlbnN1cmVCb3VuZFwiKTtcbiAgICBlbnN1cmVCb3VuZChkZWZhdWx0cy5wYWlycyArIFwiYFwiKTtcbiAgICBmdW5jdGlvbiBoYW5kbGVyKGNoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY20pIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZUNoYXIoY20sIGNoKTtcbiAgICAgIH07XG4gICAgfVxuICAgIF9fbmFtZShoYW5kbGVyLCBcImhhbmRsZXJcIik7XG4gICAgZnVuY3Rpb24gZ2V0Q29uZmlnKGNtKSB7XG4gICAgICB2YXIgZGVmbHQgPSBjbS5zdGF0ZS5jbG9zZUJyYWNrZXRzO1xuICAgICAgaWYgKCFkZWZsdCB8fCBkZWZsdC5vdmVycmlkZSlcbiAgICAgICAgcmV0dXJuIGRlZmx0O1xuICAgICAgdmFyIG1vZGUgPSBjbS5nZXRNb2RlQXQoY20uZ2V0Q3Vyc29yKCkpO1xuICAgICAgcmV0dXJuIG1vZGUuY2xvc2VCcmFja2V0cyB8fCBkZWZsdDtcbiAgICB9XG4gICAgX19uYW1lKGdldENvbmZpZywgXCJnZXRDb25maWdcIik7XG4gICAgZnVuY3Rpb24gaGFuZGxlQmFja3NwYWNlKGNtKSB7XG4gICAgICB2YXIgY29uZiA9IGdldENvbmZpZyhjbSk7XG4gICAgICBpZiAoIWNvbmYgfHwgY20uZ2V0T3B0aW9uKFwiZGlzYWJsZUlucHV0XCIpKVxuICAgICAgICByZXR1cm4gQ29kZU1pcnJvci5QYXNzO1xuICAgICAgdmFyIHBhaXJzID0gZ2V0T3B0aW9uKGNvbmYsIFwicGFpcnNcIik7XG4gICAgICB2YXIgcmFuZ2VzID0gY20ubGlzdFNlbGVjdGlvbnMoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghcmFuZ2VzW2ldLmVtcHR5KCkpXG4gICAgICAgICAgcmV0dXJuIENvZGVNaXJyb3IuUGFzcztcbiAgICAgICAgdmFyIGFyb3VuZCA9IGNoYXJzQXJvdW5kKGNtLCByYW5nZXNbaV0uaGVhZCk7XG4gICAgICAgIGlmICghYXJvdW5kIHx8IHBhaXJzLmluZGV4T2YoYXJvdW5kKSAlIDIgIT0gMClcbiAgICAgICAgICByZXR1cm4gQ29kZU1pcnJvci5QYXNzO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IHJhbmdlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgY3VyID0gcmFuZ2VzW2ldLmhlYWQ7XG4gICAgICAgIGNtLnJlcGxhY2VSYW5nZShcIlwiLCBQb3MoY3VyLmxpbmUsIGN1ci5jaCAtIDEpLCBQb3MoY3VyLmxpbmUsIGN1ci5jaCArIDEpLCBcIitkZWxldGVcIik7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShoYW5kbGVCYWNrc3BhY2UsIFwiaGFuZGxlQmFja3NwYWNlXCIpO1xuICAgIGZ1bmN0aW9uIGhhbmRsZUVudGVyKGNtKSB7XG4gICAgICB2YXIgY29uZiA9IGdldENvbmZpZyhjbSk7XG4gICAgICB2YXIgZXhwbG9kZSA9IGNvbmYgJiYgZ2V0T3B0aW9uKGNvbmYsIFwiZXhwbG9kZVwiKTtcbiAgICAgIGlmICghZXhwbG9kZSB8fCBjbS5nZXRPcHRpb24oXCJkaXNhYmxlSW5wdXRcIikpXG4gICAgICAgIHJldHVybiBDb2RlTWlycm9yLlBhc3M7XG4gICAgICB2YXIgcmFuZ2VzID0gY20ubGlzdFNlbGVjdGlvbnMoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghcmFuZ2VzW2ldLmVtcHR5KCkpXG4gICAgICAgICAgcmV0dXJuIENvZGVNaXJyb3IuUGFzcztcbiAgICAgICAgdmFyIGFyb3VuZCA9IGNoYXJzQXJvdW5kKGNtLCByYW5nZXNbaV0uaGVhZCk7XG4gICAgICAgIGlmICghYXJvdW5kIHx8IGV4cGxvZGUuaW5kZXhPZihhcm91bmQpICUgMiAhPSAwKVxuICAgICAgICAgIHJldHVybiBDb2RlTWlycm9yLlBhc3M7XG4gICAgICB9XG4gICAgICBjbS5vcGVyYXRpb24oZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBsaW5lc2VwID0gY20ubGluZVNlcGFyYXRvcigpIHx8IFwiXFxuXCI7XG4gICAgICAgIGNtLnJlcGxhY2VTZWxlY3Rpb24obGluZXNlcCArIGxpbmVzZXAsIG51bGwpO1xuICAgICAgICBtb3ZlU2VsKGNtLCAtMSk7XG4gICAgICAgIHJhbmdlcyA9IGNtLmxpc3RTZWxlY3Rpb25zKCk7XG4gICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCByYW5nZXMubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgICAgdmFyIGxpbmUgPSByYW5nZXNbaTJdLmhlYWQubGluZTtcbiAgICAgICAgICBjbS5pbmRlbnRMaW5lKGxpbmUsIG51bGwsIHRydWUpO1xuICAgICAgICAgIGNtLmluZGVudExpbmUobGluZSArIDEsIG51bGwsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgX19uYW1lKGhhbmRsZUVudGVyLCBcImhhbmRsZUVudGVyXCIpO1xuICAgIGZ1bmN0aW9uIG1vdmVTZWwoY20sIGRpcikge1xuICAgICAgdmFyIG5ld1JhbmdlcyA9IFtdLCByYW5nZXMgPSBjbS5saXN0U2VsZWN0aW9ucygpLCBwcmltYXJ5ID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgICAgaWYgKHJhbmdlLmhlYWQgPT0gY20uZ2V0Q3Vyc29yKCkpXG4gICAgICAgICAgcHJpbWFyeSA9IGk7XG4gICAgICAgIHZhciBwb3MgPSByYW5nZS5oZWFkLmNoIHx8IGRpciA+IDAgPyB7IGxpbmU6IHJhbmdlLmhlYWQubGluZSwgY2g6IHJhbmdlLmhlYWQuY2ggKyBkaXIgfSA6IHsgbGluZTogcmFuZ2UuaGVhZC5saW5lIC0gMSB9O1xuICAgICAgICBuZXdSYW5nZXMucHVzaCh7IGFuY2hvcjogcG9zLCBoZWFkOiBwb3MgfSk7XG4gICAgICB9XG4gICAgICBjbS5zZXRTZWxlY3Rpb25zKG5ld1JhbmdlcywgcHJpbWFyeSk7XG4gICAgfVxuICAgIF9fbmFtZShtb3ZlU2VsLCBcIm1vdmVTZWxcIik7XG4gICAgZnVuY3Rpb24gY29udHJhY3RTZWxlY3Rpb24oc2VsKSB7XG4gICAgICB2YXIgaW52ZXJ0ZWQgPSBDb2RlTWlycm9yLmNtcFBvcyhzZWwuYW5jaG9yLCBzZWwuaGVhZCkgPiAwO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYW5jaG9yOiBuZXcgUG9zKHNlbC5hbmNob3IubGluZSwgc2VsLmFuY2hvci5jaCArIChpbnZlcnRlZCA/IC0xIDogMSkpLFxuICAgICAgICBoZWFkOiBuZXcgUG9zKHNlbC5oZWFkLmxpbmUsIHNlbC5oZWFkLmNoICsgKGludmVydGVkID8gMSA6IC0xKSlcbiAgICAgIH07XG4gICAgfVxuICAgIF9fbmFtZShjb250cmFjdFNlbGVjdGlvbiwgXCJjb250cmFjdFNlbGVjdGlvblwiKTtcbiAgICBmdW5jdGlvbiBoYW5kbGVDaGFyKGNtLCBjaCkge1xuICAgICAgdmFyIGNvbmYgPSBnZXRDb25maWcoY20pO1xuICAgICAgaWYgKCFjb25mIHx8IGNtLmdldE9wdGlvbihcImRpc2FibGVJbnB1dFwiKSlcbiAgICAgICAgcmV0dXJuIENvZGVNaXJyb3IuUGFzcztcbiAgICAgIHZhciBwYWlycyA9IGdldE9wdGlvbihjb25mLCBcInBhaXJzXCIpO1xuICAgICAgdmFyIHBvcyA9IHBhaXJzLmluZGV4T2YoY2gpO1xuICAgICAgaWYgKHBvcyA9PSAtMSlcbiAgICAgICAgcmV0dXJuIENvZGVNaXJyb3IuUGFzcztcbiAgICAgIHZhciBjbG9zZUJlZm9yZSA9IGdldE9wdGlvbihjb25mLCBcImNsb3NlQmVmb3JlXCIpO1xuICAgICAgdmFyIHRyaXBsZXMgPSBnZXRPcHRpb24oY29uZiwgXCJ0cmlwbGVzXCIpO1xuICAgICAgdmFyIGlkZW50aWNhbCA9IHBhaXJzLmNoYXJBdChwb3MgKyAxKSA9PSBjaDtcbiAgICAgIHZhciByYW5nZXMgPSBjbS5saXN0U2VsZWN0aW9ucygpO1xuICAgICAgdmFyIG9wZW5pbmcgPSBwb3MgJSAyID09IDA7XG4gICAgICB2YXIgdHlwZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByYW5nZSA9IHJhbmdlc1tpXSwgY3VyID0gcmFuZ2UuaGVhZCwgY3VyVHlwZTtcbiAgICAgICAgdmFyIG5leHQgPSBjbS5nZXRSYW5nZShjdXIsIFBvcyhjdXIubGluZSwgY3VyLmNoICsgMSkpO1xuICAgICAgICBpZiAob3BlbmluZyAmJiAhcmFuZ2UuZW1wdHkoKSkge1xuICAgICAgICAgIGN1clR5cGUgPSBcInN1cnJvdW5kXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoKGlkZW50aWNhbCB8fCAhb3BlbmluZykgJiYgbmV4dCA9PSBjaCkge1xuICAgICAgICAgIGlmIChpZGVudGljYWwgJiYgc3RyaW5nU3RhcnRzQWZ0ZXIoY20sIGN1cikpXG4gICAgICAgICAgICBjdXJUeXBlID0gXCJib3RoXCI7XG4gICAgICAgICAgZWxzZSBpZiAodHJpcGxlcy5pbmRleE9mKGNoKSA+PSAwICYmIGNtLmdldFJhbmdlKGN1ciwgUG9zKGN1ci5saW5lLCBjdXIuY2ggKyAzKSkgPT0gY2ggKyBjaCArIGNoKVxuICAgICAgICAgICAgY3VyVHlwZSA9IFwic2tpcFRocmVlXCI7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgY3VyVHlwZSA9IFwic2tpcFwiO1xuICAgICAgICB9IGVsc2UgaWYgKGlkZW50aWNhbCAmJiBjdXIuY2ggPiAxICYmIHRyaXBsZXMuaW5kZXhPZihjaCkgPj0gMCAmJiBjbS5nZXRSYW5nZShQb3MoY3VyLmxpbmUsIGN1ci5jaCAtIDIpLCBjdXIpID09IGNoICsgY2gpIHtcbiAgICAgICAgICBpZiAoY3VyLmNoID4gMiAmJiAvXFxic3RyaW5nLy50ZXN0KGNtLmdldFRva2VuVHlwZUF0KFBvcyhjdXIubGluZSwgY3VyLmNoIC0gMikpKSlcbiAgICAgICAgICAgIHJldHVybiBDb2RlTWlycm9yLlBhc3M7XG4gICAgICAgICAgY3VyVHlwZSA9IFwiYWRkRm91clwiO1xuICAgICAgICB9IGVsc2UgaWYgKGlkZW50aWNhbCkge1xuICAgICAgICAgIHZhciBwcmV2ID0gY3VyLmNoID09IDAgPyBcIiBcIiA6IGNtLmdldFJhbmdlKFBvcyhjdXIubGluZSwgY3VyLmNoIC0gMSksIGN1cik7XG4gICAgICAgICAgaWYgKCFDb2RlTWlycm9yLmlzV29yZENoYXIobmV4dCkgJiYgcHJldiAhPSBjaCAmJiAhQ29kZU1pcnJvci5pc1dvcmRDaGFyKHByZXYpKVxuICAgICAgICAgICAgY3VyVHlwZSA9IFwiYm90aFwiO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBDb2RlTWlycm9yLlBhc3M7XG4gICAgICAgIH0gZWxzZSBpZiAob3BlbmluZyAmJiAobmV4dC5sZW5ndGggPT09IDAgfHwgL1xccy8udGVzdChuZXh0KSB8fCBjbG9zZUJlZm9yZS5pbmRleE9mKG5leHQpID4gLTEpKSB7XG4gICAgICAgICAgY3VyVHlwZSA9IFwiYm90aFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBDb2RlTWlycm9yLlBhc3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0eXBlKVxuICAgICAgICAgIHR5cGUgPSBjdXJUeXBlO1xuICAgICAgICBlbHNlIGlmICh0eXBlICE9IGN1clR5cGUpXG4gICAgICAgICAgcmV0dXJuIENvZGVNaXJyb3IuUGFzcztcbiAgICAgIH1cbiAgICAgIHZhciBsZWZ0ID0gcG9zICUgMiA/IHBhaXJzLmNoYXJBdChwb3MgLSAxKSA6IGNoO1xuICAgICAgdmFyIHJpZ2h0ID0gcG9zICUgMiA/IGNoIDogcGFpcnMuY2hhckF0KHBvcyArIDEpO1xuICAgICAgY20ub3BlcmF0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodHlwZSA9PSBcInNraXBcIikge1xuICAgICAgICAgIG1vdmVTZWwoY20sIDEpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJza2lwVGhyZWVcIikge1xuICAgICAgICAgIG1vdmVTZWwoY20sIDMpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJzdXJyb3VuZFwiKSB7XG4gICAgICAgICAgdmFyIHNlbHMgPSBjbS5nZXRTZWxlY3Rpb25zKCk7XG4gICAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IHNlbHMubGVuZ3RoOyBpMisrKVxuICAgICAgICAgICAgc2Vsc1tpMl0gPSBsZWZ0ICsgc2Vsc1tpMl0gKyByaWdodDtcbiAgICAgICAgICBjbS5yZXBsYWNlU2VsZWN0aW9ucyhzZWxzLCBcImFyb3VuZFwiKTtcbiAgICAgICAgICBzZWxzID0gY20ubGlzdFNlbGVjdGlvbnMoKS5zbGljZSgpO1xuICAgICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBzZWxzLmxlbmd0aDsgaTIrKylcbiAgICAgICAgICAgIHNlbHNbaTJdID0gY29udHJhY3RTZWxlY3Rpb24oc2Vsc1tpMl0pO1xuICAgICAgICAgIGNtLnNldFNlbGVjdGlvbnMoc2Vscyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcImJvdGhcIikge1xuICAgICAgICAgIGNtLnJlcGxhY2VTZWxlY3Rpb24obGVmdCArIHJpZ2h0LCBudWxsKTtcbiAgICAgICAgICBjbS50cmlnZ2VyRWxlY3RyaWMobGVmdCArIHJpZ2h0KTtcbiAgICAgICAgICBtb3ZlU2VsKGNtLCAtMSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcImFkZEZvdXJcIikge1xuICAgICAgICAgIGNtLnJlcGxhY2VTZWxlY3Rpb24obGVmdCArIGxlZnQgKyBsZWZ0ICsgbGVmdCwgXCJiZWZvcmVcIik7XG4gICAgICAgICAgbW92ZVNlbChjbSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBfX25hbWUoaGFuZGxlQ2hhciwgXCJoYW5kbGVDaGFyXCIpO1xuICAgIGZ1bmN0aW9uIGNoYXJzQXJvdW5kKGNtLCBwb3MpIHtcbiAgICAgIHZhciBzdHIgPSBjbS5nZXRSYW5nZShQb3MocG9zLmxpbmUsIHBvcy5jaCAtIDEpLCBQb3MocG9zLmxpbmUsIHBvcy5jaCArIDEpKTtcbiAgICAgIHJldHVybiBzdHIubGVuZ3RoID09IDIgPyBzdHIgOiBudWxsO1xuICAgIH1cbiAgICBfX25hbWUoY2hhcnNBcm91bmQsIFwiY2hhcnNBcm91bmRcIik7XG4gICAgZnVuY3Rpb24gc3RyaW5nU3RhcnRzQWZ0ZXIoY20sIHBvcykge1xuICAgICAgdmFyIHRva2VuID0gY20uZ2V0VG9rZW5BdChQb3MocG9zLmxpbmUsIHBvcy5jaCArIDEpKTtcbiAgICAgIHJldHVybiAvXFxic3RyaW5nLy50ZXN0KHRva2VuLnR5cGUpICYmIHRva2VuLnN0YXJ0ID09IHBvcy5jaCAmJiAocG9zLmNoID09IDAgfHwgIS9cXGJzdHJpbmcvLnRlc3QoY20uZ2V0VG9rZW5UeXBlQXQocG9zKSkpO1xuICAgIH1cbiAgICBfX25hbWUoc3RyaW5nU3RhcnRzQWZ0ZXIsIFwic3RyaW5nU3RhcnRzQWZ0ZXJcIik7XG4gIH0pO1xufSkoKTtcbnZhciBjbG9zZWJyYWNrZXRzID0gY2xvc2VicmFja2V0cyQyLmV4cG9ydHM7XG52YXIgY2xvc2VicmFja2V0cyQxID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIF9tZXJnZU5hbWVzcGFjZXMoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiBcIk1vZHVsZVwiLFxuICBcImRlZmF1bHRcIjogY2xvc2VicmFja2V0c1xufSwgW2Nsb3NlYnJhY2tldHMkMi5leHBvcnRzXSkpO1xuZXhwb3J0IHsgY2xvc2VicmFja2V0cyQxIGFzIGMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///60845\n')}}]);