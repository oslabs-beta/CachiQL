"use strict";(self.webpackChunkcachiql_demo=self.webpackChunkcachiql_demo||[]).push([[863],{89863:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "j": () => (/* binding */ javascript$1)\n/* harmony export */ });\n/* harmony import */ var _codemirror_es_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97480);\nvar __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, "name", { value, configurable: true });\n\nfunction _mergeNamespaces(n, m) {\n  m.forEach(function(e) {\n    e && typeof e !== "string" && !Array.isArray(e) && Object.keys(e).forEach(function(k) {\n      if (k !== "default" && !(k in n)) {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function() {\n            return e[k];\n          }\n        });\n      }\n    });\n  });\n  return Object.freeze(n);\n}\n__name(_mergeNamespaces, "_mergeNamespaces");\nvar javascript$2 = { exports: {} };\n(function(module, exports) {\n  (function(mod) {\n    mod(_codemirror_es_js__WEBPACK_IMPORTED_MODULE_0__.a.exports);\n  })(function(CodeMirror) {\n    CodeMirror.defineMode("javascript", function(config, parserConfig) {\n      var indentUnit = config.indentUnit;\n      var statementIndent = parserConfig.statementIndent;\n      var jsonldMode = parserConfig.jsonld;\n      var jsonMode = parserConfig.json || jsonldMode;\n      var trackScope = parserConfig.trackScope !== false;\n      var isTS = parserConfig.typescript;\n      var wordRE = parserConfig.wordCharacters || /[\\w$\\xa1-\\uffff]/;\n      var keywords = function() {\n        function kw(type2) {\n          return { type: type2, style: "keyword" };\n        }\n        __name(kw, "kw");\n        var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c"), D = kw("keyword d");\n        var operator = kw("operator"), atom = { type: "atom", style: "atom" };\n        return {\n          "if": kw("if"),\n          "while": A,\n          "with": A,\n          "else": B,\n          "do": B,\n          "try": B,\n          "finally": B,\n          "return": D,\n          "break": D,\n          "continue": D,\n          "new": kw("new"),\n          "delete": C,\n          "void": C,\n          "throw": C,\n          "debugger": kw("debugger"),\n          "var": kw("var"),\n          "const": kw("var"),\n          "let": kw("var"),\n          "function": kw("function"),\n          "catch": kw("catch"),\n          "for": kw("for"),\n          "switch": kw("switch"),\n          "case": kw("case"),\n          "default": kw("default"),\n          "in": operator,\n          "typeof": operator,\n          "instanceof": operator,\n          "true": atom,\n          "false": atom,\n          "null": atom,\n          "undefined": atom,\n          "NaN": atom,\n          "Infinity": atom,\n          "this": kw("this"),\n          "class": kw("class"),\n          "super": kw("atom"),\n          "yield": C,\n          "export": kw("export"),\n          "import": kw("import"),\n          "extends": C,\n          "await": C\n        };\n      }();\n      var isOperatorChar = /[+\\-*&%=<>!?|~^@]/;\n      var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;\n      function readRegexp(stream) {\n        var escaped = false, next, inSet = false;\n        while ((next = stream.next()) != null) {\n          if (!escaped) {\n            if (next == "/" && !inSet)\n              return;\n            if (next == "[")\n              inSet = true;\n            else if (inSet && next == "]")\n              inSet = false;\n          }\n          escaped = !escaped && next == "\\\\";\n        }\n      }\n      __name(readRegexp, "readRegexp");\n      var type, content;\n      function ret(tp, style, cont2) {\n        type = tp;\n        content = cont2;\n        return style;\n      }\n      __name(ret, "ret");\n      function tokenBase(stream, state) {\n        var ch = stream.next();\n        if (ch == \'"\' || ch == "\'") {\n          state.tokenize = tokenString(ch);\n          return state.tokenize(stream, state);\n        } else if (ch == "." && stream.match(/^\\d[\\d_]*(?:[eE][+\\-]?[\\d_]+)?/)) {\n          return ret("number", "number");\n        } else if (ch == "." && stream.match("..")) {\n          return ret("spread", "meta");\n        } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n          return ret(ch);\n        } else if (ch == "=" && stream.eat(">")) {\n          return ret("=>", "operator");\n        } else if (ch == "0" && stream.match(/^(?:x[\\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) {\n          return ret("number", "number");\n        } else if (/\\d/.test(ch)) {\n          stream.match(/^[\\d_]*(?:n|(?:\\.[\\d_]*)?(?:[eE][+\\-]?[\\d_]+)?)?/);\n          return ret("number", "number");\n        } else if (ch == "/") {\n          if (stream.eat("*")) {\n            state.tokenize = tokenComment;\n            return tokenComment(stream, state);\n          } else if (stream.eat("/")) {\n            stream.skipToEnd();\n            return ret("comment", "comment");\n          } else if (expressionAllowed(stream, state, 1)) {\n            readRegexp(stream);\n            stream.match(/^\\b(([gimyus])(?![gimyus]*\\2))+\\b/);\n            return ret("regexp", "string-2");\n          } else {\n            stream.eat("=");\n            return ret("operator", "operator", stream.current());\n          }\n        } else if (ch == "`") {\n          state.tokenize = tokenQuasi;\n          return tokenQuasi(stream, state);\n        } else if (ch == "#" && stream.peek() == "!") {\n          stream.skipToEnd();\n          return ret("meta", "meta");\n        } else if (ch == "#" && stream.eatWhile(wordRE)) {\n          return ret("variable", "property");\n        } else if (ch == "<" && stream.match("!--") || ch == "-" && stream.match("->") && !/\\S/.test(stream.string.slice(0, stream.start))) {\n          stream.skipToEnd();\n          return ret("comment", "comment");\n        } else if (isOperatorChar.test(ch)) {\n          if (ch != ">" || !state.lexical || state.lexical.type != ">") {\n            if (stream.eat("=")) {\n              if (ch == "!" || ch == "=")\n                stream.eat("=");\n            } else if (/[<>*+\\-|&?]/.test(ch)) {\n              stream.eat(ch);\n              if (ch == ">")\n                stream.eat(ch);\n            }\n          }\n          if (ch == "?" && stream.eat("."))\n            return ret(".");\n          return ret("operator", "operator", stream.current());\n        } else if (wordRE.test(ch)) {\n          stream.eatWhile(wordRE);\n          var word = stream.current();\n          if (state.lastType != ".") {\n            if (keywords.propertyIsEnumerable(word)) {\n              var kw = keywords[word];\n              return ret(kw.type, kw.style, word);\n            }\n            if (word == "async" && stream.match(/^(\\s|\\/\\*([^*]|\\*(?!\\/))*?\\*\\/)*[\\[\\(\\w]/, false))\n              return ret("async", "keyword", word);\n          }\n          return ret("variable", "variable", word);\n        }\n      }\n      __name(tokenBase, "tokenBase");\n      function tokenString(quote) {\n        return function(stream, state) {\n          var escaped = false, next;\n          if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)) {\n            state.tokenize = tokenBase;\n            return ret("jsonld-keyword", "meta");\n          }\n          while ((next = stream.next()) != null) {\n            if (next == quote && !escaped)\n              break;\n            escaped = !escaped && next == "\\\\";\n          }\n          if (!escaped)\n            state.tokenize = tokenBase;\n          return ret("string", "string");\n        };\n      }\n      __name(tokenString, "tokenString");\n      function tokenComment(stream, state) {\n        var maybeEnd = false, ch;\n        while (ch = stream.next()) {\n          if (ch == "/" && maybeEnd) {\n            state.tokenize = tokenBase;\n            break;\n          }\n          maybeEnd = ch == "*";\n        }\n        return ret("comment", "comment");\n      }\n      __name(tokenComment, "tokenComment");\n      function tokenQuasi(stream, state) {\n        var escaped = false, next;\n        while ((next = stream.next()) != null) {\n          if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {\n            state.tokenize = tokenBase;\n            break;\n          }\n          escaped = !escaped && next == "\\\\";\n        }\n        return ret("quasi", "string-2", stream.current());\n      }\n      __name(tokenQuasi, "tokenQuasi");\n      var brackets = "([{}])";\n      function findFatArrow(stream, state) {\n        if (state.fatArrowAt)\n          state.fatArrowAt = null;\n        var arrow = stream.string.indexOf("=>", stream.start);\n        if (arrow < 0)\n          return;\n        if (isTS) {\n          var m = /:\\s*(?:\\w+(?:<[^>]*>|\\[\\])?|\\{[^}]*\\})\\s*$/.exec(stream.string.slice(stream.start, arrow));\n          if (m)\n            arrow = m.index;\n        }\n        var depth = 0, sawSomething = false;\n        for (var pos = arrow - 1; pos >= 0; --pos) {\n          var ch = stream.string.charAt(pos);\n          var bracket = brackets.indexOf(ch);\n          if (bracket >= 0 && bracket < 3) {\n            if (!depth) {\n              ++pos;\n              break;\n            }\n            if (--depth == 0) {\n              if (ch == "(")\n                sawSomething = true;\n              break;\n            }\n          } else if (bracket >= 3 && bracket < 6) {\n            ++depth;\n          } else if (wordRE.test(ch)) {\n            sawSomething = true;\n          } else if (/["\'\\/`]/.test(ch)) {\n            for (; ; --pos) {\n              if (pos == 0)\n                return;\n              var next = stream.string.charAt(pos - 1);\n              if (next == ch && stream.string.charAt(pos - 2) != "\\\\") {\n                pos--;\n                break;\n              }\n            }\n          } else if (sawSomething && !depth) {\n            ++pos;\n            break;\n          }\n        }\n        if (sawSomething && !depth)\n          state.fatArrowAt = pos;\n      }\n      __name(findFatArrow, "findFatArrow");\n      var atomicTypes = {\n        "atom": true,\n        "number": true,\n        "variable": true,\n        "string": true,\n        "regexp": true,\n        "this": true,\n        "import": true,\n        "jsonld-keyword": true\n      };\n      function JSLexical(indented, column, type2, align, prev, info) {\n        this.indented = indented;\n        this.column = column;\n        this.type = type2;\n        this.prev = prev;\n        this.info = info;\n        if (align != null)\n          this.align = align;\n      }\n      __name(JSLexical, "JSLexical");\n      function inScope(state, varname) {\n        if (!trackScope)\n          return false;\n        for (var v = state.localVars; v; v = v.next)\n          if (v.name == varname)\n            return true;\n        for (var cx2 = state.context; cx2; cx2 = cx2.prev) {\n          for (var v = cx2.vars; v; v = v.next)\n            if (v.name == varname)\n              return true;\n        }\n      }\n      __name(inScope, "inScope");\n      function parseJS(state, style, type2, content2, stream) {\n        var cc = state.cc;\n        cx.state = state;\n        cx.stream = stream;\n        cx.marked = null, cx.cc = cc;\n        cx.style = style;\n        if (!state.lexical.hasOwnProperty("align"))\n          state.lexical.align = true;\n        while (true) {\n          var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n          if (combinator(type2, content2)) {\n            while (cc.length && cc[cc.length - 1].lex)\n              cc.pop()();\n            if (cx.marked)\n              return cx.marked;\n            if (type2 == "variable" && inScope(state, content2))\n              return "variable-2";\n            return style;\n          }\n        }\n      }\n      __name(parseJS, "parseJS");\n      var cx = { state: null, column: null, marked: null, cc: null };\n      function pass() {\n        for (var i = arguments.length - 1; i >= 0; i--)\n          cx.cc.push(arguments[i]);\n      }\n      __name(pass, "pass");\n      function cont() {\n        pass.apply(null, arguments);\n        return true;\n      }\n      __name(cont, "cont");\n      function inList(name, list) {\n        for (var v = list; v; v = v.next)\n          if (v.name == name)\n            return true;\n        return false;\n      }\n      __name(inList, "inList");\n      function register(varname) {\n        var state = cx.state;\n        cx.marked = "def";\n        if (!trackScope)\n          return;\n        if (state.context) {\n          if (state.lexical.info == "var" && state.context && state.context.block) {\n            var newContext = registerVarScoped(varname, state.context);\n            if (newContext != null) {\n              state.context = newContext;\n              return;\n            }\n          } else if (!inList(varname, state.localVars)) {\n            state.localVars = new Var(varname, state.localVars);\n            return;\n          }\n        }\n        if (parserConfig.globalVars && !inList(varname, state.globalVars))\n          state.globalVars = new Var(varname, state.globalVars);\n      }\n      __name(register, "register");\n      function registerVarScoped(varname, context) {\n        if (!context) {\n          return null;\n        } else if (context.block) {\n          var inner = registerVarScoped(varname, context.prev);\n          if (!inner)\n            return null;\n          if (inner == context.prev)\n            return context;\n          return new Context(inner, context.vars, true);\n        } else if (inList(varname, context.vars)) {\n          return context;\n        } else {\n          return new Context(context.prev, new Var(varname, context.vars), false);\n        }\n      }\n      __name(registerVarScoped, "registerVarScoped");\n      function isModifier(name) {\n        return name == "public" || name == "private" || name == "protected" || name == "abstract" || name == "readonly";\n      }\n      __name(isModifier, "isModifier");\n      function Context(prev, vars, block2) {\n        this.prev = prev;\n        this.vars = vars;\n        this.block = block2;\n      }\n      __name(Context, "Context");\n      function Var(name, next) {\n        this.name = name;\n        this.next = next;\n      }\n      __name(Var, "Var");\n      var defaultVars = new Var("this", new Var("arguments", null));\n      function pushcontext() {\n        cx.state.context = new Context(cx.state.context, cx.state.localVars, false);\n        cx.state.localVars = defaultVars;\n      }\n      __name(pushcontext, "pushcontext");\n      function pushblockcontext() {\n        cx.state.context = new Context(cx.state.context, cx.state.localVars, true);\n        cx.state.localVars = null;\n      }\n      __name(pushblockcontext, "pushblockcontext");\n      pushcontext.lex = pushblockcontext.lex = true;\n      function popcontext() {\n        cx.state.localVars = cx.state.context.vars;\n        cx.state.context = cx.state.context.prev;\n      }\n      __name(popcontext, "popcontext");\n      popcontext.lex = true;\n      function pushlex(type2, info) {\n        var result = /* @__PURE__ */ __name(function() {\n          var state = cx.state, indent = state.indented;\n          if (state.lexical.type == "stat")\n            indent = state.lexical.indented;\n          else\n            for (var outer = state.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev)\n              indent = outer.indented;\n          state.lexical = new JSLexical(indent, cx.stream.column(), type2, null, state.lexical, info);\n        }, "result");\n        result.lex = true;\n        return result;\n      }\n      __name(pushlex, "pushlex");\n      function poplex() {\n        var state = cx.state;\n        if (state.lexical.prev) {\n          if (state.lexical.type == ")")\n            state.indented = state.lexical.indented;\n          state.lexical = state.lexical.prev;\n        }\n      }\n      __name(poplex, "poplex");\n      poplex.lex = true;\n      function expect(wanted) {\n        function exp(type2) {\n          if (type2 == wanted)\n            return cont();\n          else if (wanted == ";" || type2 == "}" || type2 == ")" || type2 == "]")\n            return pass();\n          else\n            return cont(exp);\n        }\n        __name(exp, "exp");\n        return exp;\n      }\n      __name(expect, "expect");\n      function statement(type2, value) {\n        if (type2 == "var")\n          return cont(pushlex("vardef", value), vardef, expect(";"), poplex);\n        if (type2 == "keyword a")\n          return cont(pushlex("form"), parenExpr, statement, poplex);\n        if (type2 == "keyword b")\n          return cont(pushlex("form"), statement, poplex);\n        if (type2 == "keyword d")\n          return cx.stream.match(/^\\s*$/, false) ? cont() : cont(pushlex("stat"), maybeexpression, expect(";"), poplex);\n        if (type2 == "debugger")\n          return cont(expect(";"));\n        if (type2 == "{")\n          return cont(pushlex("}"), pushblockcontext, block, poplex, popcontext);\n        if (type2 == ";")\n          return cont();\n        if (type2 == "if") {\n          if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex)\n            cx.state.cc.pop()();\n          return cont(pushlex("form"), parenExpr, statement, poplex, maybeelse);\n        }\n        if (type2 == "function")\n          return cont(functiondef);\n        if (type2 == "for")\n          return cont(pushlex("form"), pushblockcontext, forspec, statement, popcontext, poplex);\n        if (type2 == "class" || isTS && value == "interface") {\n          cx.marked = "keyword";\n          return cont(pushlex("form", type2 == "class" ? type2 : value), className, poplex);\n        }\n        if (type2 == "variable") {\n          if (isTS && value == "declare") {\n            cx.marked = "keyword";\n            return cont(statement);\n          } else if (isTS && (value == "module" || value == "enum" || value == "type") && cx.stream.match(/^\\s*\\w/, false)) {\n            cx.marked = "keyword";\n            if (value == "enum")\n              return cont(enumdef);\n            else if (value == "type")\n              return cont(typename, expect("operator"), typeexpr, expect(";"));\n            else\n              return cont(pushlex("form"), pattern, expect("{"), pushlex("}"), block, poplex, poplex);\n          } else if (isTS && value == "namespace") {\n            cx.marked = "keyword";\n            return cont(pushlex("form"), expression, statement, poplex);\n          } else if (isTS && value == "abstract") {\n            cx.marked = "keyword";\n            return cont(statement);\n          } else {\n            return cont(pushlex("stat"), maybelabel);\n          }\n        }\n        if (type2 == "switch")\n          return cont(pushlex("form"), parenExpr, expect("{"), pushlex("}", "switch"), pushblockcontext, block, poplex, poplex, popcontext);\n        if (type2 == "case")\n          return cont(expression, expect(":"));\n        if (type2 == "default")\n          return cont(expect(":"));\n        if (type2 == "catch")\n          return cont(pushlex("form"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);\n        if (type2 == "export")\n          return cont(pushlex("stat"), afterExport, poplex);\n        if (type2 == "import")\n          return cont(pushlex("stat"), afterImport, poplex);\n        if (type2 == "async")\n          return cont(statement);\n        if (value == "@")\n          return cont(expression, statement);\n        return pass(pushlex("stat"), expression, expect(";"), poplex);\n      }\n      __name(statement, "statement");\n      function maybeCatchBinding(type2) {\n        if (type2 == "(")\n          return cont(funarg, expect(")"));\n      }\n      __name(maybeCatchBinding, "maybeCatchBinding");\n      function expression(type2, value) {\n        return expressionInner(type2, value, false);\n      }\n      __name(expression, "expression");\n      function expressionNoComma(type2, value) {\n        return expressionInner(type2, value, true);\n      }\n      __name(expressionNoComma, "expressionNoComma");\n      function parenExpr(type2) {\n        if (type2 != "(")\n          return pass();\n        return cont(pushlex(")"), maybeexpression, expect(")"), poplex);\n      }\n      __name(parenExpr, "parenExpr");\n      function expressionInner(type2, value, noComma) {\n        if (cx.state.fatArrowAt == cx.stream.start) {\n          var body = noComma ? arrowBodyNoComma : arrowBody;\n          if (type2 == "(")\n            return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, expect("=>"), body, popcontext);\n          else if (type2 == "variable")\n            return pass(pushcontext, pattern, expect("=>"), body, popcontext);\n        }\n        var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\n        if (atomicTypes.hasOwnProperty(type2))\n          return cont(maybeop);\n        if (type2 == "function")\n          return cont(functiondef, maybeop);\n        if (type2 == "class" || isTS && value == "interface") {\n          cx.marked = "keyword";\n          return cont(pushlex("form"), classExpression, poplex);\n        }\n        if (type2 == "keyword c" || type2 == "async")\n          return cont(noComma ? expressionNoComma : expression);\n        if (type2 == "(")\n          return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeop);\n        if (type2 == "operator" || type2 == "spread")\n          return cont(noComma ? expressionNoComma : expression);\n        if (type2 == "[")\n          return cont(pushlex("]"), arrayLiteral, poplex, maybeop);\n        if (type2 == "{")\n          return contCommasep(objprop, "}", null, maybeop);\n        if (type2 == "quasi")\n          return pass(quasi, maybeop);\n        if (type2 == "new")\n          return cont(maybeTarget(noComma));\n        return cont();\n      }\n      __name(expressionInner, "expressionInner");\n      function maybeexpression(type2) {\n        if (type2.match(/[;\\}\\)\\],]/))\n          return pass();\n        return pass(expression);\n      }\n      __name(maybeexpression, "maybeexpression");\n      function maybeoperatorComma(type2, value) {\n        if (type2 == ",")\n          return cont(maybeexpression);\n        return maybeoperatorNoComma(type2, value, false);\n      }\n      __name(maybeoperatorComma, "maybeoperatorComma");\n      function maybeoperatorNoComma(type2, value, noComma) {\n        var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\n        var expr = noComma == false ? expression : expressionNoComma;\n        if (type2 == "=>")\n          return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\n        if (type2 == "operator") {\n          if (/\\+\\+|--/.test(value) || isTS && value == "!")\n            return cont(me);\n          if (isTS && value == "<" && cx.stream.match(/^([^<>]|<[^<>]*>)*>\\s*\\(/, false))\n            return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, me);\n          if (value == "?")\n            return cont(expression, expect(":"), expr);\n          return cont(expr);\n        }\n        if (type2 == "quasi") {\n          return pass(quasi, me);\n        }\n        if (type2 == ";")\n          return;\n        if (type2 == "(")\n          return contCommasep(expressionNoComma, ")", "call", me);\n        if (type2 == ".")\n          return cont(property, me);\n        if (type2 == "[")\n          return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);\n        if (isTS && value == "as") {\n          cx.marked = "keyword";\n          return cont(typeexpr, me);\n        }\n        if (type2 == "regexp") {\n          cx.state.lastType = cx.marked = "operator";\n          cx.stream.backUp(cx.stream.pos - cx.stream.start - 1);\n          return cont(expr);\n        }\n      }\n      __name(maybeoperatorNoComma, "maybeoperatorNoComma");\n      function quasi(type2, value) {\n        if (type2 != "quasi")\n          return pass();\n        if (value.slice(value.length - 2) != "${")\n          return cont(quasi);\n        return cont(maybeexpression, continueQuasi);\n      }\n      __name(quasi, "quasi");\n      function continueQuasi(type2) {\n        if (type2 == "}") {\n          cx.marked = "string-2";\n          cx.state.tokenize = tokenQuasi;\n          return cont(quasi);\n        }\n      }\n      __name(continueQuasi, "continueQuasi");\n      function arrowBody(type2) {\n        findFatArrow(cx.stream, cx.state);\n        return pass(type2 == "{" ? statement : expression);\n      }\n      __name(arrowBody, "arrowBody");\n      function arrowBodyNoComma(type2) {\n        findFatArrow(cx.stream, cx.state);\n        return pass(type2 == "{" ? statement : expressionNoComma);\n      }\n      __name(arrowBodyNoComma, "arrowBodyNoComma");\n      function maybeTarget(noComma) {\n        return function(type2) {\n          if (type2 == ".")\n            return cont(noComma ? targetNoComma : target);\n          else if (type2 == "variable" && isTS)\n            return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma);\n          else\n            return pass(noComma ? expressionNoComma : expression);\n        };\n      }\n      __name(maybeTarget, "maybeTarget");\n      function target(_, value) {\n        if (value == "target") {\n          cx.marked = "keyword";\n          return cont(maybeoperatorComma);\n        }\n      }\n      __name(target, "target");\n      function targetNoComma(_, value) {\n        if (value == "target") {\n          cx.marked = "keyword";\n          return cont(maybeoperatorNoComma);\n        }\n      }\n      __name(targetNoComma, "targetNoComma");\n      function maybelabel(type2) {\n        if (type2 == ":")\n          return cont(poplex, statement);\n        return pass(maybeoperatorComma, expect(";"), poplex);\n      }\n      __name(maybelabel, "maybelabel");\n      function property(type2) {\n        if (type2 == "variable") {\n          cx.marked = "property";\n          return cont();\n        }\n      }\n      __name(property, "property");\n      function objprop(type2, value) {\n        if (type2 == "async") {\n          cx.marked = "property";\n          return cont(objprop);\n        } else if (type2 == "variable" || cx.style == "keyword") {\n          cx.marked = "property";\n          if (value == "get" || value == "set")\n            return cont(getterSetter);\n          var m;\n          if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\\s*:\\s*/, false)))\n            cx.state.fatArrowAt = cx.stream.pos + m[0].length;\n          return cont(afterprop);\n        } else if (type2 == "number" || type2 == "string") {\n          cx.marked = jsonldMode ? "property" : cx.style + " property";\n          return cont(afterprop);\n        } else if (type2 == "jsonld-keyword") {\n          return cont(afterprop);\n        } else if (isTS && isModifier(value)) {\n          cx.marked = "keyword";\n          return cont(objprop);\n        } else if (type2 == "[") {\n          return cont(expression, maybetype, expect("]"), afterprop);\n        } else if (type2 == "spread") {\n          return cont(expressionNoComma, afterprop);\n        } else if (value == "*") {\n          cx.marked = "keyword";\n          return cont(objprop);\n        } else if (type2 == ":") {\n          return pass(afterprop);\n        }\n      }\n      __name(objprop, "objprop");\n      function getterSetter(type2) {\n        if (type2 != "variable")\n          return pass(afterprop);\n        cx.marked = "property";\n        return cont(functiondef);\n      }\n      __name(getterSetter, "getterSetter");\n      function afterprop(type2) {\n        if (type2 == ":")\n          return cont(expressionNoComma);\n        if (type2 == "(")\n          return pass(functiondef);\n      }\n      __name(afterprop, "afterprop");\n      function commasep(what, end, sep) {\n        function proceed(type2, value) {\n          if (sep ? sep.indexOf(type2) > -1 : type2 == ",") {\n            var lex = cx.state.lexical;\n            if (lex.info == "call")\n              lex.pos = (lex.pos || 0) + 1;\n            return cont(function(type3, value2) {\n              if (type3 == end || value2 == end)\n                return pass();\n              return pass(what);\n            }, proceed);\n          }\n          if (type2 == end || value == end)\n            return cont();\n          if (sep && sep.indexOf(";") > -1)\n            return pass(what);\n          return cont(expect(end));\n        }\n        __name(proceed, "proceed");\n        return function(type2, value) {\n          if (type2 == end || value == end)\n            return cont();\n          return pass(what, proceed);\n        };\n      }\n      __name(commasep, "commasep");\n      function contCommasep(what, end, info) {\n        for (var i = 3; i < arguments.length; i++)\n          cx.cc.push(arguments[i]);\n        return cont(pushlex(end, info), commasep(what, end), poplex);\n      }\n      __name(contCommasep, "contCommasep");\n      function block(type2) {\n        if (type2 == "}")\n          return cont();\n        return pass(statement, block);\n      }\n      __name(block, "block");\n      function maybetype(type2, value) {\n        if (isTS) {\n          if (type2 == ":")\n            return cont(typeexpr);\n          if (value == "?")\n            return cont(maybetype);\n        }\n      }\n      __name(maybetype, "maybetype");\n      function maybetypeOrIn(type2, value) {\n        if (isTS && (type2 == ":" || value == "in"))\n          return cont(typeexpr);\n      }\n      __name(maybetypeOrIn, "maybetypeOrIn");\n      function mayberettype(type2) {\n        if (isTS && type2 == ":") {\n          if (cx.stream.match(/^\\s*\\w+\\s+is\\b/, false))\n            return cont(expression, isKW, typeexpr);\n          else\n            return cont(typeexpr);\n        }\n      }\n      __name(mayberettype, "mayberettype");\n      function isKW(_, value) {\n        if (value == "is") {\n          cx.marked = "keyword";\n          return cont();\n        }\n      }\n      __name(isKW, "isKW");\n      function typeexpr(type2, value) {\n        if (value == "keyof" || value == "typeof" || value == "infer" || value == "readonly") {\n          cx.marked = "keyword";\n          return cont(value == "typeof" ? expressionNoComma : typeexpr);\n        }\n        if (type2 == "variable" || value == "void") {\n          cx.marked = "type";\n          return cont(afterType);\n        }\n        if (value == "|" || value == "&")\n          return cont(typeexpr);\n        if (type2 == "string" || type2 == "number" || type2 == "atom")\n          return cont(afterType);\n        if (type2 == "[")\n          return cont(pushlex("]"), commasep(typeexpr, "]", ","), poplex, afterType);\n        if (type2 == "{")\n          return cont(pushlex("}"), typeprops, poplex, afterType);\n        if (type2 == "(")\n          return cont(commasep(typearg, ")"), maybeReturnType, afterType);\n        if (type2 == "<")\n          return cont(commasep(typeexpr, ">"), typeexpr);\n        if (type2 == "quasi") {\n          return pass(quasiType, afterType);\n        }\n      }\n      __name(typeexpr, "typeexpr");\n      function maybeReturnType(type2) {\n        if (type2 == "=>")\n          return cont(typeexpr);\n      }\n      __name(maybeReturnType, "maybeReturnType");\n      function typeprops(type2) {\n        if (type2.match(/[\\}\\)\\]]/))\n          return cont();\n        if (type2 == "," || type2 == ";")\n          return cont(typeprops);\n        return pass(typeprop, typeprops);\n      }\n      __name(typeprops, "typeprops");\n      function typeprop(type2, value) {\n        if (type2 == "variable" || cx.style == "keyword") {\n          cx.marked = "property";\n          return cont(typeprop);\n        } else if (value == "?" || type2 == "number" || type2 == "string") {\n          return cont(typeprop);\n        } else if (type2 == ":") {\n          return cont(typeexpr);\n        } else if (type2 == "[") {\n          return cont(expect("variable"), maybetypeOrIn, expect("]"), typeprop);\n        } else if (type2 == "(") {\n          return pass(functiondecl, typeprop);\n        } else if (!type2.match(/[;\\}\\)\\],]/)) {\n          return cont();\n        }\n      }\n      __name(typeprop, "typeprop");\n      function quasiType(type2, value) {\n        if (type2 != "quasi")\n          return pass();\n        if (value.slice(value.length - 2) != "${")\n          return cont(quasiType);\n        return cont(typeexpr, continueQuasiType);\n      }\n      __name(quasiType, "quasiType");\n      function continueQuasiType(type2) {\n        if (type2 == "}") {\n          cx.marked = "string-2";\n          cx.state.tokenize = tokenQuasi;\n          return cont(quasiType);\n        }\n      }\n      __name(continueQuasiType, "continueQuasiType");\n      function typearg(type2, value) {\n        if (type2 == "variable" && cx.stream.match(/^\\s*[?:]/, false) || value == "?")\n          return cont(typearg);\n        if (type2 == ":")\n          return cont(typeexpr);\n        if (type2 == "spread")\n          return cont(typearg);\n        return pass(typeexpr);\n      }\n      __name(typearg, "typearg");\n      function afterType(type2, value) {\n        if (value == "<")\n          return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType);\n        if (value == "|" || type2 == "." || value == "&")\n          return cont(typeexpr);\n        if (type2 == "[")\n          return cont(typeexpr, expect("]"), afterType);\n        if (value == "extends" || value == "implements") {\n          cx.marked = "keyword";\n          return cont(typeexpr);\n        }\n        if (value == "?")\n          return cont(typeexpr, expect(":"), typeexpr);\n      }\n      __name(afterType, "afterType");\n      function maybeTypeArgs(_, value) {\n        if (value == "<")\n          return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType);\n      }\n      __name(maybeTypeArgs, "maybeTypeArgs");\n      function typeparam() {\n        return pass(typeexpr, maybeTypeDefault);\n      }\n      __name(typeparam, "typeparam");\n      function maybeTypeDefault(_, value) {\n        if (value == "=")\n          return cont(typeexpr);\n      }\n      __name(maybeTypeDefault, "maybeTypeDefault");\n      function vardef(_, value) {\n        if (value == "enum") {\n          cx.marked = "keyword";\n          return cont(enumdef);\n        }\n        return pass(pattern, maybetype, maybeAssign, vardefCont);\n      }\n      __name(vardef, "vardef");\n      function pattern(type2, value) {\n        if (isTS && isModifier(value)) {\n          cx.marked = "keyword";\n          return cont(pattern);\n        }\n        if (type2 == "variable") {\n          register(value);\n          return cont();\n        }\n        if (type2 == "spread")\n          return cont(pattern);\n        if (type2 == "[")\n          return contCommasep(eltpattern, "]");\n        if (type2 == "{")\n          return contCommasep(proppattern, "}");\n      }\n      __name(pattern, "pattern");\n      function proppattern(type2, value) {\n        if (type2 == "variable" && !cx.stream.match(/^\\s*:/, false)) {\n          register(value);\n          return cont(maybeAssign);\n        }\n        if (type2 == "variable")\n          cx.marked = "property";\n        if (type2 == "spread")\n          return cont(pattern);\n        if (type2 == "}")\n          return pass();\n        if (type2 == "[")\n          return cont(expression, expect("]"), expect(":"), proppattern);\n        return cont(expect(":"), pattern, maybeAssign);\n      }\n      __name(proppattern, "proppattern");\n      function eltpattern() {\n        return pass(pattern, maybeAssign);\n      }\n      __name(eltpattern, "eltpattern");\n      function maybeAssign(_type, value) {\n        if (value == "=")\n          return cont(expressionNoComma);\n      }\n      __name(maybeAssign, "maybeAssign");\n      function vardefCont(type2) {\n        if (type2 == ",")\n          return cont(vardef);\n      }\n      __name(vardefCont, "vardefCont");\n      function maybeelse(type2, value) {\n        if (type2 == "keyword b" && value == "else")\n          return cont(pushlex("form", "else"), statement, poplex);\n      }\n      __name(maybeelse, "maybeelse");\n      function forspec(type2, value) {\n        if (value == "await")\n          return cont(forspec);\n        if (type2 == "(")\n          return cont(pushlex(")"), forspec1, poplex);\n      }\n      __name(forspec, "forspec");\n      function forspec1(type2) {\n        if (type2 == "var")\n          return cont(vardef, forspec2);\n        if (type2 == "variable")\n          return cont(forspec2);\n        return pass(forspec2);\n      }\n      __name(forspec1, "forspec1");\n      function forspec2(type2, value) {\n        if (type2 == ")")\n          return cont();\n        if (type2 == ";")\n          return cont(forspec2);\n        if (value == "in" || value == "of") {\n          cx.marked = "keyword";\n          return cont(expression, forspec2);\n        }\n        return pass(expression, forspec2);\n      }\n      __name(forspec2, "forspec2");\n      function functiondef(type2, value) {\n        if (value == "*") {\n          cx.marked = "keyword";\n          return cont(functiondef);\n        }\n        if (type2 == "variable") {\n          register(value);\n          return cont(functiondef);\n        }\n        if (type2 == "(")\n          return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, statement, popcontext);\n        if (isTS && value == "<")\n          return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondef);\n      }\n      __name(functiondef, "functiondef");\n      function functiondecl(type2, value) {\n        if (value == "*") {\n          cx.marked = "keyword";\n          return cont(functiondecl);\n        }\n        if (type2 == "variable") {\n          register(value);\n          return cont(functiondecl);\n        }\n        if (type2 == "(")\n          return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, popcontext);\n        if (isTS && value == "<")\n          return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondecl);\n      }\n      __name(functiondecl, "functiondecl");\n      function typename(type2, value) {\n        if (type2 == "keyword" || type2 == "variable") {\n          cx.marked = "type";\n          return cont(typename);\n        } else if (value == "<") {\n          return cont(pushlex(">"), commasep(typeparam, ">"), poplex);\n        }\n      }\n      __name(typename, "typename");\n      function funarg(type2, value) {\n        if (value == "@")\n          cont(expression, funarg);\n        if (type2 == "spread")\n          return cont(funarg);\n        if (isTS && isModifier(value)) {\n          cx.marked = "keyword";\n          return cont(funarg);\n        }\n        if (isTS && type2 == "this")\n          return cont(maybetype, maybeAssign);\n        return pass(pattern, maybetype, maybeAssign);\n      }\n      __name(funarg, "funarg");\n      function classExpression(type2, value) {\n        if (type2 == "variable")\n          return className(type2, value);\n        return classNameAfter(type2, value);\n      }\n      __name(classExpression, "classExpression");\n      function className(type2, value) {\n        if (type2 == "variable") {\n          register(value);\n          return cont(classNameAfter);\n        }\n      }\n      __name(className, "className");\n      function classNameAfter(type2, value) {\n        if (value == "<")\n          return cont(pushlex(">"), commasep(typeparam, ">"), poplex, classNameAfter);\n        if (value == "extends" || value == "implements" || isTS && type2 == ",") {\n          if (value == "implements")\n            cx.marked = "keyword";\n          return cont(isTS ? typeexpr : expression, classNameAfter);\n        }\n        if (type2 == "{")\n          return cont(pushlex("}"), classBody, poplex);\n      }\n      __name(classNameAfter, "classNameAfter");\n      function classBody(type2, value) {\n        if (type2 == "async" || type2 == "variable" && (value == "static" || value == "get" || value == "set" || isTS && isModifier(value)) && cx.stream.match(/^\\s+[\\w$\\xa1-\\uffff]/, false)) {\n          cx.marked = "keyword";\n          return cont(classBody);\n        }\n        if (type2 == "variable" || cx.style == "keyword") {\n          cx.marked = "property";\n          return cont(classfield, classBody);\n        }\n        if (type2 == "number" || type2 == "string")\n          return cont(classfield, classBody);\n        if (type2 == "[")\n          return cont(expression, maybetype, expect("]"), classfield, classBody);\n        if (value == "*") {\n          cx.marked = "keyword";\n          return cont(classBody);\n        }\n        if (isTS && type2 == "(")\n          return pass(functiondecl, classBody);\n        if (type2 == ";" || type2 == ",")\n          return cont(classBody);\n        if (type2 == "}")\n          return cont();\n        if (value == "@")\n          return cont(expression, classBody);\n      }\n      __name(classBody, "classBody");\n      function classfield(type2, value) {\n        if (value == "!")\n          return cont(classfield);\n        if (value == "?")\n          return cont(classfield);\n        if (type2 == ":")\n          return cont(typeexpr, maybeAssign);\n        if (value == "=")\n          return cont(expressionNoComma);\n        var context = cx.state.lexical.prev, isInterface = context && context.info == "interface";\n        return pass(isInterface ? functiondecl : functiondef);\n      }\n      __name(classfield, "classfield");\n      function afterExport(type2, value) {\n        if (value == "*") {\n          cx.marked = "keyword";\n          return cont(maybeFrom, expect(";"));\n        }\n        if (value == "default") {\n          cx.marked = "keyword";\n          return cont(expression, expect(";"));\n        }\n        if (type2 == "{")\n          return cont(commasep(exportField, "}"), maybeFrom, expect(";"));\n        return pass(statement);\n      }\n      __name(afterExport, "afterExport");\n      function exportField(type2, value) {\n        if (value == "as") {\n          cx.marked = "keyword";\n          return cont(expect("variable"));\n        }\n        if (type2 == "variable")\n          return pass(expressionNoComma, exportField);\n      }\n      __name(exportField, "exportField");\n      function afterImport(type2) {\n        if (type2 == "string")\n          return cont();\n        if (type2 == "(")\n          return pass(expression);\n        if (type2 == ".")\n          return pass(maybeoperatorComma);\n        return pass(importSpec, maybeMoreImports, maybeFrom);\n      }\n      __name(afterImport, "afterImport");\n      function importSpec(type2, value) {\n        if (type2 == "{")\n          return contCommasep(importSpec, "}");\n        if (type2 == "variable")\n          register(value);\n        if (value == "*")\n          cx.marked = "keyword";\n        return cont(maybeAs);\n      }\n      __name(importSpec, "importSpec");\n      function maybeMoreImports(type2) {\n        if (type2 == ",")\n          return cont(importSpec, maybeMoreImports);\n      }\n      __name(maybeMoreImports, "maybeMoreImports");\n      function maybeAs(_type, value) {\n        if (value == "as") {\n          cx.marked = "keyword";\n          return cont(importSpec);\n        }\n      }\n      __name(maybeAs, "maybeAs");\n      function maybeFrom(_type, value) {\n        if (value == "from") {\n          cx.marked = "keyword";\n          return cont(expression);\n        }\n      }\n      __name(maybeFrom, "maybeFrom");\n      function arrayLiteral(type2) {\n        if (type2 == "]")\n          return cont();\n        return pass(commasep(expressionNoComma, "]"));\n      }\n      __name(arrayLiteral, "arrayLiteral");\n      function enumdef() {\n        return pass(pushlex("form"), pattern, expect("{"), pushlex("}"), commasep(enummember, "}"), poplex, poplex);\n      }\n      __name(enumdef, "enumdef");\n      function enummember() {\n        return pass(pattern, maybeAssign);\n      }\n      __name(enummember, "enummember");\n      function isContinuedStatement(state, textAfter) {\n        return state.lastType == "operator" || state.lastType == "," || isOperatorChar.test(textAfter.charAt(0)) || /[,.]/.test(textAfter.charAt(0));\n      }\n      __name(isContinuedStatement, "isContinuedStatement");\n      function expressionAllowed(stream, state, backUp) {\n        return state.tokenize == tokenBase && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\\[{}\\(,;:]|=>)$/.test(state.lastType) || state.lastType == "quasi" && /\\{\\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0)));\n      }\n      __name(expressionAllowed, "expressionAllowed");\n      return {\n        startState: function(basecolumn) {\n          var state = {\n            tokenize: tokenBase,\n            lastType: "sof",\n            cc: [],\n            lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),\n            localVars: parserConfig.localVars,\n            context: parserConfig.localVars && new Context(null, null, false),\n            indented: basecolumn || 0\n          };\n          if (parserConfig.globalVars && typeof parserConfig.globalVars == "object")\n            state.globalVars = parserConfig.globalVars;\n          return state;\n        },\n        token: function(stream, state) {\n          if (stream.sol()) {\n            if (!state.lexical.hasOwnProperty("align"))\n              state.lexical.align = false;\n            state.indented = stream.indentation();\n            findFatArrow(stream, state);\n          }\n          if (state.tokenize != tokenComment && stream.eatSpace())\n            return null;\n          var style = state.tokenize(stream, state);\n          if (type == "comment")\n            return style;\n          state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;\n          return parseJS(state, style, type, content, stream);\n        },\n        indent: function(state, textAfter) {\n          if (state.tokenize == tokenComment || state.tokenize == tokenQuasi)\n            return CodeMirror.Pass;\n          if (state.tokenize != tokenBase)\n            return 0;\n          var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top;\n          if (!/^\\s*else\\b/.test(textAfter))\n            for (var i = state.cc.length - 1; i >= 0; --i) {\n              var c = state.cc[i];\n              if (c == poplex)\n                lexical = lexical.prev;\n              else if (c != maybeelse && c != popcontext)\n                break;\n            }\n          while ((lexical.type == "stat" || lexical.type == "form") && (firstChar == "}" || (top = state.cc[state.cc.length - 1]) && (top == maybeoperatorComma || top == maybeoperatorNoComma) && !/^[,\\.=+\\-*:?[\\(]/.test(textAfter)))\n            lexical = lexical.prev;\n          if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")\n            lexical = lexical.prev;\n          var type2 = lexical.type, closing = firstChar == type2;\n          if (type2 == "vardef")\n            return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info.length + 1 : 0);\n          else if (type2 == "form" && firstChar == "{")\n            return lexical.indented;\n          else if (type2 == "form")\n            return lexical.indented + indentUnit;\n          else if (type2 == "stat")\n            return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);\n          else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)\n            return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n          else if (lexical.align)\n            return lexical.column + (closing ? 0 : 1);\n          else\n            return lexical.indented + (closing ? 0 : indentUnit);\n        },\n        electricInput: /^\\s*(?:case .*?:|default:|\\{|\\})$/,\n        blockCommentStart: jsonMode ? null : "/*",\n        blockCommentEnd: jsonMode ? null : "*/",\n        blockCommentContinue: jsonMode ? null : " * ",\n        lineComment: jsonMode ? null : "//",\n        fold: "brace",\n        closeBrackets: "()[]{}\'\'\\"\\"``",\n        helperType: jsonMode ? "json" : "javascript",\n        jsonldMode,\n        jsonMode,\n        expressionAllowed,\n        skipExpression: function(state) {\n          parseJS(state, "atom", "atom", "true", new CodeMirror.StringStream("", 2, null));\n        }\n      };\n    });\n    CodeMirror.registerHelper("wordChars", "javascript", /[\\w$]/);\n    CodeMirror.defineMIME("text/javascript", "javascript");\n    CodeMirror.defineMIME("text/ecmascript", "javascript");\n    CodeMirror.defineMIME("application/javascript", "javascript");\n    CodeMirror.defineMIME("application/x-javascript", "javascript");\n    CodeMirror.defineMIME("application/ecmascript", "javascript");\n    CodeMirror.defineMIME("application/json", { name: "javascript", json: true });\n    CodeMirror.defineMIME("application/x-json", { name: "javascript", json: true });\n    CodeMirror.defineMIME("application/manifest+json", { name: "javascript", json: true });\n    CodeMirror.defineMIME("application/ld+json", { name: "javascript", jsonld: true });\n    CodeMirror.defineMIME("text/typescript", { name: "javascript", typescript: true });\n    CodeMirror.defineMIME("application/typescript", { name: "javascript", typescript: true });\n  });\n})();\nvar javascript = javascript$2.exports;\nvar javascript$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  [Symbol.toStringTag]: "Module",\n  "default": javascript\n}, [javascript$2.exports]));\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODk4NjMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBLDREQUE0RCwyQkFBMkI7QUFDbEM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsUUFBUSx3REFBa0I7QUFDMUIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVSxpQkFBaUIsTUFBTTtBQUNqQztBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsR0FBRyxJQUFJO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFVBQVU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLEdBQUc7QUFDekM7QUFDQTtBQUNBLHNDQUFzQyxLQUFLO0FBQzNDLGlDQUFpQyxHQUFHO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixHQUFHO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsMkNBQTJDO0FBQ3ZGO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGdCQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEdBQTRHO0FBQzVHO0FBQ0EsK0JBQStCO0FBQy9CLHVCQUF1QjtBQUN2QixnQ0FBZ0M7QUFDaEMsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBLDZEQUE2RCxjQUFjO0FBQzNFLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsY0FBYztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLEVBQUU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVSx5QkFBeUIsRUFBRTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qiw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBLHVCQUF1QjtBQUN2Qiw4Q0FBOEMsd0JBQXdCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxjQUFjLDJCQUEyQjtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0hBQWtILElBQUksaUVBQWlFO0FBQ3ZMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUY7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsb0RBQW9ELEdBQUc7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxnQ0FBZ0M7QUFDaEYsa0RBQWtELGdDQUFnQztBQUNsRix5REFBeUQsZ0NBQWdDO0FBQ3pGLG1EQUFtRCxrQ0FBa0M7QUFDckYsK0NBQStDLHNDQUFzQztBQUNyRixzREFBc0Qsc0NBQXNDO0FBQzVGLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDNEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYWNoaXFsLWRlbW8vLi9ub2RlX21vZHVsZXMvQGdyYXBoaXFsL3JlYWN0L2Rpc3QvamF2YXNjcmlwdC5lcy5qcz9mMTM1Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19uYW1lID0gKHRhcmdldCwgdmFsdWUpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwibmFtZVwiLCB7IHZhbHVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG5pbXBvcnQgeyBhIGFzIGNvZGVtaXJyb3IgfSBmcm9tIFwiLi9jb2RlbWlycm9yLmVzLmpzXCI7XG5mdW5jdGlvbiBfbWVyZ2VOYW1lc3BhY2VzKG4sIG0pIHtcbiAgbS5mb3JFYWNoKGZ1bmN0aW9uKGUpIHtcbiAgICBlICYmIHR5cGVvZiBlICE9PSBcInN0cmluZ1wiICYmICFBcnJheS5pc0FycmF5KGUpICYmIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmICEoayBpbiBuKSkge1xuICAgICAgICB2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgayk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBrLCBkLmdldCA/IGQgOiB7XG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGVba107XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xufVxuX19uYW1lKF9tZXJnZU5hbWVzcGFjZXMsIFwiX21lcmdlTmFtZXNwYWNlc1wiKTtcbnZhciBqYXZhc2NyaXB0JDIgPSB7IGV4cG9ydHM6IHt9IH07XG4oZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG4gIChmdW5jdGlvbihtb2QpIHtcbiAgICBtb2QoY29kZW1pcnJvci5leHBvcnRzKTtcbiAgfSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuICAgIENvZGVNaXJyb3IuZGVmaW5lTW9kZShcImphdmFzY3JpcHRcIiwgZnVuY3Rpb24oY29uZmlnLCBwYXJzZXJDb25maWcpIHtcbiAgICAgIHZhciBpbmRlbnRVbml0ID0gY29uZmlnLmluZGVudFVuaXQ7XG4gICAgICB2YXIgc3RhdGVtZW50SW5kZW50ID0gcGFyc2VyQ29uZmlnLnN0YXRlbWVudEluZGVudDtcbiAgICAgIHZhciBqc29ubGRNb2RlID0gcGFyc2VyQ29uZmlnLmpzb25sZDtcbiAgICAgIHZhciBqc29uTW9kZSA9IHBhcnNlckNvbmZpZy5qc29uIHx8IGpzb25sZE1vZGU7XG4gICAgICB2YXIgdHJhY2tTY29wZSA9IHBhcnNlckNvbmZpZy50cmFja1Njb3BlICE9PSBmYWxzZTtcbiAgICAgIHZhciBpc1RTID0gcGFyc2VyQ29uZmlnLnR5cGVzY3JpcHQ7XG4gICAgICB2YXIgd29yZFJFID0gcGFyc2VyQ29uZmlnLndvcmRDaGFyYWN0ZXJzIHx8IC9bXFx3JFxceGExLVxcdWZmZmZdLztcbiAgICAgIHZhciBrZXl3b3JkcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBrdyh0eXBlMikge1xuICAgICAgICAgIHJldHVybiB7IHR5cGU6IHR5cGUyLCBzdHlsZTogXCJrZXl3b3JkXCIgfTtcbiAgICAgICAgfVxuICAgICAgICBfX25hbWUoa3csIFwia3dcIik7XG4gICAgICAgIHZhciBBID0ga3coXCJrZXl3b3JkIGFcIiksIEIgPSBrdyhcImtleXdvcmQgYlwiKSwgQyA9IGt3KFwia2V5d29yZCBjXCIpLCBEID0ga3coXCJrZXl3b3JkIGRcIik7XG4gICAgICAgIHZhciBvcGVyYXRvciA9IGt3KFwib3BlcmF0b3JcIiksIGF0b20gPSB7IHR5cGU6IFwiYXRvbVwiLCBzdHlsZTogXCJhdG9tXCIgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBcImlmXCI6IGt3KFwiaWZcIiksXG4gICAgICAgICAgXCJ3aGlsZVwiOiBBLFxuICAgICAgICAgIFwid2l0aFwiOiBBLFxuICAgICAgICAgIFwiZWxzZVwiOiBCLFxuICAgICAgICAgIFwiZG9cIjogQixcbiAgICAgICAgICBcInRyeVwiOiBCLFxuICAgICAgICAgIFwiZmluYWxseVwiOiBCLFxuICAgICAgICAgIFwicmV0dXJuXCI6IEQsXG4gICAgICAgICAgXCJicmVha1wiOiBELFxuICAgICAgICAgIFwiY29udGludWVcIjogRCxcbiAgICAgICAgICBcIm5ld1wiOiBrdyhcIm5ld1wiKSxcbiAgICAgICAgICBcImRlbGV0ZVwiOiBDLFxuICAgICAgICAgIFwidm9pZFwiOiBDLFxuICAgICAgICAgIFwidGhyb3dcIjogQyxcbiAgICAgICAgICBcImRlYnVnZ2VyXCI6IGt3KFwiZGVidWdnZXJcIiksXG4gICAgICAgICAgXCJ2YXJcIjoga3coXCJ2YXJcIiksXG4gICAgICAgICAgXCJjb25zdFwiOiBrdyhcInZhclwiKSxcbiAgICAgICAgICBcImxldFwiOiBrdyhcInZhclwiKSxcbiAgICAgICAgICBcImZ1bmN0aW9uXCI6IGt3KFwiZnVuY3Rpb25cIiksXG4gICAgICAgICAgXCJjYXRjaFwiOiBrdyhcImNhdGNoXCIpLFxuICAgICAgICAgIFwiZm9yXCI6IGt3KFwiZm9yXCIpLFxuICAgICAgICAgIFwic3dpdGNoXCI6IGt3KFwic3dpdGNoXCIpLFxuICAgICAgICAgIFwiY2FzZVwiOiBrdyhcImNhc2VcIiksXG4gICAgICAgICAgXCJkZWZhdWx0XCI6IGt3KFwiZGVmYXVsdFwiKSxcbiAgICAgICAgICBcImluXCI6IG9wZXJhdG9yLFxuICAgICAgICAgIFwidHlwZW9mXCI6IG9wZXJhdG9yLFxuICAgICAgICAgIFwiaW5zdGFuY2VvZlwiOiBvcGVyYXRvcixcbiAgICAgICAgICBcInRydWVcIjogYXRvbSxcbiAgICAgICAgICBcImZhbHNlXCI6IGF0b20sXG4gICAgICAgICAgXCJudWxsXCI6IGF0b20sXG4gICAgICAgICAgXCJ1bmRlZmluZWRcIjogYXRvbSxcbiAgICAgICAgICBcIk5hTlwiOiBhdG9tLFxuICAgICAgICAgIFwiSW5maW5pdHlcIjogYXRvbSxcbiAgICAgICAgICBcInRoaXNcIjoga3coXCJ0aGlzXCIpLFxuICAgICAgICAgIFwiY2xhc3NcIjoga3coXCJjbGFzc1wiKSxcbiAgICAgICAgICBcInN1cGVyXCI6IGt3KFwiYXRvbVwiKSxcbiAgICAgICAgICBcInlpZWxkXCI6IEMsXG4gICAgICAgICAgXCJleHBvcnRcIjoga3coXCJleHBvcnRcIiksXG4gICAgICAgICAgXCJpbXBvcnRcIjoga3coXCJpbXBvcnRcIiksXG4gICAgICAgICAgXCJleHRlbmRzXCI6IEMsXG4gICAgICAgICAgXCJhd2FpdFwiOiBDXG4gICAgICAgIH07XG4gICAgICB9KCk7XG4gICAgICB2YXIgaXNPcGVyYXRvckNoYXIgPSAvWytcXC0qJiU9PD4hP3x+XkBdLztcbiAgICAgIHZhciBpc0pzb25sZEtleXdvcmQgPSAvXkAoY29udGV4dHxpZHx2YWx1ZXxsYW5ndWFnZXx0eXBlfGNvbnRhaW5lcnxsaXN0fHNldHxyZXZlcnNlfGluZGV4fGJhc2V8dm9jYWJ8Z3JhcGgpXCIvO1xuICAgICAgZnVuY3Rpb24gcmVhZFJlZ2V4cChzdHJlYW0pIHtcbiAgICAgICAgdmFyIGVzY2FwZWQgPSBmYWxzZSwgbmV4dCwgaW5TZXQgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKChuZXh0ID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgICAgICAgIGlmICghZXNjYXBlZCkge1xuICAgICAgICAgICAgaWYgKG5leHQgPT0gXCIvXCIgJiYgIWluU2V0KVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAobmV4dCA9PSBcIltcIilcbiAgICAgICAgICAgICAgaW5TZXQgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoaW5TZXQgJiYgbmV4dCA9PSBcIl1cIilcbiAgICAgICAgICAgICAgaW5TZXQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkICYmIG5leHQgPT0gXCJcXFxcXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF9fbmFtZShyZWFkUmVnZXhwLCBcInJlYWRSZWdleHBcIik7XG4gICAgICB2YXIgdHlwZSwgY29udGVudDtcbiAgICAgIGZ1bmN0aW9uIHJldCh0cCwgc3R5bGUsIGNvbnQyKSB7XG4gICAgICAgIHR5cGUgPSB0cDtcbiAgICAgICAgY29udGVudCA9IGNvbnQyO1xuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICB9XG4gICAgICBfX25hbWUocmV0LCBcInJldFwiKTtcbiAgICAgIGZ1bmN0aW9uIHRva2VuQmFzZShzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG4gICAgICAgIGlmIChjaCA9PSAnXCInIHx8IGNoID09IFwiJ1wiKSB7XG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlblN0cmluZyhjaCk7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9IGVsc2UgaWYgKGNoID09IFwiLlwiICYmIHN0cmVhbS5tYXRjaCgvXlxcZFtcXGRfXSooPzpbZUVdWytcXC1dP1tcXGRfXSspPy8pKSB7XG4gICAgICAgICAgcmV0dXJuIHJldChcIm51bWJlclwiLCBcIm51bWJlclwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PSBcIi5cIiAmJiBzdHJlYW0ubWF0Y2goXCIuLlwiKSkge1xuICAgICAgICAgIHJldHVybiByZXQoXCJzcHJlYWRcIiwgXCJtZXRhXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKC9bXFxbXFxde31cXChcXCksO1xcOlxcLl0vLnRlc3QoY2gpKSB7XG4gICAgICAgICAgcmV0dXJuIHJldChjaCk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCI9XCIgJiYgc3RyZWFtLmVhdChcIj5cIikpIHtcbiAgICAgICAgICByZXR1cm4gcmV0KFwiPT5cIiwgXCJvcGVyYXRvclwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PSBcIjBcIiAmJiBzdHJlYW0ubWF0Y2goL14oPzp4W1xcZEEtRmEtZl9dK3xvWzAtN19dK3xiWzAxX10rKW4/LykpIHtcbiAgICAgICAgICByZXR1cm4gcmV0KFwibnVtYmVyXCIsIFwibnVtYmVyXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKC9cXGQvLnRlc3QoY2gpKSB7XG4gICAgICAgICAgc3RyZWFtLm1hdGNoKC9eW1xcZF9dKig/Om58KD86XFwuW1xcZF9dKik/KD86W2VFXVsrXFwtXT9bXFxkX10rKT8pPy8pO1xuICAgICAgICAgIHJldHVybiByZXQoXCJudW1iZXJcIiwgXCJudW1iZXJcIik7XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCIvXCIpIHtcbiAgICAgICAgICBpZiAoc3RyZWFtLmVhdChcIipcIikpIHtcbiAgICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5Db21tZW50O1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuQ29tbWVudChzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5lYXQoXCIvXCIpKSB7XG4gICAgICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICAgICAgICByZXR1cm4gcmV0KFwiY29tbWVudFwiLCBcImNvbW1lbnRcIik7XG4gICAgICAgICAgfSBlbHNlIGlmIChleHByZXNzaW9uQWxsb3dlZChzdHJlYW0sIHN0YXRlLCAxKSkge1xuICAgICAgICAgICAgcmVhZFJlZ2V4cChzdHJlYW0pO1xuICAgICAgICAgICAgc3RyZWFtLm1hdGNoKC9eXFxiKChbZ2lteXVzXSkoPyFbZ2lteXVzXSpcXDIpKStcXGIvKTtcbiAgICAgICAgICAgIHJldHVybiByZXQoXCJyZWdleHBcIiwgXCJzdHJpbmctMlwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyZWFtLmVhdChcIj1cIik7XG4gICAgICAgICAgICByZXR1cm4gcmV0KFwib3BlcmF0b3JcIiwgXCJvcGVyYXRvclwiLCBzdHJlYW0uY3VycmVudCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCJgXCIpIHtcbiAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuUXVhc2k7XG4gICAgICAgICAgcmV0dXJuIHRva2VuUXVhc2koc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCIjXCIgJiYgc3RyZWFtLnBlZWsoKSA9PSBcIiFcIikge1xuICAgICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgICAgICByZXR1cm4gcmV0KFwibWV0YVwiLCBcIm1ldGFcIik7XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCIjXCIgJiYgc3RyZWFtLmVhdFdoaWxlKHdvcmRSRSkpIHtcbiAgICAgICAgICByZXR1cm4gcmV0KFwidmFyaWFibGVcIiwgXCJwcm9wZXJ0eVwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PSBcIjxcIiAmJiBzdHJlYW0ubWF0Y2goXCIhLS1cIikgfHwgY2ggPT0gXCItXCIgJiYgc3RyZWFtLm1hdGNoKFwiLT5cIikgJiYgIS9cXFMvLnRlc3Qoc3RyZWFtLnN0cmluZy5zbGljZSgwLCBzdHJlYW0uc3RhcnQpKSkge1xuICAgICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgICAgICByZXR1cm4gcmV0KFwiY29tbWVudFwiLCBcImNvbW1lbnRcIik7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNPcGVyYXRvckNoYXIudGVzdChjaCkpIHtcbiAgICAgICAgICBpZiAoY2ggIT0gXCI+XCIgfHwgIXN0YXRlLmxleGljYWwgfHwgc3RhdGUubGV4aWNhbC50eXBlICE9IFwiPlwiKSB7XG4gICAgICAgICAgICBpZiAoc3RyZWFtLmVhdChcIj1cIikpIHtcbiAgICAgICAgICAgICAgaWYgKGNoID09IFwiIVwiIHx8IGNoID09IFwiPVwiKVxuICAgICAgICAgICAgICAgIHN0cmVhbS5lYXQoXCI9XCIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgvWzw+KitcXC18Jj9dLy50ZXN0KGNoKSkge1xuICAgICAgICAgICAgICBzdHJlYW0uZWF0KGNoKTtcbiAgICAgICAgICAgICAgaWYgKGNoID09IFwiPlwiKVxuICAgICAgICAgICAgICAgIHN0cmVhbS5lYXQoY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2ggPT0gXCI/XCIgJiYgc3RyZWFtLmVhdChcIi5cIikpXG4gICAgICAgICAgICByZXR1cm4gcmV0KFwiLlwiKTtcbiAgICAgICAgICByZXR1cm4gcmV0KFwib3BlcmF0b3JcIiwgXCJvcGVyYXRvclwiLCBzdHJlYW0uY3VycmVudCgpKTtcbiAgICAgICAgfSBlbHNlIGlmICh3b3JkUkUudGVzdChjaCkpIHtcbiAgICAgICAgICBzdHJlYW0uZWF0V2hpbGUod29yZFJFKTtcbiAgICAgICAgICB2YXIgd29yZCA9IHN0cmVhbS5jdXJyZW50KCk7XG4gICAgICAgICAgaWYgKHN0YXRlLmxhc3RUeXBlICE9IFwiLlwiKSB7XG4gICAgICAgICAgICBpZiAoa2V5d29yZHMucHJvcGVydHlJc0VudW1lcmFibGUod29yZCkpIHtcbiAgICAgICAgICAgICAgdmFyIGt3ID0ga2V5d29yZHNbd29yZF07XG4gICAgICAgICAgICAgIHJldHVybiByZXQoa3cudHlwZSwga3cuc3R5bGUsIHdvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdvcmQgPT0gXCJhc3luY1wiICYmIHN0cmVhbS5tYXRjaCgvXihcXHN8XFwvXFwqKFteKl18XFwqKD8hXFwvKSkqP1xcKlxcLykqW1xcW1xcKFxcd10vLCBmYWxzZSkpXG4gICAgICAgICAgICAgIHJldHVybiByZXQoXCJhc3luY1wiLCBcImtleXdvcmRcIiwgd29yZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXQoXCJ2YXJpYWJsZVwiLCBcInZhcmlhYmxlXCIsIHdvcmQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBfX25hbWUodG9rZW5CYXNlLCBcInRva2VuQmFzZVwiKTtcbiAgICAgIGZ1bmN0aW9uIHRva2VuU3RyaW5nKHF1b3RlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgICAgdmFyIGVzY2FwZWQgPSBmYWxzZSwgbmV4dDtcbiAgICAgICAgICBpZiAoanNvbmxkTW9kZSAmJiBzdHJlYW0ucGVlaygpID09IFwiQFwiICYmIHN0cmVhbS5tYXRjaChpc0pzb25sZEtleXdvcmQpKSB7XG4gICAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgICAgICAgIHJldHVybiByZXQoXCJqc29ubGQta2V5d29yZFwiLCBcIm1ldGFcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlICgobmV4dCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChuZXh0ID09IHF1b3RlICYmICFlc2NhcGVkKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZCAmJiBuZXh0ID09IFwiXFxcXFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWVzY2FwZWQpXG4gICAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgICAgICByZXR1cm4gcmV0KFwic3RyaW5nXCIsIFwic3RyaW5nXCIpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgX19uYW1lKHRva2VuU3RyaW5nLCBcInRva2VuU3RyaW5nXCIpO1xuICAgICAgZnVuY3Rpb24gdG9rZW5Db21tZW50KHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgdmFyIG1heWJlRW5kID0gZmFsc2UsIGNoO1xuICAgICAgICB3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgICAgICAgaWYgKGNoID09IFwiL1wiICYmIG1heWJlRW5kKSB7XG4gICAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtYXliZUVuZCA9IGNoID09IFwiKlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQoXCJjb21tZW50XCIsIFwiY29tbWVudFwiKTtcbiAgICAgIH1cbiAgICAgIF9fbmFtZSh0b2tlbkNvbW1lbnQsIFwidG9rZW5Db21tZW50XCIpO1xuICAgICAgZnVuY3Rpb24gdG9rZW5RdWFzaShzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIHZhciBlc2NhcGVkID0gZmFsc2UsIG5leHQ7XG4gICAgICAgIHdoaWxlICgobmV4dCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAoIWVzY2FwZWQgJiYgKG5leHQgPT0gXCJgXCIgfHwgbmV4dCA9PSBcIiRcIiAmJiBzdHJlYW0uZWF0KFwie1wiKSkpIHtcbiAgICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZCAmJiBuZXh0ID09IFwiXFxcXFwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQoXCJxdWFzaVwiLCBcInN0cmluZy0yXCIsIHN0cmVhbS5jdXJyZW50KCkpO1xuICAgICAgfVxuICAgICAgX19uYW1lKHRva2VuUXVhc2ksIFwidG9rZW5RdWFzaVwiKTtcbiAgICAgIHZhciBicmFja2V0cyA9IFwiKFt7fV0pXCI7XG4gICAgICBmdW5jdGlvbiBmaW5kRmF0QXJyb3coc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgICBpZiAoc3RhdGUuZmF0QXJyb3dBdClcbiAgICAgICAgICBzdGF0ZS5mYXRBcnJvd0F0ID0gbnVsbDtcbiAgICAgICAgdmFyIGFycm93ID0gc3RyZWFtLnN0cmluZy5pbmRleE9mKFwiPT5cIiwgc3RyZWFtLnN0YXJ0KTtcbiAgICAgICAgaWYgKGFycm93IDwgMClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChpc1RTKSB7XG4gICAgICAgICAgdmFyIG0gPSAvOlxccyooPzpcXHcrKD86PFtePl0qPnxcXFtcXF0pP3xcXHtbXn1dKlxcfSlcXHMqJC8uZXhlYyhzdHJlYW0uc3RyaW5nLnNsaWNlKHN0cmVhbS5zdGFydCwgYXJyb3cpKTtcbiAgICAgICAgICBpZiAobSlcbiAgICAgICAgICAgIGFycm93ID0gbS5pbmRleDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVwdGggPSAwLCBzYXdTb21ldGhpbmcgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgcG9zID0gYXJyb3cgLSAxOyBwb3MgPj0gMDsgLS1wb3MpIHtcbiAgICAgICAgICB2YXIgY2ggPSBzdHJlYW0uc3RyaW5nLmNoYXJBdChwb3MpO1xuICAgICAgICAgIHZhciBicmFja2V0ID0gYnJhY2tldHMuaW5kZXhPZihjaCk7XG4gICAgICAgICAgaWYgKGJyYWNrZXQgPj0gMCAmJiBicmFja2V0IDwgMykge1xuICAgICAgICAgICAgaWYgKCFkZXB0aCkge1xuICAgICAgICAgICAgICArK3BvcztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoLS1kZXB0aCA9PSAwKSB7XG4gICAgICAgICAgICAgIGlmIChjaCA9PSBcIihcIilcbiAgICAgICAgICAgICAgICBzYXdTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGJyYWNrZXQgPj0gMyAmJiBicmFja2V0IDwgNikge1xuICAgICAgICAgICAgKytkZXB0aDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHdvcmRSRS50ZXN0KGNoKSkge1xuICAgICAgICAgICAgc2F3U29tZXRoaW5nID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKC9bXCInXFwvYF0vLnRlc3QoY2gpKSB7XG4gICAgICAgICAgICBmb3IgKDsgOyAtLXBvcykge1xuICAgICAgICAgICAgICBpZiAocG9zID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB2YXIgbmV4dCA9IHN0cmVhbS5zdHJpbmcuY2hhckF0KHBvcyAtIDEpO1xuICAgICAgICAgICAgICBpZiAobmV4dCA9PSBjaCAmJiBzdHJlYW0uc3RyaW5nLmNoYXJBdChwb3MgLSAyKSAhPSBcIlxcXFxcIikge1xuICAgICAgICAgICAgICAgIHBvcy0tO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChzYXdTb21ldGhpbmcgJiYgIWRlcHRoKSB7XG4gICAgICAgICAgICArK3BvcztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2F3U29tZXRoaW5nICYmICFkZXB0aClcbiAgICAgICAgICBzdGF0ZS5mYXRBcnJvd0F0ID0gcG9zO1xuICAgICAgfVxuICAgICAgX19uYW1lKGZpbmRGYXRBcnJvdywgXCJmaW5kRmF0QXJyb3dcIik7XG4gICAgICB2YXIgYXRvbWljVHlwZXMgPSB7XG4gICAgICAgIFwiYXRvbVwiOiB0cnVlLFxuICAgICAgICBcIm51bWJlclwiOiB0cnVlLFxuICAgICAgICBcInZhcmlhYmxlXCI6IHRydWUsXG4gICAgICAgIFwic3RyaW5nXCI6IHRydWUsXG4gICAgICAgIFwicmVnZXhwXCI6IHRydWUsXG4gICAgICAgIFwidGhpc1wiOiB0cnVlLFxuICAgICAgICBcImltcG9ydFwiOiB0cnVlLFxuICAgICAgICBcImpzb25sZC1rZXl3b3JkXCI6IHRydWVcbiAgICAgIH07XG4gICAgICBmdW5jdGlvbiBKU0xleGljYWwoaW5kZW50ZWQsIGNvbHVtbiwgdHlwZTIsIGFsaWduLCBwcmV2LCBpbmZvKSB7XG4gICAgICAgIHRoaXMuaW5kZW50ZWQgPSBpbmRlbnRlZDtcbiAgICAgICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGUyO1xuICAgICAgICB0aGlzLnByZXYgPSBwcmV2O1xuICAgICAgICB0aGlzLmluZm8gPSBpbmZvO1xuICAgICAgICBpZiAoYWxpZ24gIT0gbnVsbClcbiAgICAgICAgICB0aGlzLmFsaWduID0gYWxpZ247XG4gICAgICB9XG4gICAgICBfX25hbWUoSlNMZXhpY2FsLCBcIkpTTGV4aWNhbFwiKTtcbiAgICAgIGZ1bmN0aW9uIGluU2NvcGUoc3RhdGUsIHZhcm5hbWUpIHtcbiAgICAgICAgaWYgKCF0cmFja1Njb3BlKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgdiA9IHN0YXRlLmxvY2FsVmFyczsgdjsgdiA9IHYubmV4dClcbiAgICAgICAgICBpZiAodi5uYW1lID09IHZhcm5hbWUpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgY3gyID0gc3RhdGUuY29udGV4dDsgY3gyOyBjeDIgPSBjeDIucHJldikge1xuICAgICAgICAgIGZvciAodmFyIHYgPSBjeDIudmFyczsgdjsgdiA9IHYubmV4dClcbiAgICAgICAgICAgIGlmICh2Lm5hbWUgPT0gdmFybmFtZSlcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF9fbmFtZShpblNjb3BlLCBcImluU2NvcGVcIik7XG4gICAgICBmdW5jdGlvbiBwYXJzZUpTKHN0YXRlLCBzdHlsZSwgdHlwZTIsIGNvbnRlbnQyLCBzdHJlYW0pIHtcbiAgICAgICAgdmFyIGNjID0gc3RhdGUuY2M7XG4gICAgICAgIGN4LnN0YXRlID0gc3RhdGU7XG4gICAgICAgIGN4LnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgY3gubWFya2VkID0gbnVsbCwgY3guY2MgPSBjYztcbiAgICAgICAgY3guc3R5bGUgPSBzdHlsZTtcbiAgICAgICAgaWYgKCFzdGF0ZS5sZXhpY2FsLmhhc093blByb3BlcnR5KFwiYWxpZ25cIikpXG4gICAgICAgICAgc3RhdGUubGV4aWNhbC5hbGlnbiA9IHRydWU7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgdmFyIGNvbWJpbmF0b3IgPSBjYy5sZW5ndGggPyBjYy5wb3AoKSA6IGpzb25Nb2RlID8gZXhwcmVzc2lvbiA6IHN0YXRlbWVudDtcbiAgICAgICAgICBpZiAoY29tYmluYXRvcih0eXBlMiwgY29udGVudDIpKSB7XG4gICAgICAgICAgICB3aGlsZSAoY2MubGVuZ3RoICYmIGNjW2NjLmxlbmd0aCAtIDFdLmxleClcbiAgICAgICAgICAgICAgY2MucG9wKCkoKTtcbiAgICAgICAgICAgIGlmIChjeC5tYXJrZWQpXG4gICAgICAgICAgICAgIHJldHVybiBjeC5tYXJrZWQ7XG4gICAgICAgICAgICBpZiAodHlwZTIgPT0gXCJ2YXJpYWJsZVwiICYmIGluU2NvcGUoc3RhdGUsIGNvbnRlbnQyKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwidmFyaWFibGUtMlwiO1xuICAgICAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX19uYW1lKHBhcnNlSlMsIFwicGFyc2VKU1wiKTtcbiAgICAgIHZhciBjeCA9IHsgc3RhdGU6IG51bGwsIGNvbHVtbjogbnVsbCwgbWFya2VkOiBudWxsLCBjYzogbnVsbCB9O1xuICAgICAgZnVuY3Rpb24gcGFzcygpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICBjeC5jYy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgICB9XG4gICAgICBfX25hbWUocGFzcywgXCJwYXNzXCIpO1xuICAgICAgZnVuY3Rpb24gY29udCgpIHtcbiAgICAgICAgcGFzcy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIF9fbmFtZShjb250LCBcImNvbnRcIik7XG4gICAgICBmdW5jdGlvbiBpbkxpc3QobmFtZSwgbGlzdCkge1xuICAgICAgICBmb3IgKHZhciB2ID0gbGlzdDsgdjsgdiA9IHYubmV4dClcbiAgICAgICAgICBpZiAodi5uYW1lID09IG5hbWUpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgX19uYW1lKGluTGlzdCwgXCJpbkxpc3RcIik7XG4gICAgICBmdW5jdGlvbiByZWdpc3Rlcih2YXJuYW1lKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IGN4LnN0YXRlO1xuICAgICAgICBjeC5tYXJrZWQgPSBcImRlZlwiO1xuICAgICAgICBpZiAoIXRyYWNrU2NvcGUpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoc3RhdGUuY29udGV4dCkge1xuICAgICAgICAgIGlmIChzdGF0ZS5sZXhpY2FsLmluZm8gPT0gXCJ2YXJcIiAmJiBzdGF0ZS5jb250ZXh0ICYmIHN0YXRlLmNvbnRleHQuYmxvY2spIHtcbiAgICAgICAgICAgIHZhciBuZXdDb250ZXh0ID0gcmVnaXN0ZXJWYXJTY29wZWQodmFybmFtZSwgc3RhdGUuY29udGV4dCk7XG4gICAgICAgICAgICBpZiAobmV3Q29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmNvbnRleHQgPSBuZXdDb250ZXh0O1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICghaW5MaXN0KHZhcm5hbWUsIHN0YXRlLmxvY2FsVmFycykpIHtcbiAgICAgICAgICAgIHN0YXRlLmxvY2FsVmFycyA9IG5ldyBWYXIodmFybmFtZSwgc3RhdGUubG9jYWxWYXJzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnNlckNvbmZpZy5nbG9iYWxWYXJzICYmICFpbkxpc3QodmFybmFtZSwgc3RhdGUuZ2xvYmFsVmFycykpXG4gICAgICAgICAgc3RhdGUuZ2xvYmFsVmFycyA9IG5ldyBWYXIodmFybmFtZSwgc3RhdGUuZ2xvYmFsVmFycyk7XG4gICAgICB9XG4gICAgICBfX25hbWUocmVnaXN0ZXIsIFwicmVnaXN0ZXJcIik7XG4gICAgICBmdW5jdGlvbiByZWdpc3RlclZhclNjb3BlZCh2YXJuYW1lLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICghY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQuYmxvY2spIHtcbiAgICAgICAgICB2YXIgaW5uZXIgPSByZWdpc3RlclZhclNjb3BlZCh2YXJuYW1lLCBjb250ZXh0LnByZXYpO1xuICAgICAgICAgIGlmICghaW5uZXIpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICBpZiAoaW5uZXIgPT0gY29udGV4dC5wcmV2KVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDb250ZXh0KGlubmVyLCBjb250ZXh0LnZhcnMsIHRydWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGluTGlzdCh2YXJuYW1lLCBjb250ZXh0LnZhcnMpKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDb250ZXh0KGNvbnRleHQucHJldiwgbmV3IFZhcih2YXJuYW1lLCBjb250ZXh0LnZhcnMpLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF9fbmFtZShyZWdpc3RlclZhclNjb3BlZCwgXCJyZWdpc3RlclZhclNjb3BlZFwiKTtcbiAgICAgIGZ1bmN0aW9uIGlzTW9kaWZpZXIobmFtZSkge1xuICAgICAgICByZXR1cm4gbmFtZSA9PSBcInB1YmxpY1wiIHx8IG5hbWUgPT0gXCJwcml2YXRlXCIgfHwgbmFtZSA9PSBcInByb3RlY3RlZFwiIHx8IG5hbWUgPT0gXCJhYnN0cmFjdFwiIHx8IG5hbWUgPT0gXCJyZWFkb25seVwiO1xuICAgICAgfVxuICAgICAgX19uYW1lKGlzTW9kaWZpZXIsIFwiaXNNb2RpZmllclwiKTtcbiAgICAgIGZ1bmN0aW9uIENvbnRleHQocHJldiwgdmFycywgYmxvY2syKSB7XG4gICAgICAgIHRoaXMucHJldiA9IHByZXY7XG4gICAgICAgIHRoaXMudmFycyA9IHZhcnM7XG4gICAgICAgIHRoaXMuYmxvY2sgPSBibG9jazI7XG4gICAgICB9XG4gICAgICBfX25hbWUoQ29udGV4dCwgXCJDb250ZXh0XCIpO1xuICAgICAgZnVuY3Rpb24gVmFyKG5hbWUsIG5leHQpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICAgIF9fbmFtZShWYXIsIFwiVmFyXCIpO1xuICAgICAgdmFyIGRlZmF1bHRWYXJzID0gbmV3IFZhcihcInRoaXNcIiwgbmV3IFZhcihcImFyZ3VtZW50c1wiLCBudWxsKSk7XG4gICAgICBmdW5jdGlvbiBwdXNoY29udGV4dCgpIHtcbiAgICAgICAgY3guc3RhdGUuY29udGV4dCA9IG5ldyBDb250ZXh0KGN4LnN0YXRlLmNvbnRleHQsIGN4LnN0YXRlLmxvY2FsVmFycywgZmFsc2UpO1xuICAgICAgICBjeC5zdGF0ZS5sb2NhbFZhcnMgPSBkZWZhdWx0VmFycztcbiAgICAgIH1cbiAgICAgIF9fbmFtZShwdXNoY29udGV4dCwgXCJwdXNoY29udGV4dFwiKTtcbiAgICAgIGZ1bmN0aW9uIHB1c2hibG9ja2NvbnRleHQoKSB7XG4gICAgICAgIGN4LnN0YXRlLmNvbnRleHQgPSBuZXcgQ29udGV4dChjeC5zdGF0ZS5jb250ZXh0LCBjeC5zdGF0ZS5sb2NhbFZhcnMsIHRydWUpO1xuICAgICAgICBjeC5zdGF0ZS5sb2NhbFZhcnMgPSBudWxsO1xuICAgICAgfVxuICAgICAgX19uYW1lKHB1c2hibG9ja2NvbnRleHQsIFwicHVzaGJsb2NrY29udGV4dFwiKTtcbiAgICAgIHB1c2hjb250ZXh0LmxleCA9IHB1c2hibG9ja2NvbnRleHQubGV4ID0gdHJ1ZTtcbiAgICAgIGZ1bmN0aW9uIHBvcGNvbnRleHQoKSB7XG4gICAgICAgIGN4LnN0YXRlLmxvY2FsVmFycyA9IGN4LnN0YXRlLmNvbnRleHQudmFycztcbiAgICAgICAgY3guc3RhdGUuY29udGV4dCA9IGN4LnN0YXRlLmNvbnRleHQucHJldjtcbiAgICAgIH1cbiAgICAgIF9fbmFtZShwb3Bjb250ZXh0LCBcInBvcGNvbnRleHRcIik7XG4gICAgICBwb3Bjb250ZXh0LmxleCA9IHRydWU7XG4gICAgICBmdW5jdGlvbiBwdXNobGV4KHR5cGUyLCBpbmZvKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBzdGF0ZSA9IGN4LnN0YXRlLCBpbmRlbnQgPSBzdGF0ZS5pbmRlbnRlZDtcbiAgICAgICAgICBpZiAoc3RhdGUubGV4aWNhbC50eXBlID09IFwic3RhdFwiKVxuICAgICAgICAgICAgaW5kZW50ID0gc3RhdGUubGV4aWNhbC5pbmRlbnRlZDtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmb3IgKHZhciBvdXRlciA9IHN0YXRlLmxleGljYWw7IG91dGVyICYmIG91dGVyLnR5cGUgPT0gXCIpXCIgJiYgb3V0ZXIuYWxpZ247IG91dGVyID0gb3V0ZXIucHJldilcbiAgICAgICAgICAgICAgaW5kZW50ID0gb3V0ZXIuaW5kZW50ZWQ7XG4gICAgICAgICAgc3RhdGUubGV4aWNhbCA9IG5ldyBKU0xleGljYWwoaW5kZW50LCBjeC5zdHJlYW0uY29sdW1uKCksIHR5cGUyLCBudWxsLCBzdGF0ZS5sZXhpY2FsLCBpbmZvKTtcbiAgICAgICAgfSwgXCJyZXN1bHRcIik7XG4gICAgICAgIHJlc3VsdC5sZXggPSB0cnVlO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgX19uYW1lKHB1c2hsZXgsIFwicHVzaGxleFwiKTtcbiAgICAgIGZ1bmN0aW9uIHBvcGxleCgpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gY3guc3RhdGU7XG4gICAgICAgIGlmIChzdGF0ZS5sZXhpY2FsLnByZXYpIHtcbiAgICAgICAgICBpZiAoc3RhdGUubGV4aWNhbC50eXBlID09IFwiKVwiKVxuICAgICAgICAgICAgc3RhdGUuaW5kZW50ZWQgPSBzdGF0ZS5sZXhpY2FsLmluZGVudGVkO1xuICAgICAgICAgIHN0YXRlLmxleGljYWwgPSBzdGF0ZS5sZXhpY2FsLnByZXY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF9fbmFtZShwb3BsZXgsIFwicG9wbGV4XCIpO1xuICAgICAgcG9wbGV4LmxleCA9IHRydWU7XG4gICAgICBmdW5jdGlvbiBleHBlY3Qod2FudGVkKSB7XG4gICAgICAgIGZ1bmN0aW9uIGV4cCh0eXBlMikge1xuICAgICAgICAgIGlmICh0eXBlMiA9PSB3YW50ZWQpXG4gICAgICAgICAgICByZXR1cm4gY29udCgpO1xuICAgICAgICAgIGVsc2UgaWYgKHdhbnRlZCA9PSBcIjtcIiB8fCB0eXBlMiA9PSBcIn1cIiB8fCB0eXBlMiA9PSBcIilcIiB8fCB0eXBlMiA9PSBcIl1cIilcbiAgICAgICAgICAgIHJldHVybiBwYXNzKCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGNvbnQoZXhwKTtcbiAgICAgICAgfVxuICAgICAgICBfX25hbWUoZXhwLCBcImV4cFwiKTtcbiAgICAgICAgcmV0dXJuIGV4cDtcbiAgICAgIH1cbiAgICAgIF9fbmFtZShleHBlY3QsIFwiZXhwZWN0XCIpO1xuICAgICAgZnVuY3Rpb24gc3RhdGVtZW50KHR5cGUyLCB2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZTIgPT0gXCJ2YXJcIilcbiAgICAgICAgICByZXR1cm4gY29udChwdXNobGV4KFwidmFyZGVmXCIsIHZhbHVlKSwgdmFyZGVmLCBleHBlY3QoXCI7XCIpLCBwb3BsZXgpO1xuICAgICAgICBpZiAodHlwZTIgPT0gXCJrZXl3b3JkIGFcIilcbiAgICAgICAgICByZXR1cm4gY29udChwdXNobGV4KFwiZm9ybVwiKSwgcGFyZW5FeHByLCBzdGF0ZW1lbnQsIHBvcGxleCk7XG4gICAgICAgIGlmICh0eXBlMiA9PSBcImtleXdvcmQgYlwiKVxuICAgICAgICAgIHJldHVybiBjb250KHB1c2hsZXgoXCJmb3JtXCIpLCBzdGF0ZW1lbnQsIHBvcGxleCk7XG4gICAgICAgIGlmICh0eXBlMiA9PSBcImtleXdvcmQgZFwiKVxuICAgICAgICAgIHJldHVybiBjeC5zdHJlYW0ubWF0Y2goL15cXHMqJC8sIGZhbHNlKSA/IGNvbnQoKSA6IGNvbnQocHVzaGxleChcInN0YXRcIiksIG1heWJlZXhwcmVzc2lvbiwgZXhwZWN0KFwiO1wiKSwgcG9wbGV4KTtcbiAgICAgICAgaWYgKHR5cGUyID09IFwiZGVidWdnZXJcIilcbiAgICAgICAgICByZXR1cm4gY29udChleHBlY3QoXCI7XCIpKTtcbiAgICAgICAgaWYgKHR5cGUyID09IFwie1wiKVxuICAgICAgICAgIHJldHVybiBjb250KHB1c2hsZXgoXCJ9XCIpLCBwdXNoYmxvY2tjb250ZXh0LCBibG9jaywgcG9wbGV4LCBwb3Bjb250ZXh0KTtcbiAgICAgICAgaWYgKHR5cGUyID09IFwiO1wiKVxuICAgICAgICAgIHJldHVybiBjb250KCk7XG4gICAgICAgIGlmICh0eXBlMiA9PSBcImlmXCIpIHtcbiAgICAgICAgICBpZiAoY3guc3RhdGUubGV4aWNhbC5pbmZvID09IFwiZWxzZVwiICYmIGN4LnN0YXRlLmNjW2N4LnN0YXRlLmNjLmxlbmd0aCAtIDFdID09IHBvcGxleClcbiAgICAgICAgICAgIGN4LnN0YXRlLmNjLnBvcCgpKCk7XG4gICAgICAgICAgcmV0dXJuIGNvbnQocHVzaGxleChcImZvcm1cIiksIHBhcmVuRXhwciwgc3RhdGVtZW50LCBwb3BsZXgsIG1heWJlZWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUyID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICByZXR1cm4gY29udChmdW5jdGlvbmRlZik7XG4gICAgICAgIGlmICh0eXBlMiA9PSBcImZvclwiKVxuICAgICAgICAgIHJldHVybiBjb250KHB1c2hsZXgoXCJmb3JtXCIpLCBwdXNoYmxvY2tjb250ZXh0LCBmb3JzcGVjLCBzdGF0ZW1lbnQsIHBvcGNvbnRleHQsIHBvcGxleCk7XG4gICAgICAgIGlmICh0eXBlMiA9PSBcImNsYXNzXCIgfHwgaXNUUyAmJiB2YWx1ZSA9PSBcImludGVyZmFjZVwiKSB7XG4gICAgICAgICAgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7XG4gICAgICAgICAgcmV0dXJuIGNvbnQocHVzaGxleChcImZvcm1cIiwgdHlwZTIgPT0gXCJjbGFzc1wiID8gdHlwZTIgOiB2YWx1ZSksIGNsYXNzTmFtZSwgcG9wbGV4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZTIgPT0gXCJ2YXJpYWJsZVwiKSB7XG4gICAgICAgICAgaWYgKGlzVFMgJiYgdmFsdWUgPT0gXCJkZWNsYXJlXCIpIHtcbiAgICAgICAgICAgIGN4Lm1hcmtlZCA9IFwia2V5d29yZFwiO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnQoc3RhdGVtZW50KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzVFMgJiYgKHZhbHVlID09IFwibW9kdWxlXCIgfHwgdmFsdWUgPT0gXCJlbnVtXCIgfHwgdmFsdWUgPT0gXCJ0eXBlXCIpICYmIGN4LnN0cmVhbS5tYXRjaCgvXlxccypcXHcvLCBmYWxzZSkpIHtcbiAgICAgICAgICAgIGN4Lm1hcmtlZCA9IFwia2V5d29yZFwiO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiZW51bVwiKVxuICAgICAgICAgICAgICByZXR1cm4gY29udChlbnVtZGVmKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09IFwidHlwZVwiKVxuICAgICAgICAgICAgICByZXR1cm4gY29udCh0eXBlbmFtZSwgZXhwZWN0KFwib3BlcmF0b3JcIiksIHR5cGVleHByLCBleHBlY3QoXCI7XCIpKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbnQocHVzaGxleChcImZvcm1cIiksIHBhdHRlcm4sIGV4cGVjdChcIntcIiksIHB1c2hsZXgoXCJ9XCIpLCBibG9jaywgcG9wbGV4LCBwb3BsZXgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNUUyAmJiB2YWx1ZSA9PSBcIm5hbWVzcGFjZVwiKSB7XG4gICAgICAgICAgICBjeC5tYXJrZWQgPSBcImtleXdvcmRcIjtcbiAgICAgICAgICAgIHJldHVybiBjb250KHB1c2hsZXgoXCJmb3JtXCIpLCBleHByZXNzaW9uLCBzdGF0ZW1lbnQsIHBvcGxleCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc1RTICYmIHZhbHVlID09IFwiYWJzdHJhY3RcIikge1xuICAgICAgICAgICAgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7XG4gICAgICAgICAgICByZXR1cm4gY29udChzdGF0ZW1lbnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY29udChwdXNobGV4KFwic3RhdFwiKSwgbWF5YmVsYWJlbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlMiA9PSBcInN3aXRjaFwiKVxuICAgICAgICAgIHJldHVybiBjb250KHB1c2hsZXgoXCJmb3JtXCIpLCBwYXJlbkV4cHIsIGV4cGVjdChcIntcIiksIHB1c2hsZXgoXCJ9XCIsIFwic3dpdGNoXCIpLCBwdXNoYmxvY2tjb250ZXh0LCBibG9jaywgcG9wbGV4LCBwb3BsZXgsIHBvcGNvbnRleHQpO1xuICAgICAgICBpZiAodHlwZTIgPT0gXCJjYXNlXCIpXG4gICAgICAgICAgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbiwgZXhwZWN0KFwiOlwiKSk7XG4gICAgICAgIGlmICh0eXBlMiA9PSBcImRlZmF1bHRcIilcbiAgICAgICAgICByZXR1cm4gY29udChleHBlY3QoXCI6XCIpKTtcbiAgICAgICAgaWYgKHR5cGUyID09IFwiY2F0Y2hcIilcbiAgICAgICAgICByZXR1cm4gY29udChwdXNobGV4KFwiZm9ybVwiKSwgcHVzaGNvbnRleHQsIG1heWJlQ2F0Y2hCaW5kaW5nLCBzdGF0ZW1lbnQsIHBvcGxleCwgcG9wY29udGV4dCk7XG4gICAgICAgIGlmICh0eXBlMiA9PSBcImV4cG9ydFwiKVxuICAgICAgICAgIHJldHVybiBjb250KHB1c2hsZXgoXCJzdGF0XCIpLCBhZnRlckV4cG9ydCwgcG9wbGV4KTtcbiAgICAgICAgaWYgKHR5cGUyID09IFwiaW1wb3J0XCIpXG4gICAgICAgICAgcmV0dXJuIGNvbnQocHVzaGxleChcInN0YXRcIiksIGFmdGVySW1wb3J0LCBwb3BsZXgpO1xuICAgICAgICBpZiAodHlwZTIgPT0gXCJhc3luY1wiKVxuICAgICAgICAgIHJldHVybiBjb250KHN0YXRlbWVudCk7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBcIkBcIilcbiAgICAgICAgICByZXR1cm4gY29udChleHByZXNzaW9uLCBzdGF0ZW1lbnQpO1xuICAgICAgICByZXR1cm4gcGFzcyhwdXNobGV4KFwic3RhdFwiKSwgZXhwcmVzc2lvbiwgZXhwZWN0KFwiO1wiKSwgcG9wbGV4KTtcbiAgICAgIH1cbiAgICAgIF9fbmFtZShzdGF0ZW1lbnQsIFwic3RhdGVtZW50XCIpO1xuICAgICAgZnVuY3Rpb24gbWF5YmVDYXRjaEJpbmRpbmcodHlwZTIpIHtcbiAgICAgICAgaWYgKHR5cGUyID09IFwiKFwiKVxuICAgICAgICAgIHJldHVybiBjb250KGZ1bmFyZywgZXhwZWN0KFwiKVwiKSk7XG4gICAgICB9XG4gICAgICBfX25hbWUobWF5YmVDYXRjaEJpbmRpbmcsIFwibWF5YmVDYXRjaEJpbmRpbmdcIik7XG4gICAgICBmdW5jdGlvbiBleHByZXNzaW9uKHR5cGUyLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbklubmVyKHR5cGUyLCB2YWx1ZSwgZmFsc2UpO1xuICAgICAgfVxuICAgICAgX19uYW1lKGV4cHJlc3Npb24sIFwiZXhwcmVzc2lvblwiKTtcbiAgICAgIGZ1bmN0aW9uIGV4cHJlc3Npb25Ob0NvbW1hKHR5cGUyLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbklubmVyKHR5cGUyLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBfX25hbWUoZXhwcmVzc2lvbk5vQ29tbWEsIFwiZXhwcmVzc2lvbk5vQ29tbWFcIik7XG4gICAgICBmdW5jdGlvbiBwYXJlbkV4cHIodHlwZTIpIHtcbiAgICAgICAgaWYgKHR5cGUyICE9IFwiKFwiKVxuICAgICAgICAgIHJldHVybiBwYXNzKCk7XG4gICAgICAgIHJldHVybiBjb250KHB1c2hsZXgoXCIpXCIpLCBtYXliZWV4cHJlc3Npb24sIGV4cGVjdChcIilcIiksIHBvcGxleCk7XG4gICAgICB9XG4gICAgICBfX25hbWUocGFyZW5FeHByLCBcInBhcmVuRXhwclwiKTtcbiAgICAgIGZ1bmN0aW9uIGV4cHJlc3Npb25Jbm5lcih0eXBlMiwgdmFsdWUsIG5vQ29tbWEpIHtcbiAgICAgICAgaWYgKGN4LnN0YXRlLmZhdEFycm93QXQgPT0gY3guc3RyZWFtLnN0YXJ0KSB7XG4gICAgICAgICAgdmFyIGJvZHkgPSBub0NvbW1hID8gYXJyb3dCb2R5Tm9Db21tYSA6IGFycm93Qm9keTtcbiAgICAgICAgICBpZiAodHlwZTIgPT0gXCIoXCIpXG4gICAgICAgICAgICByZXR1cm4gY29udChwdXNoY29udGV4dCwgcHVzaGxleChcIilcIiksIGNvbW1hc2VwKGZ1bmFyZywgXCIpXCIpLCBwb3BsZXgsIGV4cGVjdChcIj0+XCIpLCBib2R5LCBwb3Bjb250ZXh0KTtcbiAgICAgICAgICBlbHNlIGlmICh0eXBlMiA9PSBcInZhcmlhYmxlXCIpXG4gICAgICAgICAgICByZXR1cm4gcGFzcyhwdXNoY29udGV4dCwgcGF0dGVybiwgZXhwZWN0KFwiPT5cIiksIGJvZHksIHBvcGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXliZW9wID0gbm9Db21tYSA/IG1heWJlb3BlcmF0b3JOb0NvbW1hIDogbWF5YmVvcGVyYXRvckNvbW1hO1xuICAgICAgICBpZiAoYXRvbWljVHlwZXMuaGFzT3duUHJvcGVydHkodHlwZTIpKVxuICAgICAgICAgIHJldHVybiBjb250KG1heWJlb3ApO1xuICAgICAgICBpZiAodHlwZTIgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIHJldHVybiBjb250KGZ1bmN0aW9uZGVmLCBtYXliZW9wKTtcbiAgICAgICAgaWYgKHR5cGUyID09IFwiY2xhc3NcIiB8fCBpc1RTICYmIHZhbHVlID09IFwiaW50ZXJmYWNlXCIpIHtcbiAgICAgICAgICBjeC5tYXJrZWQgPSBcImtleXdvcmRcIjtcbiAgICAgICAgICByZXR1cm4gY29udChwdXNobGV4KFwiZm9ybVwiKSwgY2xhc3NFeHByZXNzaW9uLCBwb3BsZXgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlMiA9PSBcImtleXdvcmQgY1wiIHx8IHR5cGUyID09IFwiYXN5bmNcIilcbiAgICAgICAgICByZXR1cm4gY29udChub0NvbW1hID8gZXhwcmVzc2lvbk5vQ29tbWEgOiBleHByZXNzaW9uKTtcbiAgICAgICAgaWYgKHR5cGUyID09IFwiKFwiKVxuICAgICAgICAgIHJldHVybiBjb250KHB1c2hsZXgoXCIpXCIpLCBtYXliZWV4cHJlc3Npb24sIGV4cGVjdChcIilcIiksIHBvcGxleCwgbWF5YmVvcCk7XG4gICAgICAgIGlmICh0eXBlMiA9PSBcIm9wZXJhdG9yXCIgfHwgdHlwZTIgPT0gXCJzcHJlYWRcIilcbiAgICAgICAgICByZXR1cm4gY29udChub0NvbW1hID8gZXhwcmVzc2lvbk5vQ29tbWEgOiBleHByZXNzaW9uKTtcbiAgICAgICAgaWYgKHR5cGUyID09IFwiW1wiKVxuICAgICAgICAgIHJldHVybiBjb250KHB1c2hsZXgoXCJdXCIpLCBhcnJheUxpdGVyYWwsIHBvcGxleCwgbWF5YmVvcCk7XG4gICAgICAgIGlmICh0eXBlMiA9PSBcIntcIilcbiAgICAgICAgICByZXR1cm4gY29udENvbW1hc2VwKG9ianByb3AsIFwifVwiLCBudWxsLCBtYXliZW9wKTtcbiAgICAgICAgaWYgKHR5cGUyID09IFwicXVhc2lcIilcbiAgICAgICAgICByZXR1cm4gcGFzcyhxdWFzaSwgbWF5YmVvcCk7XG4gICAgICAgIGlmICh0eXBlMiA9PSBcIm5ld1wiKVxuICAgICAgICAgIHJldHVybiBjb250KG1heWJlVGFyZ2V0KG5vQ29tbWEpKTtcbiAgICAgICAgcmV0dXJuIGNvbnQoKTtcbiAgICAgIH1cbiAgICAgIF9fbmFtZShleHByZXNzaW9uSW5uZXIsIFwiZXhwcmVzc2lvbklubmVyXCIpO1xuICAgICAgZnVuY3Rpb24gbWF5YmVleHByZXNzaW9uKHR5cGUyKSB7XG4gICAgICAgIGlmICh0eXBlMi5tYXRjaCgvWztcXH1cXClcXF0sXS8pKVxuICAgICAgICAgIHJldHVybiBwYXNzKCk7XG4gICAgICAgIHJldHVybiBwYXNzKGV4cHJlc3Npb24pO1xuICAgICAgfVxuICAgICAgX19uYW1lKG1heWJlZXhwcmVzc2lvbiwgXCJtYXliZWV4cHJlc3Npb25cIik7XG4gICAgICBmdW5jdGlvbiBtYXliZW9wZXJhdG9yQ29tbWEodHlwZTIsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlMiA9PSBcIixcIilcbiAgICAgICAgICByZXR1cm4gY29udChtYXliZWV4cHJlc3Npb24pO1xuICAgICAgICByZXR1cm4gbWF5YmVvcGVyYXRvck5vQ29tbWEodHlwZTIsIHZhbHVlLCBmYWxzZSk7XG4gICAgICB9XG4gICAgICBfX25hbWUobWF5YmVvcGVyYXRvckNvbW1hLCBcIm1heWJlb3BlcmF0b3JDb21tYVwiKTtcbiAgICAgIGZ1bmN0aW9uIG1heWJlb3BlcmF0b3JOb0NvbW1hKHR5cGUyLCB2YWx1ZSwgbm9Db21tYSkge1xuICAgICAgICB2YXIgbWUgPSBub0NvbW1hID09IGZhbHNlID8gbWF5YmVvcGVyYXRvckNvbW1hIDogbWF5YmVvcGVyYXRvck5vQ29tbWE7XG4gICAgICAgIHZhciBleHByID0gbm9Db21tYSA9PSBmYWxzZSA/IGV4cHJlc3Npb24gOiBleHByZXNzaW9uTm9Db21tYTtcbiAgICAgICAgaWYgKHR5cGUyID09IFwiPT5cIilcbiAgICAgICAgICByZXR1cm4gY29udChwdXNoY29udGV4dCwgbm9Db21tYSA/IGFycm93Qm9keU5vQ29tbWEgOiBhcnJvd0JvZHksIHBvcGNvbnRleHQpO1xuICAgICAgICBpZiAodHlwZTIgPT0gXCJvcGVyYXRvclwiKSB7XG4gICAgICAgICAgaWYgKC9cXCtcXCt8LS0vLnRlc3QodmFsdWUpIHx8IGlzVFMgJiYgdmFsdWUgPT0gXCIhXCIpXG4gICAgICAgICAgICByZXR1cm4gY29udChtZSk7XG4gICAgICAgICAgaWYgKGlzVFMgJiYgdmFsdWUgPT0gXCI8XCIgJiYgY3guc3RyZWFtLm1hdGNoKC9eKFtePD5dfDxbXjw+XSo+KSo+XFxzKlxcKC8sIGZhbHNlKSlcbiAgICAgICAgICAgIHJldHVybiBjb250KHB1c2hsZXgoXCI+XCIpLCBjb21tYXNlcCh0eXBlZXhwciwgXCI+XCIpLCBwb3BsZXgsIG1lKTtcbiAgICAgICAgICBpZiAodmFsdWUgPT0gXCI/XCIpXG4gICAgICAgICAgICByZXR1cm4gY29udChleHByZXNzaW9uLCBleHBlY3QoXCI6XCIpLCBleHByKTtcbiAgICAgICAgICByZXR1cm4gY29udChleHByKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZTIgPT0gXCJxdWFzaVwiKSB7XG4gICAgICAgICAgcmV0dXJuIHBhc3MocXVhc2ksIG1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZTIgPT0gXCI7XCIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodHlwZTIgPT0gXCIoXCIpXG4gICAgICAgICAgcmV0dXJuIGNvbnRDb21tYXNlcChleHByZXNzaW9uTm9Db21tYSwgXCIpXCIsIFwiY2FsbFwiLCBtZSk7XG4gICAgICAgIGlmICh0eXBlMiA9PSBcIi5cIilcbiAgICAgICAgICByZXR1cm4gY29udChwcm9wZXJ0eSwgbWUpO1xuICAgICAgICBpZiAodHlwZTIgPT0gXCJbXCIpXG4gICAgICAgICAgcmV0dXJuIGNvbnQocHVzaGxleChcIl1cIiksIG1heWJlZXhwcmVzc2lvbiwgZXhwZWN0KFwiXVwiKSwgcG9wbGV4LCBtZSk7XG4gICAgICAgIGlmIChpc1RTICYmIHZhbHVlID09IFwiYXNcIikge1xuICAgICAgICAgIGN4Lm1hcmtlZCA9IFwia2V5d29yZFwiO1xuICAgICAgICAgIHJldHVybiBjb250KHR5cGVleHByLCBtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUyID09IFwicmVnZXhwXCIpIHtcbiAgICAgICAgICBjeC5zdGF0ZS5sYXN0VHlwZSA9IGN4Lm1hcmtlZCA9IFwib3BlcmF0b3JcIjtcbiAgICAgICAgICBjeC5zdHJlYW0uYmFja1VwKGN4LnN0cmVhbS5wb3MgLSBjeC5zdHJlYW0uc3RhcnQgLSAxKTtcbiAgICAgICAgICByZXR1cm4gY29udChleHByKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX19uYW1lKG1heWJlb3BlcmF0b3JOb0NvbW1hLCBcIm1heWJlb3BlcmF0b3JOb0NvbW1hXCIpO1xuICAgICAgZnVuY3Rpb24gcXVhc2kodHlwZTIsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlMiAhPSBcInF1YXNpXCIpXG4gICAgICAgICAgcmV0dXJuIHBhc3MoKTtcbiAgICAgICAgaWYgKHZhbHVlLnNsaWNlKHZhbHVlLmxlbmd0aCAtIDIpICE9IFwiJHtcIilcbiAgICAgICAgICByZXR1cm4gY29udChxdWFzaSk7XG4gICAgICAgIHJldHVybiBjb250KG1heWJlZXhwcmVzc2lvbiwgY29udGludWVRdWFzaSk7XG4gICAgICB9XG4gICAgICBfX25hbWUocXVhc2ksIFwicXVhc2lcIik7XG4gICAgICBmdW5jdGlvbiBjb250aW51ZVF1YXNpKHR5cGUyKSB7XG4gICAgICAgIGlmICh0eXBlMiA9PSBcIn1cIikge1xuICAgICAgICAgIGN4Lm1hcmtlZCA9IFwic3RyaW5nLTJcIjtcbiAgICAgICAgICBjeC5zdGF0ZS50b2tlbml6ZSA9IHRva2VuUXVhc2k7XG4gICAgICAgICAgcmV0dXJuIGNvbnQocXVhc2kpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBfX25hbWUoY29udGludWVRdWFzaSwgXCJjb250aW51ZVF1YXNpXCIpO1xuICAgICAgZnVuY3Rpb24gYXJyb3dCb2R5KHR5cGUyKSB7XG4gICAgICAgIGZpbmRGYXRBcnJvdyhjeC5zdHJlYW0sIGN4LnN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHBhc3ModHlwZTIgPT0gXCJ7XCIgPyBzdGF0ZW1lbnQgOiBleHByZXNzaW9uKTtcbiAgICAgIH1cbiAgICAgIF9fbmFtZShhcnJvd0JvZHksIFwiYXJyb3dCb2R5XCIpO1xuICAgICAgZnVuY3Rpb24gYXJyb3dCb2R5Tm9Db21tYSh0eXBlMikge1xuICAgICAgICBmaW5kRmF0QXJyb3coY3guc3RyZWFtLCBjeC5zdGF0ZSk7XG4gICAgICAgIHJldHVybiBwYXNzKHR5cGUyID09IFwie1wiID8gc3RhdGVtZW50IDogZXhwcmVzc2lvbk5vQ29tbWEpO1xuICAgICAgfVxuICAgICAgX19uYW1lKGFycm93Qm9keU5vQ29tbWEsIFwiYXJyb3dCb2R5Tm9Db21tYVwiKTtcbiAgICAgIGZ1bmN0aW9uIG1heWJlVGFyZ2V0KG5vQ29tbWEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHR5cGUyKSB7XG4gICAgICAgICAgaWYgKHR5cGUyID09IFwiLlwiKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnQobm9Db21tYSA/IHRhcmdldE5vQ29tbWEgOiB0YXJnZXQpO1xuICAgICAgICAgIGVsc2UgaWYgKHR5cGUyID09IFwidmFyaWFibGVcIiAmJiBpc1RTKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnQobWF5YmVUeXBlQXJncywgbm9Db21tYSA/IG1heWJlb3BlcmF0b3JOb0NvbW1hIDogbWF5YmVvcGVyYXRvckNvbW1hKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gcGFzcyhub0NvbW1hID8gZXhwcmVzc2lvbk5vQ29tbWEgOiBleHByZXNzaW9uKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIF9fbmFtZShtYXliZVRhcmdldCwgXCJtYXliZVRhcmdldFwiKTtcbiAgICAgIGZ1bmN0aW9uIHRhcmdldChfLCB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT0gXCJ0YXJnZXRcIikge1xuICAgICAgICAgIGN4Lm1hcmtlZCA9IFwia2V5d29yZFwiO1xuICAgICAgICAgIHJldHVybiBjb250KG1heWJlb3BlcmF0b3JDb21tYSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF9fbmFtZSh0YXJnZXQsIFwidGFyZ2V0XCIpO1xuICAgICAgZnVuY3Rpb24gdGFyZ2V0Tm9Db21tYShfLCB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT0gXCJ0YXJnZXRcIikge1xuICAgICAgICAgIGN4Lm1hcmtlZCA9IFwia2V5d29yZFwiO1xuICAgICAgICAgIHJldHVybiBjb250KG1heWJlb3BlcmF0b3JOb0NvbW1hKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX19uYW1lKHRhcmdldE5vQ29tbWEsIFwidGFyZ2V0Tm9Db21tYVwiKTtcbiAgICAgIGZ1bmN0aW9uIG1heWJlbGFiZWwodHlwZTIpIHtcbiAgICAgICAgaWYgKHR5cGUyID09IFwiOlwiKVxuICAgICAgICAgIHJldHVybiBjb250KHBvcGxleCwgc3RhdGVtZW50KTtcbiAgICAgICAgcmV0dXJuIHBhc3MobWF5YmVvcGVyYXRvckNvbW1hLCBleHBlY3QoXCI7XCIpLCBwb3BsZXgpO1xuICAgICAgfVxuICAgICAgX19uYW1lKG1heWJlbGFiZWwsIFwibWF5YmVsYWJlbFwiKTtcbiAgICAgIGZ1bmN0aW9uIHByb3BlcnR5KHR5cGUyKSB7XG4gICAgICAgIGlmICh0eXBlMiA9PSBcInZhcmlhYmxlXCIpIHtcbiAgICAgICAgICBjeC5tYXJrZWQgPSBcInByb3BlcnR5XCI7XG4gICAgICAgICAgcmV0dXJuIGNvbnQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX19uYW1lKHByb3BlcnR5LCBcInByb3BlcnR5XCIpO1xuICAgICAgZnVuY3Rpb24gb2JqcHJvcCh0eXBlMiwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGUyID09IFwiYXN5bmNcIikge1xuICAgICAgICAgIGN4Lm1hcmtlZCA9IFwicHJvcGVydHlcIjtcbiAgICAgICAgICByZXR1cm4gY29udChvYmpwcm9wKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlMiA9PSBcInZhcmlhYmxlXCIgfHwgY3guc3R5bGUgPT0gXCJrZXl3b3JkXCIpIHtcbiAgICAgICAgICBjeC5tYXJrZWQgPSBcInByb3BlcnR5XCI7XG4gICAgICAgICAgaWYgKHZhbHVlID09IFwiZ2V0XCIgfHwgdmFsdWUgPT0gXCJzZXRcIilcbiAgICAgICAgICAgIHJldHVybiBjb250KGdldHRlclNldHRlcik7XG4gICAgICAgICAgdmFyIG07XG4gICAgICAgICAgaWYgKGlzVFMgJiYgY3guc3RhdGUuZmF0QXJyb3dBdCA9PSBjeC5zdHJlYW0uc3RhcnQgJiYgKG0gPSBjeC5zdHJlYW0ubWF0Y2goL15cXHMqOlxccyovLCBmYWxzZSkpKVxuICAgICAgICAgICAgY3guc3RhdGUuZmF0QXJyb3dBdCA9IGN4LnN0cmVhbS5wb3MgKyBtWzBdLmxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gY29udChhZnRlcnByb3ApO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUyID09IFwibnVtYmVyXCIgfHwgdHlwZTIgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGN4Lm1hcmtlZCA9IGpzb25sZE1vZGUgPyBcInByb3BlcnR5XCIgOiBjeC5zdHlsZSArIFwiIHByb3BlcnR5XCI7XG4gICAgICAgICAgcmV0dXJuIGNvbnQoYWZ0ZXJwcm9wKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlMiA9PSBcImpzb25sZC1rZXl3b3JkXCIpIHtcbiAgICAgICAgICByZXR1cm4gY29udChhZnRlcnByb3ApO1xuICAgICAgICB9IGVsc2UgaWYgKGlzVFMgJiYgaXNNb2RpZmllcih2YWx1ZSkpIHtcbiAgICAgICAgICBjeC5tYXJrZWQgPSBcImtleXdvcmRcIjtcbiAgICAgICAgICByZXR1cm4gY29udChvYmpwcm9wKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlMiA9PSBcIltcIikge1xuICAgICAgICAgIHJldHVybiBjb250KGV4cHJlc3Npb24sIG1heWJldHlwZSwgZXhwZWN0KFwiXVwiKSwgYWZ0ZXJwcm9wKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlMiA9PSBcInNwcmVhZFwiKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbk5vQ29tbWEsIGFmdGVycHJvcCk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT0gXCIqXCIpIHtcbiAgICAgICAgICBjeC5tYXJrZWQgPSBcImtleXdvcmRcIjtcbiAgICAgICAgICByZXR1cm4gY29udChvYmpwcm9wKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlMiA9PSBcIjpcIikge1xuICAgICAgICAgIHJldHVybiBwYXNzKGFmdGVycHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF9fbmFtZShvYmpwcm9wLCBcIm9ianByb3BcIik7XG4gICAgICBmdW5jdGlvbiBnZXR0ZXJTZXR0ZXIodHlwZTIpIHtcbiAgICAgICAgaWYgKHR5cGUyICE9IFwidmFyaWFibGVcIilcbiAgICAgICAgICByZXR1cm4gcGFzcyhhZnRlcnByb3ApO1xuICAgICAgICBjeC5tYXJrZWQgPSBcInByb3BlcnR5XCI7XG4gICAgICAgIHJldHVybiBjb250KGZ1bmN0aW9uZGVmKTtcbiAgICAgIH1cbiAgICAgIF9fbmFtZShnZXR0ZXJTZXR0ZXIsIFwiZ2V0dGVyU2V0dGVyXCIpO1xuICAgICAgZnVuY3Rpb24gYWZ0ZXJwcm9wKHR5cGUyKSB7XG4gICAgICAgIGlmICh0eXBlMiA9PSBcIjpcIilcbiAgICAgICAgICByZXR1cm4gY29udChleHByZXNzaW9uTm9Db21tYSk7XG4gICAgICAgIGlmICh0eXBlMiA9PSBcIihcIilcbiAgICAgICAgICByZXR1cm4gcGFzcyhmdW5jdGlvbmRlZik7XG4gICAgICB9XG4gICAgICBfX25hbWUoYWZ0ZXJwcm9wLCBcImFmdGVycHJvcFwiKTtcbiAgICAgIGZ1bmN0aW9uIGNvbW1hc2VwKHdoYXQsIGVuZCwgc2VwKSB7XG4gICAgICAgIGZ1bmN0aW9uIHByb2NlZWQodHlwZTIsIHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHNlcCA/IHNlcC5pbmRleE9mKHR5cGUyKSA+IC0xIDogdHlwZTIgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgIHZhciBsZXggPSBjeC5zdGF0ZS5sZXhpY2FsO1xuICAgICAgICAgICAgaWYgKGxleC5pbmZvID09IFwiY2FsbFwiKVxuICAgICAgICAgICAgICBsZXgucG9zID0gKGxleC5wb3MgfHwgMCkgKyAxO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnQoZnVuY3Rpb24odHlwZTMsIHZhbHVlMikge1xuICAgICAgICAgICAgICBpZiAodHlwZTMgPT0gZW5kIHx8IHZhbHVlMiA9PSBlbmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhc3MoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhc3Mod2hhdCk7XG4gICAgICAgICAgICB9LCBwcm9jZWVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGUyID09IGVuZCB8fCB2YWx1ZSA9PSBlbmQpXG4gICAgICAgICAgICByZXR1cm4gY29udCgpO1xuICAgICAgICAgIGlmIChzZXAgJiYgc2VwLmluZGV4T2YoXCI7XCIpID4gLTEpXG4gICAgICAgICAgICByZXR1cm4gcGFzcyh3aGF0KTtcbiAgICAgICAgICByZXR1cm4gY29udChleHBlY3QoZW5kKSk7XG4gICAgICAgIH1cbiAgICAgICAgX19uYW1lKHByb2NlZWQsIFwicHJvY2VlZFwiKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHR5cGUyLCB2YWx1ZSkge1xuICAgICAgICAgIGlmICh0eXBlMiA9PSBlbmQgfHwgdmFsdWUgPT0gZW5kKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnQoKTtcbiAgICAgICAgICByZXR1cm4gcGFzcyh3aGF0LCBwcm9jZWVkKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIF9fbmFtZShjb21tYXNlcCwgXCJjb21tYXNlcFwiKTtcbiAgICAgIGZ1bmN0aW9uIGNvbnRDb21tYXNlcCh3aGF0LCBlbmQsIGluZm8pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDM7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgY3guY2MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgICAgICByZXR1cm4gY29udChwdXNobGV4KGVuZCwgaW5mbyksIGNvbW1hc2VwKHdoYXQsIGVuZCksIHBvcGxleCk7XG4gICAgICB9XG4gICAgICBfX25hbWUoY29udENvbW1hc2VwLCBcImNvbnRDb21tYXNlcFwiKTtcbiAgICAgIGZ1bmN0aW9uIGJsb2NrKHR5cGUyKSB7XG4gICAgICAgIGlmICh0eXBlMiA9PSBcIn1cIilcbiAgICAgICAgICByZXR1cm4gY29udCgpO1xuICAgICAgICByZXR1cm4gcGFzcyhzdGF0ZW1lbnQsIGJsb2NrKTtcbiAgICAgIH1cbiAgICAgIF9fbmFtZShibG9jaywgXCJibG9ja1wiKTtcbiAgICAgIGZ1bmN0aW9uIG1heWJldHlwZSh0eXBlMiwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzVFMpIHtcbiAgICAgICAgICBpZiAodHlwZTIgPT0gXCI6XCIpXG4gICAgICAgICAgICByZXR1cm4gY29udCh0eXBlZXhwcik7XG4gICAgICAgICAgaWYgKHZhbHVlID09IFwiP1wiKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnQobWF5YmV0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX19uYW1lKG1heWJldHlwZSwgXCJtYXliZXR5cGVcIik7XG4gICAgICBmdW5jdGlvbiBtYXliZXR5cGVPckluKHR5cGUyLCB2YWx1ZSkge1xuICAgICAgICBpZiAoaXNUUyAmJiAodHlwZTIgPT0gXCI6XCIgfHwgdmFsdWUgPT0gXCJpblwiKSlcbiAgICAgICAgICByZXR1cm4gY29udCh0eXBlZXhwcik7XG4gICAgICB9XG4gICAgICBfX25hbWUobWF5YmV0eXBlT3JJbiwgXCJtYXliZXR5cGVPckluXCIpO1xuICAgICAgZnVuY3Rpb24gbWF5YmVyZXR0eXBlKHR5cGUyKSB7XG4gICAgICAgIGlmIChpc1RTICYmIHR5cGUyID09IFwiOlwiKSB7XG4gICAgICAgICAgaWYgKGN4LnN0cmVhbS5tYXRjaCgvXlxccypcXHcrXFxzK2lzXFxiLywgZmFsc2UpKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbiwgaXNLVywgdHlwZWV4cHIpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBjb250KHR5cGVleHByKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX19uYW1lKG1heWJlcmV0dHlwZSwgXCJtYXliZXJldHR5cGVcIik7XG4gICAgICBmdW5jdGlvbiBpc0tXKF8sIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBcImlzXCIpIHtcbiAgICAgICAgICBjeC5tYXJrZWQgPSBcImtleXdvcmRcIjtcbiAgICAgICAgICByZXR1cm4gY29udCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBfX25hbWUoaXNLVywgXCJpc0tXXCIpO1xuICAgICAgZnVuY3Rpb24gdHlwZWV4cHIodHlwZTIsIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBcImtleW9mXCIgfHwgdmFsdWUgPT0gXCJ0eXBlb2ZcIiB8fCB2YWx1ZSA9PSBcImluZmVyXCIgfHwgdmFsdWUgPT0gXCJyZWFkb25seVwiKSB7XG4gICAgICAgICAgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7XG4gICAgICAgICAgcmV0dXJuIGNvbnQodmFsdWUgPT0gXCJ0eXBlb2ZcIiA/IGV4cHJlc3Npb25Ob0NvbW1hIDogdHlwZWV4cHIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlMiA9PSBcInZhcmlhYmxlXCIgfHwgdmFsdWUgPT0gXCJ2b2lkXCIpIHtcbiAgICAgICAgICBjeC5tYXJrZWQgPSBcInR5cGVcIjtcbiAgICAgICAgICByZXR1cm4gY29udChhZnRlclR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PSBcInxcIiB8fCB2YWx1ZSA9PSBcIiZcIilcbiAgICAgICAgICByZXR1cm4gY29udCh0eXBlZXhwcik7XG4gICAgICAgIGlmICh0eXBlMiA9PSBcInN0cmluZ1wiIHx8IHR5cGUyID09IFwibnVtYmVyXCIgfHwgdHlwZTIgPT0gXCJhdG9tXCIpXG4gICAgICAgICAgcmV0dXJuIGNvbnQoYWZ0ZXJUeXBlKTtcbiAgICAgICAgaWYgKHR5cGUyID09IFwiW1wiKVxuICAgICAgICAgIHJldHVybiBjb250KHB1c2hsZXgoXCJdXCIpLCBjb21tYXNlcCh0eXBlZXhwciwgXCJdXCIsIFwiLFwiKSwgcG9wbGV4LCBhZnRlclR5cGUpO1xuICAgICAgICBpZiAodHlwZTIgPT0gXCJ7XCIpXG4gICAgICAgICAgcmV0dXJuIGNvbnQocHVzaGxleChcIn1cIiksIHR5cGVwcm9wcywgcG9wbGV4LCBhZnRlclR5cGUpO1xuICAgICAgICBpZiAodHlwZTIgPT0gXCIoXCIpXG4gICAgICAgICAgcmV0dXJuIGNvbnQoY29tbWFzZXAodHlwZWFyZywgXCIpXCIpLCBtYXliZVJldHVyblR5cGUsIGFmdGVyVHlwZSk7XG4gICAgICAgIGlmICh0eXBlMiA9PSBcIjxcIilcbiAgICAgICAgICByZXR1cm4gY29udChjb21tYXNlcCh0eXBlZXhwciwgXCI+XCIpLCB0eXBlZXhwcik7XG4gICAgICAgIGlmICh0eXBlMiA9PSBcInF1YXNpXCIpIHtcbiAgICAgICAgICByZXR1cm4gcGFzcyhxdWFzaVR5cGUsIGFmdGVyVHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF9fbmFtZSh0eXBlZXhwciwgXCJ0eXBlZXhwclwiKTtcbiAgICAgIGZ1bmN0aW9uIG1heWJlUmV0dXJuVHlwZSh0eXBlMikge1xuICAgICAgICBpZiAodHlwZTIgPT0gXCI9PlwiKVxuICAgICAgICAgIHJldHVybiBjb250KHR5cGVleHByKTtcbiAgICAgIH1cbiAgICAgIF9fbmFtZShtYXliZVJldHVyblR5cGUsIFwibWF5YmVSZXR1cm5UeXBlXCIpO1xuICAgICAgZnVuY3Rpb24gdHlwZXByb3BzKHR5cGUyKSB7XG4gICAgICAgIGlmICh0eXBlMi5tYXRjaCgvW1xcfVxcKVxcXV0vKSlcbiAgICAgICAgICByZXR1cm4gY29udCgpO1xuICAgICAgICBpZiAodHlwZTIgPT0gXCIsXCIgfHwgdHlwZTIgPT0gXCI7XCIpXG4gICAgICAgICAgcmV0dXJuIGNvbnQodHlwZXByb3BzKTtcbiAgICAgICAgcmV0dXJuIHBhc3ModHlwZXByb3AsIHR5cGVwcm9wcyk7XG4gICAgICB9XG4gICAgICBfX25hbWUodHlwZXByb3BzLCBcInR5cGVwcm9wc1wiKTtcbiAgICAgIGZ1bmN0aW9uIHR5cGVwcm9wKHR5cGUyLCB2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZTIgPT0gXCJ2YXJpYWJsZVwiIHx8IGN4LnN0eWxlID09IFwia2V5d29yZFwiKSB7XG4gICAgICAgICAgY3gubWFya2VkID0gXCJwcm9wZXJ0eVwiO1xuICAgICAgICAgIHJldHVybiBjb250KHR5cGVwcm9wKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PSBcIj9cIiB8fCB0eXBlMiA9PSBcIm51bWJlclwiIHx8IHR5cGUyID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICByZXR1cm4gY29udCh0eXBlcHJvcCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZTIgPT0gXCI6XCIpIHtcbiAgICAgICAgICByZXR1cm4gY29udCh0eXBlZXhwcik7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZTIgPT0gXCJbXCIpIHtcbiAgICAgICAgICByZXR1cm4gY29udChleHBlY3QoXCJ2YXJpYWJsZVwiKSwgbWF5YmV0eXBlT3JJbiwgZXhwZWN0KFwiXVwiKSwgdHlwZXByb3ApO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUyID09IFwiKFwiKSB7XG4gICAgICAgICAgcmV0dXJuIHBhc3MoZnVuY3Rpb25kZWNsLCB0eXBlcHJvcCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXR5cGUyLm1hdGNoKC9bO1xcfVxcKVxcXSxdLykpIHtcbiAgICAgICAgICByZXR1cm4gY29udCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBfX25hbWUodHlwZXByb3AsIFwidHlwZXByb3BcIik7XG4gICAgICBmdW5jdGlvbiBxdWFzaVR5cGUodHlwZTIsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlMiAhPSBcInF1YXNpXCIpXG4gICAgICAgICAgcmV0dXJuIHBhc3MoKTtcbiAgICAgICAgaWYgKHZhbHVlLnNsaWNlKHZhbHVlLmxlbmd0aCAtIDIpICE9IFwiJHtcIilcbiAgICAgICAgICByZXR1cm4gY29udChxdWFzaVR5cGUpO1xuICAgICAgICByZXR1cm4gY29udCh0eXBlZXhwciwgY29udGludWVRdWFzaVR5cGUpO1xuICAgICAgfVxuICAgICAgX19uYW1lKHF1YXNpVHlwZSwgXCJxdWFzaVR5cGVcIik7XG4gICAgICBmdW5jdGlvbiBjb250aW51ZVF1YXNpVHlwZSh0eXBlMikge1xuICAgICAgICBpZiAodHlwZTIgPT0gXCJ9XCIpIHtcbiAgICAgICAgICBjeC5tYXJrZWQgPSBcInN0cmluZy0yXCI7XG4gICAgICAgICAgY3guc3RhdGUudG9rZW5pemUgPSB0b2tlblF1YXNpO1xuICAgICAgICAgIHJldHVybiBjb250KHF1YXNpVHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF9fbmFtZShjb250aW51ZVF1YXNpVHlwZSwgXCJjb250aW51ZVF1YXNpVHlwZVwiKTtcbiAgICAgIGZ1bmN0aW9uIHR5cGVhcmcodHlwZTIsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlMiA9PSBcInZhcmlhYmxlXCIgJiYgY3guc3RyZWFtLm1hdGNoKC9eXFxzKls/Ol0vLCBmYWxzZSkgfHwgdmFsdWUgPT0gXCI/XCIpXG4gICAgICAgICAgcmV0dXJuIGNvbnQodHlwZWFyZyk7XG4gICAgICAgIGlmICh0eXBlMiA9PSBcIjpcIilcbiAgICAgICAgICByZXR1cm4gY29udCh0eXBlZXhwcik7XG4gICAgICAgIGlmICh0eXBlMiA9PSBcInNwcmVhZFwiKVxuICAgICAgICAgIHJldHVybiBjb250KHR5cGVhcmcpO1xuICAgICAgICByZXR1cm4gcGFzcyh0eXBlZXhwcik7XG4gICAgICB9XG4gICAgICBfX25hbWUodHlwZWFyZywgXCJ0eXBlYXJnXCIpO1xuICAgICAgZnVuY3Rpb24gYWZ0ZXJUeXBlKHR5cGUyLCB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT0gXCI8XCIpXG4gICAgICAgICAgcmV0dXJuIGNvbnQocHVzaGxleChcIj5cIiksIGNvbW1hc2VwKHR5cGVleHByLCBcIj5cIiksIHBvcGxleCwgYWZ0ZXJUeXBlKTtcbiAgICAgICAgaWYgKHZhbHVlID09IFwifFwiIHx8IHR5cGUyID09IFwiLlwiIHx8IHZhbHVlID09IFwiJlwiKVxuICAgICAgICAgIHJldHVybiBjb250KHR5cGVleHByKTtcbiAgICAgICAgaWYgKHR5cGUyID09IFwiW1wiKVxuICAgICAgICAgIHJldHVybiBjb250KHR5cGVleHByLCBleHBlY3QoXCJdXCIpLCBhZnRlclR5cGUpO1xuICAgICAgICBpZiAodmFsdWUgPT0gXCJleHRlbmRzXCIgfHwgdmFsdWUgPT0gXCJpbXBsZW1lbnRzXCIpIHtcbiAgICAgICAgICBjeC5tYXJrZWQgPSBcImtleXdvcmRcIjtcbiAgICAgICAgICByZXR1cm4gY29udCh0eXBlZXhwcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID09IFwiP1wiKVxuICAgICAgICAgIHJldHVybiBjb250KHR5cGVleHByLCBleHBlY3QoXCI6XCIpLCB0eXBlZXhwcik7XG4gICAgICB9XG4gICAgICBfX25hbWUoYWZ0ZXJUeXBlLCBcImFmdGVyVHlwZVwiKTtcbiAgICAgIGZ1bmN0aW9uIG1heWJlVHlwZUFyZ3MoXywgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IFwiPFwiKVxuICAgICAgICAgIHJldHVybiBjb250KHB1c2hsZXgoXCI+XCIpLCBjb21tYXNlcCh0eXBlZXhwciwgXCI+XCIpLCBwb3BsZXgsIGFmdGVyVHlwZSk7XG4gICAgICB9XG4gICAgICBfX25hbWUobWF5YmVUeXBlQXJncywgXCJtYXliZVR5cGVBcmdzXCIpO1xuICAgICAgZnVuY3Rpb24gdHlwZXBhcmFtKCkge1xuICAgICAgICByZXR1cm4gcGFzcyh0eXBlZXhwciwgbWF5YmVUeXBlRGVmYXVsdCk7XG4gICAgICB9XG4gICAgICBfX25hbWUodHlwZXBhcmFtLCBcInR5cGVwYXJhbVwiKTtcbiAgICAgIGZ1bmN0aW9uIG1heWJlVHlwZURlZmF1bHQoXywgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IFwiPVwiKVxuICAgICAgICAgIHJldHVybiBjb250KHR5cGVleHByKTtcbiAgICAgIH1cbiAgICAgIF9fbmFtZShtYXliZVR5cGVEZWZhdWx0LCBcIm1heWJlVHlwZURlZmF1bHRcIik7XG4gICAgICBmdW5jdGlvbiB2YXJkZWYoXywgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IFwiZW51bVwiKSB7XG4gICAgICAgICAgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7XG4gICAgICAgICAgcmV0dXJuIGNvbnQoZW51bWRlZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhc3MocGF0dGVybiwgbWF5YmV0eXBlLCBtYXliZUFzc2lnbiwgdmFyZGVmQ29udCk7XG4gICAgICB9XG4gICAgICBfX25hbWUodmFyZGVmLCBcInZhcmRlZlwiKTtcbiAgICAgIGZ1bmN0aW9uIHBhdHRlcm4odHlwZTIsIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc1RTICYmIGlzTW9kaWZpZXIodmFsdWUpKSB7XG4gICAgICAgICAgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7XG4gICAgICAgICAgcmV0dXJuIGNvbnQocGF0dGVybik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUyID09IFwidmFyaWFibGVcIikge1xuICAgICAgICAgIHJlZ2lzdGVyKHZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gY29udCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlMiA9PSBcInNwcmVhZFwiKVxuICAgICAgICAgIHJldHVybiBjb250KHBhdHRlcm4pO1xuICAgICAgICBpZiAodHlwZTIgPT0gXCJbXCIpXG4gICAgICAgICAgcmV0dXJuIGNvbnRDb21tYXNlcChlbHRwYXR0ZXJuLCBcIl1cIik7XG4gICAgICAgIGlmICh0eXBlMiA9PSBcIntcIilcbiAgICAgICAgICByZXR1cm4gY29udENvbW1hc2VwKHByb3BwYXR0ZXJuLCBcIn1cIik7XG4gICAgICB9XG4gICAgICBfX25hbWUocGF0dGVybiwgXCJwYXR0ZXJuXCIpO1xuICAgICAgZnVuY3Rpb24gcHJvcHBhdHRlcm4odHlwZTIsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlMiA9PSBcInZhcmlhYmxlXCIgJiYgIWN4LnN0cmVhbS5tYXRjaCgvXlxccyo6LywgZmFsc2UpKSB7XG4gICAgICAgICAgcmVnaXN0ZXIodmFsdWUpO1xuICAgICAgICAgIHJldHVybiBjb250KG1heWJlQXNzaWduKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZTIgPT0gXCJ2YXJpYWJsZVwiKVxuICAgICAgICAgIGN4Lm1hcmtlZCA9IFwicHJvcGVydHlcIjtcbiAgICAgICAgaWYgKHR5cGUyID09IFwic3ByZWFkXCIpXG4gICAgICAgICAgcmV0dXJuIGNvbnQocGF0dGVybik7XG4gICAgICAgIGlmICh0eXBlMiA9PSBcIn1cIilcbiAgICAgICAgICByZXR1cm4gcGFzcygpO1xuICAgICAgICBpZiAodHlwZTIgPT0gXCJbXCIpXG4gICAgICAgICAgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbiwgZXhwZWN0KFwiXVwiKSwgZXhwZWN0KFwiOlwiKSwgcHJvcHBhdHRlcm4pO1xuICAgICAgICByZXR1cm4gY29udChleHBlY3QoXCI6XCIpLCBwYXR0ZXJuLCBtYXliZUFzc2lnbik7XG4gICAgICB9XG4gICAgICBfX25hbWUocHJvcHBhdHRlcm4sIFwicHJvcHBhdHRlcm5cIik7XG4gICAgICBmdW5jdGlvbiBlbHRwYXR0ZXJuKCkge1xuICAgICAgICByZXR1cm4gcGFzcyhwYXR0ZXJuLCBtYXliZUFzc2lnbik7XG4gICAgICB9XG4gICAgICBfX25hbWUoZWx0cGF0dGVybiwgXCJlbHRwYXR0ZXJuXCIpO1xuICAgICAgZnVuY3Rpb24gbWF5YmVBc3NpZ24oX3R5cGUsIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBcIj1cIilcbiAgICAgICAgICByZXR1cm4gY29udChleHByZXNzaW9uTm9Db21tYSk7XG4gICAgICB9XG4gICAgICBfX25hbWUobWF5YmVBc3NpZ24sIFwibWF5YmVBc3NpZ25cIik7XG4gICAgICBmdW5jdGlvbiB2YXJkZWZDb250KHR5cGUyKSB7XG4gICAgICAgIGlmICh0eXBlMiA9PSBcIixcIilcbiAgICAgICAgICByZXR1cm4gY29udCh2YXJkZWYpO1xuICAgICAgfVxuICAgICAgX19uYW1lKHZhcmRlZkNvbnQsIFwidmFyZGVmQ29udFwiKTtcbiAgICAgIGZ1bmN0aW9uIG1heWJlZWxzZSh0eXBlMiwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGUyID09IFwia2V5d29yZCBiXCIgJiYgdmFsdWUgPT0gXCJlbHNlXCIpXG4gICAgICAgICAgcmV0dXJuIGNvbnQocHVzaGxleChcImZvcm1cIiwgXCJlbHNlXCIpLCBzdGF0ZW1lbnQsIHBvcGxleCk7XG4gICAgICB9XG4gICAgICBfX25hbWUobWF5YmVlbHNlLCBcIm1heWJlZWxzZVwiKTtcbiAgICAgIGZ1bmN0aW9uIGZvcnNwZWModHlwZTIsIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBcImF3YWl0XCIpXG4gICAgICAgICAgcmV0dXJuIGNvbnQoZm9yc3BlYyk7XG4gICAgICAgIGlmICh0eXBlMiA9PSBcIihcIilcbiAgICAgICAgICByZXR1cm4gY29udChwdXNobGV4KFwiKVwiKSwgZm9yc3BlYzEsIHBvcGxleCk7XG4gICAgICB9XG4gICAgICBfX25hbWUoZm9yc3BlYywgXCJmb3JzcGVjXCIpO1xuICAgICAgZnVuY3Rpb24gZm9yc3BlYzEodHlwZTIpIHtcbiAgICAgICAgaWYgKHR5cGUyID09IFwidmFyXCIpXG4gICAgICAgICAgcmV0dXJuIGNvbnQodmFyZGVmLCBmb3JzcGVjMik7XG4gICAgICAgIGlmICh0eXBlMiA9PSBcInZhcmlhYmxlXCIpXG4gICAgICAgICAgcmV0dXJuIGNvbnQoZm9yc3BlYzIpO1xuICAgICAgICByZXR1cm4gcGFzcyhmb3JzcGVjMik7XG4gICAgICB9XG4gICAgICBfX25hbWUoZm9yc3BlYzEsIFwiZm9yc3BlYzFcIik7XG4gICAgICBmdW5jdGlvbiBmb3JzcGVjMih0eXBlMiwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGUyID09IFwiKVwiKVxuICAgICAgICAgIHJldHVybiBjb250KCk7XG4gICAgICAgIGlmICh0eXBlMiA9PSBcIjtcIilcbiAgICAgICAgICByZXR1cm4gY29udChmb3JzcGVjMik7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBcImluXCIgfHwgdmFsdWUgPT0gXCJvZlwiKSB7XG4gICAgICAgICAgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7XG4gICAgICAgICAgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbiwgZm9yc3BlYzIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXNzKGV4cHJlc3Npb24sIGZvcnNwZWMyKTtcbiAgICAgIH1cbiAgICAgIF9fbmFtZShmb3JzcGVjMiwgXCJmb3JzcGVjMlwiKTtcbiAgICAgIGZ1bmN0aW9uIGZ1bmN0aW9uZGVmKHR5cGUyLCB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT0gXCIqXCIpIHtcbiAgICAgICAgICBjeC5tYXJrZWQgPSBcImtleXdvcmRcIjtcbiAgICAgICAgICByZXR1cm4gY29udChmdW5jdGlvbmRlZik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUyID09IFwidmFyaWFibGVcIikge1xuICAgICAgICAgIHJlZ2lzdGVyKHZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gY29udChmdW5jdGlvbmRlZik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUyID09IFwiKFwiKVxuICAgICAgICAgIHJldHVybiBjb250KHB1c2hjb250ZXh0LCBwdXNobGV4KFwiKVwiKSwgY29tbWFzZXAoZnVuYXJnLCBcIilcIiksIHBvcGxleCwgbWF5YmVyZXR0eXBlLCBzdGF0ZW1lbnQsIHBvcGNvbnRleHQpO1xuICAgICAgICBpZiAoaXNUUyAmJiB2YWx1ZSA9PSBcIjxcIilcbiAgICAgICAgICByZXR1cm4gY29udChwdXNobGV4KFwiPlwiKSwgY29tbWFzZXAodHlwZXBhcmFtLCBcIj5cIiksIHBvcGxleCwgZnVuY3Rpb25kZWYpO1xuICAgICAgfVxuICAgICAgX19uYW1lKGZ1bmN0aW9uZGVmLCBcImZ1bmN0aW9uZGVmXCIpO1xuICAgICAgZnVuY3Rpb24gZnVuY3Rpb25kZWNsKHR5cGUyLCB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT0gXCIqXCIpIHtcbiAgICAgICAgICBjeC5tYXJrZWQgPSBcImtleXdvcmRcIjtcbiAgICAgICAgICByZXR1cm4gY29udChmdW5jdGlvbmRlY2wpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlMiA9PSBcInZhcmlhYmxlXCIpIHtcbiAgICAgICAgICByZWdpc3Rlcih2YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIGNvbnQoZnVuY3Rpb25kZWNsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZTIgPT0gXCIoXCIpXG4gICAgICAgICAgcmV0dXJuIGNvbnQocHVzaGNvbnRleHQsIHB1c2hsZXgoXCIpXCIpLCBjb21tYXNlcChmdW5hcmcsIFwiKVwiKSwgcG9wbGV4LCBtYXliZXJldHR5cGUsIHBvcGNvbnRleHQpO1xuICAgICAgICBpZiAoaXNUUyAmJiB2YWx1ZSA9PSBcIjxcIilcbiAgICAgICAgICByZXR1cm4gY29udChwdXNobGV4KFwiPlwiKSwgY29tbWFzZXAodHlwZXBhcmFtLCBcIj5cIiksIHBvcGxleCwgZnVuY3Rpb25kZWNsKTtcbiAgICAgIH1cbiAgICAgIF9fbmFtZShmdW5jdGlvbmRlY2wsIFwiZnVuY3Rpb25kZWNsXCIpO1xuICAgICAgZnVuY3Rpb24gdHlwZW5hbWUodHlwZTIsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlMiA9PSBcImtleXdvcmRcIiB8fCB0eXBlMiA9PSBcInZhcmlhYmxlXCIpIHtcbiAgICAgICAgICBjeC5tYXJrZWQgPSBcInR5cGVcIjtcbiAgICAgICAgICByZXR1cm4gY29udCh0eXBlbmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT0gXCI8XCIpIHtcbiAgICAgICAgICByZXR1cm4gY29udChwdXNobGV4KFwiPlwiKSwgY29tbWFzZXAodHlwZXBhcmFtLCBcIj5cIiksIHBvcGxleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF9fbmFtZSh0eXBlbmFtZSwgXCJ0eXBlbmFtZVwiKTtcbiAgICAgIGZ1bmN0aW9uIGZ1bmFyZyh0eXBlMiwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IFwiQFwiKVxuICAgICAgICAgIGNvbnQoZXhwcmVzc2lvbiwgZnVuYXJnKTtcbiAgICAgICAgaWYgKHR5cGUyID09IFwic3ByZWFkXCIpXG4gICAgICAgICAgcmV0dXJuIGNvbnQoZnVuYXJnKTtcbiAgICAgICAgaWYgKGlzVFMgJiYgaXNNb2RpZmllcih2YWx1ZSkpIHtcbiAgICAgICAgICBjeC5tYXJrZWQgPSBcImtleXdvcmRcIjtcbiAgICAgICAgICByZXR1cm4gY29udChmdW5hcmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1RTICYmIHR5cGUyID09IFwidGhpc1wiKVxuICAgICAgICAgIHJldHVybiBjb250KG1heWJldHlwZSwgbWF5YmVBc3NpZ24pO1xuICAgICAgICByZXR1cm4gcGFzcyhwYXR0ZXJuLCBtYXliZXR5cGUsIG1heWJlQXNzaWduKTtcbiAgICAgIH1cbiAgICAgIF9fbmFtZShmdW5hcmcsIFwiZnVuYXJnXCIpO1xuICAgICAgZnVuY3Rpb24gY2xhc3NFeHByZXNzaW9uKHR5cGUyLCB2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZTIgPT0gXCJ2YXJpYWJsZVwiKVxuICAgICAgICAgIHJldHVybiBjbGFzc05hbWUodHlwZTIsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGNsYXNzTmFtZUFmdGVyKHR5cGUyLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBfX25hbWUoY2xhc3NFeHByZXNzaW9uLCBcImNsYXNzRXhwcmVzc2lvblwiKTtcbiAgICAgIGZ1bmN0aW9uIGNsYXNzTmFtZSh0eXBlMiwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGUyID09IFwidmFyaWFibGVcIikge1xuICAgICAgICAgIHJlZ2lzdGVyKHZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gY29udChjbGFzc05hbWVBZnRlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF9fbmFtZShjbGFzc05hbWUsIFwiY2xhc3NOYW1lXCIpO1xuICAgICAgZnVuY3Rpb24gY2xhc3NOYW1lQWZ0ZXIodHlwZTIsIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBcIjxcIilcbiAgICAgICAgICByZXR1cm4gY29udChwdXNobGV4KFwiPlwiKSwgY29tbWFzZXAodHlwZXBhcmFtLCBcIj5cIiksIHBvcGxleCwgY2xhc3NOYW1lQWZ0ZXIpO1xuICAgICAgICBpZiAodmFsdWUgPT0gXCJleHRlbmRzXCIgfHwgdmFsdWUgPT0gXCJpbXBsZW1lbnRzXCIgfHwgaXNUUyAmJiB0eXBlMiA9PSBcIixcIikge1xuICAgICAgICAgIGlmICh2YWx1ZSA9PSBcImltcGxlbWVudHNcIilcbiAgICAgICAgICAgIGN4Lm1hcmtlZCA9IFwia2V5d29yZFwiO1xuICAgICAgICAgIHJldHVybiBjb250KGlzVFMgPyB0eXBlZXhwciA6IGV4cHJlc3Npb24sIGNsYXNzTmFtZUFmdGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZTIgPT0gXCJ7XCIpXG4gICAgICAgICAgcmV0dXJuIGNvbnQocHVzaGxleChcIn1cIiksIGNsYXNzQm9keSwgcG9wbGV4KTtcbiAgICAgIH1cbiAgICAgIF9fbmFtZShjbGFzc05hbWVBZnRlciwgXCJjbGFzc05hbWVBZnRlclwiKTtcbiAgICAgIGZ1bmN0aW9uIGNsYXNzQm9keSh0eXBlMiwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGUyID09IFwiYXN5bmNcIiB8fCB0eXBlMiA9PSBcInZhcmlhYmxlXCIgJiYgKHZhbHVlID09IFwic3RhdGljXCIgfHwgdmFsdWUgPT0gXCJnZXRcIiB8fCB2YWx1ZSA9PSBcInNldFwiIHx8IGlzVFMgJiYgaXNNb2RpZmllcih2YWx1ZSkpICYmIGN4LnN0cmVhbS5tYXRjaCgvXlxccytbXFx3JFxceGExLVxcdWZmZmZdLywgZmFsc2UpKSB7XG4gICAgICAgICAgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7XG4gICAgICAgICAgcmV0dXJuIGNvbnQoY2xhc3NCb2R5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZTIgPT0gXCJ2YXJpYWJsZVwiIHx8IGN4LnN0eWxlID09IFwia2V5d29yZFwiKSB7XG4gICAgICAgICAgY3gubWFya2VkID0gXCJwcm9wZXJ0eVwiO1xuICAgICAgICAgIHJldHVybiBjb250KGNsYXNzZmllbGQsIGNsYXNzQm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUyID09IFwibnVtYmVyXCIgfHwgdHlwZTIgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICByZXR1cm4gY29udChjbGFzc2ZpZWxkLCBjbGFzc0JvZHkpO1xuICAgICAgICBpZiAodHlwZTIgPT0gXCJbXCIpXG4gICAgICAgICAgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbiwgbWF5YmV0eXBlLCBleHBlY3QoXCJdXCIpLCBjbGFzc2ZpZWxkLCBjbGFzc0JvZHkpO1xuICAgICAgICBpZiAodmFsdWUgPT0gXCIqXCIpIHtcbiAgICAgICAgICBjeC5tYXJrZWQgPSBcImtleXdvcmRcIjtcbiAgICAgICAgICByZXR1cm4gY29udChjbGFzc0JvZHkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1RTICYmIHR5cGUyID09IFwiKFwiKVxuICAgICAgICAgIHJldHVybiBwYXNzKGZ1bmN0aW9uZGVjbCwgY2xhc3NCb2R5KTtcbiAgICAgICAgaWYgKHR5cGUyID09IFwiO1wiIHx8IHR5cGUyID09IFwiLFwiKVxuICAgICAgICAgIHJldHVybiBjb250KGNsYXNzQm9keSk7XG4gICAgICAgIGlmICh0eXBlMiA9PSBcIn1cIilcbiAgICAgICAgICByZXR1cm4gY29udCgpO1xuICAgICAgICBpZiAodmFsdWUgPT0gXCJAXCIpXG4gICAgICAgICAgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbiwgY2xhc3NCb2R5KTtcbiAgICAgIH1cbiAgICAgIF9fbmFtZShjbGFzc0JvZHksIFwiY2xhc3NCb2R5XCIpO1xuICAgICAgZnVuY3Rpb24gY2xhc3NmaWVsZCh0eXBlMiwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IFwiIVwiKVxuICAgICAgICAgIHJldHVybiBjb250KGNsYXNzZmllbGQpO1xuICAgICAgICBpZiAodmFsdWUgPT0gXCI/XCIpXG4gICAgICAgICAgcmV0dXJuIGNvbnQoY2xhc3NmaWVsZCk7XG4gICAgICAgIGlmICh0eXBlMiA9PSBcIjpcIilcbiAgICAgICAgICByZXR1cm4gY29udCh0eXBlZXhwciwgbWF5YmVBc3NpZ24pO1xuICAgICAgICBpZiAodmFsdWUgPT0gXCI9XCIpXG4gICAgICAgICAgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbk5vQ29tbWEpO1xuICAgICAgICB2YXIgY29udGV4dCA9IGN4LnN0YXRlLmxleGljYWwucHJldiwgaXNJbnRlcmZhY2UgPSBjb250ZXh0ICYmIGNvbnRleHQuaW5mbyA9PSBcImludGVyZmFjZVwiO1xuICAgICAgICByZXR1cm4gcGFzcyhpc0ludGVyZmFjZSA/IGZ1bmN0aW9uZGVjbCA6IGZ1bmN0aW9uZGVmKTtcbiAgICAgIH1cbiAgICAgIF9fbmFtZShjbGFzc2ZpZWxkLCBcImNsYXNzZmllbGRcIik7XG4gICAgICBmdW5jdGlvbiBhZnRlckV4cG9ydCh0eXBlMiwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IFwiKlwiKSB7XG4gICAgICAgICAgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7XG4gICAgICAgICAgcmV0dXJuIGNvbnQobWF5YmVGcm9tLCBleHBlY3QoXCI7XCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPT0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgICBjeC5tYXJrZWQgPSBcImtleXdvcmRcIjtcbiAgICAgICAgICByZXR1cm4gY29udChleHByZXNzaW9uLCBleHBlY3QoXCI7XCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZTIgPT0gXCJ7XCIpXG4gICAgICAgICAgcmV0dXJuIGNvbnQoY29tbWFzZXAoZXhwb3J0RmllbGQsIFwifVwiKSwgbWF5YmVGcm9tLCBleHBlY3QoXCI7XCIpKTtcbiAgICAgICAgcmV0dXJuIHBhc3Moc3RhdGVtZW50KTtcbiAgICAgIH1cbiAgICAgIF9fbmFtZShhZnRlckV4cG9ydCwgXCJhZnRlckV4cG9ydFwiKTtcbiAgICAgIGZ1bmN0aW9uIGV4cG9ydEZpZWxkKHR5cGUyLCB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT0gXCJhc1wiKSB7XG4gICAgICAgICAgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7XG4gICAgICAgICAgcmV0dXJuIGNvbnQoZXhwZWN0KFwidmFyaWFibGVcIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlMiA9PSBcInZhcmlhYmxlXCIpXG4gICAgICAgICAgcmV0dXJuIHBhc3MoZXhwcmVzc2lvbk5vQ29tbWEsIGV4cG9ydEZpZWxkKTtcbiAgICAgIH1cbiAgICAgIF9fbmFtZShleHBvcnRGaWVsZCwgXCJleHBvcnRGaWVsZFwiKTtcbiAgICAgIGZ1bmN0aW9uIGFmdGVySW1wb3J0KHR5cGUyKSB7XG4gICAgICAgIGlmICh0eXBlMiA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgIHJldHVybiBjb250KCk7XG4gICAgICAgIGlmICh0eXBlMiA9PSBcIihcIilcbiAgICAgICAgICByZXR1cm4gcGFzcyhleHByZXNzaW9uKTtcbiAgICAgICAgaWYgKHR5cGUyID09IFwiLlwiKVxuICAgICAgICAgIHJldHVybiBwYXNzKG1heWJlb3BlcmF0b3JDb21tYSk7XG4gICAgICAgIHJldHVybiBwYXNzKGltcG9ydFNwZWMsIG1heWJlTW9yZUltcG9ydHMsIG1heWJlRnJvbSk7XG4gICAgICB9XG4gICAgICBfX25hbWUoYWZ0ZXJJbXBvcnQsIFwiYWZ0ZXJJbXBvcnRcIik7XG4gICAgICBmdW5jdGlvbiBpbXBvcnRTcGVjKHR5cGUyLCB2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZTIgPT0gXCJ7XCIpXG4gICAgICAgICAgcmV0dXJuIGNvbnRDb21tYXNlcChpbXBvcnRTcGVjLCBcIn1cIik7XG4gICAgICAgIGlmICh0eXBlMiA9PSBcInZhcmlhYmxlXCIpXG4gICAgICAgICAgcmVnaXN0ZXIodmFsdWUpO1xuICAgICAgICBpZiAodmFsdWUgPT0gXCIqXCIpXG4gICAgICAgICAgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7XG4gICAgICAgIHJldHVybiBjb250KG1heWJlQXMpO1xuICAgICAgfVxuICAgICAgX19uYW1lKGltcG9ydFNwZWMsIFwiaW1wb3J0U3BlY1wiKTtcbiAgICAgIGZ1bmN0aW9uIG1heWJlTW9yZUltcG9ydHModHlwZTIpIHtcbiAgICAgICAgaWYgKHR5cGUyID09IFwiLFwiKVxuICAgICAgICAgIHJldHVybiBjb250KGltcG9ydFNwZWMsIG1heWJlTW9yZUltcG9ydHMpO1xuICAgICAgfVxuICAgICAgX19uYW1lKG1heWJlTW9yZUltcG9ydHMsIFwibWF5YmVNb3JlSW1wb3J0c1wiKTtcbiAgICAgIGZ1bmN0aW9uIG1heWJlQXMoX3R5cGUsIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBcImFzXCIpIHtcbiAgICAgICAgICBjeC5tYXJrZWQgPSBcImtleXdvcmRcIjtcbiAgICAgICAgICByZXR1cm4gY29udChpbXBvcnRTcGVjKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX19uYW1lKG1heWJlQXMsIFwibWF5YmVBc1wiKTtcbiAgICAgIGZ1bmN0aW9uIG1heWJlRnJvbShfdHlwZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IFwiZnJvbVwiKSB7XG4gICAgICAgICAgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7XG4gICAgICAgICAgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF9fbmFtZShtYXliZUZyb20sIFwibWF5YmVGcm9tXCIpO1xuICAgICAgZnVuY3Rpb24gYXJyYXlMaXRlcmFsKHR5cGUyKSB7XG4gICAgICAgIGlmICh0eXBlMiA9PSBcIl1cIilcbiAgICAgICAgICByZXR1cm4gY29udCgpO1xuICAgICAgICByZXR1cm4gcGFzcyhjb21tYXNlcChleHByZXNzaW9uTm9Db21tYSwgXCJdXCIpKTtcbiAgICAgIH1cbiAgICAgIF9fbmFtZShhcnJheUxpdGVyYWwsIFwiYXJyYXlMaXRlcmFsXCIpO1xuICAgICAgZnVuY3Rpb24gZW51bWRlZigpIHtcbiAgICAgICAgcmV0dXJuIHBhc3MocHVzaGxleChcImZvcm1cIiksIHBhdHRlcm4sIGV4cGVjdChcIntcIiksIHB1c2hsZXgoXCJ9XCIpLCBjb21tYXNlcChlbnVtbWVtYmVyLCBcIn1cIiksIHBvcGxleCwgcG9wbGV4KTtcbiAgICAgIH1cbiAgICAgIF9fbmFtZShlbnVtZGVmLCBcImVudW1kZWZcIik7XG4gICAgICBmdW5jdGlvbiBlbnVtbWVtYmVyKCkge1xuICAgICAgICByZXR1cm4gcGFzcyhwYXR0ZXJuLCBtYXliZUFzc2lnbik7XG4gICAgICB9XG4gICAgICBfX25hbWUoZW51bW1lbWJlciwgXCJlbnVtbWVtYmVyXCIpO1xuICAgICAgZnVuY3Rpb24gaXNDb250aW51ZWRTdGF0ZW1lbnQoc3RhdGUsIHRleHRBZnRlcikge1xuICAgICAgICByZXR1cm4gc3RhdGUubGFzdFR5cGUgPT0gXCJvcGVyYXRvclwiIHx8IHN0YXRlLmxhc3RUeXBlID09IFwiLFwiIHx8IGlzT3BlcmF0b3JDaGFyLnRlc3QodGV4dEFmdGVyLmNoYXJBdCgwKSkgfHwgL1ssLl0vLnRlc3QodGV4dEFmdGVyLmNoYXJBdCgwKSk7XG4gICAgICB9XG4gICAgICBfX25hbWUoaXNDb250aW51ZWRTdGF0ZW1lbnQsIFwiaXNDb250aW51ZWRTdGF0ZW1lbnRcIik7XG4gICAgICBmdW5jdGlvbiBleHByZXNzaW9uQWxsb3dlZChzdHJlYW0sIHN0YXRlLCBiYWNrVXApIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplID09IHRva2VuQmFzZSAmJiAvXig/Om9wZXJhdG9yfHNvZnxrZXl3b3JkIFtiY2RdfGNhc2V8bmV3fGV4cG9ydHxkZWZhdWx0fHNwcmVhZHxbXFxbe31cXCgsOzpdfD0+KSQvLnRlc3Qoc3RhdGUubGFzdFR5cGUpIHx8IHN0YXRlLmxhc3RUeXBlID09IFwicXVhc2lcIiAmJiAvXFx7XFxzKiQvLnRlc3Qoc3RyZWFtLnN0cmluZy5zbGljZSgwLCBzdHJlYW0ucG9zIC0gKGJhY2tVcCB8fCAwKSkpO1xuICAgICAgfVxuICAgICAgX19uYW1lKGV4cHJlc3Npb25BbGxvd2VkLCBcImV4cHJlc3Npb25BbGxvd2VkXCIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oYmFzZWNvbHVtbikge1xuICAgICAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgICAgIHRva2VuaXplOiB0b2tlbkJhc2UsXG4gICAgICAgICAgICBsYXN0VHlwZTogXCJzb2ZcIixcbiAgICAgICAgICAgIGNjOiBbXSxcbiAgICAgICAgICAgIGxleGljYWw6IG5ldyBKU0xleGljYWwoKGJhc2Vjb2x1bW4gfHwgMCkgLSBpbmRlbnRVbml0LCAwLCBcImJsb2NrXCIsIGZhbHNlKSxcbiAgICAgICAgICAgIGxvY2FsVmFyczogcGFyc2VyQ29uZmlnLmxvY2FsVmFycyxcbiAgICAgICAgICAgIGNvbnRleHQ6IHBhcnNlckNvbmZpZy5sb2NhbFZhcnMgJiYgbmV3IENvbnRleHQobnVsbCwgbnVsbCwgZmFsc2UpLFxuICAgICAgICAgICAgaW5kZW50ZWQ6IGJhc2Vjb2x1bW4gfHwgMFxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKHBhcnNlckNvbmZpZy5nbG9iYWxWYXJzICYmIHR5cGVvZiBwYXJzZXJDb25maWcuZ2xvYmFsVmFycyA9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgc3RhdGUuZ2xvYmFsVmFycyA9IHBhcnNlckNvbmZpZy5nbG9iYWxWYXJzO1xuICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgICBpZiAoc3RyZWFtLnNvbCgpKSB7XG4gICAgICAgICAgICBpZiAoIXN0YXRlLmxleGljYWwuaGFzT3duUHJvcGVydHkoXCJhbGlnblwiKSlcbiAgICAgICAgICAgICAgc3RhdGUubGV4aWNhbC5hbGlnbiA9IGZhbHNlO1xuICAgICAgICAgICAgc3RhdGUuaW5kZW50ZWQgPSBzdHJlYW0uaW5kZW50YXRpb24oKTtcbiAgICAgICAgICAgIGZpbmRGYXRBcnJvdyhzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXRlLnRva2VuaXplICE9IHRva2VuQ29tbWVudCAmJiBzdHJlYW0uZWF0U3BhY2UoKSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIHZhciBzdHlsZSA9IHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICAgIGlmICh0eXBlID09IFwiY29tbWVudFwiKVxuICAgICAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgICAgIHN0YXRlLmxhc3RUeXBlID0gdHlwZSA9PSBcIm9wZXJhdG9yXCIgJiYgKGNvbnRlbnQgPT0gXCIrK1wiIHx8IGNvbnRlbnQgPT0gXCItLVwiKSA/IFwiaW5jZGVjXCIgOiB0eXBlO1xuICAgICAgICAgIHJldHVybiBwYXJzZUpTKHN0YXRlLCBzdHlsZSwgdHlwZSwgY29udGVudCwgc3RyZWFtKTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5kZW50OiBmdW5jdGlvbihzdGF0ZSwgdGV4dEFmdGVyKSB7XG4gICAgICAgICAgaWYgKHN0YXRlLnRva2VuaXplID09IHRva2VuQ29tbWVudCB8fCBzdGF0ZS50b2tlbml6ZSA9PSB0b2tlblF1YXNpKVxuICAgICAgICAgICAgcmV0dXJuIENvZGVNaXJyb3IuUGFzcztcbiAgICAgICAgICBpZiAoc3RhdGUudG9rZW5pemUgIT0gdG9rZW5CYXNlKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgdmFyIGZpcnN0Q2hhciA9IHRleHRBZnRlciAmJiB0ZXh0QWZ0ZXIuY2hhckF0KDApLCBsZXhpY2FsID0gc3RhdGUubGV4aWNhbCwgdG9wO1xuICAgICAgICAgIGlmICghL15cXHMqZWxzZVxcYi8udGVzdCh0ZXh0QWZ0ZXIpKVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YXRlLmNjLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgIHZhciBjID0gc3RhdGUuY2NbaV07XG4gICAgICAgICAgICAgIGlmIChjID09IHBvcGxleClcbiAgICAgICAgICAgICAgICBsZXhpY2FsID0gbGV4aWNhbC5wcmV2O1xuICAgICAgICAgICAgICBlbHNlIGlmIChjICE9IG1heWJlZWxzZSAmJiBjICE9IHBvcGNvbnRleHQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKChsZXhpY2FsLnR5cGUgPT0gXCJzdGF0XCIgfHwgbGV4aWNhbC50eXBlID09IFwiZm9ybVwiKSAmJiAoZmlyc3RDaGFyID09IFwifVwiIHx8ICh0b3AgPSBzdGF0ZS5jY1tzdGF0ZS5jYy5sZW5ndGggLSAxXSkgJiYgKHRvcCA9PSBtYXliZW9wZXJhdG9yQ29tbWEgfHwgdG9wID09IG1heWJlb3BlcmF0b3JOb0NvbW1hKSAmJiAhL15bLFxcLj0rXFwtKjo/W1xcKF0vLnRlc3QodGV4dEFmdGVyKSkpXG4gICAgICAgICAgICBsZXhpY2FsID0gbGV4aWNhbC5wcmV2O1xuICAgICAgICAgIGlmIChzdGF0ZW1lbnRJbmRlbnQgJiYgbGV4aWNhbC50eXBlID09IFwiKVwiICYmIGxleGljYWwucHJldi50eXBlID09IFwic3RhdFwiKVxuICAgICAgICAgICAgbGV4aWNhbCA9IGxleGljYWwucHJldjtcbiAgICAgICAgICB2YXIgdHlwZTIgPSBsZXhpY2FsLnR5cGUsIGNsb3NpbmcgPSBmaXJzdENoYXIgPT0gdHlwZTI7XG4gICAgICAgICAgaWYgKHR5cGUyID09IFwidmFyZGVmXCIpXG4gICAgICAgICAgICByZXR1cm4gbGV4aWNhbC5pbmRlbnRlZCArIChzdGF0ZS5sYXN0VHlwZSA9PSBcIm9wZXJhdG9yXCIgfHwgc3RhdGUubGFzdFR5cGUgPT0gXCIsXCIgPyBsZXhpY2FsLmluZm8ubGVuZ3RoICsgMSA6IDApO1xuICAgICAgICAgIGVsc2UgaWYgKHR5cGUyID09IFwiZm9ybVwiICYmIGZpcnN0Q2hhciA9PSBcIntcIilcbiAgICAgICAgICAgIHJldHVybiBsZXhpY2FsLmluZGVudGVkO1xuICAgICAgICAgIGVsc2UgaWYgKHR5cGUyID09IFwiZm9ybVwiKVxuICAgICAgICAgICAgcmV0dXJuIGxleGljYWwuaW5kZW50ZWQgKyBpbmRlbnRVbml0O1xuICAgICAgICAgIGVsc2UgaWYgKHR5cGUyID09IFwic3RhdFwiKVxuICAgICAgICAgICAgcmV0dXJuIGxleGljYWwuaW5kZW50ZWQgKyAoaXNDb250aW51ZWRTdGF0ZW1lbnQoc3RhdGUsIHRleHRBZnRlcikgPyBzdGF0ZW1lbnRJbmRlbnQgfHwgaW5kZW50VW5pdCA6IDApO1xuICAgICAgICAgIGVsc2UgaWYgKGxleGljYWwuaW5mbyA9PSBcInN3aXRjaFwiICYmICFjbG9zaW5nICYmIHBhcnNlckNvbmZpZy5kb3VibGVJbmRlbnRTd2l0Y2ggIT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm4gbGV4aWNhbC5pbmRlbnRlZCArICgvXig/OmNhc2V8ZGVmYXVsdClcXGIvLnRlc3QodGV4dEFmdGVyKSA/IGluZGVudFVuaXQgOiAyICogaW5kZW50VW5pdCk7XG4gICAgICAgICAgZWxzZSBpZiAobGV4aWNhbC5hbGlnbilcbiAgICAgICAgICAgIHJldHVybiBsZXhpY2FsLmNvbHVtbiArIChjbG9zaW5nID8gMCA6IDEpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBsZXhpY2FsLmluZGVudGVkICsgKGNsb3NpbmcgPyAwIDogaW5kZW50VW5pdCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVsZWN0cmljSW5wdXQ6IC9eXFxzKig/OmNhc2UgLio/OnxkZWZhdWx0OnxcXHt8XFx9KSQvLFxuICAgICAgICBibG9ja0NvbW1lbnRTdGFydDoganNvbk1vZGUgPyBudWxsIDogXCIvKlwiLFxuICAgICAgICBibG9ja0NvbW1lbnRFbmQ6IGpzb25Nb2RlID8gbnVsbCA6IFwiKi9cIixcbiAgICAgICAgYmxvY2tDb21tZW50Q29udGludWU6IGpzb25Nb2RlID8gbnVsbCA6IFwiICogXCIsXG4gICAgICAgIGxpbmVDb21tZW50OiBqc29uTW9kZSA/IG51bGwgOiBcIi8vXCIsXG4gICAgICAgIGZvbGQ6IFwiYnJhY2VcIixcbiAgICAgICAgY2xvc2VCcmFja2V0czogXCIoKVtde30nJ1xcXCJcXFwiYGBcIixcbiAgICAgICAgaGVscGVyVHlwZToganNvbk1vZGUgPyBcImpzb25cIiA6IFwiamF2YXNjcmlwdFwiLFxuICAgICAgICBqc29ubGRNb2RlLFxuICAgICAgICBqc29uTW9kZSxcbiAgICAgICAgZXhwcmVzc2lvbkFsbG93ZWQsXG4gICAgICAgIHNraXBFeHByZXNzaW9uOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgIHBhcnNlSlMoc3RhdGUsIFwiYXRvbVwiLCBcImF0b21cIiwgXCJ0cnVlXCIsIG5ldyBDb2RlTWlycm9yLlN0cmluZ1N0cmVhbShcIlwiLCAyLCBudWxsKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gICAgQ29kZU1pcnJvci5yZWdpc3RlckhlbHBlcihcIndvcmRDaGFyc1wiLCBcImphdmFzY3JpcHRcIiwgL1tcXHckXS8pO1xuICAgIENvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQvamF2YXNjcmlwdFwiLCBcImphdmFzY3JpcHRcIik7XG4gICAgQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC9lY21hc2NyaXB0XCIsIFwiamF2YXNjcmlwdFwiKTtcbiAgICBDb2RlTWlycm9yLmRlZmluZU1JTUUoXCJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0XCIsIFwiamF2YXNjcmlwdFwiKTtcbiAgICBDb2RlTWlycm9yLmRlZmluZU1JTUUoXCJhcHBsaWNhdGlvbi94LWphdmFzY3JpcHRcIiwgXCJqYXZhc2NyaXB0XCIpO1xuICAgIENvZGVNaXJyb3IuZGVmaW5lTUlNRShcImFwcGxpY2F0aW9uL2VjbWFzY3JpcHRcIiwgXCJqYXZhc2NyaXB0XCIpO1xuICAgIENvZGVNaXJyb3IuZGVmaW5lTUlNRShcImFwcGxpY2F0aW9uL2pzb25cIiwgeyBuYW1lOiBcImphdmFzY3JpcHRcIiwganNvbjogdHJ1ZSB9KTtcbiAgICBDb2RlTWlycm9yLmRlZmluZU1JTUUoXCJhcHBsaWNhdGlvbi94LWpzb25cIiwgeyBuYW1lOiBcImphdmFzY3JpcHRcIiwganNvbjogdHJ1ZSB9KTtcbiAgICBDb2RlTWlycm9yLmRlZmluZU1JTUUoXCJhcHBsaWNhdGlvbi9tYW5pZmVzdCtqc29uXCIsIHsgbmFtZTogXCJqYXZhc2NyaXB0XCIsIGpzb246IHRydWUgfSk7XG4gICAgQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwiYXBwbGljYXRpb24vbGQranNvblwiLCB7IG5hbWU6IFwiamF2YXNjcmlwdFwiLCBqc29ubGQ6IHRydWUgfSk7XG4gICAgQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC90eXBlc2NyaXB0XCIsIHsgbmFtZTogXCJqYXZhc2NyaXB0XCIsIHR5cGVzY3JpcHQ6IHRydWUgfSk7XG4gICAgQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwiYXBwbGljYXRpb24vdHlwZXNjcmlwdFwiLCB7IG5hbWU6IFwiamF2YXNjcmlwdFwiLCB0eXBlc2NyaXB0OiB0cnVlIH0pO1xuICB9KTtcbn0pKCk7XG52YXIgamF2YXNjcmlwdCA9IGphdmFzY3JpcHQkMi5leHBvcnRzO1xudmFyIGphdmFzY3JpcHQkMSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBfbWVyZ2VOYW1lc3BhY2VzKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBbU3ltYm9sLnRvU3RyaW5nVGFnXTogXCJNb2R1bGVcIixcbiAgXCJkZWZhdWx0XCI6IGphdmFzY3JpcHRcbn0sIFtqYXZhc2NyaXB0JDIuZXhwb3J0c10pKTtcbmV4cG9ydCB7IGphdmFzY3JpcHQkMSBhcyBqIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///89863\n')}}]);