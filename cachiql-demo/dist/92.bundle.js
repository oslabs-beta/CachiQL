"use strict";(self.webpackChunkcachiql_demo=self.webpackChunkcachiql_demo||[]).push([[92],{45092:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "c": () => (/* binding */ comment$1)\n/* harmony export */ });\n/* harmony import */ var _codemirror_es_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97480);\nvar __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, "name", { value, configurable: true });\n\nfunction _mergeNamespaces(n, m) {\n  m.forEach(function(e) {\n    e && typeof e !== "string" && !Array.isArray(e) && Object.keys(e).forEach(function(k) {\n      if (k !== "default" && !(k in n)) {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function() {\n            return e[k];\n          }\n        });\n      }\n    });\n  });\n  return Object.freeze(n);\n}\n__name(_mergeNamespaces, "_mergeNamespaces");\nvar comment$2 = { exports: {} };\n(function(module, exports) {\n  (function(mod) {\n    mod(_codemirror_es_js__WEBPACK_IMPORTED_MODULE_0__.a.exports);\n  })(function(CodeMirror) {\n    var noOptions = {};\n    var nonWS = /[^\\s\\u00a0]/;\n    var Pos = CodeMirror.Pos, cmp = CodeMirror.cmpPos;\n    function firstNonWS(str) {\n      var found = str.search(nonWS);\n      return found == -1 ? 0 : found;\n    }\n    __name(firstNonWS, "firstNonWS");\n    CodeMirror.commands.toggleComment = function(cm) {\n      cm.toggleComment();\n    };\n    CodeMirror.defineExtension("toggleComment", function(options) {\n      if (!options)\n        options = noOptions;\n      var cm = this;\n      var minLine = Infinity, ranges = this.listSelections(), mode = null;\n      for (var i = ranges.length - 1; i >= 0; i--) {\n        var from = ranges[i].from(), to = ranges[i].to();\n        if (from.line >= minLine)\n          continue;\n        if (to.line >= minLine)\n          to = Pos(minLine, 0);\n        minLine = from.line;\n        if (mode == null) {\n          if (cm.uncomment(from, to, options))\n            mode = "un";\n          else {\n            cm.lineComment(from, to, options);\n            mode = "line";\n          }\n        } else if (mode == "un") {\n          cm.uncomment(from, to, options);\n        } else {\n          cm.lineComment(from, to, options);\n        }\n      }\n    });\n    function probablyInsideString(cm, pos, line) {\n      return /\\bstring\\b/.test(cm.getTokenTypeAt(Pos(pos.line, 0))) && !/^[\\\'\\"\\`]/.test(line);\n    }\n    __name(probablyInsideString, "probablyInsideString");\n    function getMode(cm, pos) {\n      var mode = cm.getMode();\n      return mode.useInnerComments === false || !mode.innerMode ? mode : cm.getModeAt(pos);\n    }\n    __name(getMode, "getMode");\n    CodeMirror.defineExtension("lineComment", function(from, to, options) {\n      if (!options)\n        options = noOptions;\n      var self = this, mode = getMode(self, from);\n      var firstLine = self.getLine(from.line);\n      if (firstLine == null || probablyInsideString(self, from, firstLine))\n        return;\n      var commentString = options.lineComment || mode.lineComment;\n      if (!commentString) {\n        if (options.blockCommentStart || mode.blockCommentStart) {\n          options.fullLines = true;\n          self.blockComment(from, to, options);\n        }\n        return;\n      }\n      var end = Math.min(to.ch != 0 || to.line == from.line ? to.line + 1 : to.line, self.lastLine() + 1);\n      var pad = options.padding == null ? " " : options.padding;\n      var blankLines = options.commentBlankLines || from.line == to.line;\n      self.operation(function() {\n        if (options.indent) {\n          var baseString = null;\n          for (var i = from.line; i < end; ++i) {\n            var line = self.getLine(i);\n            var whitespace = line.slice(0, firstNonWS(line));\n            if (baseString == null || baseString.length > whitespace.length) {\n              baseString = whitespace;\n            }\n          }\n          for (var i = from.line; i < end; ++i) {\n            var line = self.getLine(i), cut = baseString.length;\n            if (!blankLines && !nonWS.test(line))\n              continue;\n            if (line.slice(0, cut) != baseString)\n              cut = firstNonWS(line);\n            self.replaceRange(baseString + commentString + pad, Pos(i, 0), Pos(i, cut));\n          }\n        } else {\n          for (var i = from.line; i < end; ++i) {\n            if (blankLines || nonWS.test(self.getLine(i)))\n              self.replaceRange(commentString + pad, Pos(i, 0));\n          }\n        }\n      });\n    });\n    CodeMirror.defineExtension("blockComment", function(from, to, options) {\n      if (!options)\n        options = noOptions;\n      var self = this, mode = getMode(self, from);\n      var startString = options.blockCommentStart || mode.blockCommentStart;\n      var endString = options.blockCommentEnd || mode.blockCommentEnd;\n      if (!startString || !endString) {\n        if ((options.lineComment || mode.lineComment) && options.fullLines != false)\n          self.lineComment(from, to, options);\n        return;\n      }\n      if (/\\bcomment\\b/.test(self.getTokenTypeAt(Pos(from.line, 0))))\n        return;\n      var end = Math.min(to.line, self.lastLine());\n      if (end != from.line && to.ch == 0 && nonWS.test(self.getLine(end)))\n        --end;\n      var pad = options.padding == null ? " " : options.padding;\n      if (from.line > end)\n        return;\n      self.operation(function() {\n        if (options.fullLines != false) {\n          var lastLineHasText = nonWS.test(self.getLine(end));\n          self.replaceRange(pad + endString, Pos(end));\n          self.replaceRange(startString + pad, Pos(from.line, 0));\n          var lead = options.blockCommentLead || mode.blockCommentLead;\n          if (lead != null) {\n            for (var i = from.line + 1; i <= end; ++i)\n              if (i != end || lastLineHasText)\n                self.replaceRange(lead + pad, Pos(i, 0));\n          }\n        } else {\n          var atCursor = cmp(self.getCursor("to"), to) == 0, empty = !self.somethingSelected();\n          self.replaceRange(endString, to);\n          if (atCursor)\n            self.setSelection(empty ? to : self.getCursor("from"), to);\n          self.replaceRange(startString, from);\n        }\n      });\n    });\n    CodeMirror.defineExtension("uncomment", function(from, to, options) {\n      if (!options)\n        options = noOptions;\n      var self = this, mode = getMode(self, from);\n      var end = Math.min(to.ch != 0 || to.line == from.line ? to.line : to.line - 1, self.lastLine()), start = Math.min(from.line, end);\n      var lineString = options.lineComment || mode.lineComment, lines = [];\n      var pad = options.padding == null ? " " : options.padding, didSomething;\n      lineComment: {\n        if (!lineString)\n          break lineComment;\n        for (var i = start; i <= end; ++i) {\n          var line = self.getLine(i);\n          var found = line.indexOf(lineString);\n          if (found > -1 && !/comment/.test(self.getTokenTypeAt(Pos(i, found + 1))))\n            found = -1;\n          if (found == -1 && nonWS.test(line))\n            break lineComment;\n          if (found > -1 && nonWS.test(line.slice(0, found)))\n            break lineComment;\n          lines.push(line);\n        }\n        self.operation(function() {\n          for (var i2 = start; i2 <= end; ++i2) {\n            var line2 = lines[i2 - start];\n            var pos = line2.indexOf(lineString), endPos = pos + lineString.length;\n            if (pos < 0)\n              continue;\n            if (line2.slice(endPos, endPos + pad.length) == pad)\n              endPos += pad.length;\n            didSomething = true;\n            self.replaceRange("", Pos(i2, pos), Pos(i2, endPos));\n          }\n        });\n        if (didSomething)\n          return true;\n      }\n      var startString = options.blockCommentStart || mode.blockCommentStart;\n      var endString = options.blockCommentEnd || mode.blockCommentEnd;\n      if (!startString || !endString)\n        return false;\n      var lead = options.blockCommentLead || mode.blockCommentLead;\n      var startLine = self.getLine(start), open = startLine.indexOf(startString);\n      if (open == -1)\n        return false;\n      var endLine = end == start ? startLine : self.getLine(end);\n      var close = endLine.indexOf(endString, end == start ? open + startString.length : 0);\n      var insideStart = Pos(start, open + 1), insideEnd = Pos(end, close + 1);\n      if (close == -1 || !/comment/.test(self.getTokenTypeAt(insideStart)) || !/comment/.test(self.getTokenTypeAt(insideEnd)) || self.getRange(insideStart, insideEnd, "\\n").indexOf(endString) > -1)\n        return false;\n      var lastStart = startLine.lastIndexOf(startString, from.ch);\n      var firstEnd = lastStart == -1 ? -1 : startLine.slice(0, from.ch).indexOf(endString, lastStart + startString.length);\n      if (lastStart != -1 && firstEnd != -1 && firstEnd + endString.length != from.ch)\n        return false;\n      firstEnd = endLine.indexOf(endString, to.ch);\n      var almostLastStart = endLine.slice(to.ch).lastIndexOf(startString, firstEnd - to.ch);\n      lastStart = firstEnd == -1 || almostLastStart == -1 ? -1 : to.ch + almostLastStart;\n      if (firstEnd != -1 && lastStart != -1 && lastStart != to.ch)\n        return false;\n      self.operation(function() {\n        self.replaceRange("", Pos(end, close - (pad && endLine.slice(close - pad.length, close) == pad ? pad.length : 0)), Pos(end, close + endString.length));\n        var openEnd = open + startString.length;\n        if (pad && startLine.slice(openEnd, openEnd + pad.length) == pad)\n          openEnd += pad.length;\n        self.replaceRange("", Pos(start, open), Pos(start, openEnd));\n        if (lead)\n          for (var i2 = start + 1; i2 <= end; ++i2) {\n            var line2 = self.getLine(i2), found2 = line2.indexOf(lead);\n            if (found2 == -1 || nonWS.test(line2.slice(0, found2)))\n              continue;\n            var foundEnd = found2 + lead.length;\n            if (pad && line2.slice(foundEnd, foundEnd + pad.length) == pad)\n              foundEnd += pad.length;\n            self.replaceRange("", Pos(i2, found2), Pos(i2, foundEnd));\n          }\n      });\n      return true;\n    });\n  });\n})();\nvar comment = comment$2.exports;\nvar comment$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  [Symbol.toStringTag]: "Module",\n  "default": comment\n}, [comment$2.exports]));\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDUwOTIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBLDREQUE0RCwyQkFBMkI7QUFDbEM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsUUFBUSx3REFBa0I7QUFDMUIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFVBQVU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFdBQVc7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsV0FBVztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYWNoaXFsLWRlbW8vLi9ub2RlX21vZHVsZXMvQGdyYXBoaXFsL3JlYWN0L2Rpc3QvY29tbWVudC5lcy5qcz83N2QzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19uYW1lID0gKHRhcmdldCwgdmFsdWUpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwibmFtZVwiLCB7IHZhbHVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG5pbXBvcnQgeyBhIGFzIGNvZGVtaXJyb3IgfSBmcm9tIFwiLi9jb2RlbWlycm9yLmVzLmpzXCI7XG5mdW5jdGlvbiBfbWVyZ2VOYW1lc3BhY2VzKG4sIG0pIHtcbiAgbS5mb3JFYWNoKGZ1bmN0aW9uKGUpIHtcbiAgICBlICYmIHR5cGVvZiBlICE9PSBcInN0cmluZ1wiICYmICFBcnJheS5pc0FycmF5KGUpICYmIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmICEoayBpbiBuKSkge1xuICAgICAgICB2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgayk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBrLCBkLmdldCA/IGQgOiB7XG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGVba107XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xufVxuX19uYW1lKF9tZXJnZU5hbWVzcGFjZXMsIFwiX21lcmdlTmFtZXNwYWNlc1wiKTtcbnZhciBjb21tZW50JDIgPSB7IGV4cG9ydHM6IHt9IH07XG4oZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG4gIChmdW5jdGlvbihtb2QpIHtcbiAgICBtb2QoY29kZW1pcnJvci5leHBvcnRzKTtcbiAgfSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuICAgIHZhciBub09wdGlvbnMgPSB7fTtcbiAgICB2YXIgbm9uV1MgPSAvW15cXHNcXHUwMGEwXS87XG4gICAgdmFyIFBvcyA9IENvZGVNaXJyb3IuUG9zLCBjbXAgPSBDb2RlTWlycm9yLmNtcFBvcztcbiAgICBmdW5jdGlvbiBmaXJzdE5vbldTKHN0cikge1xuICAgICAgdmFyIGZvdW5kID0gc3RyLnNlYXJjaChub25XUyk7XG4gICAgICByZXR1cm4gZm91bmQgPT0gLTEgPyAwIDogZm91bmQ7XG4gICAgfVxuICAgIF9fbmFtZShmaXJzdE5vbldTLCBcImZpcnN0Tm9uV1NcIik7XG4gICAgQ29kZU1pcnJvci5jb21tYW5kcy50b2dnbGVDb21tZW50ID0gZnVuY3Rpb24oY20pIHtcbiAgICAgIGNtLnRvZ2dsZUNvbW1lbnQoKTtcbiAgICB9O1xuICAgIENvZGVNaXJyb3IuZGVmaW5lRXh0ZW5zaW9uKFwidG9nZ2xlQ29tbWVudFwiLCBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgIG9wdGlvbnMgPSBub09wdGlvbnM7XG4gICAgICB2YXIgY20gPSB0aGlzO1xuICAgICAgdmFyIG1pbkxpbmUgPSBJbmZpbml0eSwgcmFuZ2VzID0gdGhpcy5saXN0U2VsZWN0aW9ucygpLCBtb2RlID0gbnVsbDtcbiAgICAgIGZvciAodmFyIGkgPSByYW5nZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIGZyb20gPSByYW5nZXNbaV0uZnJvbSgpLCB0byA9IHJhbmdlc1tpXS50bygpO1xuICAgICAgICBpZiAoZnJvbS5saW5lID49IG1pbkxpbmUpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmICh0by5saW5lID49IG1pbkxpbmUpXG4gICAgICAgICAgdG8gPSBQb3MobWluTGluZSwgMCk7XG4gICAgICAgIG1pbkxpbmUgPSBmcm9tLmxpbmU7XG4gICAgICAgIGlmIChtb2RlID09IG51bGwpIHtcbiAgICAgICAgICBpZiAoY20udW5jb21tZW50KGZyb20sIHRvLCBvcHRpb25zKSlcbiAgICAgICAgICAgIG1vZGUgPSBcInVuXCI7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbS5saW5lQ29tbWVudChmcm9tLCB0bywgb3B0aW9ucyk7XG4gICAgICAgICAgICBtb2RlID0gXCJsaW5lXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1vZGUgPT0gXCJ1blwiKSB7XG4gICAgICAgICAgY20udW5jb21tZW50KGZyb20sIHRvLCBvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbS5saW5lQ29tbWVudChmcm9tLCB0bywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBmdW5jdGlvbiBwcm9iYWJseUluc2lkZVN0cmluZyhjbSwgcG9zLCBsaW5lKSB7XG4gICAgICByZXR1cm4gL1xcYnN0cmluZ1xcYi8udGVzdChjbS5nZXRUb2tlblR5cGVBdChQb3MocG9zLmxpbmUsIDApKSkgJiYgIS9eW1xcJ1xcXCJcXGBdLy50ZXN0KGxpbmUpO1xuICAgIH1cbiAgICBfX25hbWUocHJvYmFibHlJbnNpZGVTdHJpbmcsIFwicHJvYmFibHlJbnNpZGVTdHJpbmdcIik7XG4gICAgZnVuY3Rpb24gZ2V0TW9kZShjbSwgcG9zKSB7XG4gICAgICB2YXIgbW9kZSA9IGNtLmdldE1vZGUoKTtcbiAgICAgIHJldHVybiBtb2RlLnVzZUlubmVyQ29tbWVudHMgPT09IGZhbHNlIHx8ICFtb2RlLmlubmVyTW9kZSA/IG1vZGUgOiBjbS5nZXRNb2RlQXQocG9zKTtcbiAgICB9XG4gICAgX19uYW1lKGdldE1vZGUsIFwiZ2V0TW9kZVwiKTtcbiAgICBDb2RlTWlycm9yLmRlZmluZUV4dGVuc2lvbihcImxpbmVDb21tZW50XCIsIGZ1bmN0aW9uKGZyb20sIHRvLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgIG9wdGlvbnMgPSBub09wdGlvbnM7XG4gICAgICB2YXIgc2VsZiA9IHRoaXMsIG1vZGUgPSBnZXRNb2RlKHNlbGYsIGZyb20pO1xuICAgICAgdmFyIGZpcnN0TGluZSA9IHNlbGYuZ2V0TGluZShmcm9tLmxpbmUpO1xuICAgICAgaWYgKGZpcnN0TGluZSA9PSBudWxsIHx8IHByb2JhYmx5SW5zaWRlU3RyaW5nKHNlbGYsIGZyb20sIGZpcnN0TGluZSkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHZhciBjb21tZW50U3RyaW5nID0gb3B0aW9ucy5saW5lQ29tbWVudCB8fCBtb2RlLmxpbmVDb21tZW50O1xuICAgICAgaWYgKCFjb21tZW50U3RyaW5nKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmJsb2NrQ29tbWVudFN0YXJ0IHx8IG1vZGUuYmxvY2tDb21tZW50U3RhcnQpIHtcbiAgICAgICAgICBvcHRpb25zLmZ1bGxMaW5lcyA9IHRydWU7XG4gICAgICAgICAgc2VsZi5ibG9ja0NvbW1lbnQoZnJvbSwgdG8sIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBlbmQgPSBNYXRoLm1pbih0by5jaCAhPSAwIHx8IHRvLmxpbmUgPT0gZnJvbS5saW5lID8gdG8ubGluZSArIDEgOiB0by5saW5lLCBzZWxmLmxhc3RMaW5lKCkgKyAxKTtcbiAgICAgIHZhciBwYWQgPSBvcHRpb25zLnBhZGRpbmcgPT0gbnVsbCA/IFwiIFwiIDogb3B0aW9ucy5wYWRkaW5nO1xuICAgICAgdmFyIGJsYW5rTGluZXMgPSBvcHRpb25zLmNvbW1lbnRCbGFua0xpbmVzIHx8IGZyb20ubGluZSA9PSB0by5saW5lO1xuICAgICAgc2VsZi5vcGVyYXRpb24oZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmluZGVudCkge1xuICAgICAgICAgIHZhciBiYXNlU3RyaW5nID0gbnVsbDtcbiAgICAgICAgICBmb3IgKHZhciBpID0gZnJvbS5saW5lOyBpIDwgZW5kOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBsaW5lID0gc2VsZi5nZXRMaW5lKGkpO1xuICAgICAgICAgICAgdmFyIHdoaXRlc3BhY2UgPSBsaW5lLnNsaWNlKDAsIGZpcnN0Tm9uV1MobGluZSkpO1xuICAgICAgICAgICAgaWYgKGJhc2VTdHJpbmcgPT0gbnVsbCB8fCBiYXNlU3RyaW5nLmxlbmd0aCA+IHdoaXRlc3BhY2UubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGJhc2VTdHJpbmcgPSB3aGl0ZXNwYWNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBpID0gZnJvbS5saW5lOyBpIDwgZW5kOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBsaW5lID0gc2VsZi5nZXRMaW5lKGkpLCBjdXQgPSBiYXNlU3RyaW5nLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICghYmxhbmtMaW5lcyAmJiAhbm9uV1MudGVzdChsaW5lKSlcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAobGluZS5zbGljZSgwLCBjdXQpICE9IGJhc2VTdHJpbmcpXG4gICAgICAgICAgICAgIGN1dCA9IGZpcnN0Tm9uV1MobGluZSk7XG4gICAgICAgICAgICBzZWxmLnJlcGxhY2VSYW5nZShiYXNlU3RyaW5nICsgY29tbWVudFN0cmluZyArIHBhZCwgUG9zKGksIDApLCBQb3MoaSwgY3V0KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIGkgPSBmcm9tLmxpbmU7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgICAgICAgaWYgKGJsYW5rTGluZXMgfHwgbm9uV1MudGVzdChzZWxmLmdldExpbmUoaSkpKVxuICAgICAgICAgICAgICBzZWxmLnJlcGxhY2VSYW5nZShjb21tZW50U3RyaW5nICsgcGFkLCBQb3MoaSwgMCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgQ29kZU1pcnJvci5kZWZpbmVFeHRlbnNpb24oXCJibG9ja0NvbW1lbnRcIiwgZnVuY3Rpb24oZnJvbSwgdG8sIG9wdGlvbnMpIHtcbiAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgb3B0aW9ucyA9IG5vT3B0aW9ucztcbiAgICAgIHZhciBzZWxmID0gdGhpcywgbW9kZSA9IGdldE1vZGUoc2VsZiwgZnJvbSk7XG4gICAgICB2YXIgc3RhcnRTdHJpbmcgPSBvcHRpb25zLmJsb2NrQ29tbWVudFN0YXJ0IHx8IG1vZGUuYmxvY2tDb21tZW50U3RhcnQ7XG4gICAgICB2YXIgZW5kU3RyaW5nID0gb3B0aW9ucy5ibG9ja0NvbW1lbnRFbmQgfHwgbW9kZS5ibG9ja0NvbW1lbnRFbmQ7XG4gICAgICBpZiAoIXN0YXJ0U3RyaW5nIHx8ICFlbmRTdHJpbmcpIHtcbiAgICAgICAgaWYgKChvcHRpb25zLmxpbmVDb21tZW50IHx8IG1vZGUubGluZUNvbW1lbnQpICYmIG9wdGlvbnMuZnVsbExpbmVzICE9IGZhbHNlKVxuICAgICAgICAgIHNlbGYubGluZUNvbW1lbnQoZnJvbSwgdG8sIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoL1xcYmNvbW1lbnRcXGIvLnRlc3Qoc2VsZi5nZXRUb2tlblR5cGVBdChQb3MoZnJvbS5saW5lLCAwKSkpKVxuICAgICAgICByZXR1cm47XG4gICAgICB2YXIgZW5kID0gTWF0aC5taW4odG8ubGluZSwgc2VsZi5sYXN0TGluZSgpKTtcbiAgICAgIGlmIChlbmQgIT0gZnJvbS5saW5lICYmIHRvLmNoID09IDAgJiYgbm9uV1MudGVzdChzZWxmLmdldExpbmUoZW5kKSkpXG4gICAgICAgIC0tZW5kO1xuICAgICAgdmFyIHBhZCA9IG9wdGlvbnMucGFkZGluZyA9PSBudWxsID8gXCIgXCIgOiBvcHRpb25zLnBhZGRpbmc7XG4gICAgICBpZiAoZnJvbS5saW5lID4gZW5kKVxuICAgICAgICByZXR1cm47XG4gICAgICBzZWxmLm9wZXJhdGlvbihmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuZnVsbExpbmVzICE9IGZhbHNlKSB7XG4gICAgICAgICAgdmFyIGxhc3RMaW5lSGFzVGV4dCA9IG5vbldTLnRlc3Qoc2VsZi5nZXRMaW5lKGVuZCkpO1xuICAgICAgICAgIHNlbGYucmVwbGFjZVJhbmdlKHBhZCArIGVuZFN0cmluZywgUG9zKGVuZCkpO1xuICAgICAgICAgIHNlbGYucmVwbGFjZVJhbmdlKHN0YXJ0U3RyaW5nICsgcGFkLCBQb3MoZnJvbS5saW5lLCAwKSk7XG4gICAgICAgICAgdmFyIGxlYWQgPSBvcHRpb25zLmJsb2NrQ29tbWVudExlYWQgfHwgbW9kZS5ibG9ja0NvbW1lbnRMZWFkO1xuICAgICAgICAgIGlmIChsZWFkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBmcm9tLmxpbmUgKyAxOyBpIDw9IGVuZDsgKytpKVxuICAgICAgICAgICAgICBpZiAoaSAhPSBlbmQgfHwgbGFzdExpbmVIYXNUZXh0KVxuICAgICAgICAgICAgICAgIHNlbGYucmVwbGFjZVJhbmdlKGxlYWQgKyBwYWQsIFBvcyhpLCAwKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBhdEN1cnNvciA9IGNtcChzZWxmLmdldEN1cnNvcihcInRvXCIpLCB0bykgPT0gMCwgZW1wdHkgPSAhc2VsZi5zb21ldGhpbmdTZWxlY3RlZCgpO1xuICAgICAgICAgIHNlbGYucmVwbGFjZVJhbmdlKGVuZFN0cmluZywgdG8pO1xuICAgICAgICAgIGlmIChhdEN1cnNvcilcbiAgICAgICAgICAgIHNlbGYuc2V0U2VsZWN0aW9uKGVtcHR5ID8gdG8gOiBzZWxmLmdldEN1cnNvcihcImZyb21cIiksIHRvKTtcbiAgICAgICAgICBzZWxmLnJlcGxhY2VSYW5nZShzdGFydFN0cmluZywgZnJvbSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIENvZGVNaXJyb3IuZGVmaW5lRXh0ZW5zaW9uKFwidW5jb21tZW50XCIsIGZ1bmN0aW9uKGZyb20sIHRvLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgIG9wdGlvbnMgPSBub09wdGlvbnM7XG4gICAgICB2YXIgc2VsZiA9IHRoaXMsIG1vZGUgPSBnZXRNb2RlKHNlbGYsIGZyb20pO1xuICAgICAgdmFyIGVuZCA9IE1hdGgubWluKHRvLmNoICE9IDAgfHwgdG8ubGluZSA9PSBmcm9tLmxpbmUgPyB0by5saW5lIDogdG8ubGluZSAtIDEsIHNlbGYubGFzdExpbmUoKSksIHN0YXJ0ID0gTWF0aC5taW4oZnJvbS5saW5lLCBlbmQpO1xuICAgICAgdmFyIGxpbmVTdHJpbmcgPSBvcHRpb25zLmxpbmVDb21tZW50IHx8IG1vZGUubGluZUNvbW1lbnQsIGxpbmVzID0gW107XG4gICAgICB2YXIgcGFkID0gb3B0aW9ucy5wYWRkaW5nID09IG51bGwgPyBcIiBcIiA6IG9wdGlvbnMucGFkZGluZywgZGlkU29tZXRoaW5nO1xuICAgICAgbGluZUNvbW1lbnQ6IHtcbiAgICAgICAgaWYgKCFsaW5lU3RyaW5nKVxuICAgICAgICAgIGJyZWFrIGxpbmVDb21tZW50O1xuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyArK2kpIHtcbiAgICAgICAgICB2YXIgbGluZSA9IHNlbGYuZ2V0TGluZShpKTtcbiAgICAgICAgICB2YXIgZm91bmQgPSBsaW5lLmluZGV4T2YobGluZVN0cmluZyk7XG4gICAgICAgICAgaWYgKGZvdW5kID4gLTEgJiYgIS9jb21tZW50Ly50ZXN0KHNlbGYuZ2V0VG9rZW5UeXBlQXQoUG9zKGksIGZvdW5kICsgMSkpKSlcbiAgICAgICAgICAgIGZvdW5kID0gLTE7XG4gICAgICAgICAgaWYgKGZvdW5kID09IC0xICYmIG5vbldTLnRlc3QobGluZSkpXG4gICAgICAgICAgICBicmVhayBsaW5lQ29tbWVudDtcbiAgICAgICAgICBpZiAoZm91bmQgPiAtMSAmJiBub25XUy50ZXN0KGxpbmUuc2xpY2UoMCwgZm91bmQpKSlcbiAgICAgICAgICAgIGJyZWFrIGxpbmVDb21tZW50O1xuICAgICAgICAgIGxpbmVzLnB1c2gobGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5vcGVyYXRpb24oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZm9yICh2YXIgaTIgPSBzdGFydDsgaTIgPD0gZW5kOyArK2kyKSB7XG4gICAgICAgICAgICB2YXIgbGluZTIgPSBsaW5lc1tpMiAtIHN0YXJ0XTtcbiAgICAgICAgICAgIHZhciBwb3MgPSBsaW5lMi5pbmRleE9mKGxpbmVTdHJpbmcpLCBlbmRQb3MgPSBwb3MgKyBsaW5lU3RyaW5nLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChwb3MgPCAwKVxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChsaW5lMi5zbGljZShlbmRQb3MsIGVuZFBvcyArIHBhZC5sZW5ndGgpID09IHBhZClcbiAgICAgICAgICAgICAgZW5kUG9zICs9IHBhZC5sZW5ndGg7XG4gICAgICAgICAgICBkaWRTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgICAgICAgc2VsZi5yZXBsYWNlUmFuZ2UoXCJcIiwgUG9zKGkyLCBwb3MpLCBQb3MoaTIsIGVuZFBvcykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChkaWRTb21ldGhpbmcpXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgc3RhcnRTdHJpbmcgPSBvcHRpb25zLmJsb2NrQ29tbWVudFN0YXJ0IHx8IG1vZGUuYmxvY2tDb21tZW50U3RhcnQ7XG4gICAgICB2YXIgZW5kU3RyaW5nID0gb3B0aW9ucy5ibG9ja0NvbW1lbnRFbmQgfHwgbW9kZS5ibG9ja0NvbW1lbnRFbmQ7XG4gICAgICBpZiAoIXN0YXJ0U3RyaW5nIHx8ICFlbmRTdHJpbmcpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBsZWFkID0gb3B0aW9ucy5ibG9ja0NvbW1lbnRMZWFkIHx8IG1vZGUuYmxvY2tDb21tZW50TGVhZDtcbiAgICAgIHZhciBzdGFydExpbmUgPSBzZWxmLmdldExpbmUoc3RhcnQpLCBvcGVuID0gc3RhcnRMaW5lLmluZGV4T2Yoc3RhcnRTdHJpbmcpO1xuICAgICAgaWYgKG9wZW4gPT0gLTEpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBlbmRMaW5lID0gZW5kID09IHN0YXJ0ID8gc3RhcnRMaW5lIDogc2VsZi5nZXRMaW5lKGVuZCk7XG4gICAgICB2YXIgY2xvc2UgPSBlbmRMaW5lLmluZGV4T2YoZW5kU3RyaW5nLCBlbmQgPT0gc3RhcnQgPyBvcGVuICsgc3RhcnRTdHJpbmcubGVuZ3RoIDogMCk7XG4gICAgICB2YXIgaW5zaWRlU3RhcnQgPSBQb3Moc3RhcnQsIG9wZW4gKyAxKSwgaW5zaWRlRW5kID0gUG9zKGVuZCwgY2xvc2UgKyAxKTtcbiAgICAgIGlmIChjbG9zZSA9PSAtMSB8fCAhL2NvbW1lbnQvLnRlc3Qoc2VsZi5nZXRUb2tlblR5cGVBdChpbnNpZGVTdGFydCkpIHx8ICEvY29tbWVudC8udGVzdChzZWxmLmdldFRva2VuVHlwZUF0KGluc2lkZUVuZCkpIHx8IHNlbGYuZ2V0UmFuZ2UoaW5zaWRlU3RhcnQsIGluc2lkZUVuZCwgXCJcXG5cIikuaW5kZXhPZihlbmRTdHJpbmcpID4gLTEpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBsYXN0U3RhcnQgPSBzdGFydExpbmUubGFzdEluZGV4T2Yoc3RhcnRTdHJpbmcsIGZyb20uY2gpO1xuICAgICAgdmFyIGZpcnN0RW5kID0gbGFzdFN0YXJ0ID09IC0xID8gLTEgOiBzdGFydExpbmUuc2xpY2UoMCwgZnJvbS5jaCkuaW5kZXhPZihlbmRTdHJpbmcsIGxhc3RTdGFydCArIHN0YXJ0U3RyaW5nLmxlbmd0aCk7XG4gICAgICBpZiAobGFzdFN0YXJ0ICE9IC0xICYmIGZpcnN0RW5kICE9IC0xICYmIGZpcnN0RW5kICsgZW5kU3RyaW5nLmxlbmd0aCAhPSBmcm9tLmNoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBmaXJzdEVuZCA9IGVuZExpbmUuaW5kZXhPZihlbmRTdHJpbmcsIHRvLmNoKTtcbiAgICAgIHZhciBhbG1vc3RMYXN0U3RhcnQgPSBlbmRMaW5lLnNsaWNlKHRvLmNoKS5sYXN0SW5kZXhPZihzdGFydFN0cmluZywgZmlyc3RFbmQgLSB0by5jaCk7XG4gICAgICBsYXN0U3RhcnQgPSBmaXJzdEVuZCA9PSAtMSB8fCBhbG1vc3RMYXN0U3RhcnQgPT0gLTEgPyAtMSA6IHRvLmNoICsgYWxtb3N0TGFzdFN0YXJ0O1xuICAgICAgaWYgKGZpcnN0RW5kICE9IC0xICYmIGxhc3RTdGFydCAhPSAtMSAmJiBsYXN0U3RhcnQgIT0gdG8uY2gpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIHNlbGYub3BlcmF0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLnJlcGxhY2VSYW5nZShcIlwiLCBQb3MoZW5kLCBjbG9zZSAtIChwYWQgJiYgZW5kTGluZS5zbGljZShjbG9zZSAtIHBhZC5sZW5ndGgsIGNsb3NlKSA9PSBwYWQgPyBwYWQubGVuZ3RoIDogMCkpLCBQb3MoZW5kLCBjbG9zZSArIGVuZFN0cmluZy5sZW5ndGgpKTtcbiAgICAgICAgdmFyIG9wZW5FbmQgPSBvcGVuICsgc3RhcnRTdHJpbmcubGVuZ3RoO1xuICAgICAgICBpZiAocGFkICYmIHN0YXJ0TGluZS5zbGljZShvcGVuRW5kLCBvcGVuRW5kICsgcGFkLmxlbmd0aCkgPT0gcGFkKVxuICAgICAgICAgIG9wZW5FbmQgKz0gcGFkLmxlbmd0aDtcbiAgICAgICAgc2VsZi5yZXBsYWNlUmFuZ2UoXCJcIiwgUG9zKHN0YXJ0LCBvcGVuKSwgUG9zKHN0YXJ0LCBvcGVuRW5kKSk7XG4gICAgICAgIGlmIChsZWFkKVxuICAgICAgICAgIGZvciAodmFyIGkyID0gc3RhcnQgKyAxOyBpMiA8PSBlbmQ7ICsraTIpIHtcbiAgICAgICAgICAgIHZhciBsaW5lMiA9IHNlbGYuZ2V0TGluZShpMiksIGZvdW5kMiA9IGxpbmUyLmluZGV4T2YobGVhZCk7XG4gICAgICAgICAgICBpZiAoZm91bmQyID09IC0xIHx8IG5vbldTLnRlc3QobGluZTIuc2xpY2UoMCwgZm91bmQyKSkpXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmFyIGZvdW5kRW5kID0gZm91bmQyICsgbGVhZC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAocGFkICYmIGxpbmUyLnNsaWNlKGZvdW5kRW5kLCBmb3VuZEVuZCArIHBhZC5sZW5ndGgpID09IHBhZClcbiAgICAgICAgICAgICAgZm91bmRFbmQgKz0gcGFkLmxlbmd0aDtcbiAgICAgICAgICAgIHNlbGYucmVwbGFjZVJhbmdlKFwiXCIsIFBvcyhpMiwgZm91bmQyKSwgUG9zKGkyLCBmb3VuZEVuZCkpO1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gIH0pO1xufSkoKTtcbnZhciBjb21tZW50ID0gY29tbWVudCQyLmV4cG9ydHM7XG52YXIgY29tbWVudCQxID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIF9tZXJnZU5hbWVzcGFjZXMoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiBcIk1vZHVsZVwiLFxuICBcImRlZmF1bHRcIjogY29tbWVudFxufSwgW2NvbW1lbnQkMi5leHBvcnRzXSkpO1xuZXhwb3J0IHsgY29tbWVudCQxIGFzIGMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///45092\n')}}]);