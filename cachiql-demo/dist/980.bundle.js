"use strict";(self.webpackChunkcachiql_demo=self.webpackChunkcachiql_demo||[]).push([[980],{54980:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "a": () => (/* binding */ matchbrackets$2),\n/* harmony export */   "m": () => (/* binding */ matchbrackets$1)\n/* harmony export */ });\n/* harmony import */ var _codemirror_es_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97480);\nvar __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, "name", { value, configurable: true });\n\nfunction _mergeNamespaces(n, m) {\n  m.forEach(function(e) {\n    e && typeof e !== "string" && !Array.isArray(e) && Object.keys(e).forEach(function(k) {\n      if (k !== "default" && !(k in n)) {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function() {\n            return e[k];\n          }\n        });\n      }\n    });\n  });\n  return Object.freeze(n);\n}\n__name(_mergeNamespaces, "_mergeNamespaces");\nvar matchbrackets$2 = { exports: {} };\n(function(module, exports) {\n  (function(mod) {\n    mod(_codemirror_es_js__WEBPACK_IMPORTED_MODULE_0__.a.exports);\n  })(function(CodeMirror) {\n    var ie_lt8 = /MSIE \\d/.test(navigator.userAgent) && (document.documentMode == null || document.documentMode < 8);\n    var Pos = CodeMirror.Pos;\n    var matching = { "(": ")>", ")": "(<", "[": "]>", "]": "[<", "{": "}>", "}": "{<", "<": ">>", ">": "<<" };\n    function bracketRegex(config) {\n      return config && config.bracketRegex || /[(){}[\\]]/;\n    }\n    __name(bracketRegex, "bracketRegex");\n    function findMatchingBracket(cm, where, config) {\n      var line = cm.getLineHandle(where.line), pos = where.ch - 1;\n      var afterCursor = config && config.afterCursor;\n      if (afterCursor == null)\n        afterCursor = /(^| )cm-fat-cursor($| )/.test(cm.getWrapperElement().className);\n      var re = bracketRegex(config);\n      var match = !afterCursor && pos >= 0 && re.test(line.text.charAt(pos)) && matching[line.text.charAt(pos)] || re.test(line.text.charAt(pos + 1)) && matching[line.text.charAt(++pos)];\n      if (!match)\n        return null;\n      var dir = match.charAt(1) == ">" ? 1 : -1;\n      if (config && config.strict && dir > 0 != (pos == where.ch))\n        return null;\n      var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));\n      var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style, config);\n      if (found == null)\n        return null;\n      return {\n        from: Pos(where.line, pos),\n        to: found && found.pos,\n        match: found && found.ch == match.charAt(0),\n        forward: dir > 0\n      };\n    }\n    __name(findMatchingBracket, "findMatchingBracket");\n    function scanForBracket(cm, where, dir, style, config) {\n      var maxScanLen = config && config.maxScanLineLength || 1e4;\n      var maxScanLines = config && config.maxScanLines || 1e3;\n      var stack = [];\n      var re = bracketRegex(config);\n      var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1) : Math.max(cm.firstLine() - 1, where.line - maxScanLines);\n      for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {\n        var line = cm.getLine(lineNo);\n        if (!line)\n          continue;\n        var pos = dir > 0 ? 0 : line.length - 1, end = dir > 0 ? line.length : -1;\n        if (line.length > maxScanLen)\n          continue;\n        if (lineNo == where.line)\n          pos = where.ch - (dir < 0 ? 1 : 0);\n        for (; pos != end; pos += dir) {\n          var ch = line.charAt(pos);\n          if (re.test(ch) && (style === void 0 || (cm.getTokenTypeAt(Pos(lineNo, pos + 1)) || "") == (style || ""))) {\n            var match = matching[ch];\n            if (match && match.charAt(1) == ">" == dir > 0)\n              stack.push(ch);\n            else if (!stack.length)\n              return { pos: Pos(lineNo, pos), ch };\n            else\n              stack.pop();\n          }\n        }\n      }\n      return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;\n    }\n    __name(scanForBracket, "scanForBracket");\n    function matchBrackets(cm, autoclear, config) {\n      var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1e3, highlightNonMatching = config && config.highlightNonMatching;\n      var marks = [], ranges = cm.listSelections();\n      for (var i = 0; i < ranges.length; i++) {\n        var match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, config);\n        if (match && (match.match || highlightNonMatching !== false) && cm.getLine(match.from.line).length <= maxHighlightLen) {\n          var style = match.match ? "CodeMirror-matchingbracket" : "CodeMirror-nonmatchingbracket";\n          marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), { className: style }));\n          if (match.to && cm.getLine(match.to.line).length <= maxHighlightLen)\n            marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), { className: style }));\n        }\n      }\n      if (marks.length) {\n        if (ie_lt8 && cm.state.focused)\n          cm.focus();\n        var clear = /* @__PURE__ */ __name(function() {\n          cm.operation(function() {\n            for (var i2 = 0; i2 < marks.length; i2++)\n              marks[i2].clear();\n          });\n        }, "clear");\n        if (autoclear)\n          setTimeout(clear, 800);\n        else\n          return clear;\n      }\n    }\n    __name(matchBrackets, "matchBrackets");\n    function doMatchBrackets(cm) {\n      cm.operation(function() {\n        if (cm.state.matchBrackets.currentlyHighlighted) {\n          cm.state.matchBrackets.currentlyHighlighted();\n          cm.state.matchBrackets.currentlyHighlighted = null;\n        }\n        cm.state.matchBrackets.currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);\n      });\n    }\n    __name(doMatchBrackets, "doMatchBrackets");\n    function clearHighlighted(cm) {\n      if (cm.state.matchBrackets && cm.state.matchBrackets.currentlyHighlighted) {\n        cm.state.matchBrackets.currentlyHighlighted();\n        cm.state.matchBrackets.currentlyHighlighted = null;\n      }\n    }\n    __name(clearHighlighted, "clearHighlighted");\n    CodeMirror.defineOption("matchBrackets", false, function(cm, val, old) {\n      if (old && old != CodeMirror.Init) {\n        cm.off("cursorActivity", doMatchBrackets);\n        cm.off("focus", doMatchBrackets);\n        cm.off("blur", clearHighlighted);\n        clearHighlighted(cm);\n      }\n      if (val) {\n        cm.state.matchBrackets = typeof val == "object" ? val : {};\n        cm.on("cursorActivity", doMatchBrackets);\n        cm.on("focus", doMatchBrackets);\n        cm.on("blur", clearHighlighted);\n      }\n    });\n    CodeMirror.defineExtension("matchBrackets", function() {\n      matchBrackets(this, true);\n    });\n    CodeMirror.defineExtension("findMatchingBracket", function(pos, config, oldConfig) {\n      if (oldConfig || typeof config == "boolean") {\n        if (!oldConfig) {\n          config = config ? { strict: true } : null;\n        } else {\n          oldConfig.strict = config;\n          config = oldConfig;\n        }\n      }\n      return findMatchingBracket(this, pos, config);\n    });\n    CodeMirror.defineExtension("scanForBracket", function(pos, dir, style, config) {\n      return scanForBracket(this, pos, dir, style, config);\n    });\n  });\n})();\nvar matchbrackets = matchbrackets$2.exports;\nvar matchbrackets$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  [Symbol.toStringTag]: "Module",\n  "default": matchbrackets\n}, [matchbrackets$2.exports]));\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQ5ODAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQSw0REFBNEQsMkJBQTJCO0FBQ2xDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLFFBQVEsd0RBQWtCO0FBQzFCLEdBQUc7QUFDSDtBQUNBO0FBQ0EscUJBQXFCLDhDQUE4QyxLQUFLLE1BQU0sS0FBSztBQUNuRjtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG1CQUFtQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSx3RkFBd0Ysa0JBQWtCO0FBQzFHO0FBQ0Esb0ZBQW9GLGtCQUFrQjtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQkFBbUI7QUFDaEQ7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZUFBZTtBQUM3QyxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDcUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYWNoaXFsLWRlbW8vLi9ub2RlX21vZHVsZXMvQGdyYXBoaXFsL3JlYWN0L2Rpc3QvbWF0Y2hicmFja2V0cy5lcy5qcz9lY2JlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19uYW1lID0gKHRhcmdldCwgdmFsdWUpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwibmFtZVwiLCB7IHZhbHVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG5pbXBvcnQgeyBhIGFzIGNvZGVtaXJyb3IgfSBmcm9tIFwiLi9jb2RlbWlycm9yLmVzLmpzXCI7XG5mdW5jdGlvbiBfbWVyZ2VOYW1lc3BhY2VzKG4sIG0pIHtcbiAgbS5mb3JFYWNoKGZ1bmN0aW9uKGUpIHtcbiAgICBlICYmIHR5cGVvZiBlICE9PSBcInN0cmluZ1wiICYmICFBcnJheS5pc0FycmF5KGUpICYmIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmICEoayBpbiBuKSkge1xuICAgICAgICB2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgayk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBrLCBkLmdldCA/IGQgOiB7XG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGVba107XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xufVxuX19uYW1lKF9tZXJnZU5hbWVzcGFjZXMsIFwiX21lcmdlTmFtZXNwYWNlc1wiKTtcbnZhciBtYXRjaGJyYWNrZXRzJDIgPSB7IGV4cG9ydHM6IHt9IH07XG4oZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG4gIChmdW5jdGlvbihtb2QpIHtcbiAgICBtb2QoY29kZW1pcnJvci5leHBvcnRzKTtcbiAgfSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuICAgIHZhciBpZV9sdDggPSAvTVNJRSBcXGQvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgKGRvY3VtZW50LmRvY3VtZW50TW9kZSA9PSBudWxsIHx8IGRvY3VtZW50LmRvY3VtZW50TW9kZSA8IDgpO1xuICAgIHZhciBQb3MgPSBDb2RlTWlycm9yLlBvcztcbiAgICB2YXIgbWF0Y2hpbmcgPSB7IFwiKFwiOiBcIik+XCIsIFwiKVwiOiBcIig8XCIsIFwiW1wiOiBcIl0+XCIsIFwiXVwiOiBcIls8XCIsIFwie1wiOiBcIn0+XCIsIFwifVwiOiBcIns8XCIsIFwiPFwiOiBcIj4+XCIsIFwiPlwiOiBcIjw8XCIgfTtcbiAgICBmdW5jdGlvbiBicmFja2V0UmVnZXgoY29uZmlnKSB7XG4gICAgICByZXR1cm4gY29uZmlnICYmIGNvbmZpZy5icmFja2V0UmVnZXggfHwgL1soKXt9W1xcXV0vO1xuICAgIH1cbiAgICBfX25hbWUoYnJhY2tldFJlZ2V4LCBcImJyYWNrZXRSZWdleFwiKTtcbiAgICBmdW5jdGlvbiBmaW5kTWF0Y2hpbmdCcmFja2V0KGNtLCB3aGVyZSwgY29uZmlnKSB7XG4gICAgICB2YXIgbGluZSA9IGNtLmdldExpbmVIYW5kbGUod2hlcmUubGluZSksIHBvcyA9IHdoZXJlLmNoIC0gMTtcbiAgICAgIHZhciBhZnRlckN1cnNvciA9IGNvbmZpZyAmJiBjb25maWcuYWZ0ZXJDdXJzb3I7XG4gICAgICBpZiAoYWZ0ZXJDdXJzb3IgPT0gbnVsbClcbiAgICAgICAgYWZ0ZXJDdXJzb3IgPSAvKF58ICljbS1mYXQtY3Vyc29yKCR8ICkvLnRlc3QoY20uZ2V0V3JhcHBlckVsZW1lbnQoKS5jbGFzc05hbWUpO1xuICAgICAgdmFyIHJlID0gYnJhY2tldFJlZ2V4KGNvbmZpZyk7XG4gICAgICB2YXIgbWF0Y2ggPSAhYWZ0ZXJDdXJzb3IgJiYgcG9zID49IDAgJiYgcmUudGVzdChsaW5lLnRleHQuY2hhckF0KHBvcykpICYmIG1hdGNoaW5nW2xpbmUudGV4dC5jaGFyQXQocG9zKV0gfHwgcmUudGVzdChsaW5lLnRleHQuY2hhckF0KHBvcyArIDEpKSAmJiBtYXRjaGluZ1tsaW5lLnRleHQuY2hhckF0KCsrcG9zKV07XG4gICAgICBpZiAoIW1hdGNoKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBkaXIgPSBtYXRjaC5jaGFyQXQoMSkgPT0gXCI+XCIgPyAxIDogLTE7XG4gICAgICBpZiAoY29uZmlnICYmIGNvbmZpZy5zdHJpY3QgJiYgZGlyID4gMCAhPSAocG9zID09IHdoZXJlLmNoKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgc3R5bGUgPSBjbS5nZXRUb2tlblR5cGVBdChQb3Mod2hlcmUubGluZSwgcG9zICsgMSkpO1xuICAgICAgdmFyIGZvdW5kID0gc2NhbkZvckJyYWNrZXQoY20sIFBvcyh3aGVyZS5saW5lLCBwb3MgKyAoZGlyID4gMCA/IDEgOiAwKSksIGRpciwgc3R5bGUsIGNvbmZpZyk7XG4gICAgICBpZiAoZm91bmQgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBmcm9tOiBQb3Mod2hlcmUubGluZSwgcG9zKSxcbiAgICAgICAgdG86IGZvdW5kICYmIGZvdW5kLnBvcyxcbiAgICAgICAgbWF0Y2g6IGZvdW5kICYmIGZvdW5kLmNoID09IG1hdGNoLmNoYXJBdCgwKSxcbiAgICAgICAgZm9yd2FyZDogZGlyID4gMFxuICAgICAgfTtcbiAgICB9XG4gICAgX19uYW1lKGZpbmRNYXRjaGluZ0JyYWNrZXQsIFwiZmluZE1hdGNoaW5nQnJhY2tldFwiKTtcbiAgICBmdW5jdGlvbiBzY2FuRm9yQnJhY2tldChjbSwgd2hlcmUsIGRpciwgc3R5bGUsIGNvbmZpZykge1xuICAgICAgdmFyIG1heFNjYW5MZW4gPSBjb25maWcgJiYgY29uZmlnLm1heFNjYW5MaW5lTGVuZ3RoIHx8IDFlNDtcbiAgICAgIHZhciBtYXhTY2FuTGluZXMgPSBjb25maWcgJiYgY29uZmlnLm1heFNjYW5MaW5lcyB8fCAxZTM7XG4gICAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICAgIHZhciByZSA9IGJyYWNrZXRSZWdleChjb25maWcpO1xuICAgICAgdmFyIGxpbmVFbmQgPSBkaXIgPiAwID8gTWF0aC5taW4od2hlcmUubGluZSArIG1heFNjYW5MaW5lcywgY20ubGFzdExpbmUoKSArIDEpIDogTWF0aC5tYXgoY20uZmlyc3RMaW5lKCkgLSAxLCB3aGVyZS5saW5lIC0gbWF4U2NhbkxpbmVzKTtcbiAgICAgIGZvciAodmFyIGxpbmVObyA9IHdoZXJlLmxpbmU7IGxpbmVObyAhPSBsaW5lRW5kOyBsaW5lTm8gKz0gZGlyKSB7XG4gICAgICAgIHZhciBsaW5lID0gY20uZ2V0TGluZShsaW5lTm8pO1xuICAgICAgICBpZiAoIWxpbmUpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIHZhciBwb3MgPSBkaXIgPiAwID8gMCA6IGxpbmUubGVuZ3RoIC0gMSwgZW5kID0gZGlyID4gMCA/IGxpbmUubGVuZ3RoIDogLTE7XG4gICAgICAgIGlmIChsaW5lLmxlbmd0aCA+IG1heFNjYW5MZW4pXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChsaW5lTm8gPT0gd2hlcmUubGluZSlcbiAgICAgICAgICBwb3MgPSB3aGVyZS5jaCAtIChkaXIgPCAwID8gMSA6IDApO1xuICAgICAgICBmb3IgKDsgcG9zICE9IGVuZDsgcG9zICs9IGRpcikge1xuICAgICAgICAgIHZhciBjaCA9IGxpbmUuY2hhckF0KHBvcyk7XG4gICAgICAgICAgaWYgKHJlLnRlc3QoY2gpICYmIChzdHlsZSA9PT0gdm9pZCAwIHx8IChjbS5nZXRUb2tlblR5cGVBdChQb3MobGluZU5vLCBwb3MgKyAxKSkgfHwgXCJcIikgPT0gKHN0eWxlIHx8IFwiXCIpKSkge1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gbWF0Y2hpbmdbY2hdO1xuICAgICAgICAgICAgaWYgKG1hdGNoICYmIG1hdGNoLmNoYXJBdCgxKSA9PSBcIj5cIiA9PSBkaXIgPiAwKVxuICAgICAgICAgICAgICBzdGFjay5wdXNoKGNoKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKCFzdGFjay5sZW5ndGgpXG4gICAgICAgICAgICAgIHJldHVybiB7IHBvczogUG9zKGxpbmVObywgcG9zKSwgY2ggfTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbGluZU5vIC0gZGlyID09IChkaXIgPiAwID8gY20ubGFzdExpbmUoKSA6IGNtLmZpcnN0TGluZSgpKSA/IGZhbHNlIDogbnVsbDtcbiAgICB9XG4gICAgX19uYW1lKHNjYW5Gb3JCcmFja2V0LCBcInNjYW5Gb3JCcmFja2V0XCIpO1xuICAgIGZ1bmN0aW9uIG1hdGNoQnJhY2tldHMoY20sIGF1dG9jbGVhciwgY29uZmlnKSB7XG4gICAgICB2YXIgbWF4SGlnaGxpZ2h0TGVuID0gY20uc3RhdGUubWF0Y2hCcmFja2V0cy5tYXhIaWdobGlnaHRMaW5lTGVuZ3RoIHx8IDFlMywgaGlnaGxpZ2h0Tm9uTWF0Y2hpbmcgPSBjb25maWcgJiYgY29uZmlnLmhpZ2hsaWdodE5vbk1hdGNoaW5nO1xuICAgICAgdmFyIG1hcmtzID0gW10sIHJhbmdlcyA9IGNtLmxpc3RTZWxlY3Rpb25zKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbWF0Y2ggPSByYW5nZXNbaV0uZW1wdHkoKSAmJiBmaW5kTWF0Y2hpbmdCcmFja2V0KGNtLCByYW5nZXNbaV0uaGVhZCwgY29uZmlnKTtcbiAgICAgICAgaWYgKG1hdGNoICYmIChtYXRjaC5tYXRjaCB8fCBoaWdobGlnaHROb25NYXRjaGluZyAhPT0gZmFsc2UpICYmIGNtLmdldExpbmUobWF0Y2guZnJvbS5saW5lKS5sZW5ndGggPD0gbWF4SGlnaGxpZ2h0TGVuKSB7XG4gICAgICAgICAgdmFyIHN0eWxlID0gbWF0Y2gubWF0Y2ggPyBcIkNvZGVNaXJyb3ItbWF0Y2hpbmdicmFja2V0XCIgOiBcIkNvZGVNaXJyb3Itbm9ubWF0Y2hpbmdicmFja2V0XCI7XG4gICAgICAgICAgbWFya3MucHVzaChjbS5tYXJrVGV4dChtYXRjaC5mcm9tLCBQb3MobWF0Y2guZnJvbS5saW5lLCBtYXRjaC5mcm9tLmNoICsgMSksIHsgY2xhc3NOYW1lOiBzdHlsZSB9KSk7XG4gICAgICAgICAgaWYgKG1hdGNoLnRvICYmIGNtLmdldExpbmUobWF0Y2gudG8ubGluZSkubGVuZ3RoIDw9IG1heEhpZ2hsaWdodExlbilcbiAgICAgICAgICAgIG1hcmtzLnB1c2goY20ubWFya1RleHQobWF0Y2gudG8sIFBvcyhtYXRjaC50by5saW5lLCBtYXRjaC50by5jaCArIDEpLCB7IGNsYXNzTmFtZTogc3R5bGUgfSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWFya3MubGVuZ3RoKSB7XG4gICAgICAgIGlmIChpZV9sdDggJiYgY20uc3RhdGUuZm9jdXNlZClcbiAgICAgICAgICBjbS5mb2N1cygpO1xuICAgICAgICB2YXIgY2xlYXIgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNtLm9wZXJhdGlvbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBtYXJrcy5sZW5ndGg7IGkyKyspXG4gICAgICAgICAgICAgIG1hcmtzW2kyXS5jbGVhcigpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBcImNsZWFyXCIpO1xuICAgICAgICBpZiAoYXV0b2NsZWFyKVxuICAgICAgICAgIHNldFRpbWVvdXQoY2xlYXIsIDgwMCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXR1cm4gY2xlYXI7XG4gICAgICB9XG4gICAgfVxuICAgIF9fbmFtZShtYXRjaEJyYWNrZXRzLCBcIm1hdGNoQnJhY2tldHNcIik7XG4gICAgZnVuY3Rpb24gZG9NYXRjaEJyYWNrZXRzKGNtKSB7XG4gICAgICBjbS5vcGVyYXRpb24oZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChjbS5zdGF0ZS5tYXRjaEJyYWNrZXRzLmN1cnJlbnRseUhpZ2hsaWdodGVkKSB7XG4gICAgICAgICAgY20uc3RhdGUubWF0Y2hCcmFja2V0cy5jdXJyZW50bHlIaWdobGlnaHRlZCgpO1xuICAgICAgICAgIGNtLnN0YXRlLm1hdGNoQnJhY2tldHMuY3VycmVudGx5SGlnaGxpZ2h0ZWQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNtLnN0YXRlLm1hdGNoQnJhY2tldHMuY3VycmVudGx5SGlnaGxpZ2h0ZWQgPSBtYXRjaEJyYWNrZXRzKGNtLCBmYWxzZSwgY20uc3RhdGUubWF0Y2hCcmFja2V0cyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgX19uYW1lKGRvTWF0Y2hCcmFja2V0cywgXCJkb01hdGNoQnJhY2tldHNcIik7XG4gICAgZnVuY3Rpb24gY2xlYXJIaWdobGlnaHRlZChjbSkge1xuICAgICAgaWYgKGNtLnN0YXRlLm1hdGNoQnJhY2tldHMgJiYgY20uc3RhdGUubWF0Y2hCcmFja2V0cy5jdXJyZW50bHlIaWdobGlnaHRlZCkge1xuICAgICAgICBjbS5zdGF0ZS5tYXRjaEJyYWNrZXRzLmN1cnJlbnRseUhpZ2hsaWdodGVkKCk7XG4gICAgICAgIGNtLnN0YXRlLm1hdGNoQnJhY2tldHMuY3VycmVudGx5SGlnaGxpZ2h0ZWQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBfX25hbWUoY2xlYXJIaWdobGlnaHRlZCwgXCJjbGVhckhpZ2hsaWdodGVkXCIpO1xuICAgIENvZGVNaXJyb3IuZGVmaW5lT3B0aW9uKFwibWF0Y2hCcmFja2V0c1wiLCBmYWxzZSwgZnVuY3Rpb24oY20sIHZhbCwgb2xkKSB7XG4gICAgICBpZiAob2xkICYmIG9sZCAhPSBDb2RlTWlycm9yLkluaXQpIHtcbiAgICAgICAgY20ub2ZmKFwiY3Vyc29yQWN0aXZpdHlcIiwgZG9NYXRjaEJyYWNrZXRzKTtcbiAgICAgICAgY20ub2ZmKFwiZm9jdXNcIiwgZG9NYXRjaEJyYWNrZXRzKTtcbiAgICAgICAgY20ub2ZmKFwiYmx1clwiLCBjbGVhckhpZ2hsaWdodGVkKTtcbiAgICAgICAgY2xlYXJIaWdobGlnaHRlZChjbSk7XG4gICAgICB9XG4gICAgICBpZiAodmFsKSB7XG4gICAgICAgIGNtLnN0YXRlLm1hdGNoQnJhY2tldHMgPSB0eXBlb2YgdmFsID09IFwib2JqZWN0XCIgPyB2YWwgOiB7fTtcbiAgICAgICAgY20ub24oXCJjdXJzb3JBY3Rpdml0eVwiLCBkb01hdGNoQnJhY2tldHMpO1xuICAgICAgICBjbS5vbihcImZvY3VzXCIsIGRvTWF0Y2hCcmFja2V0cyk7XG4gICAgICAgIGNtLm9uKFwiYmx1clwiLCBjbGVhckhpZ2hsaWdodGVkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBDb2RlTWlycm9yLmRlZmluZUV4dGVuc2lvbihcIm1hdGNoQnJhY2tldHNcIiwgZnVuY3Rpb24oKSB7XG4gICAgICBtYXRjaEJyYWNrZXRzKHRoaXMsIHRydWUpO1xuICAgIH0pO1xuICAgIENvZGVNaXJyb3IuZGVmaW5lRXh0ZW5zaW9uKFwiZmluZE1hdGNoaW5nQnJhY2tldFwiLCBmdW5jdGlvbihwb3MsIGNvbmZpZywgb2xkQ29uZmlnKSB7XG4gICAgICBpZiAob2xkQ29uZmlnIHx8IHR5cGVvZiBjb25maWcgPT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgaWYgKCFvbGRDb25maWcpIHtcbiAgICAgICAgICBjb25maWcgPSBjb25maWcgPyB7IHN0cmljdDogdHJ1ZSB9IDogbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbGRDb25maWcuc3RyaWN0ID0gY29uZmlnO1xuICAgICAgICAgIGNvbmZpZyA9IG9sZENvbmZpZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZpbmRNYXRjaGluZ0JyYWNrZXQodGhpcywgcG9zLCBjb25maWcpO1xuICAgIH0pO1xuICAgIENvZGVNaXJyb3IuZGVmaW5lRXh0ZW5zaW9uKFwic2NhbkZvckJyYWNrZXRcIiwgZnVuY3Rpb24ocG9zLCBkaXIsIHN0eWxlLCBjb25maWcpIHtcbiAgICAgIHJldHVybiBzY2FuRm9yQnJhY2tldCh0aGlzLCBwb3MsIGRpciwgc3R5bGUsIGNvbmZpZyk7XG4gICAgfSk7XG4gIH0pO1xufSkoKTtcbnZhciBtYXRjaGJyYWNrZXRzID0gbWF0Y2hicmFja2V0cyQyLmV4cG9ydHM7XG52YXIgbWF0Y2hicmFja2V0cyQxID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIF9tZXJnZU5hbWVzcGFjZXMoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiBcIk1vZHVsZVwiLFxuICBcImRlZmF1bHRcIjogbWF0Y2hicmFja2V0c1xufSwgW21hdGNoYnJhY2tldHMkMi5leHBvcnRzXSkpO1xuZXhwb3J0IHsgbWF0Y2hicmFja2V0cyQyIGFzIGEsIG1hdGNoYnJhY2tldHMkMSBhcyBtIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///54980\n')}}]);